; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_iwdt_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_iwdt_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_iwdt_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_IWDT_MID.c]
                          THUMB

                          AREA ||i.IWDT_Error_Handler||, CODE, READONLY, ALIGN=1

                  IWDT_Error_Handler PROC
;;;269     */
;;;270    __weak void IWDT_Error_Handler(IWDT_HandleTypeDef *mIWDT)
000000  4770              BX       lr
;;;271    {
;;;272        /* USER CODE BEGIN Error_Handler_Debug */
;;;273        /* User can add his own implementation to report the HAL error return state */
;;;274        UNUSED(mIWDT);
;;;275        /* USER CODE END Error_Handler_Debug */
;;;276    }
;;;277    ///@}
                          ENDP


                          AREA ||i.MID_IWDT_EW0INTCallback||, CODE, READONLY, ALIGN=1

                  MID_IWDT_EW0INTCallback PROC
;;;211     */
;;;212    __weak void MID_IWDT_EW0INTCallback(IWDT_HandleTypeDef *mIWDT)
000000  4770              BX       lr
;;;213    {
;;;214        /* Prevent unused argument(s) compilation warning */
;;;215        UNUSED(mIWDT);
;;;216    
;;;217        /* NOTE: This function should not be modified, when the callback is needed,
;;;218               the MID_IWDT_EarlyWakeupCallback could be implemented in the user file
;;;219        */
;;;220    }
;;;221    
                          ENDP


                          AREA ||i.MID_IWDT_EW1INTCallback||, CODE, READONLY, ALIGN=1

                  MID_IWDT_EW1INTCallback PROC
;;;229     */
;;;230    __weak void MID_IWDT_EW1INTCallback(IWDT_HandleTypeDef *mIWDT)
000000  4770              BX       lr
;;;231    {
;;;232        /* Prevent unused argument(s) compilation warning */
;;;233        UNUSED(mIWDT);
;;;234    
;;;235        /* NOTE: This function should not be modified, when the callback is needed,
;;;236               the MID_IWDT_EarlyWakeupCallback could be implemented in the user file
;;;237        */
;;;238    }
;;;239    
                          ENDP


                          AREA ||i.MID_IWDT_IRQHandler||, CODE, READONLY, ALIGN=1

                  MID_IWDT_IRQHandler PROC
;;;159     */
;;;160    void MID_IWDT_IRQHandler(IWDT_HandleTypeDef *mIWDT)
000000  b510              PUSH     {r4,lr}
;;;161    {
000002  4604              MOV      r4,r0
;;;162        /* Check if Overfloat Interrupt is enable */
;;;163        if(__DRV_IWDT_GET_INT_SOURCE(mIWDT,IWDT_IT_EW1)!= CLR)
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2102              MOVS     r1,#2
00000a  4008              ANDS     r0,r0,r1
00000c  0840              LSRS     r0,r0,#1
00000e  2800              CMP      r0,#0
000010  d00c              BEQ      |L4.44|
;;;164        {
;;;165            /* Check if IWDT Early Wakeup 1 Interrupt occurred */
;;;166            if(__DRV_IWDT_GET_FLAG(mIWDT,IWDT_STA_EW1F) != CLR)
000012  6820              LDR      r0,[r4,#0]
000014  6800              LDR      r0,[r0,#0]
000016  2108              MOVS     r1,#8
000018  4008              ANDS     r0,r0,r1
00001a  08c0              LSRS     r0,r0,#3
00001c  2800              CMP      r0,#0
00001e  d005              BEQ      |L4.44|
;;;167            {
;;;168                __DRV_IWDT_CLEAR_FLAG(mIWDT,IWDT_STA_EW1F);
000020  2008              MOVS     r0,#8
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
;;;169    
;;;170                /* IWDT eary wake up 1 interrupt callback */	
;;;171                MID_IWDT_EW1INTCallback(mIWDT);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       MID_IWDT_EW1INTCallback
                  |L4.44|
;;;172            }
;;;173        }
;;;174    
;;;175        if(__DRV_IWDT_GET_INT_SOURCE(mIWDT,IWDT_IT_EW0)!= CLR)
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  2104              MOVS     r1,#4
000032  4008              ANDS     r0,r0,r1
000034  0880              LSRS     r0,r0,#2
000036  2800              CMP      r0,#0
000038  d00b              BEQ      |L4.82|
;;;176        {
;;;177            /* Check if IWDT Early Wakeup 0 Interrupt occurred */
;;;178            if(__DRV_IWDT_GET_FLAG(mIWDT,IWDT_STA_EW0F) != CLR)
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  4008              ANDS     r0,r0,r1
000040  0880              LSRS     r0,r0,#2
000042  2800              CMP      r0,#0
000044  d005              BEQ      |L4.82|
;;;179            {
;;;180                    __DRV_IWDT_CLEAR_FLAG(mIWDT,IWDT_STA_EW0F);
000046  2004              MOVS     r0,#4
000048  6821              LDR      r1,[r4,#0]
00004a  6008              STR      r0,[r1,#0]
;;;181                /* IWDT eary wake up 0 interrupt callback */
;;;182                MID_IWDT_EW0INTCallback(mIWDT);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       MID_IWDT_EW0INTCallback
                  |L4.82|
;;;183            }
;;;184        }
;;;185        
;;;186        if(__DRV_IWDT_GET_INT_SOURCE(mIWDT,IWDT_IT_TIE)!= CLR)
000052  6820              LDR      r0,[r4,#0]
000054  6840              LDR      r0,[r0,#4]
000056  2108              MOVS     r1,#8
000058  4008              ANDS     r0,r0,r1
00005a  08c0              LSRS     r0,r0,#3
00005c  2800              CMP      r0,#0
00005e  d00c              BEQ      |L4.122|
;;;187        {
;;;188            /* Check if IWDT overfloat Interrupt occurred */
;;;189            if(__DRV_IWDT_GET_FLAG(mIWDT,IWDT_STA_TIEF) != CLR)
000060  6820              LDR      r0,[r4,#0]
000062  6800              LDR      r0,[r0,#0]
000064  2102              MOVS     r1,#2
000066  4008              ANDS     r0,r0,r1
000068  0840              LSRS     r0,r0,#1
00006a  2800              CMP      r0,#0
00006c  d005              BEQ      |L4.122|
;;;190            {
;;;191                __DRV_IWDT_CLEAR_FLAG(mIWDT,IWDT_STA_TIEF);
00006e  2002              MOVS     r0,#2
000070  6821              LDR      r1,[r4,#0]
000072  6008              STR      r0,[r1,#0]
;;;192                /* IWDT overfloat interrupt callback */
;;;193                MID_IWDT_TIEINTCallback(mIWDT);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       MID_IWDT_TIEINTCallback
                  |L4.122|
;;;194            }
;;;195        }
;;;196    }
00007a  bd10              POP      {r4,pc}
;;;197    ///@}
                          ENDP


                          AREA ||i.MID_IWDT_Init||, CODE, READONLY, ALIGN=2

                  MID_IWDT_Init PROC
;;;65      */
;;;66     MID_StatusTypeDef MID_IWDT_Init(IWDT_HandleTypeDef *mIWDT)
000000  b570              PUSH     {r4-r6,lr}
;;;67     {
000002  4604              MOV      r4,r0
;;;68         uint32_t tickstart;
;;;69     
;;;70         /* Check the IWDT handle allocation */
;;;71         if(mIWDT == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L5.12|
;;;72         {
;;;73         return MID_ERROR;
000008  2001              MOVS     r0,#1
                  |L5.10|
;;;74         }
;;;75     
;;;76         /* Check the parameters */
;;;77         assert_param(IS_IWDT_ALL_INSTANCE(mIWDT->Instance));
;;;78         assert_param(IS_IWDT_PRESCALER(mIWDT->Init.Prescaler));
;;;79         assert_param(IS_IWDT_RELOAD(mIWDT->Init.Reload));
;;;80         assert_param(IS_IWDT_WINDOW(mIWDT->Init.Window));
;;;81     
;;;82         /* Enable write access to IWDT Protect Disable, IWDT_RLR and IWDT_WINR registers by writing
;;;83         0xA217 in KEY */
;;;84         IWDT_ENABLE_WRITE_ACCESS(mIWDT);
;;;85         mIWDT->Instance->KEY.W = 0xA217;
;;;86     
;;;87         /* Enable IWDT. LSI is turned on automaticaly */
;;;88         __DRV_IWDT_START(mIWDT);
;;;89         
;;;90         __DRV_IWDT_CLEAR_FLAG(mIWDT, IWDT_STA_ALLF);
;;;91         
;;;92         /* Write to IWDT registers the Prescaler & Reload values to work with */
;;;93         mIWDT->Instance->CLK.MBIT.CK_DIV = mIWDT->Init.Prescaler;
;;;94         __DRV_IWDT_RELOAD_COUNTER(mIWDT);
;;;95     
;;;96         /* Write to IWDT registers the Prescaler & Reload values to work with */
;;;97         __DRV_IWDT_INT_ENABLE(mIWDT,mIWDT->Init.Interrupt);
;;;98     
;;;99         /* Check pending flag, if previous update not done, return timeout */
;;;100        tickstart = MID_GetTick();
;;;101    
;;;102        /* Wait for register to be updated */
;;;103        while(mIWDT->Instance->STA.W != NONE)
;;;104        {
;;;105            if((MID_GetTick() - tickstart ) > MID_IWDT_DEFAULT_TIMEOUT)
;;;106            {
;;;107                return MID_TIMEOUT;
;;;108            }
;;;109        }
;;;110        
;;;111        IWDT_DISABLE_WRITE_ACCESS(mIWDT);
;;;112        
;;;113        /* Return function status */
;;;114        return MID_OK;
;;;115    }
00000a  bd70              POP      {r4-r6,pc}
                  |L5.12|
00000c  6820              LDR      r0,[r4,#0]            ;84
00000e  68c0              LDR      r0,[r0,#0xc]          ;84
000010  4816              LDR      r0,|L5.108|
000012  6821              LDR      r1,[r4,#0]            ;85
000014  60c8              STR      r0,[r1,#0xc]          ;85
000016  2001              MOVS     r0,#1                 ;88
000018  6821              LDR      r1,[r4,#0]            ;88
00001a  6108              STR      r0,[r1,#0x10]         ;88
00001c  200e              MOVS     r0,#0xe               ;90
00001e  6821              LDR      r1,[r4,#0]            ;90
000020  6008              STR      r0,[r1,#0]            ;90
000022  6820              LDR      r0,[r4,#0]            ;93
000024  7a00              LDRB     r0,[r0,#8]            ;93
000026  21f0              MOVS     r1,#0xf0              ;93
000028  4388              BICS     r0,r0,r1              ;93
00002a  6861              LDR      r1,[r4,#4]            ;93
00002c  0109              LSLS     r1,r1,#4              ;93
00002e  22f0              MOVS     r2,#0xf0              ;93
000030  4011              ANDS     r1,r1,r2              ;93
000032  4308              ORRS     r0,r0,r1              ;93
000034  6821              LDR      r1,[r4,#0]            ;93
000036  7208              STRB     r0,[r1,#8]            ;93
000038  480d              LDR      r0,|L5.112|
00003a  6821              LDR      r1,[r4,#0]            ;94
00003c  60c8              STR      r0,[r1,#0xc]          ;94
00003e  6821              LDR      r1,[r4,#0]            ;97
000040  68a0              LDR      r0,[r4,#8]            ;97
000042  6048              STR      r0,[r1,#4]            ;97
000044  f7fffffe          BL       MID_GetTick
000048  4605              MOV      r5,r0                 ;100
00004a  e006              B        |L5.90|
                  |L5.76|
00004c  f7fffffe          BL       MID_GetTick
000050  1b40              SUBS     r0,r0,r5              ;105
000052  2827              CMP      r0,#0x27              ;105
000054  d901              BLS      |L5.90|
000056  2003              MOVS     r0,#3                 ;107
000058  e7d7              B        |L5.10|
                  |L5.90|
00005a  6820              LDR      r0,[r4,#0]            ;103
00005c  6800              LDR      r0,[r0,#0]            ;103
00005e  2800              CMP      r0,#0                 ;103
000060  d1f4              BNE      |L5.76|
000062  6820              LDR      r0,[r4,#0]            ;111
000064  68c0              LDR      r0,[r0,#0xc]          ;111
000066  2000              MOVS     r0,#0                 ;114
000068  e7cf              B        |L5.10|
;;;116    ///@}
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      0x0000a217
                  |L5.112|
                          DCD      0x00002014

                          AREA ||i.MID_IWDT_Refresh||, CODE, READONLY, ALIGN=2

                  MID_IWDT_Refresh PROC
;;;131     */
;;;132    MID_StatusTypeDef MID_IWDT_Refresh(IWDT_HandleTypeDef *mIWDT)
000000  4601              MOV      r1,r0
;;;133    {
;;;134      /* Reload IWDT counter with value defined in the reload register */
;;;135      __DRV_IWDT_RELOAD_COUNTER(mIWDT);
000002  4802              LDR      r0,|L6.12|
000004  680a              LDR      r2,[r1,#0]
000006  60d0              STR      r0,[r2,#0xc]
;;;136    
;;;137      /* Return function status */
;;;138      return MID_OK;
000008  2000              MOVS     r0,#0
;;;139    }
00000a  4770              BX       lr
;;;140    ///@}
                          ENDP

                  |L6.12|
                          DCD      0x00002014

                          AREA ||i.MID_IWDT_TIEINTCallback||, CODE, READONLY, ALIGN=1

                  MID_IWDT_TIEINTCallback PROC
;;;247     */
;;;248    __weak void MID_IWDT_TIEINTCallback(IWDT_HandleTypeDef *mIWDT)
000000  4770              BX       lr
;;;249    {
;;;250        /* Prevent unused argument(s) compilation warning */
;;;251        UNUSED(mIWDT);
;;;252    
;;;253        /* NOTE: This function should not be modified, when the callback is needed,
;;;254               the MID_IWDT_EarlyWakeupCallback could be implemented in the user file
;;;255        */
;;;256    }
;;;257    ///@}
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_IWDT_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_MG32x02z_IWDT_MID_c_815915da____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_MG32x02z_IWDT_MID_c_815915da____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_MG32x02z_IWDT_MID_c_815915da____REVSH|
#line 496
|__asm___19_MG32x02z_IWDT_MID_c_815915da____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
