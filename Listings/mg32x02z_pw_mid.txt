; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_pw_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_pw_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_pw_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_PW_MID.c]
                          THUMB

                          AREA ||i.MID_PW_BOD0Callback||, CODE, READONLY, ALIGN=1

                  MID_PW_BOD0Callback PROC
;;;314     */
;;;315    __weak void MID_PW_BOD0Callback (void)
000000  4770              BX       lr
;;;316    {
;;;317        /* NOTE : This function Should not be modified, when the callback is needed,
;;;318                  the MID_PW_BOD0Callback could be implemented in the user file
;;;319        */
;;;320    }
;;;321    
                          ENDP


                          AREA ||i.MID_PW_BOD1Callback||, CODE, READONLY, ALIGN=1

                  MID_PW_BOD1Callback PROC
;;;334     */
;;;335    __weak void MID_PW_BOD1Callback (void)
000000  4770              BX       lr
;;;336    {
;;;337        /* NOTE : This function Should not be modified, when the callback is needed,
;;;338                  the MID_PW_BOD1Callback could be implemented in the user file
;;;339        */
;;;340    }
;;;341    
                          ENDP


                          AREA ||i.MID_PW_ConfigBOD1||, CODE, READONLY, ALIGN=2

                  MID_PW_ConfigBOD1 PROC
;;;199     */
;;;200    void MID_PW_ConfigBOD1 (PW_BODxTypeDef *sConfigBOD1)
000000  4a07              LDR      r2,|L3.32|
;;;201    {
;;;202        uint32_t REG;
;;;203    
;;;204        REG = (PW->CR0.W & ~(PW_BOD1_TH_MASK | PW_BOD1_TRG_MASK));
000002  6912              LDR      r2,[r2,#0x10]
000004  230f              MOVS     r3,#0xf
000006  021b              LSLS     r3,r3,#8
000008  439a              BICS     r2,r2,r3
00000a  4611              MOV      r1,r2
;;;205        REG |= ((sConfigBOD1->BODx_THRESHOLD << 10) | 
00000c  7842              LDRB     r2,[r0,#1]
00000e  0292              LSLS     r2,r2,#10
000010  7803              LDRB     r3,[r0,#0]
000012  021b              LSLS     r3,r3,#8
000014  431a              ORRS     r2,r2,r3
000016  4311              ORRS     r1,r1,r2
;;;206                (sConfigBOD1->BODx_TRIGGER << 8));
;;;207        PW->CR0.W = REG;
000018  4a01              LDR      r2,|L3.32|
00001a  6111              STR      r1,[r2,#0x10]
;;;208    }
00001c  4770              BX       lr
;;;209    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x4c020000

                          AREA ||i.MID_PW_DeInit||, CODE, READONLY, ALIGN=2

                  MID_PW_DeInit PROC
;;;42      */
;;;43     void MID_PW_DeInit (void)
000000  480a              LDR      r0,|L4.44|
;;;44     {
;;;45         PW->KEY.MBIT.KEY = 0xA217;
000002  8980              LDRH     r0,[r0,#0xc]
000004  490a              LDR      r1,|L4.48|
000006  4608              MOV      r0,r1
000008  4908              LDR      r1,|L4.44|
00000a  8188              STRH     r0,[r1,#0xc]
;;;46         PW->STA.W = 0x000000FC;
00000c  20fc              MOVS     r0,#0xfc
00000e  6008              STR      r0,[r1,#0]
;;;47         PW->INT.W = 0x00000000;
000010  2000              MOVS     r0,#0
000012  6048              STR      r0,[r1,#4]
;;;48         PW->CR0.W = 0x00000090;
000014  2090              MOVS     r0,#0x90
000016  6108              STR      r0,[r1,#0x10]
;;;49         PW->CR1.W = 0x00000000;
000018  2000              MOVS     r0,#0
00001a  6148              STR      r0,[r1,#0x14]
;;;50         PW->WKSTP0.W = 0x00000000;
00001c  6188              STR      r0,[r1,#0x18]
;;;51         PW->WKSTP1.W = 0x00000000;
00001e  61c8              STR      r0,[r1,#0x1c]
;;;52         PW->KEY.MBIT.KEY = 0;
000020  4608              MOV      r0,r1
000022  8980              LDRH     r0,[r0,#0xc]
000024  2000              MOVS     r0,#0
000026  8188              STRH     r0,[r1,#0xc]
;;;53     }
000028  4770              BX       lr
;;;54       
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x4c020000
                  |L4.48|
                          DCD      0x0000a217

                          AREA ||i.MID_PW_DisableSleepOnExit||, CODE, READONLY, ALIGN=2

                  MID_PW_DisableSleepOnExit PROC
;;;169     */
;;;170    void MID_PW_DisableSleepOnExit (void)
000000  4803              LDR      r0,|L5.16|
;;;171    {
;;;172        // Clear SLEEPONEXIT bit of Cortex System Control Register
;;;173        CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
000002  6900              LDR      r0,[r0,#0x10]
000004  2102              MOVS     r1,#2
000006  4388              BICS     r0,r0,r1
000008  4901              LDR      r1,|L5.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;174    }
00000c  4770              BX       lr
;;;175    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe000ed00

                          AREA ||i.MID_PW_EnableSleepOnExit||, CODE, READONLY, ALIGN=2

                  MID_PW_EnableSleepOnExit PROC
;;;149     */
;;;150    void MID_PW_EnableSleepOnExit (void)
000000  4803              LDR      r0,|L6.16|
;;;151    {
;;;152        // Set SLEEPONEXIT bit of Cortex System Control Register
;;;153        SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
000002  6900              LDR      r0,[r0,#0x10]
000004  2102              MOVS     r1,#2
000006  4308              ORRS     r0,r0,r1
000008  4901              LDR      r1,|L6.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;154    }
00000c  4770              BX       lr
;;;155    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe000ed00

                          AREA ||i.MID_PW_EnterSLEEPMode||, CODE, READONLY, ALIGN=2

                  MID_PW_EnterSLEEPMode PROC
;;;70      */
;;;71     void MID_PW_EnterSLEEPMode (uint8_t SLEEPEntry)
000000  4906              LDR      r1,|L7.28|
;;;72     {
;;;73         // Check the parameters
;;;74         assert_param(IS_PW_SLEEP_ENTRY(SLEEPEntry));
;;;75         
;;;76         // Clear SLEEPDEEP bit of Cortex System Control Register
;;;77         SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
000002  6909              LDR      r1,[r1,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  4a04              LDR      r2,|L7.28|
00000a  6111              STR      r1,[r2,#0x10]
;;;78     
;;;79         // Select SLEEP mode entry
;;;80         if(SLEEPEntry == PW_SLEEPENTRY_WFI)
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L7.20|
;;;81         {
;;;82             // Request Wait For Interrupt
;;;83             __WFI();
000010  bf30              WFI      
000012  e002              B        |L7.26|
                  |L7.20|
;;;84         }
;;;85         else
;;;86         {
;;;87             // Request Wait For Event
;;;88             __SEV();
000014  bf40              SEV      
;;;89             __WFE();
000016  bf20              WFE      
;;;90             __WFE();
000018  bf20              WFE      
                  |L7.26|
;;;91         }
;;;92     }
00001a  4770              BX       lr
;;;93     
                          ENDP

                  |L7.28|
                          DCD      0xe000ed00

                          AREA ||i.MID_PW_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  MID_PW_EnterSTOPMode PROC
;;;109     */
;;;110    void MID_PW_EnterSTOPMode (uint8_t STOPEntry)
000000  4909              LDR      r1,|L8.40|
;;;111    {
;;;112        // Check the parameters
;;;113        assert_param(IS_PW_STOP_ENTRY(STOPEntry));
;;;114    
;;;115        // Set SLEEPDEEP bit of Cortex System Control Register
;;;116        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6909              LDR      r1,[r1,#0x10]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  4a07              LDR      r2,|L8.40|
00000a  6111              STR      r1,[r2,#0x10]
;;;117    
;;;118        // Select STOP mode entry
;;;119        if(STOPEntry == PW_STOPENTRY_WFI)
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L8.20|
;;;120        {
;;;121            // Request Wait For Interrupt
;;;122            __WFI();
000010  bf30              WFI      
000012  e002              B        |L8.26|
                  |L8.20|
;;;123        }
;;;124        else
;;;125        {
;;;126            // Request Wait For Event
;;;127            __SEV();
000014  bf40              SEV      
;;;128            __WFE();
000016  bf20              WFE      
;;;129            __WFE();
000018  bf20              WFE      
                  |L8.26|
;;;130        }
;;;131    
;;;132        // Reset SLEEPDEEP bit of Cortex System Control Register
;;;133        SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
00001a  4903              LDR      r1,|L8.40|
00001c  6909              LDR      r1,[r1,#0x10]
00001e  2204              MOVS     r2,#4
000020  4391              BICS     r1,r1,r2
000022  4a01              LDR      r2,|L8.40|
000024  6111              STR      r1,[r2,#0x10]
;;;134    }
000026  4770              BX       lr
;;;135    
                          ENDP

                  |L8.40|
                          DCD      0xe000ed00

                          AREA ||i.MID_PW_IRQHandler||, CODE, READONLY, ALIGN=2

                  MID_PW_IRQHandler PROC
;;;254     */
;;;255    void MID_PW_IRQHandler (void)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
;;;257        uint32_t itsource = PW->INT.W;
000002  4813              LDR      r0,|L9.80|
000004  6846              LDR      r6,[r0,#4]
;;;258        uint32_t itflag   = PW->STA.W;
000006  6805              LDR      r5,[r0,#0]
;;;259        uint32_t itieflag   = (itsource & itflag);
000008  4630              MOV      r0,r6
00000a  4028              ANDS     r0,r0,r5
00000c  4604              MOV      r4,r0
;;;260        
;;;261        
;;;262        
;;;263        /* When BOD0 happened  ----------------------------------------------------*/
;;;264        if((itieflag & PW_FLAG_BOD0F) != CLR)
00000e  2010              MOVS     r0,#0x10
000010  4020              ANDS     r0,r0,r4
000012  2800              CMP      r0,#0
000014  d005              BEQ      |L9.34|
;;;265        {
;;;266            // Clear BOD0F flag
;;;267            __DRV_PW_CLEAR_FLAG(PW_FLAG_BOD0F);
000016  2010              MOVS     r0,#0x10
000018  490d              LDR      r1,|L9.80|
00001a  6008              STR      r0,[r1,#0]
;;;268            MID_PW_BOD0Callback();
00001c  f7fffffe          BL       MID_PW_BOD0Callback
                  |L9.32|
;;;269            return;
;;;270        }
;;;271        
;;;272        /* When BOD1 happened  ----------------------------------------------------*/
;;;273        if((itieflag & PW_FLAG_BOD1F) != CLR)
;;;274        {
;;;275            // Clear BOD1F flag
;;;276            __DRV_PW_CLEAR_FLAG(PW_FLAG_BOD1F);
;;;277            MID_PW_BOD1Callback();
;;;278            return;
;;;279        }
;;;280     
;;;281    #if defined(MG32_3RD)
;;;282        /* When BOD2 happened  ----------------------------------------------------*/
;;;283        if((itieflag & PW_FLAG_BOD2F) != CLR)
;;;284        {
;;;285            // Clear BOD2F flag
;;;286            __DRV_PW_CLEAR_FLAG(PW_FLAG_BOD2F);
;;;287            MID_PW_BOD2Callback();
;;;288            return;
;;;289        }
;;;290    #endif
;;;291        
;;;292        /* When WK happened  ------------------------------------------------------*/
;;;293        if((itieflag & PW_FLAG_WKF) != CLR)
;;;294        {
;;;295            // Clear WEF flag
;;;296            __DRV_PW_CLEAR_FLAG(PW_FLAG_WKF);
;;;297            MID_PW_WKCallback();
;;;298            return;
;;;299        }
;;;300    }
000020  bd70              POP      {r4-r6,pc}
                  |L9.34|
000022  2020              MOVS     r0,#0x20              ;273
000024  4020              ANDS     r0,r0,r4              ;273
000026  2800              CMP      r0,#0                 ;273
000028  d005              BEQ      |L9.54|
00002a  2020              MOVS     r0,#0x20              ;276
00002c  4908              LDR      r1,|L9.80|
00002e  6008              STR      r0,[r1,#0]            ;276
000030  f7fffffe          BL       MID_PW_BOD1Callback
000034  e7f4              B        |L9.32|
                  |L9.54|
000036  2080              MOVS     r0,#0x80              ;293
000038  4020              ANDS     r0,r0,r4              ;293
00003a  2800              CMP      r0,#0                 ;293
00003c  d005              BEQ      |L9.74|
00003e  2080              MOVS     r0,#0x80              ;296
000040  4903              LDR      r1,|L9.80|
000042  6008              STR      r0,[r1,#0]            ;296
000044  f7fffffe          BL       MID_PW_WKCallback
000048  e7ea              B        |L9.32|
                  |L9.74|
00004a  bf00              NOP      
00004c  e7e8              B        |L9.32|
;;;301    
                          ENDP

00004e  0000              DCW      0x0000
                  |L9.80|
                          DCD      0x4c020000

                          AREA ||i.MID_PW_WKCallback||, CODE, READONLY, ALIGN=1

                  MID_PW_WKCallback PROC
;;;376     */
;;;377    __weak void MID_PW_WKCallback (void)
000000  4770              BX       lr
;;;378    {
;;;379        /* NOTE : This function Should not be modified, when the callback is needed,
;;;380                  the MID_PW_WKCallback could be implemented in the user file
;;;381        */
;;;382    }
;;;383    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_PW_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_MG32x02z_PW_MID_c_0ca48b78____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___17_MG32x02z_PW_MID_c_0ca48b78____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_MG32x02z_PW_MID_c_0ca48b78____REVSH|
#line 496
|__asm___17_MG32x02z_PW_MID_c_0ca48b78____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
