; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_emb_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_emb_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_emb_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_EMB_MID.c]
                          THUMB

                          AREA ||i.MID_EMB_DeInit||, CODE, READONLY, ALIGN=1

                  MID_EMB_DeInit PROC
;;;207     */
;;;208    MID_StatusTypeDef MID_EMB_DeInit(EMB_HandleTypeDef *mEMB)
000000  b510              PUSH     {r4,lr}
;;;209    {
000002  4604              MOV      r4,r0
;;;210        if((mEMB->Instance->STA.W & EMB_STA_BUSYF_mask_w) == 0)
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  07c0              LSLS     r0,r0,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L1.46|
;;;211        {
;;;212            mEMB->Instance->CR0.W = 0;
000010  6821              LDR      r1,[r4,#0]
000012  6108              STR      r0,[r1,#0x10]
;;;213            mEMB->Instance->INT.W = 0;
000014  6821              LDR      r1,[r4,#0]
000016  6048              STR      r0,[r1,#4]
;;;214            mEMB->Instance->CLK.W = 0;
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;215            mEMB->Instance->CR1.W = 0;
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
;;;216            mEMB->Instance->CR2.W = 0;
000020  6821              LDR      r1,[r4,#0]
000022  6188              STR      r0,[r1,#0x18]
;;;217    
;;;218            MID_EMB_MspDeInit(mEMB);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       MID_EMB_MspDeInit
;;;219    
;;;220            return MID_OK;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;221        }
;;;222        else
;;;223        {
;;;224            return MID_BUSY;
;;;225        }
;;;226    }
00002c  bd10              POP      {r4,pc}
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;224
000030  e7fc              B        |L1.44|
;;;227    
                          ENDP


                          AREA ||i.MID_EMB_IRQHandler||, CODE, READONLY, ALIGN=1

                  MID_EMB_IRQHandler PROC
;;;371     */
;;;372    void MID_EMB_IRQHandler(EMB_HandleTypeDef *mEMB)
000000  b510              PUSH     {r4,lr}
;;;373    {
000002  4604              MOV      r4,r0
;;;374      #if defined(MG32_3RD)
;;;375        if(((mEMB->Instance->STA.W & EMB_STA_IAEF_mask_w) != 0) && ((mEMB->Instance->INT.W & EMB_INT_IAE_IE_mask_w) != 0))
;;;376        {
;;;377            MID_EMB_IllegalAddressCallback(mEMB);
;;;378        }
;;;379    
;;;380        if(((mEMB->Instance->STA.W & EMB_STA_BWEF_mask_w) != 0) && ((mEMB->Instance->INT.W & EMB_INT_BWE_IE_mask_w) != 0))
;;;381        {
;;;382            MID_EMB_ByteWriteProtectCallback(mEMB);
;;;383        }
;;;384      #endif
;;;385    
;;;386      #if defined(MG32_1ST) || defined(MG32_3RD)
;;;387        if(((mEMB->Instance->STA.W & EMB_STA_WPEF_mask_w) != 0) && ((mEMB->Instance->INT.W & EMB_INT_WPE_IE_mask_w) != 0))
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  2104              MOVS     r1,#4
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d007              BEQ      |L2.32|
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  4008              ANDS     r0,r0,r1
000016  2800              CMP      r0,#0
000018  d002              BEQ      |L2.32|
;;;388        {
;;;389            MID_EMB_WriteProtectCallback(mEMB);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       MID_EMB_WriteProtectCallback
                  |L2.32|
;;;390        }
;;;391      #endif
;;;392    }
000020  bd10              POP      {r4,pc}
;;;393    
                          ENDP


                          AREA ||i.MID_EMB_Init||, CODE, READONLY, ALIGN=1

                  MID_EMB_Init PROC
;;;87      */
;;;88     MID_StatusTypeDef MID_EMB_Init(EMB_HandleTypeDef *mEMB)
000000  b510              PUSH     {r4,lr}
;;;89     {
000002  4604              MOV      r4,r0
;;;90         __IO uint32_t lTemp32;
;;;91         /* Check the parameters */
;;;92         assert_param(IS_EMB_DEVICE(mEMB->Mode.DeviceAccess));
;;;93         assert_param(IS_EMB_WRITE_SIGNAL(mEMB->Mode.WriteSignal));
;;;94         assert_param(IS_EMB_READ_SIGNAL(mEMB->Mode.ReadSignal));
;;;95         assert_param(IS_EMB_MUX(mEMB->Mode.DataAddressMux));
;;;96         assert_param(IS_EMB_MUX_MODE(mEMB->Mode.DataAddressMuxMode));
;;;97         assert_param(IS_EMB_WRITE(mEMB->Mode.WriteAccess));
;;;98         assert_param(IS_EMB_RANGE(mEMB->Mode.AddressRange));
;;;99     
;;;100        assert_param(IS_EMB_MA_REVERSE(mEMB->Extended.MABusReverse));
;;;101        assert_param(IS_EMB_MCLK_INVERSE(mEMB->Extended.MCLK_Inverse));
;;;102        assert_param(IS_EMB_MALE2_INVERSE(mEMB->Extended.MALE2_Inverse));
;;;103        assert_param(IS_EMB_MALE_INVERSE(mEMB->Extended.MALE_Inverse));
;;;104        assert_param(IS_EMB_MCE_INVERSE(mEMB->Extended.MCE_Inverse));
;;;105    
;;;106        assert_param(IS_EMB_PRESCALER(mEMB->CLKPrescaler));
;;;107        assert_param(IS_EMB_DATA_SETUP_TIME(mEMB->DataSetupTime));
;;;108        assert_param(IS_EMB_DATA_ACCESS_TIME(mEMB->DataAccessTime));
;;;109        assert_param(IS_EMB_DATA_HOLD_TIME(mEMB->DataHoldTime));
;;;110        assert_param(IS_EMB_ADDRESS_SETUP_TIME(mEMB->AddressSetupTime));
;;;111        assert_param(IS_EMB_ADDRESS_PLUSE_TIME(mEMB->AddressPulseTime));
;;;112        assert_param(IS_EMB_ADDRESS_HOLD_TIME(mEMB->AddressHoldTime));
;;;113    
;;;114      #if defined(MG32_3RD)
;;;115        assert_param(IS_EMB_MAM1_SIGNAL(mEMB->ModeInit.AddressMAM1));
;;;116        assert_param(IS_EMB_DEVICE_DATA_WIDTH(mEMB->ModeInit.DeviceDataWidth));
;;;117        assert_param(IS_EMB_BYTE_WRITE(mEMB->ModeInit.WriteByteAccess));
;;;118    
;;;119        assert_param(IS_EMB_MAD_BYTE_REVERSE(mEMB->Extended.MADBusByteSwap));
;;;120        assert_param(IS_EMB_MAD_REVERSE(mEMB->Extended.MADBusReverse));
;;;121    
;;;122        assert_param(IS_EMB_IDLE_TIME(mEMB->IdleTime));
;;;123      #endif
;;;124    
;;;125        if((mEMB->Instance->STA.W & EMB_STA_BUSYF_mask_w) == 0)
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  07c0              LSLS     r0,r0,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d148              BNE      |L3.162|
;;;126        {
;;;127            __DRV_EMB_DISABLE(mEMB);
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  0840              LSRS     r0,r0,#1
000016  0040              LSLS     r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6108              STR      r0,[r1,#0x10]
;;;128    
;;;129            MID_EMB_MspInit(mEMB);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       MID_EMB_MspInit
;;;130    
;;;131            mEMB->Instance->CLK.W = ((mEMB->CLKPrescaler - 1) << 4);
000022  6b60              LDR      r0,[r4,#0x34]
000024  1e40              SUBS     r0,r0,#1
000026  0100              LSLS     r0,r0,#4
000028  6821              LDR      r1,[r4,#0]
00002a  6088              STR      r0,[r1,#8]
;;;132    
;;;133          #if defined(MG32_1ST)
;;;134            mEMB->Instance->CR0.W = (EMB_CR0_DMA_EN_mask_w | \
00002c  2101              MOVS     r1,#1
00002e  07c9              LSLS     r1,r1,#31
000030  68a0              LDR      r0,[r4,#8]
000032  4308              ORRS     r0,r0,r1
000034  68e1              LDR      r1,[r4,#0xc]
000036  4308              ORRS     r0,r0,r1
000038  69a1              LDR      r1,[r4,#0x18]
00003a  4308              ORRS     r0,r0,r1
00003c  6961              LDR      r1,[r4,#0x14]
00003e  4308              ORRS     r0,r0,r1
000040  6921              LDR      r1,[r4,#0x10]
000042  4308              ORRS     r0,r0,r1
000044  6861              LDR      r1,[r4,#4]
000046  4308              ORRS     r0,r0,r1
000048  69e1              LDR      r1,[r4,#0x1c]
00004a  4308              ORRS     r0,r0,r1
00004c  6821              LDR      r1,[r4,#0]
00004e  6108              STR      r0,[r1,#0x10]
;;;135                                     mEMB->Init.WriteSignal | \
;;;136                                     mEMB->Init.ReadSignal | \
;;;137                                     mEMB->Init.AddressRange | \
;;;138                                     mEMB->Init.DataAddressMuxMode | \
;;;139                                     mEMB->Init.DataAddressMux | \
;;;140                                     mEMB->Init.DeviceAccess | \
;;;141                                     mEMB->Init.WriteAccess);
;;;142    
;;;143            mEMB->Instance->CR1.W = (mEMB->Extended.MABusReverse | \
000050  6a61              LDR      r1,[r4,#0x24]
000052  6a20              LDR      r0,[r4,#0x20]
000054  4308              ORRS     r0,r0,r1
000056  6aa1              LDR      r1,[r4,#0x28]
000058  4308              ORRS     r0,r0,r1
00005a  6ae1              LDR      r1,[r4,#0x2c]
00005c  4308              ORRS     r0,r0,r1
00005e  6b21              LDR      r1,[r4,#0x30]
000060  4308              ORRS     r0,r0,r1
000062  2101              MOVS     r1,#1
000064  0249              LSLS     r1,r1,#9
000066  4308              ORRS     r0,r0,r1
000068  6821              LDR      r1,[r4,#0]
00006a  6148              STR      r0,[r1,#0x14]
;;;144                                     mEMB->Extended.MCLK_Inverse | \
;;;145                                     mEMB->Extended.MALE2_Inverse | \
;;;146                                     mEMB->Extended.MALE_Inverse | \
;;;147                                     mEMB->Extended.MCE_Inverse | \
;;;148                                     0x00000200);
;;;149    
;;;150            mEMB->Instance->CR2.W = ((mEMB->AddressSetupTime << 0) | \
00006c  6be1              LDR      r1,[r4,#0x3c]
00006e  1e49              SUBS     r1,r1,#1
000070  0109              LSLS     r1,r1,#4
000072  6ba0              LDR      r0,[r4,#0x38]
000074  4308              ORRS     r0,r0,r1
000076  6c21              LDR      r1,[r4,#0x40]
000078  0209              LSLS     r1,r1,#8
00007a  4308              ORRS     r0,r0,r1
00007c  6c61              LDR      r1,[r4,#0x44]
00007e  0309              LSLS     r1,r1,#12
000080  4308              ORRS     r0,r0,r1
000082  6ca1              LDR      r1,[r4,#0x48]
000084  1e49              SUBS     r1,r1,#1
000086  0409              LSLS     r1,r1,#16
000088  4308              ORRS     r0,r0,r1
00008a  6ce1              LDR      r1,[r4,#0x4c]
00008c  0509              LSLS     r1,r1,#20
00008e  4308              ORRS     r0,r0,r1
000090  6821              LDR      r1,[r4,#0]
000092  6188              STR      r0,[r1,#0x18]
;;;151                                    ((mEMB->AddressPulseTime - 1) << 4) | \
;;;152                                     (mEMB->AddressHoldTime << 8) | \
;;;153                                     (mEMB->DataSetupTime << 12) | \
;;;154                                    ((mEMB->DataAccessTime - 1) << 16) | \
;;;155                                     (mEMB->DataHoldTime << 20 ));
;;;156          #endif
;;;157    
;;;158          #if defined(MG32_3RD)
;;;159            mEMB->Instance->CR0.W = EMB_CR0_DMA_EN_mask_w | \
;;;160                                    mEMB->Init.WriteSignal | \
;;;161                                    mEMB->Init.ReadSignal | \
;;;162                                    mEMB->Init.AddressRange | \
;;;163                                    mEMB->Init.DataAddressMuxMode | \
;;;164                                    mEMB->Init.DataAddressMux | \
;;;165                                    mEMB->Init.AddressMAM1 | \
;;;166                                    mEMB->Init.DeviceDataWidth | \
;;;167                                    mEMB->Init.DeviceAccess | \
;;;168                                    mEMB->Init.WriteByteAccess | \
;;;169                                    mEMB->Init.WriteAccess | \
;;;170                                    0;
;;;171    
;;;172            mEMB->Instance->CR1.W = mEMB->Extended.MADBusByteSwap | \
;;;173                                    mEMB->Extended.MADBusReverse | \
;;;174                                    mEMB->Extended.MABusReverse | \
;;;175                                    mEMB->Extended.MCLK_Inverse | \
;;;176                                    mEMB->Extended.MALE2_Inverse | \
;;;177                                    mEMB->Extended.MALE_Inverse | \
;;;178                                    mEMB->Extended.MCE_Inverse | \
;;;179                                    0;
;;;180    
;;;181            mEMB->Instance->CR2.W = (mEMB->AddressSetupTime << 0) | \
;;;182                                   ((mEMB->AddressPulseTime - 1) << 4) | \
;;;183                                    (mEMB->AddressHoldTime << 8) | \
;;;184                                    (mEMB->DataSetupTime << 12) | \
;;;185                                   ((mEMB->DataAccessTime - 1) << 16) | \
;;;186                                    (mEMB->DataHoldTime << 20 ) | \
;;;187                                    (mEMB->IdleTime << 24) | \
;;;188                                    0;
;;;189          #endif
;;;190            __DRV_EMB_ENABLE(mEMB);
000094  6820              LDR      r0,[r4,#0]
000096  6900              LDR      r0,[r0,#0x10]
000098  2101              MOVS     r1,#1
00009a  4308              ORRS     r0,r0,r1
00009c  6821              LDR      r1,[r4,#0]
00009e  6108              STR      r0,[r1,#0x10]
0000a0  e001              B        |L3.166|
                  |L3.162|
;;;191        }
;;;192        else
;;;193        {
;;;194            return MID_BUSY;
0000a2  2002              MOVS     r0,#2
                  |L3.164|
;;;195        }
;;;196        return MID_OK;
;;;197    }
0000a4  bd10              POP      {r4,pc}
                  |L3.166|
0000a6  2000              MOVS     r0,#0                 ;196
0000a8  e7fc              B        |L3.164|
;;;198    
                          ENDP


                          AREA ||i.MID_EMB_MspDeInit||, CODE, READONLY, ALIGN=1

                  MID_EMB_MspDeInit PROC
;;;259     */
;;;260    __weak void MID_EMB_MspDeInit(EMB_HandleTypeDef* mEMB)
000000  4770              BX       lr
;;;261    {
;;;262        //===========================================================
;;;263        //Prevent unsed argument(s) compilation warning
;;;264        UNUSED(mEMB);
;;;265        
;;;266        //===========================================================
;;;267        //Note : This function should not be modified , when the callback is needed,
;;;268        //       the MID_URT_MspDeInit can be implemented in the user file.
;;;269        
;;;270    }
;;;271    
                          ENDP


                          AREA ||i.MID_EMB_MspInit||, CODE, READONLY, ALIGN=1

                  MID_EMB_MspInit PROC
;;;237     */
;;;238    __weak void MID_EMB_MspInit(EMB_HandleTypeDef* mEMB)
000000  4770              BX       lr
;;;239    {
;;;240        //===========================================================
;;;241        //Prevent unsed argument(s) compilation warning
;;;242        UNUSED(mEMB);
;;;243        
;;;244        //===========================================================
;;;245        //Note : This function should not be modified , when the callback is needed,
;;;246        //       the MID_URT_MspInit can be implemented in the user file.
;;;247        
;;;248    }
;;;249    
                          ENDP


                          AREA ||i.MID_EMB_WriteOperation_Disable||, CODE, READONLY, ALIGN=1

                  MID_EMB_WriteOperation_Disable PROC
;;;301     */
;;;302    MID_StatusTypeDef MID_EMB_WriteOperation_Disable(EMB_HandleTypeDef *mEMB)
000000  4601              MOV      r1,r0
;;;303    {
;;;304        if((mEMB->Instance->STA.W & EMB_STA_BUSYF_mask_w) == 0)
000002  6808              LDR      r0,[r1,#0]
000004  6800              LDR      r0,[r0,#0]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
00000a  2800              CMP      r0,#0
00000c  d107              BNE      |L6.30|
;;;305        {
;;;306            /* Disable write operation */
;;;307            mEMB->Instance->CR0.W &= ~EMB_CR0_WEN_mask_w;
00000e  6808              LDR      r0,[r1,#0]
000010  6900              LDR      r0,[r0,#0x10]
000012  2202              MOVS     r2,#2
000014  4390              BICS     r0,r0,r2
000016  680a              LDR      r2,[r1,#0]
000018  6110              STR      r0,[r2,#0x10]
;;;308            return MID_OK;
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;309        }
;;;310        else
;;;311        {
;;;312            return MID_BUSY;
;;;313        }
;;;314    }
00001c  4770              BX       lr
                  |L6.30|
00001e  2002              MOVS     r0,#2                 ;312
000020  e7fc              B        |L6.28|
;;;315    
                          ENDP


                          AREA ||i.MID_EMB_WriteOperation_Enable||, CODE, READONLY, ALIGN=1

                  MID_EMB_WriteOperation_Enable PROC
;;;286     */
;;;287    MID_StatusTypeDef MID_EMB_WriteOperation_Enable(EMB_HandleTypeDef *mEMB)
000000  4601              MOV      r1,r0
;;;288    {
;;;289        /* Enable write operation */
;;;290        mEMB->Instance->CR0.W |= EMB_CR0_WEN_mask_w;
000002  6808              LDR      r0,[r1,#0]
000004  6900              LDR      r0,[r0,#0x10]
000006  2202              MOVS     r2,#2
000008  4310              ORRS     r0,r0,r2
00000a  680a              LDR      r2,[r1,#0]
00000c  6110              STR      r0,[r2,#0x10]
;;;291        return MID_OK;
00000e  2000              MOVS     r0,#0
;;;292    }
000010  4770              BX       lr
;;;293    
                          ENDP


                          AREA ||i.MID_EMB_WriteProtectCallback||, CODE, READONLY, ALIGN=1

                  MID_EMB_WriteProtectCallback PROC
;;;356     */
;;;357    __weak void MID_EMB_WriteProtectCallback(EMB_HandleTypeDef *mEMB)
000000  4770              BX       lr
;;;358    {
;;;359        
;;;360    }
;;;361    #endif
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  CSC_InitConfig
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00010000
                          DCD      0x00000000
                          DCD      0x00000210
                          DCD      0x00000001
                          DCD      0x00000008
                          DCD      0x0000911f
                          DCD      0x000f13ed
                          DCD      0x00008993
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_EMB_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_EMB_MID_c_b9d6c17d____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_EMB_MID_c_b9d6c17d____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_EMB_MID_c_b9d6c17d____REVSH|
#line 496
|__asm___18_MG32x02z_EMB_MID_c_b9d6c17d____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
