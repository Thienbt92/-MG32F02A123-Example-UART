; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_wwdt_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_wwdt_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_wwdt_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_WWDT_MID.c]
                          THUMB

                          AREA ||i.MID_WWDT_IRQHandler||, CODE, READONLY, ALIGN=1

                  MID_WWDT_IRQHandler PROC
;;;191     */
;;;192    void MID_WWDT_IRQHandler(WWDT_HandleTypeDef *mWWDT)
000000  b510              PUSH     {r4,lr}
;;;193    {
000002  4604              MOV      r4,r0
;;;194        /* Check if Overfloat Interrupt is enable */
;;;195        if(__DRV_WWDT_GET_IT_SOURCE(mWWDT,WWDT_IT_TIE) != CLR)
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2102              MOVS     r1,#2
00000a  4008              ANDS     r0,r0,r1
00000c  0840              LSRS     r0,r0,#1
00000e  2800              CMP      r0,#0
000010  d00b              BEQ      |L1.42|
;;;196        {
;;;197            /* Check if WWDT Early Wakeup Interrupt occurred */
;;;198            if(__DRV_WWDT_GET_FLAG(mWWDT, WWDT_TF) != CLR)
000012  6820              LDR      r0,[r4,#0]
000014  6800              LDR      r0,[r0,#0]
000016  4008              ANDS     r0,r0,r1
000018  0840              LSRS     r0,r0,#1
00001a  2800              CMP      r0,#0
00001c  d005              BEQ      |L1.42|
;;;199            {
;;;200                /* Clear the WWDT Early Wakeup flag */
;;;201                __DRV_WWDT_CLEAR_FLAG(mWWDT, WWDT_TF);
00001e  2002              MOVS     r0,#2
000020  6821              LDR      r1,[r4,#0]
000022  6008              STR      r0,[r1,#0]
;;;202    
;;;203                /* Overfloat interrupt callback */ 
;;;204                MID_WWDT_TFINTCallback(mWWDT);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       MID_WWDT_TFINTCallback
                  |L1.42|
;;;205            }
;;;206        }
;;;207        
;;;208        /* Check if Window Interrupt is enable */
;;;209        if(__DRV_WWDT_GET_IT_SOURCE(mWWDT,WWDT_IT_WIN) != CLR)
00002a  6820              LDR      r0,[r4,#0]
00002c  6840              LDR      r0,[r0,#4]
00002e  2104              MOVS     r1,#4
000030  4008              ANDS     r0,r0,r1
000032  0880              LSRS     r0,r0,#2
000034  2800              CMP      r0,#0
000036  d00b              BEQ      |L1.80|
;;;210        {
;;;211            /* Check if WWDT Early Wakeup Interrupt occurred */
;;;212            if(__DRV_WWDT_GET_FLAG(mWWDT, WWDT_WINF) != CLR)
000038  6820              LDR      r0,[r4,#0]
00003a  6800              LDR      r0,[r0,#0]
00003c  4008              ANDS     r0,r0,r1
00003e  0880              LSRS     r0,r0,#2
000040  2800              CMP      r0,#0
000042  d005              BEQ      |L1.80|
;;;213            {
;;;214                /* Clear the WWDT Early Wakeup flag */
;;;215                __DRV_WWDT_CLEAR_FLAG(mWWDT, WWDT_WINF);
000044  2004              MOVS     r0,#4
000046  6821              LDR      r1,[r4,#0]
000048  6008              STR      r0,[r1,#0]
;;;216    
;;;217                /* Window interrupt callback */ 
;;;218                MID_WWDT_WININTCallback(mWWDT);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       MID_WWDT_WININTCallback
                  |L1.80|
;;;219            }
;;;220        }
;;;221    
;;;222        /* Check if Warning Interrupt is enable */
;;;223        if(__DRV_WWDT_GET_IT_SOURCE(mWWDT,WWDT_IT_WRN) != CLR)
000050  6820              LDR      r0,[r4,#0]
000052  6840              LDR      r0,[r0,#4]
000054  2108              MOVS     r1,#8
000056  4008              ANDS     r0,r0,r1
000058  08c0              LSRS     r0,r0,#3
00005a  2800              CMP      r0,#0
00005c  d00b              BEQ      |L1.118|
;;;224        {
;;;225            /* Check if WWDT Early Wakeup Interrupt occurred */
;;;226            if(__DRV_WWDT_GET_FLAG(mWWDT, WWDT_WRNF) != CLR)
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  4008              ANDS     r0,r0,r1
000064  08c0              LSRS     r0,r0,#3
000066  2800              CMP      r0,#0
000068  d005              BEQ      |L1.118|
;;;227            {
;;;228                /* Clear the WWDT Early Wakeup flag */
;;;229                __DRV_WWDT_CLEAR_FLAG(mWWDT, WWDT_WRNF);
00006a  2008              MOVS     r0,#8
00006c  6821              LDR      r1,[r4,#0]
00006e  6008              STR      r0,[r1,#0]
;;;230    
;;;231                /* Warning interrupt callback */ 
;;;232                MID_WWDT_WRNINTCallback(mWWDT);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       MID_WWDT_WRNINTCallback
                  |L1.118|
;;;233            }
;;;234        }
;;;235    }
000076  bd10              POP      {r4,pc}
;;;236    ///@}
                          ENDP


                          AREA ||i.MID_WWDT_Init||, CODE, READONLY, ALIGN=2

                  MID_WWDT_Init PROC
;;;59      */
;;;60     MID_StatusTypeDef MID_WWDT_Init(WWDT_HandleTypeDef *mWWDT)
000000  b510              PUSH     {r4,lr}
;;;61     {
000002  4604              MOV      r4,r0
;;;62         /* Check the WWDT handle allocation */
;;;63         if(mWWDT == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L2.12|
;;;64         {
;;;65             return MID_ERROR;
000008  2001              MOVS     r0,#1
                  |L2.10|
;;;66         }
;;;67     
;;;68         /* Check the parameters */
;;;69         assert_param(IS_WWDT_ALL_INSTANCE(mWWDT->Instance));
;;;70         assert_param(IS_WWDT_PRESCALER(mWWDT->Init.Prescaler));
;;;71         assert_param(IS_WWDT_WINDOW(mWWDT->Init.Window));
;;;72         assert_param(IS_WWDT_COUNTER(mWWDT->Init.Counter));
;;;73         assert_param(IS_WWDT_EWI_MODE(mWWDT->Init.EWIMode));
;;;74         assert_param(IS_WWDT_WINDOW(mWWDT->Init.Window));
;;;75       
;;;76         /* Module unprotect  */
;;;77         WWDT->KEY.W = 0xA217;
;;;78         
;;;79         /* Init the low level hardware */
;;;80         MID_WWDT_MspInit(mWWDT);                        //For user control.
;;;81     
;;;82         /* Set WWDT Counter */
;;;83         WWDT->RLR.W = mWWDT->Init.WWDT_RLR;             //Write WWDT reload regiter.
;;;84         WWDT->KEY.W = 0x2014;                           //Reflash and Reload WWDT count register.
;;;85     
;;;86         /* Set WWDT Prescaler and Window */
;;;87         WWDT->WIN.W = mWWDT->Init.WWDT_RLR;             //Write window compare register, Prescaler counter we are not SUP.
;;;88         
;;;89         /* Eanable WWDT Interrujpt */
;;;90         __DRV_WWDT_ENABLE_IT(mWWDT,mWWDT->Init.WWDT_INT_SEL);
;;;91         
;;;92         /* Enable WWDT Function */
;;;93         __DRV_WWDT_ENABLE(mWWDT);
;;;94         /* WWDT module protect*/
;;;95         WWDT->KEY.W = 0;
;;;96         
;;;97         /* Return function status */
;;;98         return MID_OK;
;;;99     }
00000a  bd10              POP      {r4,pc}
                  |L2.12|
00000c  480b              LDR      r0,|L2.60|
00000e  490c              LDR      r1,|L2.64|
000010  60c8              STR      r0,[r1,#0xc]          ;77
000012  4620              MOV      r0,r4                 ;80
000014  f7fffffe          BL       MID_WWDT_MspInit
000018  4909              LDR      r1,|L2.64|
00001a  68e0              LDR      r0,[r4,#0xc]          ;83
00001c  61c8              STR      r0,[r1,#0x1c]         ;83
00001e  4809              LDR      r0,|L2.68|
000020  60c8              STR      r0,[r1,#0xc]          ;84
000022  68e0              LDR      r0,[r4,#0xc]          ;87
000024  6208              STR      r0,[r1,#0x20]         ;87
000026  6821              LDR      r1,[r4,#0]            ;90
000028  6920              LDR      r0,[r4,#0x10]         ;90
00002a  6048              STR      r0,[r1,#4]            ;90
00002c  2001              MOVS     r0,#1                 ;93
00002e  6821              LDR      r1,[r4,#0]            ;93
000030  6108              STR      r0,[r1,#0x10]         ;93
000032  2000              MOVS     r0,#0                 ;95
000034  4902              LDR      r1,|L2.64|
000036  60c8              STR      r0,[r1,#0xc]          ;95
000038  bf00              NOP                            ;98
00003a  e7e6              B        |L2.10|
;;;100    ///@}
                          ENDP

                  |L2.60|
                          DCD      0x0000a217
                  |L2.64|
                          DCD      0x5d010000
                  |L2.68|
                          DCD      0x00002014

                          AREA ||i.MID_WWDT_MspInit||, CODE, READONLY, ALIGN=1

                  MID_WWDT_MspInit PROC
;;;120     */
;;;121    __weak void MID_WWDT_MspInit(WWDT_HandleTypeDef *mWWDT)
000000  4770              BX       lr
;;;122    {
;;;123      if(mWWDT->Instance==WWDT)
;;;124      {
;;;125      /* USER CODE BEGIN WWDT_MspInit 0 */
;;;126    
;;;127      /* USER CODE END WWDT_MspInit 0 */
;;;128        /* Peripheral clock enable */
;;;129        
;;;130      /* USER CODE BEGIN WWDT_MspInit 1 */
;;;131    
;;;132      /* USER CODE END WWDT_MspInit 1 */
;;;133      }
;;;134    }
;;;135    ///@}
                          ENDP


                          AREA ||i.MID_WWDT_Refresh||, CODE, READONLY, ALIGN=2

                  MID_WWDT_Refresh PROC
;;;156    
;;;157    MID_StatusTypeDef MID_WWDT_Refresh(WWDT_HandleTypeDef *mWWDT)
000000  4601              MOV      r1,r0
;;;158    {
;;;159        /* Write to WWDT CR the WWDT Counter value to refresh with */
;;;160        WWDT->KEY.W = 0x2014;
000002  4802              LDR      r0,|L4.12|
000004  4a02              LDR      r2,|L4.16|
000006  60d0              STR      r0,[r2,#0xc]
;;;161    
;;;162        /* Return function status */
;;;163        return MID_OK;
000008  2000              MOVS     r0,#0
;;;164    }
00000a  4770              BX       lr
;;;165    ///@}
                          ENDP

                  |L4.12|
                          DCD      0x00002014
                  |L4.16|
                          DCD      0x5d010000

                          AREA ||i.MID_WWDT_TFINTCallback||, CODE, READONLY, ALIGN=1

                  MID_WWDT_TFINTCallback PROC
;;;286     */
;;;287    __weak void MID_WWDT_TFINTCallback(WWDT_HandleTypeDef *mWWDT)
000000  4770              BX       lr
;;;288    {
;;;289        /* Prevent unused argument(s) compilation warning */
;;;290        UNUSED(mWWDT);
;;;291    
;;;292        /* NOTE: This function should not be modified, when the callback is needed,
;;;293           the MID_WWDT_EarlyWakeupCallback could be implemented in the user file
;;;294        */
;;;295    }
;;;296    ///@}
                          ENDP


                          AREA ||i.MID_WWDT_WININTCallback||, CODE, READONLY, ALIGN=1

                  MID_WWDT_WININTCallback PROC
;;;268     */
;;;269    __weak void MID_WWDT_WININTCallback(WWDT_HandleTypeDef *mWWDT)
000000  4770              BX       lr
;;;270    {
;;;271        /* Prevent unused argument(s) compilation warning */
;;;272        UNUSED(mWWDT);
;;;273    
;;;274        /* NOTE: This function should not be modified, when the callback is needed,
;;;275               the MID_WWDT_EarlyWakeupCallback could be implemented in the user file
;;;276        */
;;;277    }
;;;278    
                          ENDP


                          AREA ||i.MID_WWDT_WRNINTCallback||, CODE, READONLY, ALIGN=1

                  MID_WWDT_WRNINTCallback PROC
;;;250     */
;;;251    __weak void MID_WWDT_WRNINTCallback(WWDT_HandleTypeDef *mWWDT)
000000  4770              BX       lr
;;;252    {
;;;253        /* Prevent unused argument(s) compilation warning */
;;;254        UNUSED(mWWDT);
;;;255    
;;;256        /* NOTE: This function should not be modified, when the callback is needed,
;;;257               the MID_WWDT_EarlyWakeupCallback could be implemented in the user file
;;;258        */
;;;259    }
;;;260    
                          ENDP


                          AREA ||i.WWDT_Error_Handler||, CODE, READONLY, ALIGN=1

                  WWDT_Error_Handler PROC
;;;310     */
;;;311    __weak void WWDT_Error_Handler(WWDT_HandleTypeDef *mWWDT)
000000  4770              BX       lr
;;;312    {
;;;313        /* USER CODE BEGIN Error_Handler_Debug */
;;;314        /* User can add his own implementation to report the HAL error return state */
;;;315        UNUSED(mWWDT);
;;;316        /* USER CODE END Error_Handler_Debug */
;;;317    }
;;;318    ///@}
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_WWDT_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_MG32x02z_WWDT_MID_c_e55b8c39____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_MG32x02z_WWDT_MID_c_e55b8c39____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_MG32x02z_WWDT_MID_c_e55b8c39____REVSH|
#line 496
|__asm___19_MG32x02z_WWDT_MID_c_e55b8c39____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
