; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_adc_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_adc_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_adc_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_ADC_MID.c]
                          THUMB

                          AREA ||i.ADC_ConversionStop||, CODE, READONLY, ALIGN=2

                  ADC_ConversionStop PROC
;;;1460    */
;;;1461   static MID_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;1462   {
;;;1463       /* 1. Hold ADC                                                */
;;;1464       mADC->Instance->START.W |= ADC_START_HOLD_mask_w;
000002  6808              LDR      r0,[r1,#0]
000004  6a00              LDR      r0,[r0,#0x20]
000006  2202              MOVS     r2,#2
000008  4310              ORRS     r0,r0,r2
00000a  680a              LDR      r2,[r1,#0]
00000c  6210              STR      r0,[r2,#0x20]
;;;1465       
;;;1466       /* 2.1 Change ADC conversion mode to ADC_ONESHOT
;;;1467          2.2 Discontinue 
;;;1468          2.3 Trigger START conversion switch to 'SW : ADC0_START'
;;;1469          2.4 Disable Trigger edge 
;;;1470       */
;;;1471       mADC->Instance->START.W &= ~(ADC_START_CONV_MDS_mask_w  | 
00000e  6808              LDR      r0,[r1,#0]
000010  6a00              LDR      r0,[r0,#0x20]
000012  4a06              LDR      r2,|L1.44|
000014  4010              ANDS     r0,r0,r2
000016  680a              LDR      r2,[r1,#0]
000018  6210              STR      r0,[r2,#0x20]
;;;1472                                    ADC_START_TRG_CONT_mask_w  | 
;;;1473                                    ADC_START_START_SEL_mask_w | 
;;;1474                                    ADC_START_TRG_SEL_mask_w   );
;;;1475           
;;;1476       /* 3. Continue ADC convert                                    */
;;;1477       mADC->Instance->START.W &= ~ADC_START_HOLD_mask_w;
00001a  6808              LDR      r0,[r1,#0]
00001c  6a00              LDR      r0,[r0,#0x20]
00001e  2202              MOVS     r2,#2
000020  4390              BICS     r0,r0,r2
000022  680a              LDR      r2,[r1,#0]
000024  6210              STR      r0,[r2,#0x20]
;;;1478   
;;;1479       /* Return MID status */
;;;1480       return MID_SUCCESS;
000026  2000              MOVS     r0,#0
;;;1481   }
000028  4770              BX       lr
;;;1482   
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0xfcc0ffff

                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;1489    */
;;;1490   static void ADC_DMAConvCplt(DMA_HandleTypeDef *hDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;1491   {
000002  4605              MOV      r5,r0
;;;1492       /* Retrieve ADC handle corresponding to current DMA handle */
;;;1493       ADC_HandleTypeDef* mADC = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hDMA)->Parent;
000004  6aac              LDR      r4,[r5,#0x28]
;;;1494   
;;;1495       /* Disable ADC end of single conversion interrupt on group regular */
;;;1496       /* Note: Overrun interrupt was enabled with EOC interrupt in        */
;;;1497       /* MID_Start_IT(), but is not disabled here because can be used     */
;;;1498       /* by overrun IRQ process below.                                    */
;;;1499       __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_ESCNV));
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  2128              MOVS     r1,#0x28
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6048              STR      r0,[r1,#4]
;;;1500   
;;;1501       /* Set ADC state */
;;;1502       mADC->State = MID_ADC_STATE_READY;
000012  2001              MOVS     r0,#1
000014  6420              STR      r0,[r4,#0x40]
;;;1503   
;;;1504       /* Conversion complete callback */
;;;1505       MID_ADC_ConvCpltCallback(mADC); 
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       MID_ADC_ConvCpltCallback
;;;1506   
;;;1507   }
00001c  bd70              POP      {r4-r6,pc}
;;;1508   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;1532    */
;;;1533   static void ADC_DMAError(DMA_HandleTypeDef *hDMA)  
000000  b570              PUSH     {r4-r6,lr}
;;;1534   {
000002  4605              MOV      r5,r0
;;;1535       /* Retrieve ADC handle corresponding to current DMA handle */
;;;1536       ADC_HandleTypeDef* mADC = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hDMA)->Parent;
000004  6aac              LDR      r4,[r5,#0x28]
;;;1537       
;;;1538       /* Set ADC state */
;;;1539       mADC->State = MID_ADC_STATE_ERROR_DMA;
000006  2004              MOVS     r0,#4
000008  6420              STR      r0,[r4,#0x40]
;;;1540       
;;;1541       /* Set ADC error code to DMA error */
;;;1542       mADC->ErrorCode = MID_ADC_ERROR_DMA;
00000a  2003              MOVS     r0,#3
00000c  6460              STR      r0,[r4,#0x44]
;;;1543       
;;;1544       /* Error callback */
;;;1545       MID_ADC_ErrorCallback(mADC); 
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       MID_ADC_ErrorCallback
;;;1546        
;;;1547   }    
000014  bd70              POP      {r4-r6,pc}
;;;1548   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;1516    */
;;;1517   static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;1518   {
000002  4604              MOV      r4,r0
;;;1519       /* Retrieve ADC handle corresponding to current DMA handle */
;;;1520       ADC_HandleTypeDef* mADC = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hDMA)->Parent;
000004  6aa5              LDR      r5,[r4,#0x28]
;;;1521       
;;;1522       /* Half conversion callback */
;;;1523       MID_ADC_ConvHalfCpltCallback(mADC); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MID_ADC_ConvHalfCpltCallback
;;;1524   }
00000c  bd70              POP      {r4-r6,pc}
;;;1525   
                          ENDP


                          AREA ||i.ADC_Disable||, CODE, READONLY, ALIGN=1

                  ADC_Disable PROC
;;;1442    */
;;;1443   static MID_StatusTypeDef ADC_Disable(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;1444   {
;;;1445       // Mandatory stop ADC
;;;1446       __DRV_ADC_DISABLE(mADC);      
000002  6808              LDR      r0,[r1,#0]
000004  6900              LDR      r0,[r0,#0x10]
000006  0840              LSRS     r0,r0,#1
000008  0040              LSLS     r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  6110              STR      r0,[r2,#0x10]
;;;1447   
;;;1448       /* Return MID status */
;;;1449       return MID_SUCCESS;
00000e  2000              MOVS     r0,#0
;;;1450   }
000010  4770              BX       lr
;;;1451   
                          ENDP


                          AREA ||i.ADC_Enable||, CODE, READONLY, ALIGN=1

                  ADC_Enable PROC
;;;1410    */
;;;1411   static MID_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* mADC)
000000  b570              PUSH     {r4-r6,lr}
;;;1412   {
000002  4604              MOV      r4,r0
;;;1413       uint32_t tickstart = 0U; 
000004  2500              MOVS     r5,#0
;;;1414       
;;;1415       /* Enable the ADC peripheral */
;;;1416       __DRV_ADC_ENABLE(mADC);
000006  6820              LDR      r0,[r4,#0]
000008  6900              LDR      r0,[r0,#0x10]
00000a  2101              MOVS     r1,#1
00000c  4308              ORRS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6108              STR      r0,[r1,#0x10]
;;;1417       
;;;1418       /* Get tick count */
;;;1419       tickstart = MID_GetTick();
000012  f7fffffe          BL       MID_GetTick
000016  4605              MOV      r5,r0
;;;1420       
;;;1421       /* Wait for ADC effectively enabled */
;;;1422       while(1)
000018  e005              B        |L6.38|
                  |L6.26|
;;;1423       {
;;;1424         if((MID_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
00001a  f7fffffe          BL       MID_GetTick
00001e  1b40              SUBS     r0,r0,r5
000020  280a              CMP      r0,#0xa
000022  d900              BLS      |L6.38|
;;;1425             break;
000024  e000              B        |L6.40|
                  |L6.38|
000026  e7f8              B        |L6.26|
                  |L6.40|
000028  bf00              NOP      
;;;1426       }   
;;;1427       
;;;1428      
;;;1429       /* Return MID status */
;;;1430       return MID_SUCCESS;
00002a  2000              MOVS     r0,#0
;;;1431   }
00002c  bd70              POP      {r4-r6,pc}
;;;1432   
                          ENDP


                          AREA ||i.MID_ADC_AccumulateConfig||, CODE, READONLY, ALIGN=2

                  MID_ADC_AccumulateConfig PROC
;;;1334    */
;;;1335   MID_StatusTypeDef MID_ADC_AccumulateConfig(ADC_HandleTypeDef* mADC, ADC_AccumulateConfDef* AccumulateConfig)
000000  b510              PUSH     {r4,lr}
;;;1336   {
000002  4602              MOV      r2,r0
;;;1337       uint32_t tmpReg;
;;;1338       
;;;1339       /* Process locked */
;;;1340       __MID_LOCK(mADC);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5c80              LDRB     r0,[r0,r2]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L7.18|
00000e  2002              MOVS     r0,#2
                  |L7.16|
;;;1341           
;;;1342       /* Parameters update conditioned to ADC accumulation mode, data, numbers    */
;;;1343       tmpReg = mADC->Instance->CR1.W & ~(
;;;1344                   ADC_CR1_SUM_NUM_mask_w |    /* accumulation data number */
;;;1345                   ADC_CR1_SUM_MDS_mask_w |    /* ADC data accumulation sum channel mode selec */
;;;1346                   ADC_CR1_SOVR_MDS_mask_w);   /* ADC data sum overrun mode */
;;;1347       
;;;1348       tmpReg |= ((AccumulateConfig->AccumulateNumber << 16)  | AccumulateConfig->SOverrun | AccumulateConfig->AccumulationMode);
;;;1349       mADC->Instance->CR1.W = tmpReg;
;;;1350           
;;;1351       /* Parameters update conditioned to SUM0/1/2 channel                        */
;;;1352       tmpReg = mADC->Instance->MSK.W & ~(
;;;1353                   ADC_MSK_SUM0_MUX_mask_w |   
;;;1354                   ADC_MSK_SUM1_MUX_mask_w |   
;;;1355                   ADC_MSK_SUM2_MUX_mask_w);   
;;;1356       
;;;1357       tmpReg |= ((AccumulateConfig->SUM0_Channel << 16) | (AccumulateConfig->SUM1_Channel << 20) | (AccumulateConfig->SUM2_Channel << 24));
;;;1358       mADC->Instance->MSK.W = tmpReg;
;;;1359       
;;;1360       /* Initial SUM0/1/2 base value for accumulation                             */
;;;1361       mADC->Instance->SUM0.W = (AccumulateConfig->SUM0_Init & 0x0000FFFF);  
;;;1362       mADC->Instance->SUM1.W = (AccumulateConfig->SUM1_Init & 0x0000FFFF);  
;;;1363       mADC->Instance->SUM2.W = (AccumulateConfig->SUM2_Init & 0x0000FFFF);  
;;;1364       
;;;1365       /*  - Accumulation interrupt                                                */
;;;1366       __DRV_ADC_ENABLE_IT(mADC, AccumulateConfig->ITMode);
;;;1367       if(AccumulateConfig->ITMode != 0)
;;;1368           __DRV_ADC_ENABLE_ITEA(mADC);
;;;1369           
;;;1370       /* Process unlocked */
;;;1371       __MID_UNLOCK(mADC);
;;;1372       
;;;1373       /* Return function status */
;;;1374       return MID_SUCCESS;
;;;1375       
;;;1376   }
000010  bd10              POP      {r4,pc}
                  |L7.18|
000012  2401              MOVS     r4,#1                 ;1340
000014  203c              MOVS     r0,#0x3c              ;1340
000016  5484              STRB     r4,[r0,r2]            ;1340
000018  bf00              NOP                            ;1340
00001a  6810              LDR      r0,[r2,#0]            ;1343
00001c  6940              LDR      r0,[r0,#0x14]         ;1343
00001e  4c1f              LDR      r4,|L7.156|
000020  4020              ANDS     r0,r0,r4              ;1343
000022  4603              MOV      r3,r0                 ;1343
000024  8c08              LDRH     r0,[r1,#0x20]         ;1348
000026  0400              LSLS     r0,r0,#16             ;1348
000028  6a4c              LDR      r4,[r1,#0x24]         ;1348
00002a  4320              ORRS     r0,r0,r4              ;1348
00002c  680c              LDR      r4,[r1,#0]            ;1348
00002e  4320              ORRS     r0,r0,r4              ;1348
000030  4303              ORRS     r3,r3,r0              ;1348
000032  6810              LDR      r0,[r2,#0]            ;1349
000034  6143              STR      r3,[r0,#0x14]         ;1349
000036  6810              LDR      r0,[r2,#0]            ;1352
000038  69c0              LDR      r0,[r0,#0x1c]         ;1352
00003a  4c19              LDR      r4,|L7.160|
00003c  4020              ANDS     r0,r0,r4              ;1352
00003e  4603              MOV      r3,r0                 ;1352
000040  8888              LDRH     r0,[r1,#4]            ;1357
000042  0400              LSLS     r0,r0,#16             ;1357
000044  890c              LDRH     r4,[r1,#8]            ;1357
000046  0524              LSLS     r4,r4,#20             ;1357
000048  4320              ORRS     r0,r0,r4              ;1357
00004a  7b0c              LDRB     r4,[r1,#0xc]          ;1357
00004c  0624              LSLS     r4,r4,#24             ;1357
00004e  4320              ORRS     r0,r0,r4              ;1357
000050  4303              ORRS     r3,r3,r0              ;1357
000052  6810              LDR      r0,[r2,#0]            ;1358
000054  61c3              STR      r3,[r0,#0x1c]         ;1358
000056  8a08              LDRH     r0,[r1,#0x10]         ;1361
000058  b280              UXTH     r0,r0                 ;1361
00005a  6814              LDR      r4,[r2,#0]            ;1361
00005c  6320              STR      r0,[r4,#0x30]         ;1361
00005e  8a88              LDRH     r0,[r1,#0x14]         ;1362
000060  b280              UXTH     r0,r0                 ;1362
000062  6814              LDR      r4,[r2,#0]            ;1362
000064  6360              STR      r0,[r4,#0x34]         ;1362
000066  8b08              LDRH     r0,[r1,#0x18]         ;1363
000068  b280              UXTH     r0,r0                 ;1363
00006a  6814              LDR      r4,[r2,#0]            ;1363
00006c  63a0              STR      r0,[r4,#0x38]         ;1363
00006e  6810              LDR      r0,[r2,#0]            ;1366
000070  6840              LDR      r0,[r0,#4]            ;1366
000072  69cc              LDR      r4,[r1,#0x1c]         ;1366
000074  4320              ORRS     r0,r0,r4              ;1366
000076  6814              LDR      r4,[r2,#0]            ;1366
000078  6060              STR      r0,[r4,#4]            ;1366
00007a  69c8              LDR      r0,[r1,#0x1c]         ;1367
00007c  2800              CMP      r0,#0                 ;1367
00007e  d005              BEQ      |L7.140|
000080  6810              LDR      r0,[r2,#0]            ;1368
000082  6840              LDR      r0,[r0,#4]            ;1368
000084  2401              MOVS     r4,#1                 ;1368
000086  4320              ORRS     r0,r0,r4              ;1368
000088  6814              LDR      r4,[r2,#0]            ;1368
00008a  6060              STR      r0,[r4,#4]            ;1368
                  |L7.140|
00008c  bf00              NOP                            ;1371
00008e  2400              MOVS     r4,#0                 ;1371
000090  203c              MOVS     r0,#0x3c              ;1371
000092  5484              STRB     r4,[r0,r2]            ;1371
000094  bf00              NOP                            ;1371
000096  2000              MOVS     r0,#0                 ;1374
000098  e7ba              B        |L7.16|
;;;1377   
                          ENDP

00009a  0000              DCW      0x0000
                  |L7.156|
                          DCD      0xff80f9ff
                  |L7.160|
                          DCD      0xf000ffff

                          AREA ||i.MID_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=1

                  MID_ADC_AnalogWDGConfig PROC
;;;1261    */
;;;1262   MID_StatusTypeDef MID_ADC_AnalogWDGConfig(ADC_HandleTypeDef* mADC, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  b510              PUSH     {r4,lr}
;;;1263   {
000002  4602              MOV      r2,r0
;;;1264       
;;;1265       /* Process locked */
;;;1266       __MID_LOCK(mADC);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5c80              LDRB     r0,[r0,r2]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L8.18|
00000e  2002              MOVS     r0,#2
                  |L8.16|
;;;1267           
;;;1268       /* Parameters update conditioned to ADC state:                              */
;;;1269       /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1270       /* conversion on going on regular group:                                    */
;;;1271       if(AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_NONE)
;;;1272       {
;;;1273           mADC->Instance->CR1.W &= ~(ADC_CR1_WIND_EN_disable_w);
;;;1274           __DRV_ADC_DISABLE_IT(mADC, ADC_IT_AWD);
;;;1275       }
;;;1276       else
;;;1277       {
;;;1278           /*  - Analog watchdog mode                                           */
;;;1279           mADC->Instance->CR1.W &= ~(ADC_CR1_WIND_MDS_mask_w);
;;;1280           mADC->Instance->CR1.W |= AnalogWDGConfig->WatchdogMode;
;;;1281   
;;;1282           /*  - Analog watchdog channels (Only support scan channel mode)      */
;;;1283           mADC->Instance->START.W &= ~(ADC_START_CH_MUX_mask_w);
;;;1284           mADC->Instance->START.W |= (AnalogWDGConfig->Channel & ~(ADC_START_CH_SEL_mask_w));        
;;;1285           
;;;1286           /*  - Analog watchdog thresholds                                     */
;;;1287           mADC->Instance->WINDTH.MBIT.WIND_HT = AnalogWDGConfig->HighThreshold;
;;;1288           mADC->Instance->WINDTH.MBIT.WIND_LT = AnalogWDGConfig->LowThreshold;
;;;1289           
;;;1290           /*  - Analog watchdog thresholds with ADC data output               */
;;;1291           mADC->Instance->CR0.W &= ~(ADC_CR0_LIM_MDS_mask_w);
;;;1292           mADC->Instance->CR0.W |= (AnalogWDGConfig->WatchdogDataLimit);        
;;;1293           
;;;1294           /*  - Analog watchdog interrupt                                      */
;;;1295           __DRV_ADC_ENABLE_IT(mADC, AnalogWDGConfig->ITMode);
;;;1296           
;;;1297       }
;;;1298       /* Process unlocked */
;;;1299       __MID_UNLOCK(mADC);
;;;1300       
;;;1301       /* Return function status */
;;;1302       return MID_SUCCESS;
;;;1303       
;;;1304   }
000010  bd10              POP      {r4,pc}
                  |L8.18|
000012  2301              MOVS     r3,#1                 ;1266
000014  203c              MOVS     r0,#0x3c              ;1266
000016  5483              STRB     r3,[r0,r2]            ;1266
000018  bf00              NOP                            ;1266
00001a  6808              LDR      r0,[r1,#0]            ;1271
00001c  2800              CMP      r0,#0                 ;1271
00001e  d10b              BNE      |L8.56|
000020  6810              LDR      r0,[r2,#0]            ;1273
000022  6940              LDR      r0,[r0,#0x14]         ;1273
000024  6813              LDR      r3,[r2,#0]            ;1273
000026  6158              STR      r0,[r3,#0x14]         ;1273
000028  6810              LDR      r0,[r2,#0]            ;1274
00002a  6840              LDR      r0,[r0,#4]            ;1274
00002c  2307              MOVS     r3,#7                 ;1274
00002e  021b              LSLS     r3,r3,#8              ;1274
000030  4398              BICS     r0,r0,r3              ;1274
000032  6813              LDR      r3,[r2,#0]            ;1274
000034  6058              STR      r0,[r3,#4]            ;1274
000036  e042              B        |L8.190|
                  |L8.56|
000038  6810              LDR      r0,[r2,#0]            ;1279
00003a  6940              LDR      r0,[r0,#0x14]         ;1279
00003c  2302              MOVS     r3,#2                 ;1279
00003e  4398              BICS     r0,r0,r3              ;1279
000040  6813              LDR      r3,[r2,#0]            ;1279
000042  6158              STR      r0,[r3,#0x14]         ;1279
000044  6810              LDR      r0,[r2,#0]            ;1280
000046  6940              LDR      r0,[r0,#0x14]         ;1280
000048  680b              LDR      r3,[r1,#0]            ;1280
00004a  4318              ORRS     r0,r0,r3              ;1280
00004c  6813              LDR      r3,[r2,#0]            ;1280
00004e  6158              STR      r0,[r3,#0x14]         ;1280
000050  6810              LDR      r0,[r2,#0]            ;1283
000052  6a00              LDR      r0,[r0,#0x20]         ;1283
000054  230f              MOVS     r3,#0xf               ;1283
000056  021b              LSLS     r3,r3,#8              ;1283
000058  4398              BICS     r0,r0,r3              ;1283
00005a  6813              LDR      r3,[r2,#0]            ;1283
00005c  6218              STR      r0,[r3,#0x20]         ;1283
00005e  6810              LDR      r0,[r2,#0]            ;1284
000060  6a00              LDR      r0,[r0,#0x20]         ;1284
000062  2401              MOVS     r4,#1                 ;1284
000064  0324              LSLS     r4,r4,#12             ;1284
000066  684b              LDR      r3,[r1,#4]            ;1284
000068  43a3              BICS     r3,r3,r4              ;1284
00006a  4318              ORRS     r0,r0,r3              ;1284
00006c  6813              LDR      r3,[r2,#0]            ;1284
00006e  6218              STR      r0,[r3,#0x20]         ;1284
000070  6810              LDR      r0,[r2,#0]            ;1287
000072  89c0              LDRH     r0,[r0,#0xe]          ;1287
000074  0b00              LSRS     r0,r0,#12             ;1287
000076  0300              LSLS     r0,r0,#12             ;1287
000078  898b              LDRH     r3,[r1,#0xc]          ;1287
00007a  051b              LSLS     r3,r3,#20             ;1287
00007c  0d1b              LSRS     r3,r3,#20             ;1287
00007e  4318              ORRS     r0,r0,r3              ;1287
000080  6813              LDR      r3,[r2,#0]            ;1287
000082  81d8              STRH     r0,[r3,#0xe]          ;1287
000084  6810              LDR      r0,[r2,#0]            ;1288
000086  8980              LDRH     r0,[r0,#0xc]          ;1288
000088  0b00              LSRS     r0,r0,#12             ;1288
00008a  0300              LSLS     r0,r0,#12             ;1288
00008c  8a0b              LDRH     r3,[r1,#0x10]         ;1288
00008e  051b              LSLS     r3,r3,#20             ;1288
000090  0d1b              LSRS     r3,r3,#20             ;1288
000092  4318              ORRS     r0,r0,r3              ;1288
000094  6813              LDR      r3,[r2,#0]            ;1288
000096  8198              STRH     r0,[r3,#0xc]          ;1288
000098  6810              LDR      r0,[r2,#0]            ;1291
00009a  6900              LDR      r0,[r0,#0x10]         ;1291
00009c  2303              MOVS     r3,#3                 ;1291
00009e  039b              LSLS     r3,r3,#14             ;1291
0000a0  4398              BICS     r0,r0,r3              ;1291
0000a2  6813              LDR      r3,[r2,#0]            ;1291
0000a4  6118              STR      r0,[r3,#0x10]         ;1291
0000a6  6810              LDR      r0,[r2,#0]            ;1292
0000a8  6900              LDR      r0,[r0,#0x10]         ;1292
0000aa  694b              LDR      r3,[r1,#0x14]         ;1292
0000ac  4318              ORRS     r0,r0,r3              ;1292
0000ae  6813              LDR      r3,[r2,#0]            ;1292
0000b0  6118              STR      r0,[r3,#0x10]         ;1292
0000b2  6810              LDR      r0,[r2,#0]            ;1295
0000b4  6840              LDR      r0,[r0,#4]            ;1295
0000b6  688b              LDR      r3,[r1,#8]            ;1295
0000b8  4318              ORRS     r0,r0,r3              ;1295
0000ba  6813              LDR      r3,[r2,#0]            ;1295
0000bc  6058              STR      r0,[r3,#4]            ;1295
                  |L8.190|
0000be  bf00              NOP                            ;1299
0000c0  2300              MOVS     r3,#0                 ;1299
0000c2  203c              MOVS     r0,#0x3c              ;1299
0000c4  5483              STRB     r3,[r0,r2]            ;1299
0000c6  bf00              NOP                            ;1299
0000c8  2000              MOVS     r0,#0                 ;1302
0000ca  e7a1              B        |L8.16|
;;;1305   
                          ENDP


                          AREA ||i.MID_ADC_Calibration_Start||, CODE, READONLY, ALIGN=2

                  MID_ADC_Calibration_Start PROC
;;;1864    */
;;;1865   MID_StatusTypeDef MID_ADC_Calibration_Start(ADC_HandleTypeDef* mADC)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1866   {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
;;;1867   #if defined(MG32_3RD)
;;;1868       int16_t ADC_CONV;
;;;1869       uint8_t i, OFFT_ADC_MinIDX, ADC_CALI_Complete;
;;;1870       uint32_t rADC_MSK, rADC_START, rADC_CR0, rADC_CR1;
;;;1871       uint32_t rSUM0, rSUM1, rSUM2;
;;;1872      
;;;1873       // RESAVE
;;;1874       rADC_MSK = mADC->Instance->MSK.W;
;;;1875       rADC_START = mADC->Instance->START.W;
;;;1876       rADC_CR0 = mADC->Instance->CR0.W;    
;;;1877       rADC_CR1 = mADC->Instance->CR1.W;    
;;;1878       rSUM0 = mADC->Instance->SUM0.W;
;;;1879       rSUM1 = mADC->Instance->SUM1.W;
;;;1880       rSUM2 = mADC->Instance->SUM2.W;
;;;1881      
;;;1882       // reset SUM_NUM & window detect
;;;1883       mADC->Instance->CR1.W &= ~(ADC_CR1_SUM_NUM_mask_w | ADC_CR1_WIND_EN_enable_w);
;;;1884   
;;;1885       // config ADC mode for calibration
;;;1886       mADC->Instance->CR0.W = ADC_CR0_RES_SEL_12_bit_w | ADC_CR0_EN_enable_w;
;;;1887      
;;;1888       mADC->Instance->START.W = ADC_START_CONV_MDS_one_w | ADC_START_TRG_SEL_disable_w | \
;;;1889                                 ADC_START_START_SEL_sw_w;
;;;1890      
;;;1891       // start calibration
;;;1892       // ------------------------------------------------------------------------
;;;1893       // start calibration - Offset issue
;;;1894       // ------------------------------------------------------------------------
;;;1895       mADC->Instance->START.W &= ~(ADC_START_CH_MUX_mask_w | ADC_START_CH_SEL_mask_w);
;;;1896       mADC->Instance->START.W = ADC_CHANNEL_16; // select internal channel VSSA
;;;1897      
;;;1898       OFFT_ADC_MinIDX = 0;
;;;1899   
;;;1900       // ------------------------------------------------------------------------
;;;1901       // 1. Scan minimum index when ADC sample not equal '0'
;;;1902       // ------------------------------------------------------------------------
;;;1903       while(1)
;;;1904       {
;;;1905           // set ADC_GAIN_OFFT
;;;1906           mADC->Instance->GAIN.W &= ~(ADC_GAIN_OFFT_ADC_mask_w);
;;;1907           mADC->Instance->GAIN.W |= (OFFT_ADC_MinIDX << ADC_GAIN_OFFT_ADC_shift_w);
;;;1908          
;;;1909           // sample internal VSS
;;;1910           mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
;;;1911           while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
;;;1912           __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
;;;1913           ADC_CONV += MID_ADC_GetValue(mADC);
;;;1914          
;;;1915          
;;;1916           // check ADC_CONV data (search ADC_CONV==1 or 2)  
;;;1917           if (ADC_CONV == 0)
;;;1918           {
;;;1919               OFFT_ADC_MinIDX ++;
;;;1920           }
;;;1921           else
;;;1922           {
;;;1923               if(OFFT_ADC_MinIDX < 2)     // No trimming range in this issue
;;;1924               {
;;;1925                   OFFT_ADC_MinIDX = 0;
;;;1926                   break;        
;;;1927               }
;;;1928               OFFT_ADC_MinIDX -= 2;
;;;1929               break;
;;;1930           }
;;;1931          
;;;1932           //
;;;1933           if (OFFT_ADC_MinIDX == 31) break;
;;;1934          
;;;1935       }
;;;1936      
;;;1937      
;;;1938       // ------------------------------------------------------------------------
;;;1939       // 2. average ADC conversion data -> decide the optimum
;;;1940       // ------------------------------------------------------------------------
;;;1941       while(1)
;;;1942       {
;;;1943           // set ADC_GAIN_OFFT
;;;1944           ADC0->GAIN.MBIT.OFFT_ADC = OFFT_ADC_MinIDX;
;;;1945                  
;;;1946           // Average ADC conversion
;;;1947          
;;;1948          
;;;1949           for (i=0, ADC_CONV=0 ; i<8; i++)
;;;1950           {
;;;1951               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
;;;1952               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
;;;1953               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
;;;1954               ADC_CONV += MID_ADC_GetValue(mADC);
;;;1955          
;;;1956           }        
;;;1957          
;;;1958           // check ADC_CONV data (search ADC_CONV==1 or 2)  
;;;1959           if (ADC_CONV == 0)
;;;1960           {
;;;1961               OFFT_ADC_MinIDX ++;
;;;1962           }
;;;1963           else if (ADC_CONV < 8)
;;;1964           {
;;;1965               break;
;;;1966           }
;;;1967           else
;;;1968           {
;;;1969               if(OFFT_ADC_MinIDX == 0)
;;;1970               {
;;;1971                   ADC_CALI_Complete = 0;
;;;1972                   break;         // No trimming range in this issue
;;;1973               }
;;;1974               OFFT_ADC_MinIDX --;         // make sure -> ADC can convert '0'
;;;1975               ADC_CALI_Complete = 1;
;;;1976               break;
;;;1977           }
;;;1978           //
;;;1979           if (OFFT_ADC_MinIDX == 31)
;;;1980           {
;;;1981               ADC_CALI_Complete = 0;
;;;1982               break;
;;;1983           }
;;;1984          
;;;1985       }
;;;1986      
;;;1987       // desire ADC_GAIN_OFFT
;;;1988       mADC->Instance->GAIN.W &= ~(ADC_GAIN_OFFT_ADC_mask_w);
;;;1989       mADC->Instance->GAIN.W |= (OFFT_ADC_MinIDX << ADC_GAIN_OFFT_ADC_shift_w);
;;;1990      
;;;1991      
;;;1992       // restore
;;;1993       mADC->Instance->MSK.W = rADC_MSK;
;;;1994       mADC->Instance->START.W = rADC_START;
;;;1995       mADC->Instance->CR0.W = rADC_CR0;    
;;;1996       mADC->Instance->CR1.W = rADC_CR1;    
;;;1997       mADC->Instance->SUM0.W = rSUM0;
;;;1998       mADC->Instance->SUM1.W = rSUM1;
;;;1999       mADC->Instance->SUM2.W = rSUM2;
;;;2000   
;;;2001       if (ADC_CALI_Complete == 1)
;;;2002           return MID_SUCCESS;
;;;2003       else
;;;2004           return MID_FAILURE;
;;;2005      
;;;2006   #elif defined(MG32_1ST)
;;;2007       int16_t VRP, VRN, VRM;
;;;2008       int32_t VRPV, VRNV;
;;;2009       uint8_t i;
;;;2010       uint32_t rADC_MSK, rADC_START, rADC_CR0, rADC_CR1;
;;;2011       uint32_t rSUM0, rSUM1, rSUM2;
;;;2012       
;;;2013       // RESAVE
;;;2014       rADC_MSK = mADC->Instance->MSK.W;
000006  6820              LDR      r0,[r4,#0]
000008  69c0              LDR      r0,[r0,#0x1c]
00000a  9007              STR      r0,[sp,#0x1c]
;;;2015       rADC_START = mADC->Instance->START.W;
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  9006              STR      r0,[sp,#0x18]
;;;2016       rADC_CR0 = mADC->Instance->CR0.W;    
000012  6820              LDR      r0,[r4,#0]
000014  6900              LDR      r0,[r0,#0x10]
000016  9005              STR      r0,[sp,#0x14]
;;;2017       rADC_CR1 = mADC->Instance->CR1.W;    
000018  6820              LDR      r0,[r4,#0]
00001a  6940              LDR      r0,[r0,#0x14]
00001c  9004              STR      r0,[sp,#0x10]
;;;2018       rSUM0 = mADC->Instance->SUM0.W;
00001e  6820              LDR      r0,[r4,#0]
000020  6b00              LDR      r0,[r0,#0x30]
000022  9003              STR      r0,[sp,#0xc]
;;;2019       rSUM1 = mADC->Instance->SUM1.W;
000024  6820              LDR      r0,[r4,#0]
000026  6b40              LDR      r0,[r0,#0x34]
000028  9002              STR      r0,[sp,#8]
;;;2020       rSUM2 = mADC->Instance->SUM2.W;
00002a  6820              LDR      r0,[r4,#0]
00002c  6b80              LDR      r0,[r0,#0x38]
00002e  9001              STR      r0,[sp,#4]
;;;2021       
;;;2022       // reset SUM_NUM & window detect
;;;2023       mADC->Instance->CR1.W &= ~(ADC_CR1_SUM_NUM_mask_w | ADC_CR1_WIND_EN_enable_w);
000030  6820              LDR      r0,[r4,#0]
000032  6940              LDR      r0,[r0,#0x14]
000034  4992              LDR      r1,|L9.640|
000036  4008              ANDS     r0,r0,r1
000038  6821              LDR      r1,[r4,#0]
00003a  6148              STR      r0,[r1,#0x14]
;;;2024   
;;;2025       // config ADC mode for calibration 
;;;2026       mADC->Instance->CR0.W = ADC_CR0_CODE_FMT_unsigned_w | ADC_CR0_RES_SEL_12_bit_w | \
00003c  2001              MOVS     r0,#1
00003e  6821              LDR      r1,[r4,#0]
000040  6108              STR      r0,[r1,#0x10]
;;;2027                               ADC_CR0_MDS_single_end_w | ADC_CR0_EN_enable_w;
;;;2028       
;;;2029       mADC->Instance->START.W = ADC_START_CONV_MDS_one_w | ADC_START_TRG_SEL_disable_w | \
000042  2000              MOVS     r0,#0
000044  6821              LDR      r1,[r4,#0]
000046  6208              STR      r0,[r1,#0x20]
;;;2030                                 ADC_START_START_SEL_sw_w;
;;;2031       
;;;2032       // start calibration
;;;2033       MID_UnProtectModuleReg(CFGmodule); 
000048  488e              LDR      r0,|L9.644|
00004a  f7fffffe          BL       MID_UnProtectModuleReg
;;;2034       
;;;2035       VRP = 32;
00004e  2620              MOVS     r6,#0x20
;;;2036       VRN = 32;
000050  2720              MOVS     r7,#0x20
;;;2037       VRM = 32;
000052  2020              MOVS     r0,#0x20
000054  900a              STR      r0,[sp,#0x28]
;;;2038       __DRV_CFG_WRITE_ADCREFTOP(VRP);
000056  488b              LDR      r0,|L9.644|
000058  3038              ADDS     r0,r0,#0x38
00005a  70c6              STRB     r6,[r0,#3]
;;;2039       __DRV_CFG_WRITE_ADCREFMIDDLE(VRM);
00005c  4989              LDR      r1,|L9.644|
00005e  3138              ADDS     r1,r1,#0x38
000060  980a              LDR      r0,[sp,#0x28]
000062  7088              STRB     r0,[r1,#2]
;;;2040       __DRV_CFG_WRITE_ADCREFBOTTOM(VRN);
000064  4608              MOV      r0,r1
000066  7047              STRB     r7,[r0,#1]
;;;2041       
;;;2042       
;;;2043       VRN = 0;
000068  2700              MOVS     r7,#0
;;;2044       while(1)
00006a  e063              B        |L9.308|
                  |L9.108|
;;;2045       {
;;;2046           __DRV_CFG_WRITE_ADCREFBOTTOM(VRN);
00006c  4885              LDR      r0,|L9.644|
00006e  3038              ADDS     r0,r0,#0x38
000070  7047              STRB     r7,[r0,#1]
;;;2047           __DRV_ADC_CHSELR_CHANNEL(mADC, ADC_CHANNEL_16);
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  211f              MOVS     r1,#0x1f
000078  0209              LSLS     r1,r1,#8
00007a  4388              BICS     r0,r0,r1
00007c  6821              LDR      r1,[r4,#0]
00007e  6208              STR      r0,[r1,#0x20]
000080  6820              LDR      r0,[r4,#0]
000082  6a00              LDR      r0,[r0,#0x20]
000084  2101              MOVS     r1,#1
000086  0309              LSLS     r1,r1,#12
000088  4308              ORRS     r0,r0,r1
00008a  6821              LDR      r1,[r4,#0]
00008c  6208              STR      r0,[r1,#0x20]
;;;2048   
;;;2049           for (i=0, VRNV=0 ; i<10; i++)
00008e  2500              MOVS     r5,#0
000090  2000              MOVS     r0,#0
000092  9008              STR      r0,[sp,#0x20]
000094  e012              B        |L9.188|
                  |L9.150|
;;;2050           {
;;;2051               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
000096  6820              LDR      r0,[r4,#0]
000098  6a00              LDR      r0,[r0,#0x20]
00009a  2101              MOVS     r1,#1
00009c  4308              ORRS     r0,r0,r1
00009e  6821              LDR      r1,[r4,#0]
0000a0  6208              STR      r0,[r1,#0x20]
;;;2052               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
0000a2  bf00              NOP      
                  |L9.164|
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6800              LDR      r0,[r0,#0]
0000a8  2108              MOVS     r1,#8
0000aa  4008              ANDS     r0,r0,r1
0000ac  08c0              LSRS     r0,r0,#3
0000ae  2800              CMP      r0,#0
0000b0  d0f8              BEQ      |L9.164|
;;;2053               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
0000b2  200c              MOVS     r0,#0xc
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6008              STR      r0,[r1,#0]
0000b8  1c68              ADDS     r0,r5,#1              ;2049
0000ba  b2c5              UXTB     r5,r0                 ;2049
                  |L9.188|
0000bc  2d0a              CMP      r5,#0xa               ;2049
0000be  dbea              BLT      |L9.150|
;;;2054           }
;;;2055           for (i=0, VRNV=0 ; i<10; i++)
0000c0  2500              MOVS     r5,#0
0000c2  2000              MOVS     r0,#0
0000c4  9008              STR      r0,[sp,#0x20]
0000c6  e01e              B        |L9.262|
                  |L9.200|
;;;2056           {
;;;2057               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
0000c8  6820              LDR      r0,[r4,#0]
0000ca  6a00              LDR      r0,[r0,#0x20]
0000cc  2101              MOVS     r1,#1
0000ce  4308              ORRS     r0,r0,r1
0000d0  6821              LDR      r1,[r4,#0]
0000d2  6208              STR      r0,[r1,#0x20]
;;;2058               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
0000d4  bf00              NOP      
                  |L9.214|
0000d6  6820              LDR      r0,[r4,#0]
0000d8  6800              LDR      r0,[r0,#0]
0000da  2108              MOVS     r1,#8
0000dc  4008              ANDS     r0,r0,r1
0000de  08c0              LSRS     r0,r0,#3
0000e0  2800              CMP      r0,#0
0000e2  d0f8              BEQ      |L9.214|
;;;2059               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
0000e4  200c              MOVS     r0,#0xc
0000e6  6821              LDR      r1,[r4,#0]
0000e8  6008              STR      r0,[r1,#0]
;;;2060               if( MID_ADC_GetValue(mADC) == 0x0000) break;
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       MID_ADC_GetValue
0000f0  2800              CMP      r0,#0
0000f2  d100              BNE      |L9.246|
0000f4  e009              B        |L9.266|
                  |L9.246|
;;;2061               VRNV += MID_ADC_GetValue(mADC);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       MID_ADC_GetValue
0000fc  9908              LDR      r1,[sp,#0x20]
0000fe  1840              ADDS     r0,r0,r1
000100  9008              STR      r0,[sp,#0x20]
000102  1c68              ADDS     r0,r5,#1              ;2055
000104  b2c5              UXTB     r5,r0                 ;2055
                  |L9.262|
000106  2d0a              CMP      r5,#0xa               ;2055
000108  dbde              BLT      |L9.200|
                  |L9.266|
00010a  bf00              NOP                            ;2060
;;;2062           }
;;;2063           VRNV = VRNV / 10;
00010c  210a              MOVS     r1,#0xa
00010e  9808              LDR      r0,[sp,#0x20]
000110  f7fffffe          BL       __aeabi_idivmod
000114  9008              STR      r0,[sp,#0x20]
;;;2064   
;;;2065           
;;;2066           if (VRNV > 0) VRN ++;
000116  9808              LDR      r0,[sp,#0x20]
000118  2800              CMP      r0,#0
00011a  dd01              BLE      |L9.288|
00011c  1c78              ADDS     r0,r7,#1
00011e  b207              SXTH     r7,r0
                  |L9.288|
;;;2067           if (VRNV == 0) 
000120  9808              LDR      r0,[sp,#0x20]
000122  2800              CMP      r0,#0
000124  d102              BNE      |L9.300|
;;;2068           {
;;;2069               VRN -= 1; 
000126  1e78              SUBS     r0,r7,#1
000128  b207              SXTH     r7,r0
;;;2070               break;
00012a  e004              B        |L9.310|
                  |L9.300|
;;;2071           }
;;;2072           if (VRN == 64) 
00012c  2f40              CMP      r7,#0x40
00012e  d101              BNE      |L9.308|
;;;2073           {
;;;2074               VRN = 32;
000130  2720              MOVS     r7,#0x20
;;;2075               break;
000132  e000              B        |L9.310|
                  |L9.308|
000134  e79a              B        |L9.108|
                  |L9.310|
000136  bf00              NOP                            ;2070
;;;2076           }
;;;2077       }
;;;2078       
;;;2079       __DRV_CFG_WRITE_ADCREFMIDDLE(32);
000138  2120              MOVS     r1,#0x20
00013a  4852              LDR      r0,|L9.644|
00013c  3038              ADDS     r0,r0,#0x38
00013e  7081              STRB     r1,[r0,#2]
;;;2080       __DRV_CFG_WRITE_ADCREFBOTTOM(32);
000140  7041              STRB     r1,[r0,#1]
;;;2081       VRP = 0;
000142  2600              MOVS     r6,#0
;;;2082       while(1)
000144  e064              B        |L9.528|
                  |L9.326|
;;;2083       {
;;;2084           __DRV_CFG_WRITE_ADCREFTOP(VRP);
000146  484f              LDR      r0,|L9.644|
000148  3038              ADDS     r0,r0,#0x38
00014a  70c6              STRB     r6,[r0,#3]
;;;2085           
;;;2086           __DRV_ADC_CHSELR_CHANNEL(mADC, ADC_CHANNEL_17);
00014c  6820              LDR      r0,[r4,#0]
00014e  6a00              LDR      r0,[r0,#0x20]
000150  211f              MOVS     r1,#0x1f
000152  0209              LSLS     r1,r1,#8
000154  4388              BICS     r0,r0,r1
000156  6821              LDR      r1,[r4,#0]
000158  6208              STR      r0,[r1,#0x20]
00015a  6820              LDR      r0,[r4,#0]
00015c  6a00              LDR      r0,[r0,#0x20]
00015e  2111              MOVS     r1,#0x11
000160  0209              LSLS     r1,r1,#8
000162  4308              ORRS     r0,r0,r1
000164  6821              LDR      r1,[r4,#0]
000166  6208              STR      r0,[r1,#0x20]
;;;2087           for (i=0, VRPV=0 ; i<10; i++)
000168  2500              MOVS     r5,#0
00016a  2000              MOVS     r0,#0
00016c  9009              STR      r0,[sp,#0x24]
00016e  e012              B        |L9.406|
                  |L9.368|
;;;2088           {
;;;2089               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
000170  6820              LDR      r0,[r4,#0]
000172  6a00              LDR      r0,[r0,#0x20]
000174  2101              MOVS     r1,#1
000176  4308              ORRS     r0,r0,r1
000178  6821              LDR      r1,[r4,#0]
00017a  6208              STR      r0,[r1,#0x20]
;;;2090               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
00017c  bf00              NOP      
                  |L9.382|
00017e  6820              LDR      r0,[r4,#0]
000180  6800              LDR      r0,[r0,#0]
000182  2108              MOVS     r1,#8
000184  4008              ANDS     r0,r0,r1
000186  08c0              LSRS     r0,r0,#3
000188  2800              CMP      r0,#0
00018a  d0f8              BEQ      |L9.382|
;;;2091               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
00018c  200c              MOVS     r0,#0xc
00018e  6821              LDR      r1,[r4,#0]
000190  6008              STR      r0,[r1,#0]
000192  1c68              ADDS     r0,r5,#1              ;2087
000194  b2c5              UXTB     r5,r0                 ;2087
                  |L9.406|
000196  2d0a              CMP      r5,#0xa               ;2087
000198  dbea              BLT      |L9.368|
;;;2092           }
;;;2093           for (i=0, VRPV=0 ; i<10; i++)
00019a  2500              MOVS     r5,#0
00019c  2000              MOVS     r0,#0
00019e  9009              STR      r0,[sp,#0x24]
0001a0  e01f              B        |L9.482|
                  |L9.418|
;;;2094           {
;;;2095               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
0001a2  6820              LDR      r0,[r4,#0]
0001a4  6a00              LDR      r0,[r0,#0x20]
0001a6  2101              MOVS     r1,#1
0001a8  4308              ORRS     r0,r0,r1
0001aa  6821              LDR      r1,[r4,#0]
0001ac  6208              STR      r0,[r1,#0x20]
;;;2096               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
0001ae  bf00              NOP      
                  |L9.432|
0001b0  6820              LDR      r0,[r4,#0]
0001b2  6800              LDR      r0,[r0,#0]
0001b4  2108              MOVS     r1,#8
0001b6  4008              ANDS     r0,r0,r1
0001b8  08c0              LSRS     r0,r0,#3
0001ba  2800              CMP      r0,#0
0001bc  d0f8              BEQ      |L9.432|
;;;2097               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
0001be  200c              MOVS     r0,#0xc
0001c0  6821              LDR      r1,[r4,#0]
0001c2  6008              STR      r0,[r1,#0]
;;;2098               if( MID_ADC_GetValue(mADC)  < 4095) break;
0001c4  4620              MOV      r0,r4
0001c6  f7fffffe          BL       MID_ADC_GetValue
0001ca  492f              LDR      r1,|L9.648|
0001cc  4288              CMP      r0,r1
0001ce  d200              BCS      |L9.466|
0001d0  e009              B        |L9.486|
                  |L9.466|
;;;2099               VRPV += MID_ADC_GetValue(mADC);
0001d2  4620              MOV      r0,r4
0001d4  f7fffffe          BL       MID_ADC_GetValue
0001d8  9909              LDR      r1,[sp,#0x24]
0001da  1840              ADDS     r0,r0,r1
0001dc  9009              STR      r0,[sp,#0x24]
0001de  1c68              ADDS     r0,r5,#1              ;2093
0001e0  b2c5              UXTB     r5,r0                 ;2093
                  |L9.482|
0001e2  2d0a              CMP      r5,#0xa               ;2093
0001e4  dbdd              BLT      |L9.418|
                  |L9.486|
0001e6  bf00              NOP                            ;2098
;;;2100           }
;;;2101           VRPV = VRPV / 10;
0001e8  210a              MOVS     r1,#0xa
0001ea  9809              LDR      r0,[sp,#0x24]
0001ec  f7fffffe          BL       __aeabi_idivmod
0001f0  9009              STR      r0,[sp,#0x24]
;;;2102           
;;;2103           if (VRPV > 4094) 
0001f2  4925              LDR      r1,|L9.648|
0001f4  1e49              SUBS     r1,r1,#1
0001f6  9809              LDR      r0,[sp,#0x24]
0001f8  4288              CMP      r0,r1
0001fa  dd02              BLE      |L9.514|
;;;2104               VRP ++;
0001fc  1c70              ADDS     r0,r6,#1
0001fe  b206              SXTH     r6,r0
000200  e002              B        |L9.520|
                  |L9.514|
;;;2105           else 
;;;2106           {
;;;2107               VRP --;
000202  1e70              SUBS     r0,r6,#1
000204  b206              SXTH     r6,r0
;;;2108               break;
000206  e004              B        |L9.530|
                  |L9.520|
;;;2109           }
;;;2110           
;;;2111           if (VRP == 64) 
000208  2e40              CMP      r6,#0x40
00020a  d101              BNE      |L9.528|
;;;2112           {
;;;2113               VRP = 32;
00020c  2620              MOVS     r6,#0x20
;;;2114               break;
00020e  e000              B        |L9.530|
                  |L9.528|
000210  e799              B        |L9.326|
                  |L9.530|
000212  bf00              NOP                            ;2108
;;;2115           }
;;;2116           
;;;2117       }
;;;2118       
;;;2119       __DRV_CFG_WRITE_ADCREFTOP(VRP);
000214  481b              LDR      r0,|L9.644|
000216  3038              ADDS     r0,r0,#0x38
000218  70c6              STRB     r6,[r0,#3]
;;;2120       __DRV_CFG_WRITE_ADCREFMIDDLE(VRM);
00021a  980a              LDR      r0,[sp,#0x28]
00021c  b2c1              UXTB     r1,r0
00021e  4819              LDR      r0,|L9.644|
000220  3038              ADDS     r0,r0,#0x38
000222  7081              STRB     r1,[r0,#2]
;;;2121       __DRV_CFG_WRITE_ADCREFBOTTOM(VRN);
000224  7047              STRB     r7,[r0,#1]
;;;2122       
;;;2123       VRM = (__DRV_CFG_READ_ADCREFTOP() + __DRV_CFG_READ_ADCREFBOTTOM()) / 2;
000226  4601              MOV      r1,r0
000228  78ca              LDRB     r2,[r1,#3]
00022a  7849              LDRB     r1,[r1,#1]
00022c  1850              ADDS     r0,r2,r1
00022e  0fc1              LSRS     r1,r0,#31
000230  1809              ADDS     r1,r1,r0
000232  1049              ASRS     r1,r1,#1
000234  910a              STR      r1,[sp,#0x28]
;;;2124       __DRV_CFG_WRITE_ADCREFMIDDLE(VRM);
000236  980a              LDR      r0,[sp,#0x28]
000238  b2c1              UXTB     r1,r0
00023a  4812              LDR      r0,|L9.644|
00023c  3038              ADDS     r0,r0,#0x38
00023e  7081              STRB     r1,[r0,#2]
;;;2125       
;;;2126   //    // middle trim
;;;2127       MID_ADC_VRMCalibration_Start(mADC, VRM);
000240  980a              LDR      r0,[sp,#0x28]
000242  b2c1              UXTB     r1,r0
000244  4620              MOV      r0,r4
000246  f7fffffe          BL       MID_ADC_VRMCalibration_Start
;;;2128               
;;;2129       MID_ProtectModuleReg(CFGmodule);   
00024a  480e              LDR      r0,|L9.644|
00024c  f7fffffe          BL       MID_ProtectModuleReg
;;;2130       
;;;2131       mADC->Instance->MSK.W = rADC_MSK;
000250  9807              LDR      r0,[sp,#0x1c]
000252  6821              LDR      r1,[r4,#0]
000254  61c8              STR      r0,[r1,#0x1c]
;;;2132       mADC->Instance->START.W = rADC_START;
000256  9806              LDR      r0,[sp,#0x18]
000258  6821              LDR      r1,[r4,#0]
00025a  6208              STR      r0,[r1,#0x20]
;;;2133       mADC->Instance->CR0.W = rADC_CR0;    
00025c  9805              LDR      r0,[sp,#0x14]
00025e  6821              LDR      r1,[r4,#0]
000260  6108              STR      r0,[r1,#0x10]
;;;2134       mADC->Instance->CR1.W = rADC_CR1;    
000262  9804              LDR      r0,[sp,#0x10]
000264  6821              LDR      r1,[r4,#0]
000266  6148              STR      r0,[r1,#0x14]
;;;2135       mADC->Instance->SUM0.W = rSUM0;
000268  9803              LDR      r0,[sp,#0xc]
00026a  6821              LDR      r1,[r4,#0]
00026c  6308              STR      r0,[r1,#0x30]
;;;2136       mADC->Instance->SUM1.W = rSUM1;
00026e  9802              LDR      r0,[sp,#8]
000270  6821              LDR      r1,[r4,#0]
000272  6348              STR      r0,[r1,#0x34]
;;;2137       mADC->Instance->SUM2.W = rSUM2;
000274  9801              LDR      r0,[sp,#4]
000276  6821              LDR      r1,[r4,#0]
000278  6388              STR      r0,[r1,#0x38]
;;;2138       
;;;2139       return MID_SUCCESS;
00027a  2000              MOVS     r0,#0
;;;2140   #else
;;;2141       return MID_SUCCESS;    
;;;2142   #endif    
;;;2143   }
00027c  b00b              ADD      sp,sp,#0x2c
00027e  bdf0              POP      {r4-r7,pc}
;;;2144   ///@}
                          ENDP

                  |L9.640|
                          DCD      0xff80fffe
                  |L9.644|
                          DCD      0x4ff0000c
                  |L9.648|
                          DCD      0x00000fff

                          AREA ||i.MID_ADC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  MID_ADC_ConfigChannel PROC
;;;1201    */
;;;1202   MID_StatusTypeDef MID_ADC_ConfigChannel(ADC_HandleTypeDef* mADC, ADC_ChannelConfTypeDef *ChannelMux)
000000  b510              PUSH     {r4,lr}
;;;1203   {
000002  4602              MOV      r2,r0
;;;1204       /* Process locked */
;;;1205       __MID_LOCK(mADC);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5c80              LDRB     r0,[r0,r2]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L10.18|
00000e  2002              MOVS     r0,#2
                  |L10.16|
;;;1206   
;;;1207       /* Parameters update conditioned to ADC state:                              */
;;;1208       /*  - Channel number                                                        */
;;;1209       switch(mADC->Init.ConversionMode)
;;;1210       {
;;;1211       /* Trigger once and conversion once                                       */
;;;1212       case ADC_ONESHOT:
;;;1213       /* Trigger once and repeat convesion one channel                          */
;;;1214       case ADC_REPITIVE_CHANNEL:   
;;;1215           __DRV_ADC_CHSELR_CHANNEL(mADC, ChannelMux->Channel);
;;;1216           break;
;;;1217       
;;;1218       /* Manual trigger conversion                                              */
;;;1219       case ADC_SCAN_MANUAL:   
;;;1220       /* TTrigger once and auto scan mask channel                               */
;;;1221       case ADC_SCAN_AUTO:   
;;;1222       /* Conversion loop mode                                                   */
;;;1223       case ADC_LOOP_AUTO:   
;;;1224           __DRV_ADC_RQGULAR_CHANNEL(mADC, ChannelMux->SequenceChannelMUX);
;;;1225           break;
;;;1226       
;;;1227       default:
;;;1228           return MID_FAILURE;
;;;1229       }
;;;1230   
;;;1231       /* Process unlocked */
;;;1232       __MID_UNLOCK(mADC);
;;;1233   
;;;1234       /* Return function status */
;;;1235       return MID_SUCCESS;
;;;1236   }
000010  bd10              POP      {r4,pc}
                  |L10.18|
000012  2301              MOVS     r3,#1                 ;1205
000014  203c              MOVS     r0,#0x3c              ;1205
000016  5483              STRB     r3,[r0,r2]            ;1205
000018  bf00              NOP                            ;1205
00001a  061c              LSLS     r4,r3,#24             ;1209
00001c  6950              LDR      r0,[r2,#0x14]         ;1209
00001e  1b03              SUBS     r3,r0,r4              ;1209
000020  42a0              CMP      r0,r4                 ;1209
000022  d01f              BEQ      |L10.100|
000024  dc06              BGT      |L10.52|
000026  2800              CMP      r0,#0                 ;1209
000028  d00d              BEQ      |L10.70|
00002a  2301              MOVS     r3,#1                 ;1209
00002c  04db              LSLS     r3,r3,#19             ;1209
00002e  1ac0              SUBS     r0,r0,r3              ;1209
000030  d11e              BNE      |L10.112|
000032  e009              B        |L10.72|
                  |L10.52|
000034  2001              MOVS     r0,#1                 ;1209
000036  04c0              LSLS     r0,r0,#19             ;1209
000038  1a18              SUBS     r0,r3,r0              ;1209
00003a  d014              BEQ      |L10.102|
00003c  231f              MOVS     r3,#0x1f              ;1209
00003e  04db              LSLS     r3,r3,#19             ;1209
000040  1ac0              SUBS     r0,r0,r3              ;1209
000042  d115              BNE      |L10.112|
000044  e010              B        |L10.104|
                  |L10.70|
000046  bf00              NOP                            ;1214
                  |L10.72|
000048  6810              LDR      r0,[r2,#0]            ;1215
00004a  6a00              LDR      r0,[r0,#0x20]         ;1215
00004c  231f              MOVS     r3,#0x1f              ;1215
00004e  021b              LSLS     r3,r3,#8              ;1215
000050  4398              BICS     r0,r0,r3              ;1215
000052  6813              LDR      r3,[r2,#0]            ;1215
000054  6218              STR      r0,[r3,#0x20]         ;1215
000056  6810              LDR      r0,[r2,#0]            ;1215
000058  6a00              LDR      r0,[r0,#0x20]         ;1215
00005a  680b              LDR      r3,[r1,#0]            ;1215
00005c  4318              ORRS     r0,r0,r3              ;1215
00005e  6813              LDR      r3,[r2,#0]            ;1215
000060  6218              STR      r0,[r3,#0x20]         ;1215
000062  e007              B        |L10.116|
                  |L10.100|
000064  bf00              NOP                            ;1221
                  |L10.102|
000066  bf00              NOP                            ;1223
                  |L10.104|
000068  8888              LDRH     r0,[r1,#4]            ;1224
00006a  6813              LDR      r3,[r2,#0]            ;1224
00006c  8398              STRH     r0,[r3,#0x1c]         ;1224
00006e  e001              B        |L10.116|
                  |L10.112|
000070  2001              MOVS     r0,#1                 ;1228
000072  e7cd              B        |L10.16|
                  |L10.116|
000074  bf00              NOP                            ;1216
000076  bf00              NOP                            ;1232
000078  2300              MOVS     r3,#0                 ;1232
00007a  203c              MOVS     r0,#0x3c              ;1232
00007c  5483              STRB     r3,[r0,r2]            ;1232
00007e  bf00              NOP                            ;1232
000080  2000              MOVS     r0,#0                 ;1235
000082  e7c5              B        |L10.16|
;;;1237   
                          ENDP


                          AREA ||i.MID_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_ADC_ConvCpltCallback PROC
;;;1103    */
;;;1104   __weak void MID_ADC_ConvCpltCallback(ADC_HandleTypeDef* mADC)
000000  4770              BX       lr
;;;1105   {
;;;1106     /* Prevent unused argument(s) compilation warning */
;;;1107     UNUSED(mADC);
;;;1108   
;;;1109   }
;;;1110   
                          ENDP


                          AREA ||i.MID_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_ADC_ConvHalfCpltCallback PROC
;;;1118    */
;;;1119   __weak void MID_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* mADC)
000000  4770              BX       lr
;;;1120   {
;;;1121     /* Prevent unused argument(s) compilation warning */
;;;1122     UNUSED(mADC);
;;;1123   
;;;1124     /* NOTE : This function should not be modified. When the callback is needed,
;;;1125               function MID_ADC_ConvHalfCpltCallback must be implemented in the user file.
;;;1126      */
;;;1127   }
;;;1128   
                          ENDP


                          AREA ||i.MID_ADC_DeInit||, CODE, READONLY, ALIGN=1

                  MID_ADC_DeInit PROC
;;;214     */
;;;215    MID_StatusTypeDef MID_ADC_DeInit(ADC_HandleTypeDef *mADC)
000000  b510              PUSH     {r4,lr}
;;;216    {
000002  4604              MOV      r4,r0
;;;217    
;;;218        /* Process locked */
;;;219        __MID_LOCK(mADC);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L13.18|
00000e  2002              MOVS     r0,#2
                  |L13.16|
;;;220    
;;;221        /* 1. Stop potential conversion on going, on regular group */
;;;222        ADC_ConversionStop(mADC);
;;;223    
;;;224        /* Disable ADC end of conversion interrupt for regular group */
;;;225        /* Disable ADC overrun interrupt */
;;;226        __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_ESMP | ADC_IT_E1CNV | ADC_IT_OVR));
;;;227    
;;;228        /* 2. Disable the ADC peripheral */
;;;229        ADC_Disable(mADC);
;;;230    
;;;231        /* Set ADC state */
;;;232        mADC->State = MID_ADC_STATE_READY;
;;;233    
;;;234        /* Process unlocked */
;;;235        __MID_UNLOCK(mADC);
;;;236    
;;;237        /* Return function status */
;;;238        return MID_SUCCESS;
;;;239    }
000010  bd10              POP      {r4,pc}
                  |L13.18|
000012  2101              MOVS     r1,#1                 ;219
000014  203c              MOVS     r0,#0x3c              ;219
000016  5501              STRB     r1,[r0,r4]            ;219
000018  bf00              NOP                            ;219
00001a  4620              MOV      r0,r4                 ;222
00001c  f7fffffe          BL       ADC_ConversionStop
000020  6820              LDR      r0,[r4,#0]            ;226
000022  6840              LDR      r0,[r0,#4]            ;226
000024  218c              MOVS     r1,#0x8c              ;226
000026  4388              BICS     r0,r0,r1              ;226
000028  6821              LDR      r1,[r4,#0]            ;226
00002a  6048              STR      r0,[r1,#4]            ;226
00002c  4620              MOV      r0,r4                 ;229
00002e  f7fffffe          BL       ADC_Disable
000032  2001              MOVS     r0,#1                 ;232
000034  6420              STR      r0,[r4,#0x40]         ;232
000036  bf00              NOP                            ;235
000038  2100              MOVS     r1,#0                 ;235
00003a  203c              MOVS     r0,#0x3c              ;235
00003c  5501              STRB     r1,[r0,r4]            ;235
00003e  bf00              NOP                            ;235
000040  2000              MOVS     r0,#0                 ;238
000042  e7e5              B        |L13.16|
;;;240    
                          ENDP


                          AREA ||i.MID_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  MID_ADC_ErrorCallback PROC
;;;1155    */
;;;1156   __weak void MID_ADC_ErrorCallback(ADC_HandleTypeDef *mADC)
000000  4770              BX       lr
;;;1157   {
;;;1158     /* Prevent unused argument(s) compilation warning */
;;;1159     UNUSED(mADC);
;;;1160   
;;;1161   }
;;;1162   
                          ENDP


                          AREA ||i.MID_ADC_GetError||, CODE, READONLY, ALIGN=1

                  MID_ADC_GetError PROC
;;;1397    */
;;;1398   uint32_t MID_ADC_GetError(ADC_HandleTypeDef *mADC)
000000  4601              MOV      r1,r0
;;;1399   {
;;;1400       return mADC->ErrorCode;
000002  6c48              LDR      r0,[r1,#0x44]
;;;1401   }
000004  4770              BX       lr
;;;1402   
                          ENDP


                          AREA ||i.MID_ADC_GetSUM0Value||, CODE, READONLY, ALIGN=1

                  MID_ADC_GetSUM0Value PROC
;;;940     */
;;;941    uint32_t MID_ADC_GetSUM0Value(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;942    {
;;;943        /* Return ADC accumulation value */ 
;;;944        return mADC->Instance->SUM0.H[0];
000002  6808              LDR      r0,[r1,#0]
000004  8e00              LDRH     r0,[r0,#0x30]
;;;945    }
000006  4770              BX       lr
;;;946    
                          ENDP


                          AREA ||i.MID_ADC_GetSUM1Value||, CODE, READONLY, ALIGN=1

                  MID_ADC_GetSUM1Value PROC
;;;954     */
;;;955    uint32_t MID_ADC_GetSUM1Value(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;956    {
;;;957        /* Return ADC accumulation value */ 
;;;958        return mADC->Instance->SUM1.H[0];
000002  6808              LDR      r0,[r1,#0]
000004  8e80              LDRH     r0,[r0,#0x34]
;;;959    }
000006  4770              BX       lr
;;;960    
                          ENDP


                          AREA ||i.MID_ADC_GetSUM2Value||, CODE, READONLY, ALIGN=1

                  MID_ADC_GetSUM2Value PROC
;;;968     */
;;;969    uint32_t MID_ADC_GetSUM2Value(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;970    {
;;;971        /* Return ADC accumulation value */ 
;;;972        return mADC->Instance->SUM2.H[0];
000002  6808              LDR      r0,[r1,#0]
000004  8f00              LDRH     r0,[r0,#0x38]
;;;973    }
000006  4770              BX       lr
;;;974    
                          ENDP


                          AREA ||i.MID_ADC_GetState||, CODE, READONLY, ALIGN=1

                  MID_ADC_GetState PROC
;;;1384    */
;;;1385   uint32_t MID_ADC_GetState(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;1386   {
;;;1387       return mADC->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;1388   }
000004  4770              BX       lr
;;;1389   
                          ENDP


                          AREA ||i.MID_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  MID_ADC_GetValue PROC
;;;927     */
;;;928    uint32_t MID_ADC_GetValue(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;929    {
;;;930        /* Return ADC converted value */ 
;;;931        return mADC->Instance->DAT0.H[0];
000002  6808              LDR      r0,[r1,#0]
000004  3040              ADDS     r0,r0,#0x40
000006  8800              LDRH     r0,[r0,#0]
;;;932    }
000008  4770              BX       lr
;;;933    
                          ENDP


                          AREA ||i.MID_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  MID_ADC_IRQHandler PROC
;;;989     */
;;;990    void MID_ADC_IRQHandler(ADC_HandleTypeDef* mADC)
000000  b510              PUSH     {r4,lr}
;;;991    {
000002  4604              MOV      r4,r0
;;;992        volatile uint32_t a,b;
;;;993        /* ========== Check End of Conversion flag for regular group ========== */
;;;994        if(__DRV_ADC_GET_EVENT(mADC, ADC_IT_CONVERSION) && __DRV_ADC_GET_IT_EVENT(mADC, ADC_IT_CONVERSION))
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  2128              MOVS     r1,#0x28
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d045              BEQ      |L21.156|
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  4008              ANDS     r0,r0,r1
000016  2800              CMP      r0,#0
000018  d040              BEQ      |L21.156|
;;;995        {
;;;996    
;;;997            /* Determine whether any further conversion upcoming on group regular     */
;;;998            /* by external trigger, continuous mode or scan sequence on going.        */
;;;999            switch(mADC->Init.ConversionMode)
00001a  2201              MOVS     r2,#1
00001c  0612              LSLS     r2,r2,#24
00001e  6960              LDR      r0,[r4,#0x14]
000020  1a81              SUBS     r1,r0,r2
000022  4290              CMP      r0,r2
000024  d018              BEQ      |L21.88|
000026  dc06              BGT      |L21.54|
000028  2800              CMP      r0,#0
00002a  d00d              BEQ      |L21.72|
00002c  2101              MOVS     r1,#1
00002e  04c9              LSLS     r1,r1,#19
000030  1a40              SUBS     r0,r0,r1
000032  d12b              BNE      |L21.140|
000034  e00f              B        |L21.86|
                  |L21.54|
000036  2001              MOVS     r0,#1
000038  04c0              LSLS     r0,r0,#19
00003a  1a08              SUBS     r0,r1,r0
00003c  d01c              BEQ      |L21.120|
00003e  211f              MOVS     r1,#0x1f
000040  04c9              LSLS     r1,r1,#19
000042  1a40              SUBS     r0,r0,r1
000044  d122              BNE      |L21.140|
000046  e020              B        |L21.138|
                  |L21.72|
;;;1000           {
;;;1001           case ADC_ONESHOT:           // One chnnel complete end
;;;1002               __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_E1CNV));
000048  6820              LDR      r0,[r4,#0]
00004a  6840              LDR      r0,[r0,#4]
00004c  2108              MOVS     r1,#8
00004e  4388              BICS     r0,r0,r1
000050  6821              LDR      r1,[r4,#0]
000052  6048              STR      r0,[r1,#4]
;;;1003               break;
000054  e01b              B        |L21.142|
                  |L21.86|
;;;1004           
;;;1005           case ADC_REPITIVE_CHANNEL:  // Repitive sample channel
;;;1006               break;
000056  e01a              B        |L21.142|
                  |L21.88|
;;;1007           
;;;1008           case ADC_SCAN_MANUAL:       // until ADC scan complete 
;;;1009               if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_ESCNV) == 0x00)
000058  6820              LDR      r0,[r4,#0]
00005a  6800              LDR      r0,[r0,#0]
00005c  2120              MOVS     r1,#0x20
00005e  4008              ANDS     r0,r0,r1
000060  0940              LSRS     r0,r0,#5
000062  2800              CMP      r0,#0
000064  d107              BNE      |L21.118|
;;;1010               {
;;;1011                   __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_ESCNV));
000066  6820              LDR      r0,[r4,#0]
000068  6840              LDR      r0,[r0,#4]
00006a  2128              MOVS     r1,#0x28
00006c  4388              BICS     r0,r0,r1
00006e  6821              LDR      r1,[r4,#0]
000070  6048              STR      r0,[r1,#4]
;;;1012                   mADC->State = MID_ADC_STATE_READY;
000072  2001              MOVS     r0,#1
000074  6420              STR      r0,[r4,#0x40]
                  |L21.118|
;;;1013               }
;;;1014               break;
000076  e00a              B        |L21.142|
                  |L21.120|
;;;1015               
;;;1016           case ADC_SCAN_AUTO:         // Scan complete end 
;;;1017               __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_ESCNV));
000078  6820              LDR      r0,[r4,#0]
00007a  6840              LDR      r0,[r0,#4]
00007c  2128              MOVS     r1,#0x28
00007e  4388              BICS     r0,r0,r1
000080  6821              LDR      r1,[r4,#0]
000082  6048              STR      r0,[r1,#4]
;;;1018               mADC->State = MID_ADC_STATE_READY;
000084  2001              MOVS     r0,#1
000086  6420              STR      r0,[r4,#0x40]
;;;1019               break;
000088  e001              B        |L21.142|
                  |L21.138|
;;;1020           
;;;1021           case ADC_LOOP_AUTO:         // Don't stop ADC conversion mode
;;;1022               break;
00008a  e000              B        |L21.142|
                  |L21.140|
;;;1023           
;;;1024           default:
;;;1025               break;
00008c  bf00              NOP      
                  |L21.142|
00008e  bf00              NOP                            ;1003
;;;1026           }
;;;1027           
;;;1028   
;;;1029           /* Conversion complete callback */
;;;1030           /* Note: into callback, to determine if conversion has been triggered     */
;;;1031           /*       from EOC or EOS, possibility to use:                             */
;;;1032           /*        " if( ____DRV_ADC_GET_FLAG(&mADC, ADC_FLAG_EOS)) "              */
;;;1033           MID_ADC_ConvCpltCallback(mADC);
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       MID_ADC_ConvCpltCallback
;;;1034   
;;;1035   
;;;1036           /* Clear regular group conversion flag */
;;;1037           /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
;;;1038           /*       conversion flags clear induces the release of the preserved data.*/
;;;1039           /*       Therefore, if the preserved data value is needed, it must be     */
;;;1040           /*       read preliminarily into MID_ADC_ConvCpltCallback().              */
;;;1041           __DRV_ADC_CLEAR_FLAG(mADC, (ADC_FLAG_E1CNV | ADC_FLAG_ESCNV) );
000096  2028              MOVS     r0,#0x28
000098  6821              LDR      r1,[r4,#0]
00009a  6008              STR      r0,[r1,#0]
                  |L21.156|
;;;1042       }
;;;1043   
;;;1044       /* ========== Check Analog watchdog flags ========== */
;;;1045       if(__DRV_ADC_GET_EVENT(mADC, ADC_FLAG_AWD) && __DRV_ADC_GET_IT_EVENT(mADC, ADC_IT_AWD))
00009c  6820              LDR      r0,[r4,#0]
00009e  6800              LDR      r0,[r0,#0]
0000a0  2107              MOVS     r1,#7
0000a2  0209              LSLS     r1,r1,#8
0000a4  4008              ANDS     r0,r0,r1
0000a6  2800              CMP      r0,#0
0000a8  d00d              BEQ      |L21.198|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6840              LDR      r0,[r0,#4]
0000ae  4008              ANDS     r0,r0,r1
0000b0  2800              CMP      r0,#0
0000b2  d008              BEQ      |L21.198|
;;;1046       {
;;;1047           /* Set ADC state */
;;;1048           mADC->State = MID_ADC_STATE_AWD1;
0000b4  2004              MOVS     r0,#4
0000b6  6420              STR      r0,[r4,#0x40]
;;;1049   
;;;1050           /* Level out of window callback */ 
;;;1051           MID_ADC_LevelOutOfWindowCallback(mADC);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       MID_ADC_LevelOutOfWindowCallback
;;;1052   
;;;1053           /* Clear ADC Analog watchdog flag */
;;;1054           __DRV_ADC_CLEAR_FLAG(mADC, ADC_FLAG_AWD);
0000be  2007              MOVS     r0,#7
0000c0  0200              LSLS     r0,r0,#8
0000c2  6821              LDR      r1,[r4,#0]
0000c4  6008              STR      r0,[r1,#0]
                  |L21.198|
;;;1055   
;;;1056       }
;;;1057   
;;;1058   
;;;1059       /* ========== Check Overrun flag ========== */
;;;1060       if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_OVR) && __DRV_ADC_GET_IT_SOURCE(mADC, ADC_IT_OVR))
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  2180              MOVS     r1,#0x80
0000cc  4008              ANDS     r0,r0,r1
0000ce  2880              CMP      r0,#0x80
0000d0  d113              BNE      |L21.250|
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6840              LDR      r0,[r0,#4]
0000d6  4008              ANDS     r0,r0,r1
0000d8  09c0              LSRS     r0,r0,#7
0000da  2800              CMP      r0,#0
0000dc  d00d              BEQ      |L21.250|
;;;1061       {
;;;1062           /* If overrun is set to overwrite previous data (default setting),        */
;;;1063           /* overrun event is not considered as an error.                           */
;;;1064           /* (cf ref manual "Managing conversions without using the DMA and without */
;;;1065           /* overrun ")                                                             */
;;;1066           /* Exception for usage with DMA overrun event always considered as an     */
;;;1067           /* error.                                                                 */
;;;1068           if (mADC->Init.Overrun == ADC_ACCEPT_OVERRUN)  
0000de  6aa0              LDR      r0,[r4,#0x28]
0000e0  2800              CMP      r0,#0
0000e2  d107              BNE      |L21.244|
;;;1069           {
;;;1070               /* Set ADC error code to overrun */
;;;1071               mADC->ErrorCode = MID_ADC_ERROR_OVR;
0000e4  2002              MOVS     r0,#2
0000e6  6460              STR      r0,[r4,#0x44]
;;;1072   
;;;1073               /* Clear ADC overrun flag */
;;;1074               __DRV_ADC_CLEAR_FLAG(mADC, ADC_FLAG_OVR);
0000e8  2080              MOVS     r0,#0x80
0000ea  6821              LDR      r1,[r4,#0]
0000ec  6008              STR      r0,[r1,#0]
;;;1075   
;;;1076               /* Error callback */ 
;;;1077               MID_ADC_ErrorCallback(mADC);
0000ee  4620              MOV      r0,r4
0000f0  f7fffffe          BL       MID_ADC_ErrorCallback
                  |L21.244|
;;;1078           }
;;;1079   
;;;1080           /* Clear the Overrun flag */
;;;1081           __DRV_ADC_CLEAR_FLAG(mADC, ADC_FLAG_OVR);
0000f4  2080              MOVS     r0,#0x80
0000f6  6821              LDR      r1,[r4,#0]
0000f8  6008              STR      r0,[r1,#0]
                  |L21.250|
;;;1082       }
;;;1083       /* ========== Check accumulation event ========== */
;;;1084       if(__DRV_ADC_GET_EVENT(mADC, ADC_SUM_EVENT) && __DRV_ADC_GET_IT_EVENT(mADC, ADC_IT_SUM))
0000fa  6820              LDR      r0,[r4,#0]
0000fc  6800              LDR      r0,[r0,#0]
0000fe  2107              MOVS     r1,#7
000100  0349              LSLS     r1,r1,#13
000102  4008              ANDS     r0,r0,r1
000104  2800              CMP      r0,#0
000106  d00b              BEQ      |L21.288|
000108  6820              LDR      r0,[r4,#0]
00010a  6840              LDR      r0,[r0,#4]
00010c  4008              ANDS     r0,r0,r1
00010e  2800              CMP      r0,#0
000110  d006              BEQ      |L21.288|
;;;1085       {
;;;1086           
;;;1087           /* ADC Sum callback */
;;;1088           MID_ADC_SumCallback(mADC);
000112  4620              MOV      r0,r4
000114  f7fffffe          BL       MID_ADC_SumCallback
;;;1089           
;;;1090           /* Clear all accumulation flag */
;;;1091           __DRV_ADC_CLEAR_FLAG(mADC, ADC_FLAG_SUM);
000118  200f              MOVS     r0,#0xf
00011a  0300              LSLS     r0,r0,#12
00011c  6821              LDR      r1,[r4,#0]
00011e  6008              STR      r0,[r1,#0]
                  |L21.288|
;;;1092       }
;;;1093   
;;;1094   }
000120  bd10              POP      {r4,pc}
;;;1095   
                          ENDP


                          AREA ||i.MID_ADC_Init||, CODE, READONLY, ALIGN=2

                  MID_ADC_Init PROC
;;;92      */
;;;93     MID_StatusTypeDef MID_ADC_Init(ADC_HandleTypeDef* mADC)
000000  b570              PUSH     {r4-r6,lr}
;;;94     {
000002  4604              MOV      r4,r0
;;;95         uint32_t tmpREG;
;;;96         
;;;97         /* Check ADC handle */
;;;98         if(mADC == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L22.12|
;;;99         {
;;;100            return MID_FAILURE;
000008  2001              MOVS     r0,#1
                  |L22.10|
;;;101        }
;;;102            
;;;103        if (mADC->State == MID_ADC_STATE_RESET)
;;;104        {
;;;105            /* Initialize ADC error code */
;;;106            __DRV_ADC_CLEAR_ERRORCODE(mADC);
;;;107            
;;;108            /* Allocate lock resource and initialize it */
;;;109            mADC->Lock = MID_UnLocked;
;;;110            
;;;111            /* Init the low level hardware */
;;;112            MID_ADC_MspInit(mADC);
;;;113        }
;;;114    
;;;115        /* Enable the ADC peripheral */
;;;116        ADC_Enable(mADC);
;;;117        
;;;118        // ------------------------------------------------------------------------
;;;119        /* Config ADC Clock */
;;;120        // ------------------------------------------------------------------------
;;;121        mADC->Instance->CLK.W = mADC->Init.ADCClock;
;;;122            
;;;123        // ------------------------------------------------------------------------
;;;124        /* Config of ADC parameters:                                              */
;;;125        // ------------------------------------------------------------------------
;;;126        /*  - Conversion Type (Single-End or Different mode)                      */
;;;127        /*  - LowPowerAutoWait mode                                               */
;;;128        /*  - LowPowerAutoPowerOff mode                                           */
;;;129        /*  - resolution                                                          */
;;;130        #if defined(MG32_1ST)
;;;131        tmpREG = mADC->Instance->CR0.W & ~(ADC_CR0_AUTOFF_EN_mask_w | \
;;;132                 ADC_CR0_WAIT_EN_mask_w | ADC_CR0_RES_SEL_mask_w | \
;;;133                 ADC_CR0_MDS_mask_w | ADC_CR0_CODE_FMT_mask_w);
;;;134        tmpREG |= (mADC->Init.LowPowerAutoWait | mADC->Init.LowPowerAutoPowerOff | \
;;;135                  mADC->Init.Resolution | mADC->Init.ADCConType);
;;;136        #endif
;;;137        #if defined(MG32_2ND) || defined(MG32_3RD)
;;;138        tmpREG = mADC->Instance->CR0.W & ~(  \
;;;139                 ADC_CR0_WAIT_EN_mask_w | ADC_CR0_RES_SEL_mask_w \
;;;140                 );
;;;141        tmpREG |= (mADC->Init.LowPowerAutoWait | \
;;;142                  mADC->Init.Resolution | mADC->Init.ADCConType);
;;;143        #endif
;;;144        
;;;145        // Setting output code (unsigned or 2's complment)
;;;146        #if defined(MG32_1ST)
;;;147        if(mADC->Init.ADCConType == ADC_CONV_DIFFERENT)     
;;;148            tmpREG |= ADC_CR0_CODE_FMT_2s_w;
;;;149        #endif
;;;150            
;;;151        mADC->Instance->CR0.W = tmpREG;
;;;152        
;;;153        #if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
;;;154        /*  - PGA Command                                                         */
;;;155        if (mADC->Init.PGACmd == PGA_ENABLE)
;;;156            __DRV_ADC_PGA_ENABLE(mADC);
;;;157        else
;;;158            __DRV_ADC_PGA_DISABLE(mADC);
;;;159        #endif
;;;160        
;;;161        /*  - PGA Gain                                                            */
;;;162        __DRV_ADC_PGA_UPDATE_GAIN(mADC, mADC->Init.PGAGain);
;;;163    
;;;164        /*  - overrun                                                             */
;;;165        /*  - data alignment                                                      */
;;;166        tmpREG = mADC->Instance->CR1.W & ~(ADC_CR1_ALIGN_SEL_mask_w | ADC_CR1_OVR_MDS_mask_w);
;;;167        tmpREG |= (mADC->Init.Overrun | mADC->Init.DataAlign);
;;;168        mADC->Instance->CR1.W = tmpREG;
;;;169        
;;;170        /*  - ConversionMode mode                                                  */
;;;171        /*  - Trigger Converion Source                                             */
;;;172        /*  - Trigger Converion edge                                               */
;;;173        tmpREG = mADC->Instance->START.W & ~(ADC_START_START_SEL_mask_w | ADC_START_TRG_SEL_mask_w | \
;;;174                 ADC_START_CONV_MDS_mask_w | ADC_START_TRG_CONT_mask_w);
;;;175        tmpREG |= (mADC->Init.TriggerConverionSrc | mADC->Init.TriggerConverionEdge | mADC->Init.ConversionMode);
;;;176        mADC->Instance->START.W = tmpREG;
;;;177        
;;;178        /* Update ADC configuration register with previous settings                */
;;;179        tmpREG = mADC->Instance->CR0.W & ~(ADC_CR0_SMP_SEL_mask_w);
;;;180        tmpREG |= (mADC->Init.ExtendSamplingTime << 16);
;;;181        mADC->Instance->CR0.W = tmpREG;
;;;182        
;;;183        // ------------------------------------------------------------------------
;;;184        /* ADC calibration                                                         */
;;;185        // ------------------------------------------------------------------------
;;;186        MID_ADC_Calibration_Start(mADC);
;;;187        
;;;188        #if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
;;;189        // ------------------------------------------------------------------------
;;;190        /* PGA calibration                                                         */
;;;191        // ------------------------------------------------------------------------
;;;192        if (mADC->Init.PGACmd == PGA_ENABLE)
;;;193            MID_ADC_PGACalibration_Start(mADC);
;;;194        #endif
;;;195        
;;;196        /* Return function status */
;;;197        return MID_SUCCESS;
;;;198    }
00000a  bd70              POP      {r4-r6,pc}
                  |L22.12|
00000c  6c20              LDR      r0,[r4,#0x40]         ;103
00000e  2800              CMP      r0,#0                 ;103
000010  d106              BNE      |L22.32|
000012  6460              STR      r0,[r4,#0x44]         ;106
000014  2100              MOVS     r1,#0                 ;109
000016  203c              MOVS     r0,#0x3c              ;109
000018  5501              STRB     r1,[r0,r4]            ;109
00001a  4620              MOV      r0,r4                 ;112
00001c  f7fffffe          BL       MID_ADC_MspInit
                  |L22.32|
000020  4620              MOV      r0,r4                 ;116
000022  f7fffffe          BL       ADC_Enable
000026  6821              LDR      r1,[r4,#0]            ;121
000028  68a0              LDR      r0,[r4,#8]            ;121
00002a  6088              STR      r0,[r1,#8]            ;121
00002c  6820              LDR      r0,[r4,#0]            ;131
00002e  6900              LDR      r0,[r0,#0x10]         ;131
000030  21ff              MOVS     r1,#0xff              ;131
000032  31cf              ADDS     r1,r1,#0xcf           ;131
000034  4388              BICS     r0,r0,r1              ;131
000036  4605              MOV      r5,r0                 ;131
000038  69e1              LDR      r1,[r4,#0x1c]         ;134
00003a  69a0              LDR      r0,[r4,#0x18]         ;134
00003c  4308              ORRS     r0,r0,r1              ;134
00003e  68e1              LDR      r1,[r4,#0xc]          ;134
000040  4308              ORRS     r0,r0,r1              ;134
000042  6861              LDR      r1,[r4,#4]            ;134
000044  4308              ORRS     r0,r0,r1              ;134
000046  4305              ORRS     r5,r5,r0              ;134
000048  6860              LDR      r0,[r4,#4]            ;147
00004a  2808              CMP      r0,#8                 ;147
00004c  d101              BNE      |L22.82|
00004e  0140              LSLS     r0,r0,#5              ;148
000050  4305              ORRS     r5,r5,r0              ;148
                  |L22.82|
000052  6820              LDR      r0,[r4,#0]            ;151
000054  6105              STR      r5,[r0,#0x10]         ;151
000056  6b20              LDR      r0,[r4,#0x30]         ;155
000058  2804              CMP      r0,#4                 ;155
00005a  d106              BNE      |L22.106|
00005c  6820              LDR      r0,[r4,#0]            ;156
00005e  6a40              LDR      r0,[r0,#0x24]         ;156
000060  2104              MOVS     r1,#4                 ;156
000062  4308              ORRS     r0,r0,r1              ;156
000064  6821              LDR      r1,[r4,#0]            ;156
000066  6248              STR      r0,[r1,#0x24]         ;156
000068  e005              B        |L22.118|
                  |L22.106|
00006a  6820              LDR      r0,[r4,#0]            ;158
00006c  6a40              LDR      r0,[r0,#0x24]         ;158
00006e  2104              MOVS     r1,#4                 ;158
000070  4388              BICS     r0,r0,r1              ;158
000072  6821              LDR      r1,[r4,#0]            ;158
000074  6248              STR      r0,[r1,#0x24]         ;158
                  |L22.118|
000076  8ea0              LDRH     r0,[r4,#0x34]         ;162
000078  6821              LDR      r1,[r4,#0]            ;162
00007a  8588              STRH     r0,[r1,#0x2c]         ;162
00007c  6820              LDR      r0,[r4,#0]            ;166
00007e  6940              LDR      r0,[r0,#0x14]         ;166
000080  21ff              MOVS     r1,#0xff              ;166
000082  3109              ADDS     r1,r1,#9              ;166
000084  4388              BICS     r0,r0,r1              ;166
000086  4605              MOV      r5,r0                 ;166
000088  6921              LDR      r1,[r4,#0x10]         ;167
00008a  6aa0              LDR      r0,[r4,#0x28]         ;167
00008c  4308              ORRS     r0,r0,r1              ;167
00008e  4305              ORRS     r5,r5,r0              ;167
000090  6820              LDR      r0,[r4,#0]            ;168
000092  6145              STR      r5,[r0,#0x14]         ;168
000094  6820              LDR      r0,[r4,#0]            ;173
000096  6a00              LDR      r0,[r0,#0x20]         ;173
000098  4910              LDR      r1,|L22.220|
00009a  4008              ANDS     r0,r0,r1              ;173
00009c  4605              MOV      r5,r0                 ;173
00009e  6a61              LDR      r1,[r4,#0x24]         ;175
0000a0  6a20              LDR      r0,[r4,#0x20]         ;175
0000a2  4308              ORRS     r0,r0,r1              ;175
0000a4  6961              LDR      r1,[r4,#0x14]         ;175
0000a6  4308              ORRS     r0,r0,r1              ;175
0000a8  4305              ORRS     r5,r5,r0              ;175
0000aa  6820              LDR      r0,[r4,#0]            ;176
0000ac  6205              STR      r5,[r0,#0x20]         ;176
0000ae  6820              LDR      r0,[r4,#0]            ;179
0000b0  6900              LDR      r0,[r0,#0x10]         ;179
0000b2  21ff              MOVS     r1,#0xff              ;179
0000b4  0409              LSLS     r1,r1,#16             ;179
0000b6  4388              BICS     r0,r0,r1              ;179
0000b8  4605              MOV      r5,r0                 ;179
0000ba  8da0              LDRH     r0,[r4,#0x2c]         ;180
0000bc  0400              LSLS     r0,r0,#16             ;180
0000be  4305              ORRS     r5,r5,r0              ;180
0000c0  6820              LDR      r0,[r4,#0]            ;181
0000c2  6105              STR      r5,[r0,#0x10]         ;181
0000c4  4620              MOV      r0,r4                 ;186
0000c6  f7fffffe          BL       MID_ADC_Calibration_Start
0000ca  6b20              LDR      r0,[r4,#0x30]         ;192
0000cc  2804              CMP      r0,#4                 ;192
0000ce  d102              BNE      |L22.214|
0000d0  4620              MOV      r0,r4                 ;193
0000d2  f7fffffe          BL       MID_ADC_PGACalibration_Start
                  |L22.214|
0000d6  2000              MOVS     r0,#0                 ;197
0000d8  e797              B        |L22.10|
;;;199    
                          ENDP

0000da  0000              DCW      0x0000
                  |L22.220|
                          DCD      0xfcc0ffff

                          AREA ||i.MID_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  MID_ADC_LevelOutOfWindowCallback PROC
;;;1140    */
;;;1141   __weak void MID_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* mADC)
000000  4770              BX       lr
;;;1142   {
;;;1143     /* Prevent unused argument(s) compilation warning */
;;;1144     UNUSED(mADC);
;;;1145   
;;;1146   }
;;;1147   
                          ENDP


                          AREA ||i.MID_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  MID_ADC_MspDeInit PROC
;;;263     */
;;;264    __weak void MID_ADC_MspDeInit(ADC_HandleTypeDef* mADC)
000000  4770              BX       lr
;;;265    {
;;;266      /* Prevent unused argument(s) compilation warning */
;;;267      UNUSED(mADC);
;;;268      /* NOTE : This function Should not be modified, when the callback is needed,
;;;269                the MID_ADC_MspDeInit could be implemented in the user file
;;;270       */
;;;271    }
;;;272    ///@} 
                          ENDP


                          AREA ||i.MID_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  MID_ADC_MspInit PROC
;;;247     */
;;;248    __weak void MID_ADC_MspInit(ADC_HandleTypeDef* mADC)
000000  4770              BX       lr
;;;249    {
;;;250      /* Prevent unused argument(s) compilation warning */
;;;251      UNUSED(mADC);
;;;252      /* NOTE : This function Should not be modified, when the callback is needed,
;;;253                the MID_ADC_MspInit could be implemented in the user file
;;;254       */
;;;255    }
;;;256    
                          ENDP


                          AREA ||i.MID_ADC_PGACalibration_Start||, CODE, READONLY, ALIGN=1

                  MID_ADC_PGACalibration_Start PROC
;;;1556    */
;;;1557   MID_StatusTypeDef MID_ADC_PGACalibration_Start(ADC_HandleTypeDef* mADC)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
000002  4601              MOV      r1,r0
;;;1559   #if defined(MG32_3RD)
;;;1560       uint8_t OFFT_PGA_MaxIDX, OFFT_PGA_MinIDX, OFFT_PGA_ActIDX, old_PGA_Gain, TargetIDX;
;;;1561       uint8_t COMPCNT;
;;;1562       uint32_t i, j;
;;;1563       uint16_t ResultADC;
;;;1564       float Disable_PGA_Value, MinCompareValue; 
;;;1565       uint32_t rADC_MSK, rADC_START, rADC_CR0, rADC_CR1;
;;;1566       uint32_t rSUM0, rSUM1, rSUM2;
;;;1567       
;;;1568       float PGA_Gain_V[] = {
;;;1569           1.000, 1.012, 1.024, 1.037, 1.050, 1.063, 1.077, 1.091, 1.105, 1.120, 
;;;1570           1.135, 1.151, 1.167, 1.183, 1.200, 1.217, 1.235, 1.254, 1.273, 1.292,
;;;1571           1.313, 1.333, 1.355, 1.377, 1.400, 1.424, 1.448, 1.474, 1.500, 1.527,
;;;1572           1.556, 1.585, 1.615, 1.647, 1.680, 1.714, 1.750, 1.787, 1.826, 1.867,
;;;1573           1.909, 1.953, 2.000, 2.049, 2.100, 2.154, 2.211, 2.270, 2.333, 2.400,
;;;1574           2.471, 2.545, 2.625, 2.710, 2.800, 2.897, 3.000, 3.111, 3.231, 3.360,
;;;1575           3.500, 3.652, 3.818, 4.000 
;;;1576       };
;;;1577   
;;;1578       // RESAVE
;;;1579       rADC_MSK = ADC0->MSK.W;
;;;1580       rADC_START = ADC0->START.W;
;;;1581       rADC_CR0 = ADC0->CR0.W;    
;;;1582       rADC_CR1 = ADC0->CR1.W;    
;;;1583       rSUM0 = ADC0->SUM0.W;
;;;1584       rSUM1 = ADC0->SUM1.W;
;;;1585       rSUM2 = ADC0->SUM2.W;
;;;1586        
;;;1587       // check VBUF state
;;;1588       if (PW->CR0.MBIT.IVR_EN == CLR)
;;;1589       {
;;;1590           // Enable VBUF + select (0)
;;;1591           MID_UnProtectModuleReg(PWmodule);
;;;1592           __DRV_PW_ENANLE_VBUF();
;;;1593           MID_ProtectModuleReg(PWmodule);
;;;1594           
;;;1595           // delay a time (2020.02.17) - VBUF settling time
;;;1596           for(i=0;i<65536;i++);
;;;1597       }
;;;1598           
;;;1599       // reset SUM_NUM & window detect
;;;1600       mADC->Instance->CR1.W &= ~(ADC_CR1_SUM_NUM_mask_w | ADC_CR1_WIND_EN_enable_w);
;;;1601   
;;;1602       // config ADC mode for calibration 
;;;1603       mADC->Instance->CR0.W = ADC_CR0_RES_SEL_12_bit_w | ADC_CR0_EN_enable_w;
;;;1604       
;;;1605       mADC->Instance->START.W = ADC_START_CONV_MDS_one_w | ADC_START_TRG_SEL_disable_w | \
;;;1606                                 ADC_START_START_SEL_sw_w;
;;;1607       
;;;1608       // ------------------------------------------------------------------------
;;;1609       // Dsiable PGA & disable PGAOUT
;;;1610       __DRV_ADC_PGA_DISABLE(mADC);
;;;1611       
;;;1612       // Sample ADC conversion without PGA
;;;1613       old_PGA_Gain = mADC->Instance->GAIN.H[1] & ADC_GAIN_OFFT_PGA_mask_h1;
;;;1614       __DRV_ADC_CHSELR_CHANNEL(mADC, ADC_CHANNEL_27);
;;;1615       {
;;;1616           for (j=0;j<10;j++)
;;;1617           {
;;;1618               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
;;;1619               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
;;;1620               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
;;;1621           }
;;;1622           
;;;1623           for (j=0,ResultADC=0;j<10;j++)
;;;1624           {
;;;1625               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
;;;1626               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
;;;1627               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
;;;1628               ResultADC += MID_ADC_GetValue(mADC);
;;;1629           }
;;;1630           ResultADC = ResultADC / 10;
;;;1631           Disable_PGA_Value = ((float) ResultADC) * PGA_Gain_V[old_PGA_Gain];
;;;1632       }
;;;1633       
;;;1634       // ------------------------------------------------------------------------
;;;1635       // Enable PGA
;;;1636       __DRV_ADC_PGA_ENABLE(mADC);
;;;1637       
;;;1638       // Initial OFFT of PGA
;;;1639       COMPCNT = 0;
;;;1640       OFFT_PGA_MinIDX = 0;
;;;1641       OFFT_PGA_MaxIDX = 63;
;;;1642       TargetIDX = OFFT_PGA_ActIDX = OFFT_PGA_MaxIDX >> 1;
;;;1643       
;;;1644       // ------------------------------------------------------------------------
;;;1645       // Compare ADC x PGA 
;;;1646       while(COMPCNT < 6 )
;;;1647       {
;;;1648           // set ADC_GAIN_OFFT
;;;1649           __DRV_ADC_PGA_UPDATE_OFFT(mADC, OFFT_PGA_ActIDX);
;;;1650           
;;;1651           // Average ADC conversion
;;;1652           for (i=0, ResultADC=0 ; i<10; i++)
;;;1653           {
;;;1654               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
;;;1655               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
;;;1656               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
;;;1657               ResultADC += MID_ADC_GetValue(mADC);
;;;1658           }
;;;1659           ResultADC = ResultADC / 10;
;;;1660                   
;;;1661           // --------------------------------------------------------------------
;;;1662           // exit condition
;;;1663           if (ResultADC == Disable_PGA_Value)
;;;1664           {
;;;1665               TargetIDX = OFFT_PGA_ActIDX;
;;;1666               break;
;;;1667           }
;;;1668           
;;;1669           // --------------------------------------------------------------------
;;;1670           // compare minimum MinCompareValue then get target index
;;;1671           if (ResultADC >= Disable_PGA_Value)
;;;1672           {
;;;1673               if ((ResultADC - Disable_PGA_Value) < MinCompareValue)
;;;1674               {
;;;1675                   TargetIDX = OFFT_PGA_ActIDX;
;;;1676                   MinCompareValue = (Disable_PGA_Value - ResultADC);
;;;1677               }
;;;1678           }
;;;1679           else if ((Disable_PGA_Value - ResultADC) < MinCompareValue)
;;;1680           {
;;;1681               TargetIDX = OFFT_PGA_ActIDX;
;;;1682               MinCompareValue = (Disable_PGA_Value - ResultADC);
;;;1683           }
;;;1684           
;;;1685           // --------------------------------------------------------------------
;;;1686           // check ADC_CONV data - Update OFFT_PGA_MaxIDX, OFFT_PGA_MinIDX & OFFT_PGA_ActIDX
;;;1687           if (ResultADC >= Disable_PGA_Value)
;;;1688           {
;;;1689               OFFT_PGA_MaxIDX = OFFT_PGA_ActIDX;
;;;1690               OFFT_PGA_ActIDX = (OFFT_PGA_MinIDX + OFFT_PGA_MaxIDX) >> 1;
;;;1691           }
;;;1692           else 
;;;1693           {
;;;1694               OFFT_PGA_MinIDX = OFFT_PGA_ActIDX;
;;;1695               OFFT_PGA_ActIDX = (OFFT_PGA_MinIDX + OFFT_PGA_MaxIDX) >> 1;
;;;1696           }
;;;1697           
;;;1698           COMPCNT ++;
;;;1699       }
;;;1700   
;;;1701       // ------------------------------------------------------------------------
;;;1702       // set ADC_GAIN_OFFT by TargetIDX
;;;1703       __DRV_ADC_PGA_UPDATE_OFFT(mADC, TargetIDX);
;;;1704   
;;;1705   
;;;1706       // restore
;;;1707       ADC0->MSK.W = rADC_MSK;
;;;1708       ADC0->START.W = rADC_START;
;;;1709       ADC0->CR0.W = rADC_CR0;    
;;;1710       ADC0->CR1.W = rADC_CR1;    
;;;1711       ADC0->SUM0.W = rSUM0;
;;;1712       ADC0->SUM1.W = rSUM1;
;;;1713       ADC0->SUM2.W = rSUM2;
;;;1714       
;;;1715       return MID_SUCCESS;
;;;1716       
;;;1717   #elif defined(MG32_1ST) || defined(MG32_2ND)
;;;1718       uint8_t VOD_x, VOD_0, VOD_63;
;;;1719       uint8_t PGAOFFT;
;;;1720       
;;;1721       // enable PGA calibration state
;;;1722       mADC->Instance->CAL.W |= (ADC_CAL_CAL_POFFT_enable_w);
000004  6808              LDR      r0,[r1,#0]
000006  6a80              LDR      r0,[r0,#0x28]
000008  2608              MOVS     r6,#8
00000a  4330              ORRS     r0,r0,r6
00000c  680e              LDR      r6,[r1,#0]
00000e  62b0              STR      r0,[r6,#0x28]
;;;1723       
;;;1724       //
;;;1725       PGAOFFT = 32;
000010  2220              MOVS     r2,#0x20
;;;1726       mADC->Instance->GAIN.B[2] = (PGAOFFT);
000012  6808              LDR      r0,[r1,#0]
000014  302c              ADDS     r0,r0,#0x2c
000016  7082              STRB     r2,[r0,#2]
;;;1727       mADC->Instance->ANA.W |= (ADC_ANA_PGA_EN_enable_w);
000018  6808              LDR      r0,[r1,#0]
00001a  6a40              LDR      r0,[r0,#0x24]
00001c  2604              MOVS     r6,#4
00001e  4330              ORRS     r0,r0,r6
000020  680e              LDR      r6,[r1,#0]
000022  6270              STR      r0,[r6,#0x24]
;;;1728       
;;;1729       // read VOD
;;;1730       VOD_x = ADC0->STA.MBIT.POF;
000024  205b              MOVS     r0,#0x5b
000026  0600              LSLS     r0,r0,#24
000028  78c0              LDRB     r0,[r0,#3]
00002a  07c3              LSLS     r3,r0,#31
00002c  0fdb              LSRS     r3,r3,#31
;;;1731       
;;;1732       mADC->Instance->GAIN.B[2] = (0);
00002e  2600              MOVS     r6,#0
000030  6808              LDR      r0,[r1,#0]
000032  302c              ADDS     r0,r0,#0x2c
000034  7086              STRB     r6,[r0,#2]
;;;1733       VOD_0 = ADC0->STA.MBIT.POF;
000036  205b              MOVS     r0,#0x5b
000038  0600              LSLS     r0,r0,#24
00003a  78c0              LDRB     r0,[r0,#3]
00003c  07c4              LSLS     r4,r0,#31
00003e  0fe4              LSRS     r4,r4,#31
;;;1734       
;;;1735       mADC->Instance->GAIN.B[2] = (63);
000040  263f              MOVS     r6,#0x3f
000042  6808              LDR      r0,[r1,#0]
000044  302c              ADDS     r0,r0,#0x2c
000046  7086              STRB     r6,[r0,#2]
;;;1736       VOD_63 = ADC0->STA.MBIT.POF;
000048  205b              MOVS     r0,#0x5b
00004a  0600              LSLS     r0,r0,#24
00004c  78c0              LDRB     r0,[r0,#3]
00004e  07c5              LSLS     r5,r0,#31
000050  0fed              LSRS     r5,r5,#31
;;;1737       
;;;1738       if((VOD_0 == VOD_x) && (VOD_63 == VOD_x))
000052  429c              CMP      r4,r3
000054  d10c              BNE      |L26.112|
000056  429d              CMP      r5,r3
000058  d10a              BNE      |L26.112|
;;;1739       {
;;;1740           mADC->Instance->GAIN.B[2] = (PGAOFFT);
00005a  6808              LDR      r0,[r1,#0]
00005c  302c              ADDS     r0,r0,#0x2c
00005e  7082              STRB     r2,[r0,#2]
;;;1741           mADC->Instance->CAL.W &= ~(ADC_CAL_CAL_POFFT_enable_w);
000060  6808              LDR      r0,[r1,#0]
000062  6a80              LDR      r0,[r0,#0x28]
000064  2608              MOVS     r6,#8
000066  43b0              BICS     r0,r0,r6
000068  680e              LDR      r6,[r1,#0]
00006a  62b0              STR      r0,[r6,#0x28]
;;;1742           return MID_FAILURE;
00006c  2001              MOVS     r0,#1
                  |L26.110|
;;;1743       }
;;;1744       
;;;1745       // read VOD 
;;;1746       if (ADC0->STA.MBIT.POF != VOD_x)
;;;1747       {
;;;1748           PGAOFFT  = 33;
;;;1749           mADC->Instance->GAIN.B[2] = (PGAOFFT);
;;;1750           
;;;1751           while (1)
;;;1752           {
;;;1753               if (ADC0->STA.MBIT.POF != VOD_x) break;
;;;1754               PGAOFFT ++;
;;;1755               mADC->Instance->GAIN.B[2] = (PGAOFFT);
;;;1756           }
;;;1757       } else 
;;;1758       {
;;;1759           PGAOFFT  = 31;
;;;1760           mADC->Instance->GAIN.B[2] = (PGAOFFT);
;;;1761           
;;;1762           while (1)
;;;1763           {
;;;1764               if (ADC0->STA.MBIT.POF != VOD_x) break;
;;;1765               PGAOFFT --;
;;;1766               mADC->Instance->GAIN.B[2] = (PGAOFFT);
;;;1767           }
;;;1768           
;;;1769       }
;;;1770           
;;;1771       // Disable calibration 
;;;1772       mADC->Instance->CAL.W &= ~(ADC_CAL_CAL_POFFT_enable_w);
;;;1773       return MID_SUCCESS;
;;;1774   #else
;;;1775       return MID_FAILURE;
;;;1776   #endif
;;;1777   
;;;1778   }
00006e  bd70              POP      {r4-r6,pc}
                  |L26.112|
000070  205b              MOVS     r0,#0x5b              ;1746
000072  0600              LSLS     r0,r0,#24             ;1746
000074  78c0              LDRB     r0,[r0,#3]            ;1746
000076  07c0              LSLS     r0,r0,#31             ;1746
000078  0fc0              LSRS     r0,r0,#31             ;1746
00007a  4298              CMP      r0,r3                 ;1746
00007c  d013              BEQ      |L26.166|
00007e  2221              MOVS     r2,#0x21              ;1748
000080  6808              LDR      r0,[r1,#0]            ;1749
000082  302c              ADDS     r0,r0,#0x2c           ;1749
000084  7082              STRB     r2,[r0,#2]            ;1749
000086  e00c              B        |L26.162|
                  |L26.136|
000088  205b              MOVS     r0,#0x5b              ;1753
00008a  0600              LSLS     r0,r0,#24             ;1753
00008c  78c0              LDRB     r0,[r0,#3]            ;1753
00008e  07c0              LSLS     r0,r0,#31             ;1753
000090  0fc0              LSRS     r0,r0,#31             ;1753
000092  4298              CMP      r0,r3                 ;1753
000094  d000              BEQ      |L26.152|
000096  e005              B        |L26.164|
                  |L26.152|
000098  1c50              ADDS     r0,r2,#1              ;1754
00009a  b2c2              UXTB     r2,r0                 ;1754
00009c  6808              LDR      r0,[r1,#0]            ;1755
00009e  302c              ADDS     r0,r0,#0x2c           ;1755
0000a0  7082              STRB     r2,[r0,#2]            ;1755
                  |L26.162|
0000a2  e7f1              B        |L26.136|
                  |L26.164|
0000a4  e013              B        |L26.206|
                  |L26.166|
0000a6  221f              MOVS     r2,#0x1f              ;1759
0000a8  6808              LDR      r0,[r1,#0]            ;1760
0000aa  302c              ADDS     r0,r0,#0x2c           ;1760
0000ac  7082              STRB     r2,[r0,#2]            ;1760
0000ae  e00c              B        |L26.202|
                  |L26.176|
0000b0  205b              MOVS     r0,#0x5b              ;1764
0000b2  0600              LSLS     r0,r0,#24             ;1764
0000b4  78c0              LDRB     r0,[r0,#3]            ;1764
0000b6  07c0              LSLS     r0,r0,#31             ;1764
0000b8  0fc0              LSRS     r0,r0,#31             ;1764
0000ba  4298              CMP      r0,r3                 ;1764
0000bc  d000              BEQ      |L26.192|
0000be  e005              B        |L26.204|
                  |L26.192|
0000c0  1e50              SUBS     r0,r2,#1              ;1765
0000c2  b2c2              UXTB     r2,r0                 ;1765
0000c4  6808              LDR      r0,[r1,#0]            ;1766
0000c6  302c              ADDS     r0,r0,#0x2c           ;1766
0000c8  7082              STRB     r2,[r0,#2]            ;1766
                  |L26.202|
0000ca  e7f1              B        |L26.176|
                  |L26.204|
0000cc  bf00              NOP                            ;1764
                  |L26.206|
0000ce  6808              LDR      r0,[r1,#0]            ;1772
0000d0  6a80              LDR      r0,[r0,#0x28]         ;1772
0000d2  2608              MOVS     r6,#8                 ;1772
0000d4  43b0              BICS     r0,r0,r6              ;1772
0000d6  680e              LDR      r6,[r1,#0]            ;1772
0000d8  62b0              STR      r0,[r6,#0x28]         ;1772
0000da  2000              MOVS     r0,#0                 ;1773
0000dc  e7c7              B        |L26.110|
;;;1779   
                          ENDP


                          AREA ||i.MID_ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  MID_ADC_PollForConversion PROC
;;;366     */
;;;367    MID_StatusTypeDef MID_ADC_PollForConversion(ADC_HandleTypeDef* mADC, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;368    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;369        uint32_t tickstart;
;;;370    
;;;371        /* Get tick count */
;;;372        tickstart = MID_GetTick();
000006  f7fffffe          BL       MID_GetTick
00000a  4606              MOV      r6,r0
;;;373        
;;;374        /* Wait until End of Conversion flag is raised */
;;;375        switch(mADC->Init.ConversionMode)
00000c  2201              MOVS     r2,#1
00000e  0612              LSLS     r2,r2,#24
000010  6960              LDR      r0,[r4,#0x14]
000012  1a81              SUBS     r1,r0,r2
000014  4290              CMP      r0,r2
000016  d058              BEQ      |L27.202|
000018  dc06              BGT      |L27.40|
00001a  2800              CMP      r0,#0
00001c  d00d              BEQ      |L27.58|
00001e  2101              MOVS     r1,#1
000020  04c9              LSLS     r1,r1,#19
000022  1a40              SUBS     r0,r0,r1
                  |L27.36|
000024  d174              BNE      |L27.272|
000026  e02c              B        |L27.130|
                  |L27.40|
000028  2001              MOVS     r0,#1
00002a  04c0              LSLS     r0,r0,#19
00002c  1a08              SUBS     r0,r1,r0
00002e  d072              BEQ      |L27.278|
000030  211f              MOVS     r1,#0x1f
000032  04c9              LSLS     r1,r1,#19
000034  1a40              SUBS     r0,r0,r1
000036  d1f5              BNE      |L27.36|
000038  e091              B        |L27.350|
                  |L27.58|
;;;376        {
;;;377        /* Trigger once and conversion once                                       */
;;;378        case ADC_ONESHOT:
;;;379            __DRV_ADC_DISABLE_IT(mADC, ADC_IT_E1CNV);
00003a  6820              LDR      r0,[r4,#0]
00003c  6840              LDR      r0,[r0,#4]
00003e  2108              MOVS     r1,#8
000040  4388              BICS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  6048              STR      r0,[r1,#4]
;;;380            
;;;381            /* Wait until End of Conversion flag is raised */
;;;382            while(1)
000046  e01b              B        |L27.128|
                  |L27.72|
;;;383            {
;;;384                // one channel conversion end flag
;;;385                if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_E1CNV) != 0x00)
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  2108              MOVS     r1,#8
00004e  4008              ANDS     r0,r0,r1
000050  08c0              LSRS     r0,r0,#3
000052  2800              CMP      r0,#0
000054  d003              BEQ      |L27.94|
;;;386                {
;;;387                    mADC->State = MID_ADC_STATE_READY;
000056  2001              MOVS     r0,#1
000058  6420              STR      r0,[r4,#0x40]
;;;388                    return MID_SUCCESS;
00005a  2000              MOVS     r0,#0
                  |L27.92|
;;;389                }
;;;390                
;;;391                /* Check if timeout is disabled (set to infinite wait) */ 
;;;392                if(Timeout != MID_MAX_DELAY)
;;;393                {
;;;394                    if((MID_GetTick()-tickstart) > Timeout)
;;;395                    {
;;;396                        /* Update ADC state machine to timeout */
;;;397                        mADC->State = MID_ADC_STATE_TIMEOUT;
;;;398    
;;;399                        /* Process unlocked */
;;;400                        __MID_UNLOCK(mADC);
;;;401    
;;;402                        return MID_TIMEOUT;
;;;403                    }
;;;404                }
;;;405            }
;;;406        
;;;407        /* Trigger once and repeat convesion one channel                          */
;;;408        case ADC_REPITIVE_CHANNEL:   
;;;409            __DRV_ADC_DISABLE_IT(mADC, ADC_IT_E1CNV);
;;;410            // one channel conversion end flag
;;;411            /* Wait until End of Conversion flag is raised */
;;;412            while(1)
;;;413            {
;;;414                // one channel conversion end flag
;;;415                if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_E1CNV) != 0x00)
;;;416                {
;;;417                    mADC->State = MID_ADC_STATE_READY;
;;;418                    return MID_SUCCESS;
;;;419                }
;;;420                
;;;421                /* Check if timeout is disabled (set to infinite wait) */ 
;;;422                if(Timeout != MID_MAX_DELAY)
;;;423                {
;;;424                    if((MID_GetTick()-tickstart) > Timeout)
;;;425                    {
;;;426                        /* Update ADC state machine to timeout */
;;;427                        mADC->State = MID_ADC_STATE_TIMEOUT;
;;;428    
;;;429                        /* Process unlocked */
;;;430                        __MID_UNLOCK(mADC);
;;;431    
;;;432                        return MID_TIMEOUT;
;;;433                    }
;;;434                }
;;;435            }
;;;436        
;;;437        /* Manual trigger conversion                                              */
;;;438        case ADC_SCAN_MANUAL:   
;;;439            __DRV_ADC_DISABLE_IT(mADC, ADC_IT_E1CNV);
;;;440            // one channel conversion end flag
;;;441            /* Wait until End of Conversion flag is raised */
;;;442            while(1)
;;;443            {
;;;444                // one channel conversion end flag
;;;445                if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_E1CNV) != 0x00)
;;;446                {
;;;447                    mADC->State = MID_ADC_STATE_READY;
;;;448                    return MID_SUCCESS;
;;;449                }
;;;450                
;;;451                /* Check if timeout is disabled (set to infinite wait) */ 
;;;452                if(Timeout != MID_MAX_DELAY)
;;;453                {
;;;454                    if((MID_GetTick()-tickstart) > Timeout)
;;;455                    {
;;;456                        /* Update ADC state machine to timeout */
;;;457                        mADC->State = MID_ADC_STATE_TIMEOUT;
;;;458    
;;;459                        /* Process unlocked */
;;;460                        __MID_UNLOCK(mADC);
;;;461    
;;;462                        return MID_TIMEOUT;
;;;463                    }
;;;464                }
;;;465            }
;;;466        
;;;467        /* TTrigger once and auto scan mask channel                               */
;;;468        case ADC_SCAN_AUTO:   
;;;469            __DRV_ADC_DISABLE_IT(mADC, ADC_IT_E1CNV | ADC_IT_ESCNV);
;;;470            // scan conversion end flag
;;;471            /* Wait until End of Conversion flag is raised */
;;;472            while(1)
;;;473            {
;;;474                // one channel conversion end flag
;;;475                if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_ESCNV) != 0x00)
;;;476                {
;;;477                    mADC->State = MID_ADC_STATE_READY;
;;;478                    return MID_SUCCESS;
;;;479                }
;;;480                
;;;481                /* Check if timeout is disabled (set to infinite wait) */ 
;;;482                if(Timeout != MID_MAX_DELAY)
;;;483                {
;;;484                    if((MID_GetTick()-tickstart) > Timeout)
;;;485                    {
;;;486                        /* Update ADC state machine to timeout */
;;;487                        mADC->State = MID_ADC_STATE_TIMEOUT;
;;;488    
;;;489                        /* Process unlocked */
;;;490                        __MID_UNLOCK(mADC);
;;;491    
;;;492                        return MID_TIMEOUT;
;;;493                    }
;;;494                }
;;;495            }
;;;496        
;;;497        /* Conversion loop mode                                                   */
;;;498        case ADC_LOOP_AUTO:   
;;;499            __DRV_ADC_DISABLE_IT(mADC, ADC_IT_E1CNV | ADC_IT_ESCNV);
;;;500            
;;;501            if(mADC->Instance->MSK.H[0] != 0x0000)
;;;502            {
;;;503                /* Wait until End of Conversion flag is raised */
;;;504                while(1)
;;;505                {
;;;506                    // one channel conversion end flag
;;;507                    if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_ESCNV) != 0x00)
;;;508                    {
;;;509                        mADC->State = MID_ADC_STATE_READY;
;;;510                        return MID_SUCCESS;
;;;511                    }
;;;512                    
;;;513                    /* Check if timeout is disabled (set to infinite wait) */ 
;;;514                    if(Timeout != MID_MAX_DELAY)
;;;515                    {
;;;516                        if((MID_GetTick()-tickstart) > Timeout)
;;;517                        {
;;;518                            /* Update ADC state machine to timeout */
;;;519                            mADC->State = MID_ADC_STATE_TIMEOUT;
;;;520    
;;;521                            /* Process unlocked */
;;;522                            __MID_UNLOCK(mADC);
;;;523    
;;;524                            return MID_TIMEOUT;
;;;525                        }
;;;526                    }
;;;527                }
;;;528            }
;;;529            else
;;;530            {
;;;531                /* Wait until End of Conversion flag is raised */
;;;532                while(1)
;;;533                {
;;;534                    // one channel conversion end flag
;;;535                    if(__DRV_ADC_GET_FLAG(mADC, ADC_FLAG_E1CNV) != 0x00)
;;;536                    {
;;;537                        mADC->State = MID_ADC_STATE_READY;
;;;538                        return MID_SUCCESS;
;;;539                    }
;;;540                    
;;;541                    /* Check if timeout is disabled (set to infinite wait) */ 
;;;542                    if(Timeout != MID_MAX_DELAY)
;;;543                    {
;;;544                        if((MID_GetTick()-tickstart) > Timeout)
;;;545                        {
;;;546                            /* Update ADC state machine to timeout */
;;;547                            mADC->State = MID_ADC_STATE_TIMEOUT;
;;;548    
;;;549                            /* Process unlocked */
;;;550                            __MID_UNLOCK(mADC);
;;;551    
;;;552                            return MID_TIMEOUT;
;;;553                        }
;;;554                    }
;;;555                }
;;;556            }
;;;557        
;;;558        default:
;;;559            mADC->State = MID_ADC_STATE_READY;
;;;560            mADC->ErrorCode = MID_ADC_ERROR_INTERNAL;
;;;561            return MID_FAILURE;
;;;562        }
;;;563        
;;;564    }
00005c  bd70              POP      {r4-r6,pc}
                  |L27.94|
00005e  1c68              ADDS     r0,r5,#1              ;392
000060  2800              CMP      r0,#0                 ;392
000062  d00d              BEQ      |L27.128|
000064  f7fffffe          BL       MID_GetTick
000068  1b80              SUBS     r0,r0,r6              ;394
00006a  42a8              CMP      r0,r5                 ;394
00006c  d908              BLS      |L27.128|
00006e  2003              MOVS     r0,#3                 ;397
000070  6420              STR      r0,[r4,#0x40]         ;397
000072  bf00              NOP                            ;400
000074  2100              MOVS     r1,#0                 ;400
000076  203c              MOVS     r0,#0x3c              ;400
000078  5501              STRB     r1,[r0,r4]            ;400
00007a  bf00              NOP                            ;400
00007c  2003              MOVS     r0,#3                 ;402
00007e  e7ed              B        |L27.92|
                  |L27.128|
000080  e7e2              B        |L27.72|
                  |L27.130|
000082  6820              LDR      r0,[r4,#0]            ;409
000084  6840              LDR      r0,[r0,#4]            ;409
000086  2108              MOVS     r1,#8                 ;409
000088  4388              BICS     r0,r0,r1              ;409
00008a  6821              LDR      r1,[r4,#0]            ;409
00008c  6048              STR      r0,[r1,#4]            ;409
00008e  e01b              B        |L27.200|
                  |L27.144|
000090  6820              LDR      r0,[r4,#0]            ;415
000092  6800              LDR      r0,[r0,#0]            ;415
000094  2108              MOVS     r1,#8                 ;415
000096  4008              ANDS     r0,r0,r1              ;415
000098  08c0              LSRS     r0,r0,#3              ;415
00009a  2800              CMP      r0,#0                 ;415
00009c  d003              BEQ      |L27.166|
00009e  2001              MOVS     r0,#1                 ;417
0000a0  6420              STR      r0,[r4,#0x40]         ;417
0000a2  2000              MOVS     r0,#0                 ;418
0000a4  e7da              B        |L27.92|
                  |L27.166|
0000a6  1c68              ADDS     r0,r5,#1              ;422
0000a8  2800              CMP      r0,#0                 ;422
0000aa  d00d              BEQ      |L27.200|
0000ac  f7fffffe          BL       MID_GetTick
0000b0  1b80              SUBS     r0,r0,r6              ;424
0000b2  42a8              CMP      r0,r5                 ;424
0000b4  d908              BLS      |L27.200|
0000b6  2003              MOVS     r0,#3                 ;427
0000b8  6420              STR      r0,[r4,#0x40]         ;427
0000ba  bf00              NOP                            ;430
0000bc  2100              MOVS     r1,#0                 ;430
0000be  203c              MOVS     r0,#0x3c              ;430
0000c0  5501              STRB     r1,[r0,r4]            ;430
0000c2  bf00              NOP                            ;430
0000c4  2003              MOVS     r0,#3                 ;432
0000c6  e7c9              B        |L27.92|
                  |L27.200|
0000c8  e7e2              B        |L27.144|
                  |L27.202|
0000ca  6820              LDR      r0,[r4,#0]            ;439
0000cc  6840              LDR      r0,[r0,#4]            ;439
0000ce  2108              MOVS     r1,#8                 ;439
0000d0  4388              BICS     r0,r0,r1              ;439
0000d2  6821              LDR      r1,[r4,#0]            ;439
0000d4  6048              STR      r0,[r1,#4]            ;439
0000d6  e01d              B        |L27.276|
                  |L27.216|
0000d8  6820              LDR      r0,[r4,#0]            ;445
0000da  6800              LDR      r0,[r0,#0]            ;445
0000dc  2108              MOVS     r1,#8                 ;445
0000de  4008              ANDS     r0,r0,r1              ;445
0000e0  08c0              LSRS     r0,r0,#3              ;445
0000e2  2800              CMP      r0,#0                 ;445
0000e4  d003              BEQ      |L27.238|
0000e6  2001              MOVS     r0,#1                 ;447
0000e8  6420              STR      r0,[r4,#0x40]         ;447
0000ea  2000              MOVS     r0,#0                 ;448
0000ec  e7b6              B        |L27.92|
                  |L27.238|
0000ee  1c68              ADDS     r0,r5,#1              ;452
0000f0  2800              CMP      r0,#0                 ;452
0000f2  d00f              BEQ      |L27.276|
0000f4  f7fffffe          BL       MID_GetTick
0000f8  1b80              SUBS     r0,r0,r6              ;454
0000fa  42a8              CMP      r0,r5                 ;454
0000fc  d90a              BLS      |L27.276|
0000fe  2003              MOVS     r0,#3                 ;457
000100  6420              STR      r0,[r4,#0x40]         ;457
000102  bf00              NOP                            ;460
000104  2100              MOVS     r1,#0                 ;460
000106  203c              MOVS     r0,#0x3c              ;460
000108  5501              STRB     r1,[r0,r4]            ;460
00010a  bf00              NOP                            ;460
00010c  2003              MOVS     r0,#3                 ;462
00010e  e7a5              B        |L27.92|
                  |L27.272|
000110  e06b              B        |L27.490|
000112  e000              B        |L27.278|
                  |L27.276|
000114  e7e0              B        |L27.216|
                  |L27.278|
000116  6820              LDR      r0,[r4,#0]            ;469
000118  6840              LDR      r0,[r0,#4]            ;469
00011a  2128              MOVS     r1,#0x28              ;469
00011c  4388              BICS     r0,r0,r1              ;469
00011e  6821              LDR      r1,[r4,#0]            ;469
000120  6048              STR      r0,[r1,#4]            ;469
000122  e01b              B        |L27.348|
                  |L27.292|
000124  6820              LDR      r0,[r4,#0]            ;475
000126  6800              LDR      r0,[r0,#0]            ;475
000128  2120              MOVS     r1,#0x20              ;475
00012a  4008              ANDS     r0,r0,r1              ;475
00012c  0940              LSRS     r0,r0,#5              ;475
00012e  2800              CMP      r0,#0                 ;475
000130  d003              BEQ      |L27.314|
000132  2001              MOVS     r0,#1                 ;477
000134  6420              STR      r0,[r4,#0x40]         ;477
000136  2000              MOVS     r0,#0                 ;478
000138  e790              B        |L27.92|
                  |L27.314|
00013a  1c68              ADDS     r0,r5,#1              ;482
00013c  2800              CMP      r0,#0                 ;482
00013e  d00d              BEQ      |L27.348|
000140  f7fffffe          BL       MID_GetTick
000144  1b80              SUBS     r0,r0,r6              ;484
000146  42a8              CMP      r0,r5                 ;484
000148  d908              BLS      |L27.348|
00014a  2003              MOVS     r0,#3                 ;487
00014c  6420              STR      r0,[r4,#0x40]         ;487
00014e  bf00              NOP                            ;490
000150  2100              MOVS     r1,#0                 ;490
000152  203c              MOVS     r0,#0x3c              ;490
000154  5501              STRB     r1,[r0,r4]            ;490
000156  bf00              NOP                            ;490
000158  2003              MOVS     r0,#3                 ;492
00015a  e77f              B        |L27.92|
                  |L27.348|
00015c  e7e2              B        |L27.292|
                  |L27.350|
00015e  6820              LDR      r0,[r4,#0]            ;499
000160  6840              LDR      r0,[r0,#4]            ;499
000162  2128              MOVS     r1,#0x28              ;499
000164  4388              BICS     r0,r0,r1              ;499
000166  6821              LDR      r1,[r4,#0]            ;499
000168  6048              STR      r0,[r1,#4]            ;499
00016a  6820              LDR      r0,[r4,#0]            ;501
00016c  8b80              LDRH     r0,[r0,#0x1c]         ;501
00016e  2800              CMP      r0,#0                 ;501
000170  d01d              BEQ      |L27.430|
000172  e01b              B        |L27.428|
                  |L27.372|
000174  6820              LDR      r0,[r4,#0]            ;507
000176  6800              LDR      r0,[r0,#0]            ;507
000178  2120              MOVS     r1,#0x20              ;507
00017a  4008              ANDS     r0,r0,r1              ;507
00017c  0940              LSRS     r0,r0,#5              ;507
00017e  2800              CMP      r0,#0                 ;507
000180  d003              BEQ      |L27.394|
000182  2001              MOVS     r0,#1                 ;509
000184  6420              STR      r0,[r4,#0x40]         ;509
000186  2000              MOVS     r0,#0                 ;510
000188  e768              B        |L27.92|
                  |L27.394|
00018a  1c68              ADDS     r0,r5,#1              ;514
00018c  2800              CMP      r0,#0                 ;514
00018e  d00d              BEQ      |L27.428|
000190  f7fffffe          BL       MID_GetTick
000194  1b80              SUBS     r0,r0,r6              ;516
000196  42a8              CMP      r0,r5                 ;516
000198  d908              BLS      |L27.428|
00019a  2003              MOVS     r0,#3                 ;519
00019c  6420              STR      r0,[r4,#0x40]         ;519
00019e  bf00              NOP                            ;522
0001a0  2100              MOVS     r1,#0                 ;522
0001a2  203c              MOVS     r0,#0x3c              ;522
0001a4  5501              STRB     r1,[r0,r4]            ;522
0001a6  bf00              NOP                            ;522
0001a8  2003              MOVS     r0,#3                 ;524
0001aa  e757              B        |L27.92|
                  |L27.428|
0001ac  e7e2              B        |L27.372|
                  |L27.430|
0001ae  e01b              B        |L27.488|
                  |L27.432|
0001b0  6820              LDR      r0,[r4,#0]            ;535
0001b2  6800              LDR      r0,[r0,#0]            ;535
0001b4  2108              MOVS     r1,#8                 ;535
0001b6  4008              ANDS     r0,r0,r1              ;535
0001b8  08c0              LSRS     r0,r0,#3              ;535
0001ba  2800              CMP      r0,#0                 ;535
0001bc  d003              BEQ      |L27.454|
0001be  2001              MOVS     r0,#1                 ;537
0001c0  6420              STR      r0,[r4,#0x40]         ;537
0001c2  2000              MOVS     r0,#0                 ;538
0001c4  e74a              B        |L27.92|
                  |L27.454|
0001c6  1c68              ADDS     r0,r5,#1              ;542
0001c8  2800              CMP      r0,#0                 ;542
0001ca  d00d              BEQ      |L27.488|
0001cc  f7fffffe          BL       MID_GetTick
0001d0  1b80              SUBS     r0,r0,r6              ;544
0001d2  42a8              CMP      r0,r5                 ;544
0001d4  d908              BLS      |L27.488|
0001d6  2003              MOVS     r0,#3                 ;547
0001d8  6420              STR      r0,[r4,#0x40]         ;547
0001da  bf00              NOP                            ;550
0001dc  2100              MOVS     r1,#0                 ;550
0001de  203c              MOVS     r0,#0x3c              ;550
0001e0  5501              STRB     r1,[r0,r4]            ;550
0001e2  bf00              NOP                            ;550
0001e4  2003              MOVS     r0,#3                 ;552
0001e6  e739              B        |L27.92|
                  |L27.488|
0001e8  e7e2              B        |L27.432|
                  |L27.490|
0001ea  2001              MOVS     r0,#1                 ;559
0001ec  6420              STR      r0,[r4,#0x40]         ;559
0001ee  6460              STR      r0,[r4,#0x44]         ;560
0001f0  bf00              NOP                            ;561
0001f2  e733              B        |L27.92|
;;;565    
                          ENDP


                          AREA ||i.MID_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  MID_ADC_PollForEvent PROC
;;;584     */
;;;585    MID_StatusTypeDef MID_ADC_PollForEvent(ADC_HandleTypeDef* mADC, uint32_t EventType, uint32_t Timeout)
000000  b5f8              PUSH     {r3-r7,lr}
;;;586    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;587        uint32_t tickstart = 0;
000008  2700              MOVS     r7,#0
;;;588        
;;;589        /* Get tick count */
;;;590        tickstart = MID_GetTick();
00000a  f7fffffe          BL       MID_GetTick
00000e  4607              MOV      r7,r0
;;;591        
;;;592        /* Check selected event flag */
;;;593        while(__DRV_ADC_GET_EVENT(mADC, EventType) == 0x0000)
000010  e012              B        |L28.56|
                  |L28.18|
;;;594        {
;;;595            /* Check if timeout is disable (set to infinite wait) */
;;;596            if(Timeout != MID_MAX_DELAY)
000012  1c68              ADDS     r0,r5,#1
000014  2800              CMP      r0,#0
000016  d00f              BEQ      |L28.56|
;;;597            {
;;;598                if((Timeout == 0U) || ((MID_GetTick() - tickstart) > Timeout))
000018  2d00              CMP      r5,#0
00001a  d004              BEQ      |L28.38|
00001c  f7fffffe          BL       MID_GetTick
000020  1bc0              SUBS     r0,r0,r7
000022  42a8              CMP      r0,r5
000024  d908              BLS      |L28.56|
                  |L28.38|
;;;599                {
;;;600                    /* Update ADC state machine to timeout */
;;;601                    mADC->State = MID_ADC_STATE_TIMEOUT;
000026  2003              MOVS     r0,#3
000028  6420              STR      r0,[r4,#0x40]
;;;602                    
;;;603                    /* Process unlocked */
;;;604                    __MID_UNLOCK(mADC);
00002a  bf00              NOP      
00002c  2100              MOVS     r1,#0
00002e  203c              MOVS     r0,#0x3c
000030  5501              STRB     r1,[r0,r4]
000032  bf00              NOP      
;;;605                    
;;;606                    return MID_TIMEOUT;
000034  2003              MOVS     r0,#3
                  |L28.54|
;;;607                }
;;;608            }     
;;;609        }
;;;610        
;;;611        switch(EventType)
;;;612        {
;;;613        /* Analog watchdog (level out of window) event */
;;;614        case ADC_AWD_EVENT:
;;;615            /* Set ADC state */
;;;616            mADC->State = MID_ADC_STATE_AWD1;
;;;617    
;;;618            /* Clear ADC analog watchdog flag */
;;;619            __DRV_ADC_CLEAR_FLAG(mADC, ADC_FLAG_AWD);
;;;620            break;
;;;621    
;;;622        /* Overrun event */
;;;623        default: /* Case ADC_OVR_EVENT */
;;;624            /* If overrun is set to overwrite previous data, overrun event is not     */
;;;625            /* considered as an error.                                                */
;;;626            /* (cf ref manual "Managing conversions without using the DMA and without */
;;;627            /* overrun ")                                                             */
;;;628            if (mADC->Init.Overrun == ADC_ACCEPT_OVERRUN)
;;;629            {
;;;630                /* Set ADC state */
;;;631                mADC->State = MID_ADC_STATE_REG_OVR;
;;;632    
;;;633                /* Set ADC error code to overrun */
;;;634                mADC->ErrorCode = MID_ADC_ERROR_OVR;
;;;635            }
;;;636    
;;;637            /* Clear ADC Overrun flag */
;;;638            __DRV_ADC_CLEAR_FLAG(mADC, ADC_FLAG_OVR);
;;;639            break;
;;;640        }
;;;641      
;;;642        
;;;643        /* Return function status */
;;;644        return MID_SUCCESS;
;;;645    }
000036  bdf8              POP      {r3-r7,pc}
                  |L28.56|
000038  6820              LDR      r0,[r4,#0]            ;593
00003a  6800              LDR      r0,[r0,#0]            ;593
00003c  4030              ANDS     r0,r0,r6              ;593
00003e  2800              CMP      r0,#0                 ;593
000040  d001              BEQ      |L28.70|
000042  2001              MOVS     r0,#1                 ;593
000044  e000              B        |L28.72|
                  |L28.70|
000046  2000              MOVS     r0,#0                 ;593
                  |L28.72|
000048  2800              CMP      r0,#0                 ;593
00004a  d0e2              BEQ      |L28.18|
00004c  2007              MOVS     r0,#7                 ;611
00004e  0200              LSLS     r0,r0,#8              ;611
000050  1a30              SUBS     r0,r6,r0              ;611
000052  d106              BNE      |L28.98|
000054  2004              MOVS     r0,#4                 ;616
000056  6420              STR      r0,[r4,#0x40]         ;616
000058  2007              MOVS     r0,#7                 ;619
00005a  0200              LSLS     r0,r0,#8              ;619
00005c  6821              LDR      r1,[r4,#0]            ;619
00005e  6008              STR      r0,[r1,#0]            ;619
000060  e00a              B        |L28.120|
                  |L28.98|
000062  6aa0              LDR      r0,[r4,#0x28]         ;628
000064  2800              CMP      r0,#0                 ;628
000066  d103              BNE      |L28.112|
000068  2005              MOVS     r0,#5                 ;631
00006a  6420              STR      r0,[r4,#0x40]         ;631
00006c  2002              MOVS     r0,#2                 ;634
00006e  6460              STR      r0,[r4,#0x44]         ;634
                  |L28.112|
000070  2080              MOVS     r0,#0x80              ;638
000072  6821              LDR      r1,[r4,#0]            ;638
000074  6008              STR      r0,[r1,#0]            ;638
000076  bf00              NOP                            ;639
                  |L28.120|
000078  bf00              NOP                            ;620
00007a  2000              MOVS     r0,#0                 ;644
00007c  e7db              B        |L28.54|
;;;646    
                          ENDP


                          AREA ||i.MID_ADC_Start||, CODE, READONLY, ALIGN=1

                  MID_ADC_Start PROC
;;;302     */
;;;303    MID_StatusTypeDef MID_ADC_Start(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;304    {
;;;305        /* Enable conversion of                                                  */
;;;306        if(mADC->Init.TriggerConverionSrc == ADC_SOFTWARE_START)
000002  6a08              LDR      r0,[r1,#0x20]
000004  2800              CMP      r0,#0
000006  d105              BNE      |L29.20|
;;;307            mADC->Instance->START.W |= ADC_START_START_mask_w;
000008  6808              LDR      r0,[r1,#0]
00000a  6a00              LDR      r0,[r0,#0x20]
00000c  2201              MOVS     r2,#1
00000e  4310              ORRS     r0,r0,r2
000010  680a              LDR      r2,[r1,#0]
000012  6210              STR      r0,[r2,#0x20]
                  |L29.20|
;;;308        
;;;309        return MID_SUCCESS;
000014  2000              MOVS     r0,#0
;;;310    }
000016  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.MID_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  MID_ADC_Start_DMA PROC
;;;810     */
;;;811    MID_StatusTypeDef MID_ADC_Start_DMA(ADC_HandleTypeDef* mADC, uint32_t* pData, uint32_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;812    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;813        
;;;814        /* Perform ADC enable and conversion start if no conversion is on going */
;;;815    
;;;816        /* Process locked */
;;;817        __MID_LOCK(mADC);
000008  bf00              NOP      
00000a  203c              MOVS     r0,#0x3c
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L30.22|
000012  2002              MOVS     r0,#2
                  |L30.20|
;;;818    
;;;819        /* Enable the ADC peripheral */
;;;820        ADC_Enable(mADC);
;;;821    
;;;822        /* Process unlocked */
;;;823        /* Unlock before starting ADC conversions: in case of potential         */
;;;824        /* interruption, to let the process to ADC IRQ Handler.                 */
;;;825        __MID_UNLOCK(mADC);
;;;826        
;;;827        /* Set the DMA Period elapsed callback */
;;;828        mADC->DMA_Handle->XferCpltCallback  = ADC_DMAConvCplt;
;;;829    
;;;830        /* Set the DMA half transfer complete callback */
;;;831        mADC->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;832    
;;;833        /* Set the DMA error callback */
;;;834        mADC->DMA_Handle->XferErrorCallback = ADC_DMAError ;
;;;835    
;;;836        /* Clear regular group conversion flag and overrun flag */
;;;837        /* (To ensure of no unknown state from potential previous ADC           */
;;;838        /* operations)                                                          */
;;;839        __DRV_ADC_CLEAR_FLAG(mADC, (ADC_FLAG_ESMP | ADC_FLAG_E1CNV | ADC_FLAG_ESCNV | ADC_FLAG_OVR));
;;;840    
;;;841        /* Enable ADC overrun interrupt */
;;;842        __DRV_ADC_ENABLE_IT(mADC, ADC_IT_OVR);
;;;843        __DRV_ADC_ENABLE_ITEA(mADC);
;;;844    
;;;845        /* Enable the ADC Capture/Compare 0 DMA request */
;;;846        __DRV_ADC_ENABLE_DMA(mADC);
;;;847          
;;;848        /* Start the DMA channel */
;;;849        MID_DMA_Start_IT(mADC->DMA_Handle, NULL, (uint32_t)pData, Length);  
;;;850    
;;;851        /* Set ADC state                                                        */
;;;852        /* - Clear state bitfield related to regular group conversion results   */
;;;853        /* - Set state bitfield related to regular operation                    */
;;;854        mADC->State = MID_ADC_STATE_REG_BUSY;
;;;855    
;;;856        /* Reset ADC all error code fields */
;;;857        mADC->ErrorCode = MID_ADC_ERROR_NONE;
;;;858    
;;;859        /* Enable conversion of regular group.                                  */
;;;860        /* If software start has been selected, conversion starts immediately.  */
;;;861        /* If external trigger has been selected, conversion will start at next */
;;;862        /* trigger event.                                                       */
;;;863        mADC->Instance->START.W |= ADC_START_START_mask_w;
;;;864        
;;;865        /* Return function status */
;;;866        return MID_SUCCESS;
;;;867    }
000014  bd70              POP      {r4-r6,pc}
                  |L30.22|
000016  2101              MOVS     r1,#1                 ;817
000018  203c              MOVS     r0,#0x3c              ;817
00001a  5501              STRB     r1,[r0,r4]            ;817
00001c  bf00              NOP                            ;817
00001e  4620              MOV      r0,r4                 ;820
000020  f7fffffe          BL       ADC_Enable
000024  bf00              NOP                            ;825
000026  2100              MOVS     r1,#0                 ;825
000028  203c              MOVS     r0,#0x3c              ;825
00002a  5501              STRB     r1,[r0,r4]            ;825
00002c  bf00              NOP                            ;825
00002e  4818              LDR      r0,|L30.144|
000030  6ba1              LDR      r1,[r4,#0x38]         ;828
000032  62c8              STR      r0,[r1,#0x2c]         ;828
000034  4817              LDR      r0,|L30.148|
000036  6ba1              LDR      r1,[r4,#0x38]         ;831
000038  6308              STR      r0,[r1,#0x30]         ;831
00003a  4817              LDR      r0,|L30.152|
00003c  6ba1              LDR      r1,[r4,#0x38]         ;834
00003e  6348              STR      r0,[r1,#0x34]         ;834
000040  20ac              MOVS     r0,#0xac              ;839
000042  6821              LDR      r1,[r4,#0]            ;839
000044  6008              STR      r0,[r1,#0]            ;839
000046  6820              LDR      r0,[r4,#0]            ;842
000048  6840              LDR      r0,[r0,#4]            ;842
00004a  2180              MOVS     r1,#0x80              ;842
00004c  4308              ORRS     r0,r0,r1              ;842
00004e  6821              LDR      r1,[r4,#0]            ;842
000050  6048              STR      r0,[r1,#4]            ;842
000052  6820              LDR      r0,[r4,#0]            ;843
000054  6840              LDR      r0,[r0,#4]            ;843
000056  2101              MOVS     r1,#1                 ;843
000058  4308              ORRS     r0,r0,r1              ;843
00005a  6821              LDR      r1,[r4,#0]            ;843
00005c  6048              STR      r0,[r1,#4]            ;843
00005e  6820              LDR      r0,[r4,#0]            ;846
000060  6900              LDR      r0,[r0,#0x10]         ;846
000062  2101              MOVS     r1,#1                 ;846
000064  07c9              LSLS     r1,r1,#31             ;846
000066  4308              ORRS     r0,r0,r1              ;846
000068  6821              LDR      r1,[r4,#0]            ;846
00006a  6108              STR      r0,[r1,#0x10]         ;846
00006c  4633              MOV      r3,r6                 ;849
00006e  462a              MOV      r2,r5                 ;849
000070  2100              MOVS     r1,#0                 ;849
000072  6ba0              LDR      r0,[r4,#0x38]         ;849
000074  f7fffffe          BL       MID_DMA_Start_IT
000078  2006              MOVS     r0,#6                 ;854
00007a  6420              STR      r0,[r4,#0x40]         ;854
00007c  2000              MOVS     r0,#0                 ;857
00007e  6460              STR      r0,[r4,#0x44]         ;857
000080  6820              LDR      r0,[r4,#0]            ;863
000082  6a00              LDR      r0,[r0,#0x20]         ;863
000084  2101              MOVS     r1,#1                 ;863
000086  4308              ORRS     r0,r0,r1              ;863
000088  6821              LDR      r1,[r4,#0]            ;863
00008a  6208              STR      r0,[r1,#0x20]         ;863
00008c  2000              MOVS     r0,#0                 ;866
00008e  e7c1              B        |L30.20|
;;;868    
                          ENDP

                  |L30.144|
                          DCD      ADC_DMAConvCplt
                  |L30.148|
                          DCD      ADC_DMAHalfConvCplt
                  |L30.152|
                          DCD      ADC_DMAError

                          AREA ||i.MID_ADC_Start_IT||, CODE, READONLY, ALIGN=1

                  MID_ADC_Start_IT PROC
;;;666     */
;;;667    MID_StatusTypeDef MID_ADC_Start_IT(ADC_HandleTypeDef* mADC)
000000  4601              MOV      r1,r0
;;;668    {
;;;669      
;;;670        /* Perform ADC enable and conversion start if no conversion is on going  */
;;;671        
;;;672        /* Process locked */
;;;673        __MID_LOCK(mADC);
000002  bf00              NOP      
000004  203c              MOVS     r0,#0x3c
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L31.16|
00000c  2002              MOVS     r0,#2
                  |L31.14|
;;;674         
;;;675        /* Set ADC state                                                         */
;;;676        /* - Clear state bitfield related to regular group conversion results    */
;;;677        /* - Set state bitfield related to regular operation                     */
;;;678        mADC->State = MID_ADC_STATE_REG_BUSY;                                    
;;;679                                                                                 
;;;680        /* Reset ADC all error code fields */                                    
;;;681        mADC->ErrorCode = MID_ADC_ERROR_NONE;                                    
;;;682                                                                                 
;;;683        /* Process unlocked */                                                   
;;;684        /* Unlock before starting ADC conversions: in case of potential          */
;;;685        /* interruption, to let the process to ADC IRQ Handler.                  */
;;;686        __MID_UNLOCK(mADC);                                                      
;;;687                                                                                 
;;;688        /* Clear regular group conversion flag and overrun flag */               
;;;689        /* (To ensure of no unknown state from potential previous ADC            */
;;;690        /* operations)                                                           */
;;;691        __DRV_ADC_CLEAR_FLAG(mADC, (ADC_FLAG_ESMP | ADC_FLAG_E1CNV | ADC_FLAG_ESCNV | ADC_FLAG_OVR));
;;;692          
;;;693        /* Clear all IT                                                          */
;;;694        __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_ESMP | ADC_IT_E1CNV | ADC_IT_ESCNV | ADC_IT_OVR));
;;;695        
;;;696        /* Enable IT what ADC conversion mode                                    */
;;;697        switch(mADC->Init.ConversionMode)
;;;698        {
;;;699        /* Trigger once and conversion once                                       */
;;;700        case ADC_ONESHOT:
;;;701            __DRV_ADC_ENABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_OVR));
;;;702            __DRV_ADC_ENABLE_ITEA(mADC);
;;;703            break;
;;;704        
;;;705        /* Trigger once and repeat convesion one channel                          */
;;;706        case ADC_REPITIVE_CHANNEL:   
;;;707            __DRV_ADC_ENABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_OVR));
;;;708            __DRV_ADC_ENABLE_ITEA(mADC);
;;;709            break;
;;;710        
;;;711        /* Manual trigger conversion                                              */
;;;712        case ADC_SCAN_MANUAL:   
;;;713            __DRV_ADC_ENABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_OVR));
;;;714            __DRV_ADC_ENABLE_ITEA(mADC);
;;;715            break;
;;;716        
;;;717        /* TTrigger once and auto scan mask channel                               */
;;;718        case ADC_SCAN_AUTO:   
;;;719            __DRV_ADC_ENABLE_IT(mADC, (ADC_IT_ESCNV | ADC_IT_OVR));
;;;720            __DRV_ADC_ENABLE_ITEA(mADC);
;;;721            break;
;;;722        
;;;723        /* Conversion loop mode                                                   */
;;;724        case ADC_LOOP_AUTO:   
;;;725            if(mADC->Instance->MSK.H[0] != 0x0000)
;;;726                __DRV_ADC_ENABLE_IT(mADC, (ADC_IT_ESCNV | ADC_IT_OVR));
;;;727            else
;;;728                __DRV_ADC_ENABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_OVR));
;;;729            
;;;730            __DRV_ADC_ENABLE_ITEA(mADC);
;;;731            break;
;;;732        
;;;733        default:
;;;734            return MID_FAILURE;
;;;735        }
;;;736    
;;;737          
;;;738        /* Enable conversion of regular group.                                  */
;;;739        /* If software start has been selected, conversion starts immediately.  */
;;;740        /* If external trigger has been selected, conversion will start at next */
;;;741        /* trigger event.                                                       */
;;;742        if(mADC->Init.TriggerConverionSrc == ADC_SOFTWARE_START)
;;;743            mADC->Instance->START.W |= ADC_START_START_mask_w;
;;;744        
;;;745        /* Return function status */
;;;746        return MID_SUCCESS;
;;;747    }
00000e  4770              BX       lr
                  |L31.16|
000010  2201              MOVS     r2,#1                 ;673
000012  203c              MOVS     r0,#0x3c              ;673
000014  5442              STRB     r2,[r0,r1]            ;673
000016  bf00              NOP                            ;673
000018  2006              MOVS     r0,#6                 ;678
00001a  6408              STR      r0,[r1,#0x40]         ;678
00001c  2000              MOVS     r0,#0                 ;681
00001e  6448              STR      r0,[r1,#0x44]         ;681
000020  bf00              NOP                            ;686
000022  2200              MOVS     r2,#0                 ;686
000024  203c              MOVS     r0,#0x3c              ;686
000026  5442              STRB     r2,[r0,r1]            ;686
000028  bf00              NOP                            ;686
00002a  20ac              MOVS     r0,#0xac              ;691
00002c  680a              LDR      r2,[r1,#0]            ;691
00002e  6010              STR      r0,[r2,#0]            ;691
000030  6808              LDR      r0,[r1,#0]            ;694
000032  6840              LDR      r0,[r0,#4]            ;694
000034  22ac              MOVS     r2,#0xac              ;694
000036  4390              BICS     r0,r0,r2              ;694
000038  680a              LDR      r2,[r1,#0]            ;694
00003a  6050              STR      r0,[r2,#4]            ;694
00003c  2301              MOVS     r3,#1                 ;697
00003e  061b              LSLS     r3,r3,#24             ;697
000040  6948              LDR      r0,[r1,#0x14]         ;697
000042  1ac2              SUBS     r2,r0,r3              ;697
000044  4298              CMP      r0,r3                 ;697
000046  d02a              BEQ      |L31.158|
000048  dc06              BGT      |L31.88|
00004a  2800              CMP      r0,#0                 ;697
00004c  d00d              BEQ      |L31.106|
00004e  2201              MOVS     r2,#1                 ;697
000050  04d2              LSLS     r2,r2,#19             ;697
000052  1a80              SUBS     r0,r0,r2              ;697
000054  d155              BNE      |L31.258|
000056  e015              B        |L31.132|
                  |L31.88|
000058  2001              MOVS     r0,#1                 ;697
00005a  04c0              LSLS     r0,r0,#19             ;697
00005c  1a10              SUBS     r0,r2,r0              ;697
00005e  d02b              BEQ      |L31.184|
000060  221f              MOVS     r2,#0x1f              ;697
000062  04d2              LSLS     r2,r2,#19             ;697
000064  1a80              SUBS     r0,r0,r2              ;697
000066  d14c              BNE      |L31.258|
000068  e033              B        |L31.210|
                  |L31.106|
00006a  6808              LDR      r0,[r1,#0]            ;701
00006c  6840              LDR      r0,[r0,#4]            ;701
00006e  2288              MOVS     r2,#0x88              ;701
000070  4310              ORRS     r0,r0,r2              ;701
000072  680a              LDR      r2,[r1,#0]            ;701
000074  6050              STR      r0,[r2,#4]            ;701
000076  6808              LDR      r0,[r1,#0]            ;702
000078  6840              LDR      r0,[r0,#4]            ;702
00007a  2201              MOVS     r2,#1                 ;702
00007c  4310              ORRS     r0,r0,r2              ;702
00007e  680a              LDR      r2,[r1,#0]            ;702
000080  6050              STR      r0,[r2,#4]            ;702
000082  e040              B        |L31.262|
                  |L31.132|
000084  6808              LDR      r0,[r1,#0]            ;707
000086  6840              LDR      r0,[r0,#4]            ;707
000088  2288              MOVS     r2,#0x88              ;707
00008a  4310              ORRS     r0,r0,r2              ;707
00008c  680a              LDR      r2,[r1,#0]            ;707
00008e  6050              STR      r0,[r2,#4]            ;707
000090  6808              LDR      r0,[r1,#0]            ;708
000092  6840              LDR      r0,[r0,#4]            ;708
000094  2201              MOVS     r2,#1                 ;708
000096  4310              ORRS     r0,r0,r2              ;708
000098  680a              LDR      r2,[r1,#0]            ;708
00009a  6050              STR      r0,[r2,#4]            ;708
00009c  e033              B        |L31.262|
                  |L31.158|
00009e  6808              LDR      r0,[r1,#0]            ;713
0000a0  6840              LDR      r0,[r0,#4]            ;713
0000a2  2288              MOVS     r2,#0x88              ;713
0000a4  4310              ORRS     r0,r0,r2              ;713
0000a6  680a              LDR      r2,[r1,#0]            ;713
0000a8  6050              STR      r0,[r2,#4]            ;713
0000aa  6808              LDR      r0,[r1,#0]            ;714
0000ac  6840              LDR      r0,[r0,#4]            ;714
0000ae  2201              MOVS     r2,#1                 ;714
0000b0  4310              ORRS     r0,r0,r2              ;714
0000b2  680a              LDR      r2,[r1,#0]            ;714
0000b4  6050              STR      r0,[r2,#4]            ;714
0000b6  e026              B        |L31.262|
                  |L31.184|
0000b8  6808              LDR      r0,[r1,#0]            ;719
0000ba  6840              LDR      r0,[r0,#4]            ;719
0000bc  22a0              MOVS     r2,#0xa0              ;719
0000be  4310              ORRS     r0,r0,r2              ;719
0000c0  680a              LDR      r2,[r1,#0]            ;719
0000c2  6050              STR      r0,[r2,#4]            ;719
0000c4  6808              LDR      r0,[r1,#0]            ;720
0000c6  6840              LDR      r0,[r0,#4]            ;720
0000c8  2201              MOVS     r2,#1                 ;720
0000ca  4310              ORRS     r0,r0,r2              ;720
0000cc  680a              LDR      r2,[r1,#0]            ;720
0000ce  6050              STR      r0,[r2,#4]            ;720
0000d0  e019              B        |L31.262|
                  |L31.210|
0000d2  6808              LDR      r0,[r1,#0]            ;725
0000d4  8b80              LDRH     r0,[r0,#0x1c]         ;725
0000d6  2800              CMP      r0,#0                 ;725
0000d8  d006              BEQ      |L31.232|
0000da  6808              LDR      r0,[r1,#0]            ;726
0000dc  6840              LDR      r0,[r0,#4]            ;726
0000de  22a0              MOVS     r2,#0xa0              ;726
0000e0  4310              ORRS     r0,r0,r2              ;726
0000e2  680a              LDR      r2,[r1,#0]            ;726
0000e4  6050              STR      r0,[r2,#4]            ;726
0000e6  e005              B        |L31.244|
                  |L31.232|
0000e8  6808              LDR      r0,[r1,#0]            ;728
0000ea  6840              LDR      r0,[r0,#4]            ;728
0000ec  2288              MOVS     r2,#0x88              ;728
0000ee  4310              ORRS     r0,r0,r2              ;728
0000f0  680a              LDR      r2,[r1,#0]            ;728
0000f2  6050              STR      r0,[r2,#4]            ;728
                  |L31.244|
0000f4  6808              LDR      r0,[r1,#0]            ;730
0000f6  6840              LDR      r0,[r0,#4]            ;730
0000f8  2201              MOVS     r2,#1                 ;730
0000fa  4310              ORRS     r0,r0,r2              ;730
0000fc  680a              LDR      r2,[r1,#0]            ;730
0000fe  6050              STR      r0,[r2,#4]            ;730
000100  e001              B        |L31.262|
                  |L31.258|
000102  2001              MOVS     r0,#1                 ;734
000104  e783              B        |L31.14|
                  |L31.262|
000106  bf00              NOP                            ;703
000108  6a08              LDR      r0,[r1,#0x20]         ;742
00010a  2800              CMP      r0,#0                 ;742
00010c  d105              BNE      |L31.282|
00010e  6808              LDR      r0,[r1,#0]            ;743
000110  6a00              LDR      r0,[r0,#0x20]         ;743
000112  2201              MOVS     r2,#1                 ;743
000114  4310              ORRS     r0,r0,r2              ;743
000116  680a              LDR      r2,[r1,#0]            ;743
000118  6210              STR      r0,[r2,#0x20]         ;743
                  |L31.282|
00011a  2000              MOVS     r0,#0                 ;746
00011c  e777              B        |L31.14|
;;;748    
                          ENDP


                          AREA ||i.MID_ADC_Stop||, CODE, READONLY, ALIGN=1

                  MID_ADC_Stop PROC
;;;324     */
;;;325    MID_StatusTypeDef MID_ADC_Stop(ADC_HandleTypeDef* mADC)
000000  b510              PUSH     {r4,lr}
;;;326    {
000002  4604              MOV      r4,r0
;;;327        /* Stop potential conversion on going, on regular group */
;;;328        ADC_ConversionStop(mADC);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       ADC_ConversionStop
;;;329        
;;;330        /* Set ADC state */
;;;331        mADC->State = MID_ADC_STATE_READY;
00000a  2001              MOVS     r0,#1
00000c  6420              STR      r0,[r4,#0x40]
;;;332        
;;;333        return MID_SUCCESS;
00000e  2000              MOVS     r0,#0
;;;334    }
000010  bd10              POP      {r4,pc}
;;;335    
                          ENDP


                          AREA ||i.MID_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  MID_ADC_Stop_DMA PROC
;;;884     */
;;;885    MID_StatusTypeDef MID_ADC_Stop_DMA(ADC_HandleTypeDef* mADC)
000000  b510              PUSH     {r4,lr}
;;;886    {
000002  4604              MOV      r4,r0
;;;887        
;;;888        /* Process locked */
;;;889        __MID_LOCK(mADC);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L33.18|
00000e  2002              MOVS     r0,#2
                  |L33.16|
;;;890    
;;;891        /* 1. Stop potential conversion on going, on regular group */
;;;892        ADC_ConversionStop(mADC);
;;;893    
;;;894        /* Disable ADC DMA (ADC DMA configuration ADC_CFGR_DMACFG is kept) */
;;;895        __DRV_ADC_DISABLE_DMA(mADC);
;;;896    
;;;897        /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;898        /* while DMA transfer is on going)                                        */
;;;899        /* Check if DMA channel effectively disabled */
;;;900        MID_DMA_Abort(mADC->DMA_Handle);
;;;901    
;;;902        /* Disable ADC overrun interrupt */
;;;903        __DRV_ADC_DISABLE_IT(mADC, ADC_IT_OVR);
;;;904    
;;;905        /* 2. Disable the ADC peripheral */
;;;906        /* Update "tmp_MID_status" only if DMA channel disabling passed, to keep  */
;;;907        /* in memory a potential failing status.                                  */
;;;908        ADC_Disable(mADC);
;;;909    
;;;910        /* Check if ADC is effectively disabled */
;;;911        mADC->State = MID_ADC_STATE_READY;
;;;912    
;;;913        /* Process unlocked */
;;;914        __MID_UNLOCK(mADC);
;;;915    
;;;916        /* Return function status */
;;;917        return MID_SUCCESS;
;;;918    }
000010  bd10              POP      {r4,pc}
                  |L33.18|
000012  2101              MOVS     r1,#1                 ;889
000014  203c              MOVS     r0,#0x3c              ;889
000016  5501              STRB     r1,[r0,r4]            ;889
000018  bf00              NOP                            ;889
00001a  4620              MOV      r0,r4                 ;892
00001c  f7fffffe          BL       ADC_ConversionStop
000020  6820              LDR      r0,[r4,#0]            ;895
000022  6900              LDR      r0,[r0,#0x10]         ;895
000024  0040              LSLS     r0,r0,#1              ;895
000026  0840              LSRS     r0,r0,#1              ;895
000028  6821              LDR      r1,[r4,#0]            ;895
00002a  6108              STR      r0,[r1,#0x10]         ;895
00002c  6ba0              LDR      r0,[r4,#0x38]         ;900
00002e  f7fffffe          BL       MID_DMA_Abort
000032  6820              LDR      r0,[r4,#0]            ;903
000034  6840              LDR      r0,[r0,#4]            ;903
000036  2180              MOVS     r1,#0x80              ;903
000038  4388              BICS     r0,r0,r1              ;903
00003a  6821              LDR      r1,[r4,#0]            ;903
00003c  6048              STR      r0,[r1,#4]            ;903
00003e  4620              MOV      r0,r4                 ;908
000040  f7fffffe          BL       ADC_Disable
000044  2001              MOVS     r0,#1                 ;911
000046  6420              STR      r0,[r4,#0x40]         ;911
000048  bf00              NOP                            ;914
00004a  2100              MOVS     r1,#0                 ;914
00004c  203c              MOVS     r0,#0x3c              ;914
00004e  5501              STRB     r1,[r0,r4]            ;914
000050  bf00              NOP                            ;914
000052  2000              MOVS     r0,#0                 ;917
000054  e7dc              B        |L33.16|
;;;919    
                          ENDP


                          AREA ||i.MID_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  MID_ADC_Stop_IT PROC
;;;764     */
;;;765    MID_StatusTypeDef MID_ADC_Stop_IT(ADC_HandleTypeDef* mADC)
000000  b510              PUSH     {r4,lr}
;;;766    {
000002  4604              MOV      r4,r0
;;;767    
;;;768        /* Process locked */
;;;769        __MID_LOCK(mADC);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L34.18|
00000e  2002              MOVS     r0,#2
                  |L34.16|
;;;770    
;;;771        /* 1. Stop potential conversion on going, on regular group */
;;;772        ADC_ConversionStop(mADC);
;;;773    
;;;774        /* Disable ADC end of conversion interrupt for regular group */
;;;775        /* Disable ADC overrun interrupt */
;;;776        __DRV_ADC_DISABLE_IT(mADC, (ADC_IT_E1CNV | ADC_IT_ESCNV | ADC_IT_OVR));
;;;777    
;;;778        /* 2. Disable the ADC peripheral */
;;;779        ADC_Disable(mADC);
;;;780    
;;;781        /* Set ADC state */
;;;782        mADC->State = MID_ADC_STATE_READY;
;;;783    
;;;784        /* Process unlocked */
;;;785        __MID_UNLOCK(mADC);
;;;786    
;;;787        /* Return function status */
;;;788        return MID_SUCCESS;
;;;789    }
000010  bd10              POP      {r4,pc}
                  |L34.18|
000012  2101              MOVS     r1,#1                 ;769
000014  203c              MOVS     r0,#0x3c              ;769
000016  5501              STRB     r1,[r0,r4]            ;769
000018  bf00              NOP                            ;769
00001a  4620              MOV      r0,r4                 ;772
00001c  f7fffffe          BL       ADC_ConversionStop
000020  6820              LDR      r0,[r4,#0]            ;776
000022  6840              LDR      r0,[r0,#4]            ;776
000024  21a8              MOVS     r1,#0xa8              ;776
000026  4388              BICS     r0,r0,r1              ;776
000028  6821              LDR      r1,[r4,#0]            ;776
00002a  6048              STR      r0,[r1,#4]            ;776
00002c  4620              MOV      r0,r4                 ;779
00002e  f7fffffe          BL       ADC_Disable
000032  2001              MOVS     r0,#1                 ;782
000034  6420              STR      r0,[r4,#0x40]         ;782
000036  bf00              NOP                            ;785
000038  2100              MOVS     r1,#0                 ;785
00003a  203c              MOVS     r0,#0x3c              ;785
00003c  5501              STRB     r1,[r0,r4]            ;785
00003e  bf00              NOP                            ;785
000040  2000              MOVS     r0,#0                 ;788
000042  e7e5              B        |L34.16|
;;;790    
                          ENDP


                          AREA ||i.MID_ADC_SumCallback||, CODE, READONLY, ALIGN=1

                  MID_ADC_SumCallback PROC
;;;1169    */
;;;1170   __weak void MID_ADC_SumCallback(ADC_HandleTypeDef *mADC)
000000  4770              BX       lr
;;;1171   {
;;;1172     /* Prevent unused argument(s) compilation warning */
;;;1173     UNUSED(mADC);
;;;1174   
;;;1175   }
;;;1176   ///@}
                          ENDP


                          AREA ||i.MID_ADC_VRMCalibration_Start||, CODE, READONLY, ALIGN=2

                  MID_ADC_VRMCalibration_Start PROC
;;;1789    */
;;;1790   MID_StatusTypeDef MID_ADC_VRMCalibration_Start(ADC_HandleTypeDef* mADC, uint8_t VRMV)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;1791   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;1792   #if defined(MG32_1ST)
;;;1793       int32_t VRPV, VRNV, VRM;
;;;1794       int32_t CaliV;
;;;1795       uint8_t i;
;;;1796       
;;;1797       MID_UnProtectModuleReg(CFGmodule); 
000006  485e              LDR      r0,|L36.384|
000008  f7fffffe          BL       MID_UnProtectModuleReg
;;;1798   
;;;1799       VRM = VRMV;
00000c  9f04              LDR      r7,[sp,#0x10]
;;;1800       
;;;1801       // middle trim
;;;1802       while (1)
00000e  e0ae              B        |L36.366|
                  |L36.16|
;;;1803       {
;;;1804           __DRV_ADC_CHSELR_CHANNEL(mADC, ADC_CHANNEL_16);
000010  6820              LDR      r0,[r4,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  211f              MOVS     r1,#0x1f
000016  0209              LSLS     r1,r1,#8
000018  4388              BICS     r0,r0,r1
00001a  6821              LDR      r1,[r4,#0]
00001c  6208              STR      r0,[r1,#0x20]
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  2101              MOVS     r1,#1
000024  0309              LSLS     r1,r1,#12
000026  4308              ORRS     r0,r0,r1
000028  6821              LDR      r1,[r4,#0]
00002a  6208              STR      r0,[r1,#0x20]
;;;1805           for (i=0, VRNV=0 ; i<10; i++)
00002c  2600              MOVS     r6,#0
00002e  2000              MOVS     r0,#0
000030  9001              STR      r0,[sp,#4]
000032  e012              B        |L36.90|
                  |L36.52|
;;;1806           {
;;;1807               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
000034  6820              LDR      r0,[r4,#0]
000036  6a00              LDR      r0,[r0,#0x20]
000038  2101              MOVS     r1,#1
00003a  4308              ORRS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  6208              STR      r0,[r1,#0x20]
;;;1808               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
000040  bf00              NOP      
                  |L36.66|
000042  6820              LDR      r0,[r4,#0]
000044  6800              LDR      r0,[r0,#0]
000046  2108              MOVS     r1,#8
000048  4008              ANDS     r0,r0,r1
00004a  08c0              LSRS     r0,r0,#3
00004c  2800              CMP      r0,#0
00004e  d0f8              BEQ      |L36.66|
;;;1809               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
000050  200c              MOVS     r0,#0xc
000052  6821              LDR      r1,[r4,#0]
000054  6008              STR      r0,[r1,#0]
000056  1c70              ADDS     r0,r6,#1              ;1805
000058  b2c6              UXTB     r6,r0                 ;1805
                  |L36.90|
00005a  2e0a              CMP      r6,#0xa               ;1805
00005c  dbea              BLT      |L36.52|
;;;1810           }
;;;1811           for (i=0, VRNV=0 ; i<10; i++)
00005e  2600              MOVS     r6,#0
000060  2000              MOVS     r0,#0
000062  9001              STR      r0,[sp,#4]
000064  e018              B        |L36.152|
                  |L36.102|
;;;1812           {
;;;1813               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
000066  6820              LDR      r0,[r4,#0]
000068  6a00              LDR      r0,[r0,#0x20]
00006a  2101              MOVS     r1,#1
00006c  4308              ORRS     r0,r0,r1
00006e  6821              LDR      r1,[r4,#0]
000070  6208              STR      r0,[r1,#0x20]
;;;1814               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
000072  bf00              NOP      
                  |L36.116|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  2108              MOVS     r1,#8
00007a  4008              ANDS     r0,r0,r1
00007c  08c0              LSRS     r0,r0,#3
00007e  2800              CMP      r0,#0
000080  d0f8              BEQ      |L36.116|
;;;1815               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
000082  200c              MOVS     r0,#0xc
000084  6821              LDR      r1,[r4,#0]
000086  6008              STR      r0,[r1,#0]
;;;1816               VRNV += MID_ADC_GetValue(mADC);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       MID_ADC_GetValue
00008e  9901              LDR      r1,[sp,#4]
000090  1840              ADDS     r0,r0,r1
000092  9001              STR      r0,[sp,#4]
000094  1c70              ADDS     r0,r6,#1              ;1811
000096  b2c6              UXTB     r6,r0                 ;1811
                  |L36.152|
000098  2e0a              CMP      r6,#0xa               ;1811
00009a  dbe4              BLT      |L36.102|
;;;1817           }
;;;1818           VRNV = VRNV / 10;
00009c  210a              MOVS     r1,#0xa
00009e  9801              LDR      r0,[sp,#4]
0000a0  f7fffffe          BL       __aeabi_idivmod
0000a4  9001              STR      r0,[sp,#4]
;;;1819           
;;;1820           //-------------------------------------------------
;;;1821           __DRV_ADC_CHSELR_CHANNEL(mADC, ADC_CHANNEL_17);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6a00              LDR      r0,[r0,#0x20]
0000aa  211f              MOVS     r1,#0x1f
0000ac  0209              LSLS     r1,r1,#8
0000ae  4388              BICS     r0,r0,r1
0000b0  6821              LDR      r1,[r4,#0]
0000b2  6208              STR      r0,[r1,#0x20]
0000b4  6820              LDR      r0,[r4,#0]
0000b6  6a00              LDR      r0,[r0,#0x20]
0000b8  2111              MOVS     r1,#0x11
0000ba  0209              LSLS     r1,r1,#8
0000bc  4308              ORRS     r0,r0,r1
0000be  6821              LDR      r1,[r4,#0]
0000c0  6208              STR      r0,[r1,#0x20]
;;;1822           for (i=0, VRNV=0 ; i<10; i++)
0000c2  2600              MOVS     r6,#0
0000c4  2000              MOVS     r0,#0
0000c6  9001              STR      r0,[sp,#4]
0000c8  e012              B        |L36.240|
                  |L36.202|
;;;1823           {
;;;1824               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6a00              LDR      r0,[r0,#0x20]
0000ce  2101              MOVS     r1,#1
0000d0  4308              ORRS     r0,r0,r1
0000d2  6821              LDR      r1,[r4,#0]
0000d4  6208              STR      r0,[r1,#0x20]
;;;1825               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
0000d6  bf00              NOP      
                  |L36.216|
0000d8  6820              LDR      r0,[r4,#0]
0000da  6800              LDR      r0,[r0,#0]
0000dc  2108              MOVS     r1,#8
0000de  4008              ANDS     r0,r0,r1
0000e0  08c0              LSRS     r0,r0,#3
0000e2  2800              CMP      r0,#0
0000e4  d0f8              BEQ      |L36.216|
;;;1826               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
0000e6  200c              MOVS     r0,#0xc
0000e8  6821              LDR      r1,[r4,#0]
0000ea  6008              STR      r0,[r1,#0]
0000ec  1c70              ADDS     r0,r6,#1              ;1822
0000ee  b2c6              UXTB     r6,r0                 ;1822
                  |L36.240|
0000f0  2e0a              CMP      r6,#0xa               ;1822
0000f2  dbea              BLT      |L36.202|
;;;1827           }
;;;1828           for (i=0, VRPV=0 ; i<10; i++)
0000f4  2600              MOVS     r6,#0
0000f6  2000              MOVS     r0,#0
0000f8  9002              STR      r0,[sp,#8]
0000fa  e018              B        |L36.302|
                  |L36.252|
;;;1829           {
;;;1830               mADC->Instance->START.W |= ADC_START_START_mask_w;          // MID_ADC_Start(mADC);
0000fc  6820              LDR      r0,[r4,#0]
0000fe  6a00              LDR      r0,[r0,#0x20]
000100  2101              MOVS     r1,#1
000102  4308              ORRS     r0,r0,r1
000104  6821              LDR      r1,[r4,#0]
000106  6208              STR      r0,[r1,#0x20]
;;;1831               while (__DRV_ADC_GET_FLAG(mADC,ADC_FLAG_E1CNV) == 0x00);
000108  bf00              NOP      
                  |L36.266|
00010a  6820              LDR      r0,[r4,#0]
00010c  6800              LDR      r0,[r0,#0]
00010e  2108              MOVS     r1,#8
000110  4008              ANDS     r0,r0,r1
000112  08c0              LSRS     r0,r0,#3
000114  2800              CMP      r0,#0
000116  d0f8              BEQ      |L36.266|
;;;1832               __DRV_ADC_CLEAR_FLAG(mADC,(ADC_FLAG_E1CNV | ADC_FLAG_ESMP));
000118  200c              MOVS     r0,#0xc
00011a  6821              LDR      r1,[r4,#0]
00011c  6008              STR      r0,[r1,#0]
;;;1833               VRPV += MID_ADC_GetValue(mADC);
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       MID_ADC_GetValue
000124  9902              LDR      r1,[sp,#8]
000126  1840              ADDS     r0,r0,r1
000128  9002              STR      r0,[sp,#8]
00012a  1c70              ADDS     r0,r6,#1              ;1828
00012c  b2c6              UXTB     r6,r0                 ;1828
                  |L36.302|
00012e  2e0a              CMP      r6,#0xa               ;1828
000130  dbe4              BLT      |L36.252|
;;;1834           }
;;;1835           VRPV = VRPV / 10;
000132  210a              MOVS     r1,#0xa
000134  9802              LDR      r0,[sp,#8]
000136  f7fffffe          BL       __aeabi_idivmod
00013a  9002              STR      r0,[sp,#8]
;;;1836           
;;;1837           
;;;1838           //-------------------------------------------------
;;;1839           CaliV = (VRNV + VRPV) >> 1;
00013c  9902              LDR      r1,[sp,#8]
00013e  9801              LDR      r0,[sp,#4]
000140  1840              ADDS     r0,r0,r1
000142  1045              ASRS     r5,r0,#1
;;;1840           CaliV = CaliV - 2048;
000144  2001              MOVS     r0,#1
000146  02c0              LSLS     r0,r0,#11
000148  1a2d              SUBS     r5,r5,r0
;;;1841           CaliV = CaliV / 2;
00014a  4628              MOV      r0,r5
00014c  0fe9              LSRS     r1,r5,#31
00014e  1809              ADDS     r1,r1,r0
000150  104d              ASRS     r5,r1,#1
;;;1842           VRM = VRM + CaliV;
000152  197f              ADDS     r7,r7,r5
;;;1843           __DRV_CFG_WRITE_ADCREFMIDDLE(VRM);
000154  480a              LDR      r0,|L36.384|
000156  3038              ADDS     r0,r0,#0x38
000158  7087              STRB     r7,[r0,#2]
;;;1844                           
;;;1845           if (CaliV == 1) break;
00015a  2d01              CMP      r5,#1
00015c  d100              BNE      |L36.352|
00015e  e007              B        |L36.368|
                  |L36.352|
;;;1846           if (CaliV == 0) break;
000160  2d00              CMP      r5,#0
000162  d100              BNE      |L36.358|
000164  e004              B        |L36.368|
                  |L36.358|
;;;1847           if (CaliV == -1) break;
000166  1c68              ADDS     r0,r5,#1
000168  2800              CMP      r0,#0
00016a  d100              BNE      |L36.366|
00016c  e000              B        |L36.368|
                  |L36.366|
00016e  e74f              B        |L36.16|
                  |L36.368|
000170  bf00              NOP                            ;1845
;;;1848           
;;;1849       }
;;;1850           
;;;1851       // 
;;;1852       VRM = VRM + 1;
000172  1c7f              ADDS     r7,r7,#1
;;;1853       __DRV_CFG_WRITE_ADCREFMIDDLE(VRM);
000174  4802              LDR      r0,|L36.384|
000176  3038              ADDS     r0,r0,#0x38
000178  7087              STRB     r7,[r0,#2]
;;;1854   #endif
;;;1855       return MID_SUCCESS;
00017a  2000              MOVS     r0,#0
;;;1856   }
00017c  b005              ADD      sp,sp,#0x14
00017e  bdf0              POP      {r4-r7,pc}
;;;1857   
                          ENDP

                  |L36.384|
                          DCD      0x4ff0000c

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_ADC_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_ADC_MID_c_635859f1____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_ADC_MID_c_635859f1____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_ADC_MID_c_635859f1____REVSH|
#line 496
|__asm___18_MG32x02z_ADC_MID_c_635859f1____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
