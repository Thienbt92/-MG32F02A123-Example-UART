L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_TM_MID.c"
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_TM_MID.c
N *
N * @brief       This file provides firmware functions to manage the following
N *              functionalities of the TM peripheral:
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.07
N * @date        2020/07/03
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer
N *      The Demo software is provided "AS IS"  without any warranty, either
N *      expressed or implied, including, but not limited to, the implied warranties
N *      of merchantability and fitness for a particular purpose.  The author will
N *      not be liable for any special, incidental, consequential or indirect
N *      damages due to loss of data or any other reason.
N *      These statements agree with the world wide and local dictated laws about
N *      authorship and violence against these laws.
N ******************************************************************************
N ******************************************************************************
N */
N
N
N
N#include "MG32x02z_TM_MID.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_TM_MID.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_TM_MID.H
N *
N * @brief       This file provides firmware functions to manage the following
N *              functionalities of the TM peripheral:
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.06
N * @date        2021/01/27
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer
N *      The Demo software is provided "AS IS"  without any warranty, either
N *      expressed or implied, including, but not limited to, the implied warranties
N *      of merchantability and fitness for a particular purpose.  The author will
N *      not be liable for any special, incidental, consequential or indirect
N *      damages due to loss of data or any other reason.
N *      These statements agree with the world wide and local dictated laws about
N *      authorship and violence against these laws.
N ******************************************************************************
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_TM_MID_H
N
N/*!< _MG32x02z_TM_DRV_H */
N#define _MG32x02z_TM_MID_H
N
N#include "MG32x02z.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z.h
N *
N * @brief       MG32x02z Device Peripheral Access Layer Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_H
N#define _MG32x02z_H
N#define _MG32x02z_H_VER                             3.9     /*!< File Version */
N
N
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N *************************************************
N *  Chip definitions
N *************************************************
N */
N// Chip Generation
N#if defined(MG32F02A132) || defined(MG32F02A072) || defined(MA862)
X#if 1L || 0L || 0L
N  #define MG32_1ST
N#elif defined(MG32F02A032)
S  #define MG32_2ND
S#elif defined(MG32F02A128) || defined(MG32F02U128) || defined(MG32F02A064) || defined(MG32F02U064)
S  #define MG32_3RD
S#elif defined(MG32F02V032)
S  #define MG32_4TH
N#endif
N
N#if defined(MG32F02U128) || defined(MG32F02U064)
X#if 0L || 0L
S  #define USB_TYPE    1
N#else
N  #define USB_TYPE    0
N#endif
N    
N
N/**
N *************************************************
N *  ARM CPU Configuration Setting
N *************************************************
N */
N#define __CM0_REV                 0 /*!< Core Revision r0p0                             */
N#define __MPU_PRESENT             0 /*!< Chip do not provide MPU                       */
N#define __NVIC_PRIO_BITS          2 /*!< Chip uses 2 Bits for the Priority Levels      */
N#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used   */
N
N/**
N ******************************************************************************
N * @enum        IRQn
N *              Interrupt Number Definition
N ******************************************************************************
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers Definitions *****************************************/
N    NMI_IRQn                    = -14 , /*!<  ;Non Maskable Interrupt                               */
N    HardFault_IRQn              = -13 , /*!<  ;Cortex-M0 Hard Fault Interrupt                       */
N    SVC_IRQn                    = -5 ,  /*!<  ;Cortex-M0 SV Call Interrupt                          */
N    PendSV_IRQn                 = -2 ,  /*!<  ;Cortex-M0 Pend SV Interrupt                          */
N    SysTick_IRQn                = -1 ,  /*!<  ;Cortex-M0 System Tick Interrupt                      */
N/******  Peripheral Interrupt Numbers Definitions ***************************************************/
N    WWDT_IRQn                   =  0 ,  /*!<  ;Window Watchdog                                      */
N    SYS_IRQn                    =  1 ,  /*!<  ;System global Interrupt                              */
N    EXINT0_IRQn                 =  3 ,  /*!<  ;EXIC EXINT0 (PA)                                     */
N    EXINT1_IRQn                 =  4 ,  /*!<  ;EXIC EXINT1 (PB)                                     */
N    EXINT2_IRQn                 =  5 ,  /*!<  ;EXIC EXINT2 (PC)                                     */
N    EXINT3_IRQn                 =  6 ,  /*!<  ;EXIC EXINT3/EXINT4 (PD/PE)                           */
N    COMP_IRQn                   =  7 ,  /*!<  ;Analog Comparators global Interrupt                  */
N    DMA_IRQn                    =  8 ,  /*!<  ;DMA all channel global Interrupt                     */
N    ADC_IRQn                    =  10 , /*!<  ;ADC                                                  */
N    DAC_IRQn                    =  11 , /*!<  ;DAC                                                  */
N    TM0x_IRQn                   =  12 , /*!<  ;Timer TM0x global Interrupt                          */
N    TM10_IRQn                   =  13 , /*!<  ;Timer TM10                                           */
N    TM1x_IRQn                   =  14 , /*!<  ;Timer TM16 ... global Interrupt                      */
N    TM20_IRQn                   =  15 , /*!<  ;Timer TM20                                           */
N    TM2x_IRQn                   =  16 , /*!<  ;Timer TM26 ... global Interrupt                      */
N    TM3x_IRQn                   =  17 , /*!<  ;Timer TM3x global Interrupt                          */
N    URT0_IRQn                   =  20 , /*!<  ;UART URT0                                            */
N    URT123_IRQn                 =  21 , /*!<  ;UART URT1/2/3 global Interrupt                       */
N    URT4x_IRQn                  =  22 , /*!<  ;UART URT4/5/6/7 global Interrupt                     */
N    SPI0_IRQn                   =  24 , /*!<  ;SPI0                                                 */
N    I2C0_IRQn                   =  28 , /*!<  ;I2C0                                                 */
N    I2Cx_IRQn                   =  29 , /*!<  ;I2C1 ... global Interrupt                            */
N    USB_IRQn                    =  30 , /*!<  ;USB                                                  */
N    APX_IRQn                    =  31 , /*!<  ;APX                                                  */
N} IRQn_Type;                    /*!< Interrupt Number Definition */
N
N
N#include "core_cm0.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.8
N * @date     21. August 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.4
N * @date     23. July 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 4U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N 
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_FP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.2.1
N * @date     26. March 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
S#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RESERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  *(vectors + (int32_t)IRQn) = vector;                              /* use pointer arithmetic to access vector */
N  /* ARM Application Note 321 states that the M0 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  return *(vectors + (int32_t)IRQn);                                /* use pointer arithmetic to access vector */
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 107 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z.H" 2
N#include <stdint.h>
N
N/**
N *************************************************
N *  New type definitions
N *************************************************
N */
Ntypedef signed char boolean;		/*!< Boolean	*/
Ntypedef unsigned char byte;			/*!< Byte		*/
N//typedef signed char int8;
N//typedef signed char sint8;
N//typedef unsigned char uint8;
N//typedef signed short int16;
N//typedef signed short sint16;
N//typedef unsigned short uint16;
N//typedef signed int int16;
N//typedef signed int sint16;
N//typedef unsigned int uint16;
N//typedef signed long int32;
N//typedef signed long sint32;
N//typedef unsigned long uint32;
Ntypedef unsigned long long uint64;	/*!< Uint 64-bit	*/
Ntypedef float float32;				/*!< Float 32-bit	*/
Ntypedef double float64;				/*!< Float 64-bit	*/
N
N/**
N *************************************************
N *  @union		ctype
N *				Combined 32/16/8-bit type
N *************************************************
N */
Ntypedef union
N{								
N	__IO uint8_t    B[4];			/*!< Byte 8-bit 		*/
X	volatile uint8_t    B[4];			 
N	__IO uint16_t   H[2];			/*!< Half-Word 16-bit 	*/
X	volatile uint16_t   H[2];			 
N	__IO uint32_t   W;				/*!< Word 32-bit 		*/
X	volatile uint32_t   W;				 
N} ctype;
N
N
N/**
N *************************************************
N *  General definitions
N *************************************************
N */
N//#define     __I     volatile                /*!< defines 'read only' permissions		*/
N//#define     __O     volatile                /*!< defines 'write only' permissions		*/
N//#define     __IO    volatile                /*!< defines 'read / write' permissions	*/
N
N#define TRUE		1				/*!< True	*/
N#define FALSE		0				/*!< False	*/
N
N//#define ENABLE		1
N//#define DISABLE		0
N
N#define MASK8(val)  (((val) < 256) ? (val) : (val) < 65536 ? (val) >> 8 : (val) < 16777216 ?  (val) >> 16 : (val) >> 24)	/*!< Mask 8-bit		*/  
N#define MASK16(val)  (((val) < 65536) ? (val) : (val)>> 16) 																/*!< Mask 16-bit	*/
N
N/**
N ******************************************************************************
N * @enum        FunctionalState
N *              Enable/Disable
N ******************************************************************************
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;										/*!< Enable/Disable	*/
N/**
N ******************************************************************************
N * @enum        FlagStatus
N *              Clear/Se
N ******************************************************************************
N */
Ntypedef enum {CLR = 0, SET = !CLR} FlagStatus ,BitAction;											/*!< Clear/Set	*/
N/**
N ******************************************************************************
N * @enum        ITStatus
N *              None/Happened/Stable/Unstable
N ******************************************************************************
N */
Ntypedef enum {NONE = 0,  HAPPENED = !NONE, UNSTABLE = 0, STABLE = !UNSTABLE} ITStatus, CSCStatus;	/*!< None/Happened/Stable/Unstablee	*/       
N
N
N/**
N *************************************************
N *  Hardware Access
N *************************************************
N */
N 
N///**
N// * @brief  get register value
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// */
N//#define HW_ReadReg(_reg)             (_reg)											/*!< Hardware Read Register */
N
N///**
N// * @brief  set register value
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _value : definitions of register value, like MODULE_REGNAME_xyz
N// */
N//#define HW_WriteReg(_reg, _value)     _reg = (_value)								/*!< Hardware Write Register */
N
N///**
N// * @brief  set register bits value =1
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _mask : definitions of register mask value, like MODULE_REGNAME_mask
N// */
N//#define HW_SetBit(_reg, _mask)		HW_WriteReg(_reg, (HW_ReadReg(_reg) | (_mask))) /*!< Hardware Set Register Bit */
N
N///**
N// * @brief  set register bits value =0
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _mask : definitions of register mask value, like MODULE_REGNAME_mask
N// */
N//#define HW_ClrBit(_reg, _mask)		HW_WriteReg(_reg, (HW_ReadReg(_reg) & ~(_mask)))    /*!< Hardware Clear Register Bit */
N
N/**
N * @brief  get register bit value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N/**
N * @brief  clear register, value = 0
N * @param  REG : definitions of register name, like MODULE_REGNAME
N */
N#define CLEAR_REG(REG)        ((REG) = (0x0))                                       /*!< Hardware Clear Register */
N
N/**
N * @brief  set register value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  VAL : definitions of register value, like MODULE_REGNAME_xyz
N */
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))                                       /*!< Hardware Write Register */
N
N/**
N * @brief  get register value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N */
N#define READ_REG(REG)         ((REG))                                               /*!< Hardware Write Register */
N
N/**
N * @brief  set register bits value =1
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))                                      /*!< Hardware Set Register Bit */
N
N/**
N * @brief  set register bits value =0
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))                                     /*!< Hardware Clear Register Bit */
N
N/**
N * @brief  set register bits value =1
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  CLEARMASK : definitions of register mask value, like MODULE_REGNAME_mask
N * @param  SETMASK : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))  /*!< Hardware Register Modify */
N
N/**
N ******************************************************************************
N *
N *              Header Files Include
N *
N ******************************************************************************
N */
N//#include "MG32x02z__RegPointer.h"
N//#include "MG32x02z__RegAddress.h"
N//#include "MG32x02z_GPIO.h"
N//#include "MG32x02z_GPL.h"
N//#include "MG32x02z_DMA.h"
N//#include "MG32x02z_RST.h"
N//#include "MG32x02z_CSC.h"
N//#include "MG32x02z_PW.h"
N//#include "MG32x02z_SYS.h"
N//#include "MG32x02z_MEM.h"
N//#include "MG32x02z_EMB.h"
N//#include "MG32x02z_CFG.h"
N//#include "MG32x02z_EXIC.h"
N//#include "MG32x02z_I2C.h"
N//#include "MG32x02z_URT.h"
N//#include "MG32x02z_SPI.h"
N//#include "MG32x02z_TM.h"
N//#include "MG32x02z_ADC.h"
N//#include "MG32x02z_CMP.h"
N//#include "MG32x02z_DAC.h"
N//#include "MG32x02z_IWDT.h"
N//#include "MG32x02z_WWDT.h"
N//#include "MG32x02z_RTC.h"
N//#include "MG32x02z_APB.h"
N//#include "MG32x02z_CPU.h"
N
N#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) /* ARM Compiler V6 */
X#if 1L && (5060960 >= 6010050)  
S  #ifndef __weak
S    #define __weak  __attribute__((weak))
S  #endif
S  #ifndef __packed
S    #define __packed  __attribute__((packed))
S  #endif
S#elif defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#elif 0L && !1L  
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__ */
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) /* ARM Compiler V6 */
X#if 1L && (5060960 >= 6010050)  
S  #ifndef __ALIGN_BEGIN
S    #define __ALIGN_BEGIN
S  #endif
S  #ifndef __ALIGN_END
S    #define __ALIGN_END      __attribute__ ((aligned (4)))
S  #endif
S#elif defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#elif 0L && !1L  
S  #ifndef __ALIGN_END
S    #define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler V5*/
X    #if 1L       
N      #define __ALIGN_BEGIN    __align(4)  
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__ */
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)) || defined   (  __GNUC__  )
X#if 1L || (1L && (5060960 >= 6010050)) || 0L
N/* ARM V4/V5 and V6 & GNU Compiler
N   -------------------------------
N*/
N  #define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S  /* ICCARM Compiler
S     ---------------
S  */
S  #define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  // _MG32x02z_H
N
N/*----------------------------------------------------------------------------*/
N/*                           End of file MG32x02z.h                           */
N/*----------------------------------------------------------------------------*/
L 36 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_TM_MID.h" 2
N#include "MG32x02z_Common_MID.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_Common_MID.H" 1
N /**
N ******************************************************************************
N *
N * @file        MG32x02z_Common_MID.H
N * @brief       Header file of Common Configuration module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2019/10/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2019 megawin Technology Co., Ltd.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of megawin Technology Co., Ltd. nor the names of its
N *      contributors may be used to endorse or promote products derived from this
N *      software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SMID_L THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef _MG32x02z_COMMON_MID_H
N#define _MG32x02z_COMMON_MID_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 55 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_Common_MID.H" 2
N#include "MG32x02z.h"
N#include "MG32x02z_SYS.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_SYS.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_SYS.h
N *
N * @brief       MG32x02z SYS Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_SYS_H
N#define _MG32x02z_SYS_H
N#define _MG32x02z_SYS_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_SYS_H_VER)
S    #error "MG32x02z_SYS_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      SYS_Struct
N *              SYS  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x00]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] System interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  SYS interrupt enable register */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t MID           :32;    //[31..0] Chip manufacture identification code.
X            volatile const  uint32_t MID           :32;    
N        }MBIT;
N    }MID;                               /*!< MID        ~ Offset[0x0C]  SYS chip manufacture identification code */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  CH0_LAST      :1;     //[16] DMA Channel-0 last loop command
X            volatile uint8_t  CH0_LAST      :1;     
N                                        //0 = Not
N                                        //1 = Yes
N            __IO uint8_t  CH1_LAST      :1;     //[17] DMA Channel-1 last loop command
X            volatile uint8_t  CH1_LAST      :1;     
N                                        //0 = Not
N                                        //1 = Yes
N            __IO uint8_t  CH2_LAST      :1;     //[18] DMA Channel-2 last loop command
X            volatile uint8_t  CH2_LAST      :1;     
N                                        //0 = Not
N                                        //1 = Yes
N            __IO uint8_t  GPR           :5;     //[23..19] General purpose data register bits.
X            volatile uint8_t  GPR           :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  SYS System control register 0 */
N
N} SYS_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        SYS  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define SYS_Base                        ((uint32_t)0x4C030000)              /*!< System and Chip Control */
N#define SYS                             ((SYS_Struct*) SYS_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        SYS  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        SYS_INT  [register's definitions]
N *              Offset[0x04]  SYS interrupt enable register (0x4C030004)
N ******************************************************************************
N */
N///@{
N#define SYS_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SYS_INT */
N#define SYS_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define SYS_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SYS_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SYS_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SYS_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SYS_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SYS_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define SYS_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define SYS_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SYS_MID  [register's definitions]
N *              Offset[0x0C]  SYS chip manufacture identification code (0x4C03000C)
N ******************************************************************************
N */
N///@{
N#define SYS_MID_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SYS_MID */
N#define SYS_MID_MID_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define SYS_MID_MID_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define SYS_MID_MID_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define SYS_MID_MID_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SYS_CR0  [register's definitions]
N *              Offset[0x10]  SYS System control register 0 (0x4C030010)
N ******************************************************************************
N */
N///@{
N#define SYS_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SYS_CR0 */
N#define SYS_CR0_GPR_mask_w                          ((uint32_t)0x00F80000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_GPR_mask_h1                         ((uint16_t)0x00F8)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_GPR_mask_b2                         ((uint8_t )0xF8)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_GPR_shift_w                         (19)                    /*!< Bit Shift of 32bit */
N#define SYS_CR0_GPR_shift_h1                        (3)                     /*!< Bit Shift of 16bit */
N#define SYS_CR0_GPR_shift_b2                        (3)                     /*!< Bit Shift of 8bit */
N
N#define SYS_CR0_CH2_LAST_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_CH2_LAST_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_CH2_LAST_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_CH2_LAST_not_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Not of 32bit */
N#define SYS_CR0_CH2_LAST_not_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Not of 16bit */
N#define SYS_CR0_CH2_LAST_not_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Not of 8bit */
N#define SYS_CR0_CH2_LAST_yes_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Yes of 32bit */
N#define SYS_CR0_CH2_LAST_yes_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Yes of 16bit */
N#define SYS_CR0_CH2_LAST_yes_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Yes of 8bit */
N
N#define SYS_CR0_CH1_LAST_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_CH1_LAST_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_CH1_LAST_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_CH1_LAST_not_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Not of 32bit */
N#define SYS_CR0_CH1_LAST_not_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Not of 16bit */
N#define SYS_CR0_CH1_LAST_not_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Not of 8bit */
N#define SYS_CR0_CH1_LAST_yes_w                      ((uint32_t)0x00020000)  /*!< Bit Value =(1):Yes of 32bit */
N#define SYS_CR0_CH1_LAST_yes_h1                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Yes of 16bit */
N#define SYS_CR0_CH1_LAST_yes_b2                     ((uint8_t )0x02)        /*!< Bit Value =(1):Yes of 8bit */
N
N#define SYS_CR0_CH0_LAST_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_CH0_LAST_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_CH0_LAST_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_CH0_LAST_not_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Not of 32bit */
N#define SYS_CR0_CH0_LAST_not_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Not of 16bit */
N#define SYS_CR0_CH0_LAST_not_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Not of 8bit */
N#define SYS_CR0_CH0_LAST_yes_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Yes of 32bit */
N#define SYS_CR0_CH0_LAST_yes_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Yes of 16bit */
N#define SYS_CR0_CH0_LAST_yes_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Yes of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_SYS_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_SYS.h                         */
N/*----------------------------------------------------------------------------*/
L 57 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_Common_MID.H" 2
N#include "MG32x02z_CONF_MID.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_CONF_MID.h" 1
N /**
N ******************************************************************************
N *
N * @file        MG32x02z_CONF_MID.h
N * @brief       Header file of Configuration MID module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2019/10/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N * 
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2019 megawin Technology Co., Ltd.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of megawin Technology Co., Ltd. nor the names of its
N *      contributors may be used to endorse or promote products derived from this
N *      software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SMID_L THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef _MG32x02z_CONF_MID_H
N#define _MG32x02z_CONF_MID_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* ########################## XTAL/IHRCO Values adaptation ##################### */
N/**
N  * @brief Adjust the value of External Clock Input Speed (EXTCK) used in your application.
N  *        This value is used by the RCC MID_ module to compute the system frequency
N  *        (when EXTCK is used as system clock source, directly or through the PLL).  
N  */
N#if !defined  (EXTCK_VALUE) 
X#if !0L 
N  #define EXTCK_VALUE    ((uint32_t)12000000) /*!< Value of the External Input Clock Speed in Hz */
N#endif /* EXTCK_VALUE */
N
N/**
N  * @brief Adjust the value of External High Speed oscillator (XTAL) used in your application.
N  *        This value is used by the RCC MID_ module to compute the system frequency
N  *        (when XTAL is used as system clock source, directly or through the PLL).  
N  */
N#if !defined  (XTAL_VALUE) 
X#if !0L 
N  #define XTAL_VALUE    ((uint32_t)12000000) /*!< Value of the External oscillator in Hz */
N#endif /* XTAL_VALUE */
N
N/**
N  * @brief In the following line adjust the External High Speed oscillator (XTAL) Startup 
N  *        Timeout value 
N  */
N#if !defined  (XTAL_STARTUP_TIMEOUT)
X#if !0L
N  #define XTAL_STARTUP_TIMEOUT    ((uint32_t)100)   /*!< Time out for XTAL start up, in ms */
N#endif /* XTAL_STARTUP_TIMEOUT */
N
N/**
N  * @brief Internal High Speed oscillator (IHRCO) value.
N  *        This value is used by the RCC MID_ module to compute the system frequency
N  *        (when IHRCO is used as system clock source, directly or through the PLL). 
N  */
N#if !defined  (IHRCO_VALUE)
X#if !0L
N  #define IHRCO_VALUE    ((uint32_t)12000000) /*!< Value of the Internal oscillator in Hz*/
N#endif /* IHRCO_VALUE */
N
N/**
N  * @brief In the following line adjust the Internal High Speed oscillator (IHRCO) Startup 
N  *        Timeout value 
N  */
N#if !defined  (IHRCO_STARTUP_TIMEOUT) 
X#if !0L 
N #define IHRCO_STARTUP_TIMEOUT   ((uint32_t)5000) /*!< Time out for IHRCO start up */
N#endif /* IHRCO_STARTUP_TIMEOUT */  
N
N/**
N  * @brief Internal Low Speed oscillator (ILRCO) value.
N  */
N#if !defined  (ILRCO_VALUE) 
X#if !0L 
N #define ILRCO_VALUE  ((uint32_t)32000)    
N#endif /* ILRCO_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
N                                                   The real value may vary depending on the variations
N                                                   in voltage and temperature.  */
N
N/* Tip: To avoid modifying this file each time you need to use different XTAL,
N   ===  you can define the XTAL value in your toolchain compiler preprocessor. */
N
N/* ########################### System Configuration ######################### */
N/**
N  * @brief This is the MID_ system configuration section
N  */     
N#define  VDD_VALUE                    ((uint32_t)5000) /*!< Value of VDD in mv */           
N#define  TICK_INT_PRIORITY            ((uint32_t)0)    /*!< tick interrupt priority (lowest by default)  */            
N                                                       /*  Warning: Must be set to higher priority for MID_Delay()  */
N                                                       /*  and MID_GetTick() usage under interrupt context          */
N#define  USE_RTOS                       0              /*!< Application the RTOS */
N//#define  INSTRUCTION_CACHE_ENABLE     0
N//#define  DATA_CACHE_ENABLE            0
N/* ########################## Assert Selection ############################## */
N/**
N  * @brief Uncomment the line below to expanse the "assert_param" macro in the 
N  *        MID_ drivers code
N  */
N/* #define USE_FULL_ASSERT   1U */
N
N
N
N/* Includes ------------------------------------------------------------------*/
N
N
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function
S  *         which reports the name of the source file and the source
S  *         line number of the call that failed. 
S  *         If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((char *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(char* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */    
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MG32x02z_CONF_MID_H */
N
N/************** (C) COPYRIGHT megawin Technology Co., Ltd. *****END OF FILE****/
N
N
L 58 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_Common_MID.H" 2
N#include "MG32x02z_CORTEX_MID.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_CORTEX_MID.H" 1
N /**
N ******************************************************************************
N *
N * @file        MG32x02z_Cortex_MID.h
N * @brief       Header file of CORTEX MID module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2019/10/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2019 megawin Technology Co., Ltd.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of megawin Technology Co., Ltd. nor the names of its
N *      contributors may be used to endorse or promote products derived from this
N *      software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SMIDL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef _MG32x02z_cortex_MID_H
N#define _MG32x02z_cortex_MID_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MG32x02z_COMMON_MID.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_COMMON_MID.h" 1
N /**
N ******************************************************************************
N *
N * @file        MG32x02z_Common_MID.H
N * @brief       Header file of Common Configuration module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2019/10/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2019 megawin Technology Co., Ltd.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of megawin Technology Co., Ltd. nor the names of its
N *      contributors may be used to endorse or promote products derived from this
N *      software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SMID_L THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef _MG32x02z_COMMON_MID_H
S#define _MG32x02z_COMMON_MID_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include <stdio.h>
S#include "MG32x02z.h"
S#include "MG32x02z_SYS.h"
S#include "MG32x02z_CONF_MID.h"
S#include "MG32x02z_CORTEX_MID.H"
S
S/* Exported types ------------------------------------------------------------*/
S
S/** 
S  * @enum   MID_StatusTypeDef
S  * @brief  MID Status structures definition  
S  */  
Stypedef enum 
S{
S    MID_SUCCESS  = 0x00,    /*!< Success    */
S    MID_FAILURE  = 0x01,    /*!< Failure    */
S    MID_OK       = 0x00,    /*!< OK         */
S    MID_ERROR    = 0x01,    /*!< Error      */
S    MID_BUSY     = 0x02,    /*!< Busy       */
S    MID_TIMEOUT  = 0x03,    /*!< Timout     */
S}MID_StatusTypeDef;
S
S
S
S/** 
S  * @enum   MID_LockTypeDef
S  * @brief  MID Lock structures definition  
S  */
Stypedef enum 
S{
S    MID_UnLocked = 0x00,
S    MID_UNLOCKED = 0x00,
S    MID_Locked   = 0x01,
S    MID_LOCKED   = 0x01,
S}MID_LockTypeDef;
S
S
S
S
S#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))  /*!< MID Status param Check */
S
S
S/** 
S  * @enum   ErrorStatus
S  * @brief  MID Lock structures definition  
S  */
Stypedef enum
S{
S    ERROR = 0,
S    SUCCESS = !ERROR
S}   ErrorStatus;
S
S
S/** 
S  * @enum   MID_ProtectTypeDef
S  * @brief  MID Lock structures definition  
S  */
Stypedef enum
S{
S    RSTmodule    = (uint32_t)0x4C00000C,
S    CSCmodule    = (uint32_t)0x4C01000C,  
S    PWmodule     = (uint32_t)0x4C02000C,
S    MEMmodule    = (uint32_t)0x4D00000C,  
S    MEM2module   = (uint32_t)0x4D00000E,
S    CFGmodule    = (uint32_t)0x4FF0000C,
S    IWDTmodule   = (uint32_t)0x5D00000C,  
S    WWDTmodule   = (uint32_t)0x5D01000C,  
S    RTCmodule    = (uint32_t)0x5D04000C,
S}MID_ProtectTypeDef;          /*!< Definitions for protection function */
S
S
S
S/* Exported constants -------------------------------------------------------*/
S
S
S
S/* Exported macro ------------------------------------------------------------*/
S
S#define MID_MAX_DELAY               0xFFFFFFFFU      /*!< Max Delay Time */
S
S#define MID_IS_BIT_SET(REG, BIT)    (((REG) & (BIT)) == (BIT))
S#define MID_IS_BIT_CLR(REG, BIT)    (((REG) & (BIT)) == 0U)
S
S#define __MID_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \
S                        do{                                                      \
S                              (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); \
S                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \
S                          } while(0)
X#define __MID_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)                                       do{                                                                                    (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__);                               (__DMA_HANDLE__).Parent = (__HANDLE__);                                       } while(0)
S
S#define assert_param(expr) ((void)0U)               /*!< assert_param Not Check */
S        
S#define UNUSED(x) ((void)(x))                       /*!< UNUSED Function */
S
S/** @brief Reset the Handle's State field.
S  * @param "__HANDLE__" specifies the Peripheral Handle.
S  * @note  This macro can be used for the following purpose:
S  *          - When the Handle is declared as local variable; before passing it as parameter
S  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro
S  *            to set to 0 the Handle's "State" field.
S  *            Otherwise, "State" field may have any random value and the first time the function
S  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
S  *            (i.e. HAL_PPP_MspInit() will not be executed).
S  *          - When there is a need to reconfigure the low level hardware: instead of calling
S  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
S  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
S  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
S  * @retval None
S  */
S#define __MID_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0)
S
S#if (USE_RTOS == 1)
S  #error " USE_RTOS should be 0 in the current MID release "
S#else
S    #define __MID_LOCK(__HANDLE__)                                             \
S                                    do{                                        \
S                                        if((__HANDLE__)->Lock == MID_Locked)   \
S                                        {                                      \
S                                           return MID_BUSY;                    \
S                                        }                                      \
S                                        else                                   \
S                                        {                                      \
S                                           (__HANDLE__)->Lock = MID_Locked;    \
S                                        }                                      \
S                                      }while (0)  /*!< Module Lcok */
X    #define __MID_LOCK(__HANDLE__)                                                                                 do{                                                                                if((__HANDLE__)->Lock == MID_Locked)                                           {                                                                                 return MID_BUSY;                                                            }                                                                              else                                                                           {                                                                                 (__HANDLE__)->Lock = MID_Locked;                                            }                                                                            }while (0)   
S
S
S    #define __MID_UNLOCK(__HANDLE__)                                            \
S                                      do{                                       \
S                                          (__HANDLE__)->Lock = MID_UnLocked;    \
S                                        }while (0)  /*!< Module UnLcok */
X    #define __MID_UNLOCK(__HANDLE__)                                                                                  do{                                                                                 (__HANDLE__)->Lock = MID_UnLocked;                                            }while (0)   
S#endif /* USE_RTOS */
S
S#define __MID_UnProtectModule(__MODULE__)   ((__MODULE__)->Instance->KEY.H[0] = 0xA217U)        /*!< Module Register UnProtect */
S#define __MID_ProtectModule(__MODULE__)    ((__MODULE__)->Instance->KEY.H[0] = 0U)              /*!< Module Register Protect */
S
S/* Exported functions -------------------------------------------------------*/
S
S/** @name MID_Exported_Functions
S  * @{
S  */
S
S/** @name MID_Exported_Functions_Group1
S  * @{
S  */
S/* Initialization and de-initialization functions  ******************************/
SMID_StatusTypeDef MID_Init(void);
SMID_StatusTypeDef MID_DeInit(void);
Svoid MID_MspInit(void);
Svoid MID_MspDeInit(void);
SMID_StatusTypeDef MID_InitTick (uint32_t TickPriority);
S/**
S  * @}
S  */
S
S/** @name MID_Exported_Functions_Group2
S  * @{
S  */
S
S/* Peripheral Control functions  ************************************************/
Svoid MID_IncTick(void);
Svoid MID_ClearTick(void);
Svoid MID_Delay(__IO uint32_t Delay);
Suint32_t MID_GetTick(void);
Svoid MID_SuspendTick(void);
Svoid MID_ResumeTick(void);
SMID_StatusTypeDef MID_ProtectModuleReg(MID_ProtectTypeDef Module);
SMID_StatusTypeDef MID_UnProtectModuleReg(MID_ProtectTypeDef Module);
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __MG32x02z_MID_COMMON */
N
N
N
N/************** (C) COPYRIGHT megawin Technology Co., Ltd. *****END OF FILE****/
N
N
L 55 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_CORTEX_MID.H" 2
N
N/** @addtogroup MG32x02z_Driver_MID
N  * @{
N  */
N
N/** @addtogroup CORTEX CORTEX
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
N  * @{
N  */
N  
N/** @defgroup CORTEX_SysTick_clock_source CORTEX SysTick clock source
N  * @{
N  */
N#define SYSTICK_CLKSOURCE_HCLK_DIV8    (0x00000000U)        /*!< Systick Clocl Source from HCLK DIV8 */
N#define SYSTICK_CLKSOURCE_HCLK         (0x00000004U)        /*!< Systick Clocl Source from HCLK */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Exported Macros -----------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CORTEX_Exported_Functions CORTEX Exported Functions
N  * @{
N  */
N/** @addtogroup CORTEX_Exported_Functions_Group1 Initialization and de-initialization functions 
N *  @brief    Initialization and Configuration functions
N * @{
N */
N/* Initialization and de-initialization functions *******************************/
Nvoid MID_NVIC_SetPriority(IRQn_Type IRQn,uint32_t PreemptPriority, uint32_t SubPriority);
Nvoid MID_NVIC_EnableIRQ(IRQn_Type IRQn);
Nvoid MID_NVIC_DisableIRQ(IRQn_Type IRQn);
Nvoid MID_NVIC_SystemReset(void);
Nuint32_t MID_SYSTICK_Config(uint32_t TicksNumb);
N/**
N  * @}
N  */
N
N/** @addtogroup CORTEX_Exported_Functions_Group2 Peripheral Control functions 
N *  @brief   Cortex control functions
N * @{
N */
N 
N/* Peripheral Control functions *************************************************/
Nuint32_t MID_NVIC_GetPriority(IRQn_Type IRQn);
Nuint32_t MID_NVIC_GetPendingIRQ(IRQn_Type IRQn);
Nvoid MID_NVIC_SetPendingIRQ(IRQn_Type IRQn);
Nvoid MID_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
Nvoid MID_SYSTICK_EnableIRQ(void);
Nvoid MID_SYSTICK_DisableIRQ(void);
Nuint32_t MID_SYSTICK_GetCurrentValue(void);
Nvoid MID_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
Nvoid MID_SYSTICK_IRQHandler(void);
Nvoid MID_SYSTICK_Callback(void);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Private types -------------------------------------------------------------*/ 
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CORTEX_Private_Macros CORTEX Private Macros
N  * @{
N  */
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x4) /*!< NVIC PRIORITY Level Check*/
N
N#define IS_NVIC_DEVICE_IRQ(IRQ)                ((IRQ) >= 0x00)    /*!< NVIC Device IRQ Number Check */
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || \
N                                      ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8)) /*!< SYSTICK Clock Source Check */
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) ||                                       ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))  
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MG32x02z_cortex_MID_H */
N 
N
N/************** (C) COPYRIGHT megawin Technology Co., Ltd. *****END OF FILE****/
N
N
L 59 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_Common_MID.H" 2
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @enum   MID_StatusTypeDef
N  * @brief  MID Status structures definition  
N  */  
Ntypedef enum 
N{
N    MID_SUCCESS  = 0x00,    /*!< Success    */
N    MID_FAILURE  = 0x01,    /*!< Failure    */
N    MID_OK       = 0x00,    /*!< OK         */
N    MID_ERROR    = 0x01,    /*!< Error      */
N    MID_BUSY     = 0x02,    /*!< Busy       */
N    MID_TIMEOUT  = 0x03,    /*!< Timout     */
N}MID_StatusTypeDef;
N
N
N
N/** 
N  * @enum   MID_LockTypeDef
N  * @brief  MID Lock structures definition  
N  */
Ntypedef enum 
N{
N    MID_UnLocked = 0x00,
N    MID_UNLOCKED = 0x00,
N    MID_Locked   = 0x01,
N    MID_LOCKED   = 0x01,
N}MID_LockTypeDef;
N
N
N
N
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))  /*!< MID Status param Check */
N
N
N/** 
N  * @enum   ErrorStatus
N  * @brief  MID Lock structures definition  
N  */
Ntypedef enum
N{
N    ERROR = 0,
N    SUCCESS = !ERROR
N}   ErrorStatus;
N
N
N/** 
N  * @enum   MID_ProtectTypeDef
N  * @brief  MID Lock structures definition  
N  */
Ntypedef enum
N{
N    RSTmodule    = (uint32_t)0x4C00000C,
N    CSCmodule    = (uint32_t)0x4C01000C,  
N    PWmodule     = (uint32_t)0x4C02000C,
N    MEMmodule    = (uint32_t)0x4D00000C,  
N    MEM2module   = (uint32_t)0x4D00000E,
N    CFGmodule    = (uint32_t)0x4FF0000C,
N    IWDTmodule   = (uint32_t)0x5D00000C,  
N    WWDTmodule   = (uint32_t)0x5D01000C,  
N    RTCmodule    = (uint32_t)0x5D04000C,
N}MID_ProtectTypeDef;          /*!< Definitions for protection function */
N
N
N
N/* Exported constants -------------------------------------------------------*/
N
N
N
N/* Exported macro ------------------------------------------------------------*/
N
N#define MID_MAX_DELAY               0xFFFFFFFFU      /*!< Max Delay Time */
N
N#define MID_IS_BIT_SET(REG, BIT)    (((REG) & (BIT)) == (BIT))
N#define MID_IS_BIT_CLR(REG, BIT)    (((REG) & (BIT)) == 0U)
N
N#define __MID_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \
N                        do{                                                      \
N                              (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); \
N                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \
N                          } while(0)
X#define __MID_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)                                       do{                                                                                    (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__);                               (__DMA_HANDLE__).Parent = (__HANDLE__);                                       } while(0)
N
N#define assert_param(expr) ((void)0U)               /*!< assert_param Not Check */
N        
N#define UNUSED(x) ((void)(x))                       /*!< UNUSED Function */
N
N/** @brief Reset the Handle's State field.
N  * @param "__HANDLE__" specifies the Peripheral Handle.
N  * @note  This macro can be used for the following purpose:
N  *          - When the Handle is declared as local variable; before passing it as parameter
N  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro
N  *            to set to 0 the Handle's "State" field.
N  *            Otherwise, "State" field may have any random value and the first time the function
N  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
N  *            (i.e. HAL_PPP_MspInit() will not be executed).
N  *          - When there is a need to reconfigure the low level hardware: instead of calling
N  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
N  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
N  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
N  * @retval None
N  */
N#define __MID_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0)
N
N#if (USE_RTOS == 1)
X#if (0 == 1)
S  #error " USE_RTOS should be 0 in the current MID release "
N#else
N    #define __MID_LOCK(__HANDLE__)                                             \
N                                    do{                                        \
N                                        if((__HANDLE__)->Lock == MID_Locked)   \
N                                        {                                      \
N                                           return MID_BUSY;                    \
N                                        }                                      \
N                                        else                                   \
N                                        {                                      \
N                                           (__HANDLE__)->Lock = MID_Locked;    \
N                                        }                                      \
N                                      }while (0)  /*!< Module Lcok */
X    #define __MID_LOCK(__HANDLE__)                                                                                 do{                                                                                if((__HANDLE__)->Lock == MID_Locked)                                           {                                                                                 return MID_BUSY;                                                            }                                                                              else                                                                           {                                                                                 (__HANDLE__)->Lock = MID_Locked;                                            }                                                                            }while (0)   
N
N
N    #define __MID_UNLOCK(__HANDLE__)                                            \
N                                      do{                                       \
N                                          (__HANDLE__)->Lock = MID_UnLocked;    \
N                                        }while (0)  /*!< Module UnLcok */
X    #define __MID_UNLOCK(__HANDLE__)                                                                                  do{                                                                                 (__HANDLE__)->Lock = MID_UnLocked;                                            }while (0)   
N#endif /* USE_RTOS */
N
N#define __MID_UnProtectModule(__MODULE__)   ((__MODULE__)->Instance->KEY.H[0] = 0xA217U)        /*!< Module Register UnProtect */
N#define __MID_ProtectModule(__MODULE__)    ((__MODULE__)->Instance->KEY.H[0] = 0U)              /*!< Module Register Protect */
N
N/* Exported functions -------------------------------------------------------*/
N
N/** @name MID_Exported_Functions
N  * @{
N  */
N
N/** @name MID_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ******************************/
NMID_StatusTypeDef MID_Init(void);
NMID_StatusTypeDef MID_DeInit(void);
Nvoid MID_MspInit(void);
Nvoid MID_MspDeInit(void);
NMID_StatusTypeDef MID_InitTick (uint32_t TickPriority);
N/**
N  * @}
N  */
N
N/** @name MID_Exported_Functions_Group2
N  * @{
N  */
N
N/* Peripheral Control functions  ************************************************/
Nvoid MID_IncTick(void);
Nvoid MID_ClearTick(void);
Nvoid MID_Delay(__IO uint32_t Delay);
Xvoid MID_Delay(volatile uint32_t Delay);
Nuint32_t MID_GetTick(void);
Nvoid MID_SuspendTick(void);
Nvoid MID_ResumeTick(void);
NMID_StatusTypeDef MID_ProtectModuleReg(MID_ProtectTypeDef Module);
NMID_StatusTypeDef MID_UnProtectModuleReg(MID_ProtectTypeDef Module);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MG32x02z_MID_COMMON */
N
N
N
N/************** (C) COPYRIGHT megawin Technology Co., Ltd. *****END OF FILE****/
N
N
L 37 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_TM_MID.h" 2
N#include "MG32x02z_TM.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_TM.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_TM.h
N *
N * @brief       MG32x02z TM Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_TM_H
N#define _MG32x02z_TM_H
N#define _MG32x02z_TM_H_VER                          3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_TM_H_VER)
S    #error "MG32x02z_TM_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      TM_Struct
N *              TM  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  DIRF          :1;     //[0] Main Timer up/down counting flag.
X            volatile const  uint8_t  DIRF          :1;     
N                                        //0 = Up counting
N                                        //1 = Down counting
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKF           :1;     //[2] Timer break input flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  BKF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  EXF           :1;     //[3] Timer external trigger flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  EXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TOF           :1;     //[4] Main Timer overflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TOF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TOF2          :1;     //[5] 2nd Timer overflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TOF2          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TUF           :1;     //[6] Main Timer underflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TUF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TUF2          :1;     //[7] 2nd Timer underflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TUF2          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF0A          :1;     //[8] Timer IC0 rising edge flag/OC0 event main flag
X            volatile uint8_t  CF0A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF1A          :1;     //[9] Timer IC1 rising edge flag/OC1 event main flag
X            volatile uint8_t  CF1A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF2A          :1;     //[10] Timer IC2 rising edge flag/OC2 event main flag
X            volatile uint8_t  CF2A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF3A          :1;     //[11] Timer IC3 rising edge flag/OC3 event main flag
X            volatile uint8_t  CF3A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF0B          :1;     //[12] Timer IC0 falling edge flag/OC0 event sub flag
X            volatile uint8_t  CF0B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF1B          :1;     //[13] Timer IC1 falling edge flag/OC1 event sub flag
X            volatile uint8_t  CF1B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF2B          :1;     //[14] Timer IC2 falling edge flag/OC2 event sub flag
X            volatile uint8_t  CF2B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF3B          :1;     //[15] Timer IC3 falling edge flag/OC3 event sub flag
X            volatile uint8_t  CF3B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  DIRCF         :1;     //[16] Main Timer up/down counting direction change flag.
X            volatile uint8_t  DIRCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IDXF          :1;     //[18] Main Timer QEI external index signal input active detect and internal timer reset fla
X            volatile uint8_t  IDXF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  QPEF          :1;     //[19] Main Timer QEI phase state transition error detect flag.
X            volatile uint8_t  QPEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  TM Timer status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] Timer interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKIE          :1;     //[2] Timer break input interrupt enable.
X            volatile uint8_t  BKIE          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EXIE          :1;     //[3] Timer external trigger interrupt enable.
X            volatile uint8_t  EXIE          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TIE           :1;     //[4] Timer overflow/underflow interrupt enable.
X            volatile uint8_t  TIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TIE2          :1;     //[5] 2nd Timer overflow/underflow interrupt enable.
X            volatile uint8_t  TIE2          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CC0_IE        :1;     //[8] Timer IC0/OC0 interrupt enable.
X            volatile uint8_t  CC0_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CC1_IE        :1;     //[9] Timer IC1/OC1 interrupt enable.
X            volatile uint8_t  CC1_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CC2_IE        :1;     //[10] Timer IC2/OC2 interrupt enable.
X            volatile uint8_t  CC2_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CC3_IE        :1;     //[11] Timer IC3/OC3 interrupt enable.
X            volatile uint8_t  CC3_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DIRC_IE       :1;     //[16] Main Timer up/down counting direction change interrupt enable.
X            volatile uint8_t  DIRC_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IDX_IE        :1;     //[18] Main Timer QEI external index signal input active detect interrupt enable.
X            volatile uint8_t  IDX_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  QPE_IE        :1;     //[19] Main Timer QEI phase state transition error detect interrupt enable.
X            volatile uint8_t  QPE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  TM Timer interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :3;     //[2..0] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CKE_SEL       :2;     //[5..4] Timer internal clock CK_EXT source select.
X            volatile uint8_t  CKE_SEL       :2;     
N                                        //0x0 = ETR (CK_ETR)
N                                        //0x1 = ITR (CK_ITR)
N                                        //0x2 = IN0 (TM_IN0)
N                                        //0x3 = IN1 (TM_IN1)
N            __IO uint8_t  CKS_SEL       :1;     //[6] Counter/Timer CK_TC clock source select.
X            volatile uint8_t  CKS_SEL       :1;     
N                                        //0 = CK_INT
N                                        //1 = CK_EXT
N            __IO uint8_t  CKS2_SEL      :1;     //[7] Counter/Timer CK_TC2 clock source select.
X            volatile uint8_t  CKS2_SEL      :1;     
N                                        //0 = CK_INT
N                                        //1 = CK_EXT
N            __IO uint8_t  CKI_SEL       :2;     //[9..8] Timer input clock CK_TM source select.
X            volatile uint8_t  CKI_SEL       :2;     
N                                        //0x0 = PROC : CK_TM_PR process clock from CSC
N                                        //0x1 = Reserved
N                                        //0x2 = CK_LS
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CKI_DIV       :2;     //[13..12] Timer internal clock CK_TM_INT input divider.
X            volatile uint8_t  CKI_DIV       :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  DTG_DIV       :2;     //[17..16] Timer internal dead time clock CK_DTG divider.
X            volatile uint8_t  DTG_DIV       :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  TM Timer clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TRGI_MDS      :3;     //[2..0] Timer trigger input mode select
X            volatile uint8_t  TRGI_MDS      :3;     
N                                        //0x0 = No operation
N                                        //0x1 = Trigger-R (TRGI rising)
N                                        //0x2 = Reset-R (TRGI rising)
N                                        //0x3 = Gate-H (TRGI high)
N                                        //0x4 = Reset (TRGI dual edge)
N                                        //0x5 = Trigger-F (TRGI falling)
N                                        //0x6 = Reset-F (TRGI falling)
N                                        //0x7 = Gate-L (TRGI low)
N            __IO uint8_t  TRGI2_MDS     :3;     //[5..3] 2nd Timer trigger input mode select
X            volatile uint8_t  TRGI2_MDS     :3;     
N                                        //0x0 = No operation
N                                        //0x1 = Trigger-R (TRGI rising)
N                                        //0x2 = Reset-R (TRGI rising)
N                                        //0x3 = Gate-H (TRGI high)
N                                        //0x4 = Reset (TRGI dual edge)
N                                        //0x5 = Trigger-F (TRGI falling)
N                                        //0x6 = Reset-F (TRGI falling)
N                                        //0x7 = Gate-L (TRGI low)
N            __IO uint8_t  TRG_MUX       :2;     //[7..6] Timer trigger source TRGI select.
X            volatile uint8_t  TRG_MUX       :2;     
N                                        //0x0 = ETR (CK_ETR)
N                                        //0x1 = ITR (CK_ITR)
N                                        //0x2 = IN0 (TM_IN0)
N                                        //0x3 = IN1 (TM_IN1)
N            __IO uint8_t  ITR_MUX       :3;     //[10..8] Timer internal trigger source select
X            volatile uint8_t  ITR_MUX       :3;     
N                                        //0x0 = ITR0 (TM_ITR0)
N                                        //0x1 = ITR1 (TM_ITR1)
N                                        //0x2 = ITR2 (TM_ITR2)
N                                        //0x3 = ITR3 (TM_ITR3)
N                                        //0x4 = ITR4 (TM_ITR4)
N                                        //0x5 = ITR5 (TM_ITR5)
N                                        //0x6 = ITR6 (TM_ITR6)
N                                        //0x7 = ITR7 (TM_ITR7)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TRGO_MDS      :4;     //[15..12] Timer trigger output mode select
X            volatile uint8_t  TRGO_MDS      :4;     
N                                        //0x0 = RST : TM_RST (Main Timer Reset)
N                                        //0x1 = EN : TM_EN (Main Timer Enable)
N                                        //0x2 = UEV : TM_UEV (Main Timer Update event)
N                                        //0x3 = TOF : TM_TOF (Main Timer overflow)
N                                        //0x4 = TUF : TM_TUF (Main Timer underflow)
N                                        //0x5 = EN2 : TM_EN2 (Timer-2 Enable)
N                                        //0x6 = TOF2 :TM_TOF2 (Timer-2 overflow)
N                                        //0x7 = DIR : TM_DIR (Main Timer direction event)
N                                        //0x8 = UEV2 : TM_UEV2 (Timer-2 Update event)
N                                        //0x9 = SW : TM_TRGO_SW (software control bit)
N                                        //0xA = OS0 : TM_OS0 (channel-0 output state signal)
N                                        //0xB = OS1 : TM_OS1 (channel-1 output state signal)
N                                        //0xC = OS2 : TM_OS2 (channel-2 output state signal)
N                                        //0xD = OS3 : TM_OS3 (channel-3 output state signal)
N                                        //0xE = TRGI : TM_TRGI (internal TRGI signal)
N                                        //0xF = POE : TM_POE (Output enable register preload signal)
N            __IO uint8_t  QEI_MDS       :3;     //[18..16] Main Timer quadrature encoder interface
X            volatile uint8_t  QEI_MDS       :3;     
N                                        //0x0 = No operation (up/down control by TM_DIR)
N                                        //0x1 = IN0POS : TM_IN0 positive (high level up count, low level down count)
N                                        //0x2 = IN0NEG : TM_IN0 negative (low level up count, high level down count)
N                                        //0x3 = Reserved
N                                        //0x4 = Reserved
N                                        //0x5 = BOTH : Both TM_IN0 and TM_IN1 edge
N            __IO uint8_t  IDX_EN        :1;     //[19] Main Timer QEI external index signal input enable
X            volatile uint8_t  IDX_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IDX_MDS       :2;     //[21..20] Main Timer QEI external index signal input reset timer transition state select.
X            volatile uint8_t  IDX_MDS       :2;     
N                                        //0x0 = 1T2 : State change between 1 and 2
N                                        //0x1 = 2T3 : State change between 2 and 3
N                                        //0x2 = 3T4 : State change between 3 and 4
N                                        //0x3 = 4T1 : State change between 4 and 1
N            __IO uint8_t  UEV_SEL       :2;     //[23..22] Timer UEV output select bits for TM_TRGO
X            volatile uint8_t  UEV_SEL       :2;     
N                                        //0x0 = All : output all UEV pulses
N                                        //0x1 = TOF : output timer overflow pulses
N                                        //0x2 = UDF : output timer underflow pulses
N                                        //0x3 = Reserved
N            __IO uint8_t  TRGO_SW       :1;     //[24] Timer TRGO software control data bit.
X            volatile uint8_t  TRGO_SW       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  TRGO_INV      :1;     //[25] Timer TRGO output inverse enable bit.
X            volatile uint8_t  TRGO_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  RST_SW        :1;     //[28] Timer reset software enable bit.
X            volatile uint8_t  RST_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RST2_SW       :1;     //[29] 2nd Timer reset software enable bit.
X            volatile uint8_t  RST2_SW       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  GT_SW         :1;     //[30] Timer clock gating software enable bit.
X            volatile uint8_t  GT_SW         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  GT2_SW        :1;     //[31] 2nd Timer clock gating software enable bit.
X            volatile uint8_t  GT2_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }TRG;                               /*!< TRG        ~ Offset[0x0C]  TM Timer trigger control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] Main Timer/Counter enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EN2           :1;     //[1] 2nd Timer/Counter enable bit.
X            volatile uint8_t  EN2           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MDS           :2;     //[5..4] Timer operation mode select
X            volatile uint8_t  MDS           :2;     
N                                        //0x0 = Cascade : 16-bit counter with 16-bit prescaler  Mode
N                                        //0x1 = Separate : Separated two 16-bit counters Mode
N                                        //0x2 = Full-Counter : 32-bit counter Mode
N                                        //0x3 = Reserved
N            __IO uint8_t  DIR           :1;     //[6] Main Timer counting direction bit
X            volatile uint8_t  DIR           :1;     
N                                        //0 = Up (Up Counting)
N                                        //1 = Down (Down Counting)
N            __IO uint8_t  DIR2          :1;     //[7] 2nd Timer counting direction bit.
X            volatile uint8_t  DIR2          :1;     
N                                        //0 = Up (Up Counting)
N                                        //1 = Down (Down Counting)
N            __IO uint8_t  ASTOP_EN      :1;     //[8] Timer auto stop mode enable
X            volatile uint8_t  ASTOP_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  EX_EN         :1;     //[10] Timer external trigger event enable.
X            volatile uint8_t  EX_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EX_INV        :1;     //[11] Timer external trigger input inverted enable.
X            volatile uint8_t  EX_INV        :1;     
N                                        //0 = Normal
N                                        //1 = Inverted
N            __IO uint8_t  UEV_DIS       :1;     //[12] Update event generation disable for main Timer
X            volatile uint8_t  UEV_DIS       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  DIR_INV       :1;     //[13] Main Timer counting direction inverted enable.
X            volatile uint8_t  DIR_INV       :1;     
N                                        //0 = Normal
N                                        //1 = Inverted
N            __IO uint8_t  USW_EN        :1;     //[14] Timer software update event generation enable.  (automatically clear by hardware)
X            volatile uint8_t  USW_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  UEX_EN        :1;     //[15] Timer external trigger update event enable.
X            volatile uint8_t  UEX_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  TM Timer control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OVR0_MDS      :1;     //[0] Timer channel 0 capture data buffer overrun mode select
X            volatile uint8_t  OVR0_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __IO uint8_t  OVR1_MDS      :1;     //[1] Timer channel 1 capture data buffer overrun mode select
X            volatile uint8_t  OVR1_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __IO uint8_t  OVR2_MDS      :1;     //[2] Timer channel 2 capture data buffer overrun mode select
X            volatile uint8_t  OVR2_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __IO uint8_t  OVR3_MDS      :1;     //[3] Timer channel 3 capture data buffer overrun mode select
X            volatile uint8_t  OVR3_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CC0A_SEN      :1;     //[8] Timer channel 0 software IC/OC event-A generation enable
X            volatile uint8_t  CC0A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC1A_SEN      :1;     //[9] Timer channel 1 software IC/OC event-A generation enable
X            volatile uint8_t  CC1A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC2A_SEN      :1;     //[10] Timer channel 2 software IC/OC event-A generation enable
X            volatile uint8_t  CC2A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC3A_SEN      :1;     //[11] Timer channel 3 software IC/OC event-A generation enable
X            volatile uint8_t  CC3A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC0B_SEN      :1;     //[12] Timer channel 0 software IC/OC event-B generation enable
X            volatile uint8_t  CC0B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC1B_SEN      :1;     //[13] Timer channel 1 software IC/OC event-B generation enable
X            volatile uint8_t  CC1B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC2B_SEN      :1;     //[14] Timer channel 2 software IC/OC event-B generation enable
X            volatile uint8_t  CC2B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC3B_SEN      :1;     //[15] Timer channel 3 software IC/OC event-B generation enable
X            volatile uint8_t  CC3B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  TM Timer control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CKO_EN        :1;     //[0] Timer overflow as CKO output enable.
X            volatile uint8_t  CKO_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CKO_SEL       :1;     //[1] Timer overflow as CKO output source select.
X            volatile uint8_t  CKO_SEL       :1;     
N                                        //0 = 2nd : 2nd Timer overflow
N                                        //1 = Main : Main Timer overflow
N            __IO uint8_t  CKO_STA       :1;     //[2] Timer CKO output signal initial state
X            volatile uint8_t  CKO_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  CKO_LCK       :1;     //[3] TM_CKO_STA  register write access protected control
X            volatile uint8_t  CKO_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CKO;                               /*!< CKO        ~ Offset[0x18]  TM Timer CKO control register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x1C]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CNT           :16;    //[15..0] Main timer/counter register.
X            volatile uint16_t CNT           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x20]  TM Timer main counter register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t ARR           :16;    //[15..0] Main timer/counter auto-reload value register.
X            volatile uint16_t ARR           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }ARR;                               /*!< ARR        ~ Offset[0x24]  TM Timer main counter auto-reload value register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t PSCNT         :16;    //[15..0] Timer prescaler or 2nd  timer/counter register
X            volatile uint16_t PSCNT         :16;    
N            __I  uint16_t CNTA          :16;    //[31..16] Main timer/counter alias register
X            volatile const  uint16_t CNTA          :16;    
N        }MBIT;
N    }PSCNT;                             /*!< PSCNT      ~ Offset[0x28]  TM Timer prescaler register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t PSARR         :16;    //[15..0] Timer prescaler or 2nd timer/counter auto-reload value register
X            volatile uint16_t PSARR         :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PSARR;                             /*!< PSARR      ~ Offset[0x2C]  TM Timer prescaler auto-reload register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CC0_MDS       :3;     //[2..0] Timer channel 0 capture and compare mode select.
X            volatile uint8_t  CC0_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N                                        //0x6 = 16bit_PWM_DTG (16bit PWM with DTG)
N                                        //0x7 = 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CC1_MDS       :3;     //[6..4] Timer channel 1 capture and compare mode select. 
X            volatile uint8_t  CC1_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N                                        //0x6 = 16bit_PWM_DTG (16bit PWM with DTG)
N                                        //0x7 = 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CC2_MDS       :3;     //[10..8] Timer channel 2 capture and compare mode select. 
X            volatile uint8_t  CC2_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N                                        //0x6 = 16bit_PWM_DTG (16bit PWM with DTG)
N                                        //0x7 = 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CC3_MDS       :3;     //[14..12] Timer channel 3 capture and compare mode select. 
X            volatile uint8_t  CC3_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC_LCK        :1;     //[16] Timer output compare reload function lock enable bit for all channel
X            volatile uint8_t  OC_LCK        :1;     
N                                        //0 = un-Locked : enable unlocked
N                                        //1 = Locked : enable locked
N            __I  uint8_t                :6;     //[22..17] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  DMA_OMDS      :1;     //[23] Timer output DMA request mode select
X            volatile uint8_t  DMA_OMDS      :1;     
N                                        //0 = UEV : UEV update event only
N                                        //1 = ITR : both UEV and ITR
N            __IO uint8_t  DMA_CC0E      :1;     //[24] Direct memory access enable for OC0.
X            volatile uint8_t  DMA_CC0E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_CC1E      :1;     //[25] Direct memory access enable for OC1.
X            volatile uint8_t  DMA_CC1E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_CC2E      :1;     //[26] Direct memory access enable for OC2.
X            volatile uint8_t  DMA_CC2E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_CC3E      :1;     //[27] Direct memory access enable for IC3.
X            volatile uint8_t  DMA_CC3E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CCMDS;                             /*!< CCMDS      ~ Offset[0x30]  TM Timer capture and compare mode select register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IC0_MUX       :2;     //[1..0] Timer channel 0 input Mux select for input capture.
X            volatile uint8_t  IC0_MUX       :2;     
N                                        //0x0 = IC00 : TM_IC0
N                                        //0x1 = IC01 : TM_ITR
N                                        //0x2 = IC02 : CMP0_OUT
N                                        //0x3 = IC03 : TM_XOR
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC1_MUX       :2;     //[5..4] Timer channel 1 input Mux select for input capture.
X            volatile uint8_t  IC1_MUX       :2;     
N                                        //0x0 = IC10 : TM_IC1
N                                        //0x1 = IC11 : TM_ITR
N                                        //0x2 = IC12 : CMP1_OUT
N                                        //0x3 = IC13 : Reserved
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC2_MUX       :2;     //[9..8] Timer channel 2 input Mux select for input capture.
X            volatile uint8_t  IC2_MUX       :2;     
N                                        //0x0 = IC20 : TM_IC2
N                                        //0x1 = IC21 : TM_ITR
N                                        //0x2 = IC22 : CMP2_OUT
N                                        //0x3 = IC23 : Reserved
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC3_MUX       :2;     //[13..12] Timer channel 3 input Mux select for input capture.
X            volatile uint8_t  IC3_MUX       :2;     
N                                        //0x0 = IC30 : TM_IC3
N                                        //0x1 = IC31 : TM_ITR
N                                        //0x2 = IC32 : CMP3_OUT
N                                        //0x3 = IC33 : TM_XOR
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC0_TRGS      :2;     //[17..16] Timer channel 0 input trigger edge select.
X            volatile uint8_t  IC0_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  IC1_TRGS      :2;     //[19..18] Timer channel 1 input trigger edge select. 
X            volatile uint8_t  IC1_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  IC2_TRGS      :2;     //[21..20] Timer channel 2 input trigger edge select.
X            volatile uint8_t  IC2_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  IC3_TRGS      :2;     //[23..22] Timer channel 3 input trigger edge select.
X            volatile uint8_t  IC3_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }ICCR;                              /*!< ICCR       ~ Offset[0x34]  TM Timer input capture control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OS0_STA       :1;     //[0] Timer channel 0 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS0_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS1_STA       :1;     //[1] Timer channel 1 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS1_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS2_STA       :1;     //[2] Timer channel 2 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS2_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS3_STA       :1;     //[3] Timer channel 3 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS3_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS0_LCK       :1;     //[4] TM_OS0_STA register write access protected control
X            volatile uint8_t  OS0_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS1_LCK       :1;     //[5] TM_OS1_STA register write access protected control
X            volatile uint8_t  OS1_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS2_LCK       :1;     //[6] TM_OS2_STA register write access protected control
X            volatile uint8_t  OS2_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS3_LCK       :1;     //[7] TM_OS3_STA register write access protected control
X            volatile uint8_t  OS3_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS0H_STA      :1;     //[8] Timer channel 0 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS0H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS1H_STA      :1;     //[9] Timer channel 1 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS1H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS2H_STA      :1;     //[10] Timer channel 2 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS2H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS3H_STA      :1;     //[11] Timer channel 3 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS3H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS0H_LCK      :1;     //[12] TM_OS0H_STA register write access protected control
X            volatile uint8_t  OS0H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS1H_LCK      :1;     //[13] TM_OS1H_STA register write access protected control
X            volatile uint8_t  OS1H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS2H_LCK      :1;     //[14] TM_OS2H_STA register write access protected control
X            volatile uint8_t  OS2H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS3H_LCK      :1;     //[15] TM_OS3H_STA register write access protected control
X            volatile uint8_t  OS3H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[18] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OSCR;                              /*!< OSCR       ~ Offset[0x38]  TM Timer output compare state register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OC0_OE0       :1;     //[0] Timer channel 0 OC line-0 output enable.
X            volatile uint8_t  OC0_OE0       :1;     
N                                        //0 = Disable (output by TM_BK0_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC0_OE1       :1;     //[1] Timer channel 0 OC line-1 output enable.
X            volatile uint8_t  OC0_OE1       :1;     
N                                        //0 = Disable (output by TM_BK0_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC0_OE2       :1;     //[2] Timer channel 0 OC line-2 output enable.
X            volatile uint8_t  OC0_OE2       :1;     
N                                        //0 = Disable (output by TM_BK0_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC1_OE0       :1;     //[4] Timer channel 1 OC line-0 output enable.
X            volatile uint8_t  OC1_OE0       :1;     
N                                        //0 = Disable (output by TM_BK1_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC1_OE1       :1;     //[5] Timer channel 1 OC line-1 output enable.
X            volatile uint8_t  OC1_OE1       :1;     
N                                        //0 = Disable (output by TM_BK1_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC1_OE2       :1;     //[6] Timer channel 1 OC line-2 output enable.
X            volatile uint8_t  OC1_OE2       :1;     
N                                        //0 = Disable (output by TM_BK1_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC2_OE        :1;     //[8] Timer channel 2 OC line output enable.
X            volatile uint8_t  OC2_OE        :1;     
N                                        //0 = Disable (output by TM_BK2_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[11..9] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC3_OE        :1;     //[12] Timer channel 3 OC line output enable.
X            volatile uint8_t  OC3_OE        :1;     
N                                        //0 = Disable (output by TM_BK3_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC0N_OE       :1;     //[16] Timer channel 0 OC0N (complement) line output enable.
X            volatile uint8_t  OC0N_OE       :1;     
N                                        //0 = Disable (output by TM_BK0N_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[19..17] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC1N_OE       :1;     //[20] Timer channel 1 OC1N (complement) line output enable.
X            volatile uint8_t  OC1N_OE       :1;     
N                                        //0 = Disable (output by TM_BK1N_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC2N_OE       :1;     //[24] Timer channel 2 OC2N (complement) line output enable.
X            volatile uint8_t  OC2N_OE       :1;     
N                                        //0 = Disable (output by TM_BK2N_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[27..25] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :1;     //[28] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[29] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[30] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }OCCR0;                             /*!< OCCR0      ~ Offset[0x3C]  TM Timer output compare control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OC0_INV       :1;     //[0] Timer channel 0 output inverse enable.
X            volatile uint8_t  OC0_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1_INV       :1;     //[1] Timer channel 1 output inverse enable.
X            volatile uint8_t  OC1_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC2_INV       :1;     //[2] Timer channel 2 output inverse enable.
X            volatile uint8_t  OC2_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC3_INV       :1;     //[3] Timer channel 3 output inverse enable.
X            volatile uint8_t  OC3_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0H_INV      :1;     //[4] Timer channel 0 output inverse enable.
X            volatile uint8_t  OC0H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1H_INV      :1;     //[5] Timer channel 1 output inverse enable.
X            volatile uint8_t  OC1H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC2H_INV      :1;     //[6] Timer channel 2 output inverse enable.
X            volatile uint8_t  OC2H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC3H_INV      :1;     //[7] Timer channel 3 output inverse enable.
X            volatile uint8_t  OC3H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0N_INV      :1;     //[8] Timer channel 0 complement output inverse enable.
X            volatile uint8_t  OC0N_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1N_INV      :1;     //[9] Timer channel 1 complement output inverse enable.
X            volatile uint8_t  OC1N_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC2N_INV      :1;     //[10] Timer channel 2 complement output inverse enable.
X            volatile uint8_t  OC2N_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  OC0_POE0      :1;     //[16] Timer channel 0 OC line-0 output enable preload register bit
X            volatile uint8_t  OC0_POE0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0_POE1      :1;     //[17] Timer channel 0 OC line-1 output enable preload register bit
X            volatile uint8_t  OC0_POE1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0_POE2      :1;     //[18] Timer channel 0 OC line-2 output enable preload register bit
X            volatile uint8_t  OC0_POE2      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC1_POE0      :1;     //[20] Timer channel 1 OC line-0 output enable preload register bit
X            volatile uint8_t  OC1_POE0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1_POE1      :1;     //[21] Timer channel 1 OC line-1 output enable preload register bit
X            volatile uint8_t  OC1_POE1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1_POE2      :1;     //[22] Timer channel 1 OC line-2 output enable preload register bit
X            volatile uint8_t  OC1_POE2      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  POE_EN0       :1;     //[24] Timer OC preload enable bit for output enable preload register control
X            volatile uint8_t  POE_EN0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  POE_EN1       :1;     //[25] Timer OC preload enable bit for output enable preload register control
X            volatile uint8_t  POE_EN1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  POE_EN2       :1;     //[26] Timer OC preload enable bit for output enable preload register control
X            volatile uint8_t  POE_EN2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[27] 
X            volatile const  uint8_t                :1;     
N            __O  uint8_t  POE_SW        :1;     //[28] Timer output enable registers preload software enable bit
X            volatile  uint8_t  POE_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[31..29] 
X            volatile const  uint8_t                :3;     
N        }MBIT;
N    }OCCR1;                             /*!< OCCR1      ~ Offset[0x40]  TM Timer output compare control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PWM_MDS       :2;     //[1..0] Timer OC0/1/2/3 PWM mode select.
X            volatile uint8_t  PWM_MDS       :2;     
N                                        //0x0 = Edge Left-aligned
N                                        //0x1 = Center-aligned
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  DTG_DY        :8;     //[15..8] Timer output DTG dead-time delay(CK_DTG clock time base) for all channels
X            volatile uint8_t  DTG_DY        :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PWM;                               /*!< PWM        ~ Offset[0x44]  TM Timer PWM and DTG control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  BK_EN         :1;     //[0] Timer Break Input enable for OC[2:0]. (output state stop or reset)
X            volatile uint8_t  BK_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BK_EN3        :1;     //[3] Timer Break Input enable for OC3. (output state stop or reset)
X            volatile uint8_t  BK_EN3        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BK_MDS        :1;     //[4] Timer break event input control mode select.
X            volatile uint8_t  BK_MDS        :1;     
N                                        //0 = Latch mode
N                                        //1 = Cycle by cycle
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKSW_EN       :1;     //[7] Timer software break input generation enable.
X            volatile uint8_t  BKSW_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN0       :1;     //[8] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN1       :1;     //[9] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN2       :1;     //[10] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN3       :1;     //[11] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN3       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN4       :1;     //[12] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN4       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN5       :1;     //[13] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN5       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN6       :1;     //[14] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN6       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN7       :1;     //[15] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN7       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKI_EN0       :1;     //[16] Timer Break internal input channels' enable bit
X            volatile uint8_t  BKI_EN0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKI_EN1       :1;     //[17] Timer Break internal input channels' enable bit
X            volatile uint8_t  BKI_EN1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKI_EN2       :1;     //[18] Timer Break internal input channels' enable bit
X            volatile uint8_t  BKI_EN2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BK0_CTL       :1;     //[20] Timer OC0 output switch control when break event happened
X            volatile uint8_t  BK0_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  BK1_CTL       :1;     //[21] Timer OC1 output switch control when break event happened
X            volatile uint8_t  BK1_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  BK2_CTL       :1;     //[22] Timer OC2 output switch control when break event happened
X            volatile uint8_t  BK2_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  BK3_CTL       :1;     //[23] Timer OC3 output switch control when break event happened
X            volatile uint8_t  BK3_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  STP0_STA      :1;     //[24] Timer BK input active or stop condition output OC0 state select.
X            volatile uint8_t  STP0_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP1_STA      :1;     //[25] Timer BK input active or stop condition output OC1 state select.
X            volatile uint8_t  STP1_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP2_STA      :1;     //[26] Timer BK input active or stop condition output OC2 state select.
X            volatile uint8_t  STP2_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP3_STA      :1;     //[27] Timer BK input active or stop condition output OC3 state select.
X            volatile uint8_t  STP3_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP0N_STA     :1;     //[28] Timer BK input active or stop condition output OC0N state select.
X            volatile uint8_t  STP0N_STA     :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP1N_STA     :1;     //[29] Timer BK input active or stop condition output OC1N state select.
X            volatile uint8_t  STP1N_STA     :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP2N_STA     :1;     //[30] Timer BK input active or stop condition output OC2N state select.
X            volatile uint8_t  STP2N_STA     :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }BS;                                /*!< BS         ~ Offset[0x48]  TM Timer break and stop control register */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x4C]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC0A          :16;    //[15..0] TM Timer capture and compare register 0A for channel 0
X            volatile uint16_t CC0A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC0A;                              /*!< CC0A       ~ Offset[0x50]  TM Timer capture and compare register 0A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC0B          :16;    //[15..0] TM Timer capture and compare register 0B for channel 0
X            volatile uint16_t CC0B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC0B;                              /*!< CC0B       ~ Offset[0x54]  TM Timer capture and compare register 0B */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC1A          :16;    //[15..0] TM Timer capture and compare register 1A for channel 1
X            volatile uint16_t CC1A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC1A;                              /*!< CC1A       ~ Offset[0x58]  TM Timer capture and compare register 1A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC1B          :16;    //[15..0] TM Timer capture and compare register 1B for channel 1
X            volatile uint16_t CC1B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC1B;                              /*!< CC1B       ~ Offset[0x5c]  TM Timer capture and compare register 1B */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC2A          :16;    //[15..0] TM Timer capture and compare register 2A for channel 2
X            volatile uint16_t CC2A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC2A;                              /*!< CC2A       ~ Offset[0x60]  TM Timer capture and compare register 2A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC2B          :16;    //[15..0] TM Timer capture and compare register 2B for channel 2
X            volatile uint16_t CC2B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC2B;                              /*!< CC2B       ~ Offset[0x64]  TM Timer capture and compare register 2B */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC3A          :16;    //[15..0] TM Timer capture and compare register 3A for channel 3
X            volatile uint16_t CC3A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC3A;                              /*!< CC3A       ~ Offset[0x68]  TM Timer capture and compare register 3A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC3B          :16;    //[15..0] Timer TM capture and compare register 3B for channel 3
X            volatile uint16_t CC3B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC3B;                              /*!< CC3B       ~ Offset[0x6c]  TM Timer capture and compare register 3B */
N
N} TM_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        TM  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define TM00_Base                       ((uint32_t)0x55000000)              /*!< Timer Control Module-00 */
N#define TM01_Base                       ((uint32_t)0x55010000)              /*!< Timer Control Module-01 */
N#define TM10_Base                       ((uint32_t)0x55800000)              /*!< Timer Control Module-10 */
N#define TM16_Base                       ((uint32_t)0x55860000)              /*!< Timer Control Module-16 */
N#define TM20_Base                       ((uint32_t)0x56000000)              /*!< Timer Control Module-20 */
N#define TM26_Base                       ((uint32_t)0x56060000)              /*!< Timer Control Module-26 */
N#define TM36_Base                       ((uint32_t)0x56860000)              /*!< Timer Control Module-36 */
N#define TM00                            ((TM_Struct*) TM00_Base)
N#define TM01                            ((TM_Struct*) TM01_Base)
N#define TM10                            ((TM_Struct*) TM10_Base)
N#define TM16                            ((TM_Struct*) TM16_Base)
N#define TM20                            ((TM_Struct*) TM20_Base)
N#define TM26                            ((TM_Struct*) TM26_Base)
N#define TM36                            ((TM_Struct*) TM36_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        TM  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        TM_STA  [register's definitions]
N *              Offset[0x00]  TM Timer status register
N ******************************************************************************
N */
N///@{
N#define TM_STA_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_STA */
N#define TM_STA_QPEF_mask_w                          ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define TM_STA_QPEF_mask_h1                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_STA_QPEF_mask_b2                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_STA_QPEF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_QPEF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_QPEF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_QPEF_happened_w                      ((uint32_t)0x00080000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_QPEF_happened_h1                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_QPEF_happened_b2                     ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_IDXF_mask_w                          ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_STA_IDXF_mask_h1                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_STA_IDXF_mask_b2                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_STA_IDXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_IDXF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_IDXF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_IDXF_happened_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_IDXF_happened_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_IDXF_happened_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_DIRCF_mask_w                         ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_STA_DIRCF_mask_h1                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_STA_DIRCF_mask_b2                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_STA_DIRCF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_DIRCF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_DIRCF_normal_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_DIRCF_happened_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_DIRCF_happened_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_DIRCF_happened_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF3B_mask_w                          ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF3B_mask_h0                         ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF3B_mask_b1                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF3B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF3B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF3B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF3B_happened_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF3B_happened_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF3B_happened_b1                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF2B_mask_w                          ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF2B_mask_h0                         ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF2B_mask_b1                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF2B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF2B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF2B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF2B_happened_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF2B_happened_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF2B_happened_b1                     ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF1B_mask_w                          ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF1B_mask_h0                         ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF1B_mask_b1                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF1B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF1B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF1B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF1B_happened_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF1B_happened_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF1B_happened_b1                     ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF0B_mask_w                          ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF0B_mask_h0                         ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF0B_mask_b1                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF0B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF0B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF0B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF0B_happened_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF0B_happened_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF0B_happened_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF3A_mask_w                          ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF3A_mask_h0                         ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF3A_mask_b1                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF3A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF3A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF3A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF3A_happened_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF3A_happened_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF3A_happened_b1                     ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF2A_mask_w                          ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF2A_mask_h0                         ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF2A_mask_b1                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF2A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF2A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF2A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF2A_happened_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF2A_happened_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF2A_happened_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF1A_mask_w                          ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF1A_mask_h0                         ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF1A_mask_b1                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF1A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF1A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF1A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF1A_happened_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF1A_happened_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF1A_happened_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF0A_mask_w                          ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF0A_mask_h0                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF0A_mask_b1                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF0A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF0A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF0A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF0A_happened_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF0A_happened_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF0A_happened_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TUF2_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_STA_TUF2_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_STA_TUF2_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_STA_TUF2_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TUF2_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TUF2_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TUF2_happened_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TUF2_happened_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TUF2_happened_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TUF_mask_w                           ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_STA_TUF_mask_h0                          ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_STA_TUF_mask_b0                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_STA_TUF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TUF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TUF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TUF_happened_w                       ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TUF_happened_h0                      ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TUF_happened_b0                      ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TOF2_mask_w                          ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_STA_TOF2_mask_h0                         ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_STA_TOF2_mask_b0                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_STA_TOF2_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TOF2_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TOF2_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TOF2_happened_w                      ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TOF2_happened_h0                     ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TOF2_happened_b0                     ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TOF_mask_w                           ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_STA_TOF_mask_h0                          ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_STA_TOF_mask_b0                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_STA_TOF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TOF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TOF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TOF_happened_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TOF_happened_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TOF_happened_b0                      ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_EXF_mask_w                           ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_STA_EXF_mask_h0                          ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_STA_EXF_mask_b0                          ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_STA_EXF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_EXF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_EXF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_EXF_happened_w                       ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_EXF_happened_h0                      ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_EXF_happened_b0                      ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_BKF_mask_w                           ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_STA_BKF_mask_h0                          ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_STA_BKF_mask_b0                          ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_STA_BKF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_BKF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_BKF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_BKF_happened_w                       ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_BKF_happened_h0                      ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_BKF_happened_b0                      ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_DIRF_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_STA_DIRF_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_STA_DIRF_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_STA_DIRF_up_counting_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Up counting of 32bit */
N#define TM_STA_DIRF_up_counting_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Up counting of 16bit */
N#define TM_STA_DIRF_up_counting_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Up counting of 8bit */
N#define TM_STA_DIRF_down_counting_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(1):Down counting of 32bit */
N#define TM_STA_DIRF_down_counting_h0                ((uint16_t)0x0001)      /*!< Bit Value =(1):Down counting of 16bit */
N#define TM_STA_DIRF_down_counting_b0                ((uint8_t )0x01)        /*!< Bit Value =(1):Down counting of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_INT  [register's definitions]
N *              Offset[0x04]  TM Timer interrupt enable register
N ******************************************************************************
N */
N///@{
N#define TM_INT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_INT */
N#define TM_INT_QPE_IE_mask_w                        ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define TM_INT_QPE_IE_mask_h1                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_INT_QPE_IE_mask_b2                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_INT_QPE_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_QPE_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_QPE_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_QPE_IE_enable_w                      ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_QPE_IE_enable_h1                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_QPE_IE_enable_b2                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_IDX_IE_mask_w                        ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_INT_IDX_IE_mask_h1                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_INT_IDX_IE_mask_b2                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_INT_IDX_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_IDX_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_IDX_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_IDX_IE_enable_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_IDX_IE_enable_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_IDX_IE_enable_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_DIRC_IE_mask_w                       ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_INT_DIRC_IE_mask_h1                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_INT_DIRC_IE_mask_b2                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_INT_DIRC_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_DIRC_IE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_DIRC_IE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_DIRC_IE_enable_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_DIRC_IE_enable_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_DIRC_IE_enable_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC3_IE_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC3_IE_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC3_IE_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC3_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC3_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC3_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC3_IE_enable_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC3_IE_enable_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC3_IE_enable_b1                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC2_IE_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC2_IE_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC2_IE_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC2_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC2_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC2_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC2_IE_enable_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC2_IE_enable_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC2_IE_enable_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC1_IE_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC1_IE_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC1_IE_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC1_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC1_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC1_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC1_IE_enable_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC1_IE_enable_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC1_IE_enable_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC0_IE_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC0_IE_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC0_IE_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC0_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC0_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC0_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC0_IE_enable_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC0_IE_enable_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC0_IE_enable_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_TIE2_mask_w                          ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_INT_TIE2_mask_h0                         ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_INT_TIE2_mask_b0                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_INT_TIE2_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_TIE2_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_TIE2_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_TIE2_enable_w                        ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_TIE2_enable_h0                       ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_TIE2_enable_b0                       ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_TIE_mask_w                           ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_INT_TIE_mask_h0                          ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_INT_TIE_mask_b0                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_INT_TIE_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_TIE_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_TIE_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_TIE_enable_w                         ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_TIE_enable_h0                        ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_TIE_enable_b0                        ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_EXIE_mask_w                          ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_INT_EXIE_mask_h0                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_INT_EXIE_mask_b0                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_INT_EXIE_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_EXIE_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_EXIE_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_EXIE_enable_w                        ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_EXIE_enable_h0                       ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_EXIE_enable_b0                       ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_BKIE_mask_w                          ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_INT_BKIE_mask_h0                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_INT_BKIE_mask_b0                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_INT_BKIE_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_BKIE_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_BKIE_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_BKIE_enable_w                        ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_BKIE_enable_h0                       ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_BKIE_enable_b0                       ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_IEA_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_INT_IEA_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_INT_IEA_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_INT_IEA_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_IEA_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_IEA_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_IEA_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_IEA_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_IEA_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CLK  [register's definitions]
N *              Offset[0x08]  TM Timer clock source register
N ******************************************************************************
N */
N///@{
N#define TM_CLK_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CLK */
N#define TM_CLK_DTG_DIV_mask_w                       ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define TM_CLK_DTG_DIV_mask_h1                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_CLK_DTG_DIV_mask_b2                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_CLK_DTG_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define TM_CLK_DTG_DIV_div1_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define TM_CLK_DTG_DIV_div1_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define TM_CLK_DTG_DIV_div2_w                       ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define TM_CLK_DTG_DIV_div2_h1                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define TM_CLK_DTG_DIV_div2_b2                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define TM_CLK_DTG_DIV_div4_w                       ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define TM_CLK_DTG_DIV_div4_h1                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define TM_CLK_DTG_DIV_div4_b2                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define TM_CLK_DTG_DIV_div8_w                       ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define TM_CLK_DTG_DIV_div8_h1                      ((uint16_t)0x0003)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define TM_CLK_DTG_DIV_div8_b2                      ((uint8_t )0x03)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define TM_CLK_CKI_DIV_mask_w                       ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKI_DIV_mask_h0                      ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKI_DIV_mask_b1                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKI_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define TM_CLK_CKI_DIV_div1_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define TM_CLK_CKI_DIV_div1_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define TM_CLK_CKI_DIV_div2_w                       ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define TM_CLK_CKI_DIV_div2_h0                      ((uint16_t)0x1000)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define TM_CLK_CKI_DIV_div2_b1                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define TM_CLK_CKI_DIV_div4_w                       ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define TM_CLK_CKI_DIV_div4_h0                      ((uint16_t)0x2000)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define TM_CLK_CKI_DIV_div4_b1                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define TM_CLK_CKI_DIV_div8_w                       ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define TM_CLK_CKI_DIV_div8_h0                      ((uint16_t)0x3000)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define TM_CLK_CKI_DIV_div8_b1                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define TM_CLK_CKI_SEL_mask_w                       ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKI_SEL_mask_h0                      ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKI_SEL_mask_b1                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKI_SEL_proc_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):PROC of 32bit */
N#define TM_CLK_CKI_SEL_proc_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):PROC of 16bit */
N#define TM_CLK_CKI_SEL_proc_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):PROC of 8bit */
N#define TM_CLK_CKI_SEL_ck_ls_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CK_LS of 32bit */
N#define TM_CLK_CKI_SEL_ck_ls_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CK_LS of 16bit */
N#define TM_CLK_CKI_SEL_ck_ls_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):CK_LS of 8bit */
N
N#define TM_CLK_CKS2_SEL_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKS2_SEL_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKS2_SEL_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKS2_SEL_ck_int_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):CK_INT of 32bit */
N#define TM_CLK_CKS2_SEL_ck_int_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):CK_INT of 16bit */
N#define TM_CLK_CKS2_SEL_ck_int_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):CK_INT of 8bit */
N#define TM_CLK_CKS2_SEL_ck_ext_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):CK_EXT of 32bit */
N#define TM_CLK_CKS2_SEL_ck_ext_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):CK_EXT of 16bit */
N#define TM_CLK_CKS2_SEL_ck_ext_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):CK_EXT of 8bit */
N
N#define TM_CLK_CKS_SEL_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKS_SEL_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKS_SEL_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKS_SEL_ck_int_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):CK_INT of 32bit */
N#define TM_CLK_CKS_SEL_ck_int_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):CK_INT of 16bit */
N#define TM_CLK_CKS_SEL_ck_int_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):CK_INT of 8bit */
N#define TM_CLK_CKS_SEL_ck_ext_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):CK_EXT of 32bit */
N#define TM_CLK_CKS_SEL_ck_ext_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):CK_EXT of 16bit */
N#define TM_CLK_CKS_SEL_ck_ext_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):CK_EXT of 8bit */
N
N#define TM_CLK_CKE_SEL_mask_w                       ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKE_SEL_mask_h0                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKE_SEL_mask_b0                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKE_SEL_etr_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ETR of 32bit */
N#define TM_CLK_CKE_SEL_etr_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ETR of 16bit */
N#define TM_CLK_CKE_SEL_etr_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):ETR of 8bit */
N#define TM_CLK_CKE_SEL_itr_w                        ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):ITR of 32bit */
N#define TM_CLK_CKE_SEL_itr_h0                       ((uint16_t)0x0010)      /*!< Bit Value =(0x1):ITR of 16bit */
N#define TM_CLK_CKE_SEL_itr_b0                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):ITR of 8bit */
N#define TM_CLK_CKE_SEL_in0_w                        ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):IN0 of 32bit */
N#define TM_CLK_CKE_SEL_in0_h0                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):IN0 of 16bit */
N#define TM_CLK_CKE_SEL_in0_b0                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):IN0 of 8bit */
N#define TM_CLK_CKE_SEL_in1_w                        ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):IN1 of 32bit */
N#define TM_CLK_CKE_SEL_in1_h0                       ((uint16_t)0x0030)      /*!< Bit Value =(0x3):IN1 of 16bit */
N#define TM_CLK_CKE_SEL_in1_b0                       ((uint8_t )0x30)        /*!< Bit Value =(0x3):IN1 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_TRG  [register's definitions]
N *              Offset[0x0C]  TM Timer trigger control register
N ******************************************************************************
N */
N///@{
N#define TM_TRG_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_TRG */
N#define TM_TRG_GT2_SW_mask_w                        ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_GT2_SW_mask_h1                       ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_GT2_SW_mask_b3                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_TRG_GT2_SW_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_GT2_SW_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_GT2_SW_disable_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_GT2_SW_enable_w                      ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_GT2_SW_enable_h1                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_GT2_SW_enable_b3                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_GT_SW_mask_w                         ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_GT_SW_mask_h1                        ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_GT_SW_mask_b3                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_TRG_GT_SW_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_GT_SW_disable_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_GT_SW_disable_b3                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_GT_SW_enable_w                       ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_GT_SW_enable_h1                      ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_GT_SW_enable_b3                      ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_RST2_SW_mask_w                       ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_RST2_SW_mask_h1                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_RST2_SW_mask_b3                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_TRG_RST2_SW_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_RST2_SW_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_RST2_SW_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_RST2_SW_enable_w                     ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_RST2_SW_enable_h1                    ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_RST2_SW_enable_b3                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_RST_SW_mask_w                        ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_RST_SW_mask_h1                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_RST_SW_mask_b3                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_TRG_RST_SW_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_RST_SW_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_RST_SW_disable_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_RST_SW_enable_w                      ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_RST_SW_enable_h1                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_RST_SW_enable_b3                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_TRGO_INV_mask_w                      ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGO_INV_mask_h1                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGO_INV_mask_b3                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGO_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_TRGO_INV_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_TRGO_INV_disable_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_TRGO_INV_enable_w                    ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_TRGO_INV_enable_h1                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_TRGO_INV_enable_b3                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_TRGO_SW_mask_w                       ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGO_SW_mask_h1                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGO_SW_mask_b3                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGO_SW_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_TRG_TRGO_SW_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_TRG_TRGO_SW_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_TRG_TRGO_SW_1_w                          ((uint32_t)0x01000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_TRG_TRGO_SW_1_h1                         ((uint16_t)0x0100)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_TRG_TRGO_SW_1_b3                         ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_TRG_UEV_SEL_mask_w                       ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_UEV_SEL_mask_h1                      ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define TM_TRG_UEV_SEL_mask_b2                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define TM_TRG_UEV_SEL_all_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):All of 32bit */
N#define TM_TRG_UEV_SEL_all_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):All of 16bit */
N#define TM_TRG_UEV_SEL_all_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):All of 8bit */
N#define TM_TRG_UEV_SEL_tof_w                        ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):TOF of 32bit */
N#define TM_TRG_UEV_SEL_tof_h1                       ((uint16_t)0x0040)      /*!< Bit Value =(0x1):TOF of 16bit */
N#define TM_TRG_UEV_SEL_tof_b2                       ((uint8_t )0x40)        /*!< Bit Value =(0x1):TOF of 8bit */
N#define TM_TRG_UEV_SEL_udf_w                        ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):UDF of 32bit */
N#define TM_TRG_UEV_SEL_udf_h1                       ((uint16_t)0x0080)      /*!< Bit Value =(0x2):UDF of 16bit */
N#define TM_TRG_UEV_SEL_udf_b2                       ((uint8_t )0x80)        /*!< Bit Value =(0x2):UDF of 8bit */
N
N#define TM_TRG_IDX_MDS_mask_w                       ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_IDX_MDS_mask_h1                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_TRG_IDX_MDS_mask_b2                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_TRG_IDX_MDS_1t2_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1T2 of 32bit */
N#define TM_TRG_IDX_MDS_1t2_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1T2 of 16bit */
N#define TM_TRG_IDX_MDS_1t2_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):1T2 of 8bit */
N#define TM_TRG_IDX_MDS_2t3_w                        ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):2T3 of 32bit */
N#define TM_TRG_IDX_MDS_2t3_h1                       ((uint16_t)0x0010)      /*!< Bit Value =(0x1):2T3 of 16bit */
N#define TM_TRG_IDX_MDS_2t3_b2                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):2T3 of 8bit */
N#define TM_TRG_IDX_MDS_3t4_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):3T4 of 32bit */
N#define TM_TRG_IDX_MDS_3t4_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):3T4 of 16bit */
N#define TM_TRG_IDX_MDS_3t4_b2                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):3T4 of 8bit */
N#define TM_TRG_IDX_MDS_4t1_w                        ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):4T1 of 32bit */
N#define TM_TRG_IDX_MDS_4t1_h1                       ((uint16_t)0x0030)      /*!< Bit Value =(0x3):4T1 of 16bit */
N#define TM_TRG_IDX_MDS_4t1_b2                       ((uint8_t )0x30)        /*!< Bit Value =(0x3):4T1 of 8bit */
N
N#define TM_TRG_IDX_EN_mask_w                        ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_IDX_EN_mask_h1                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_TRG_IDX_EN_mask_b2                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_TRG_IDX_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_IDX_EN_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_IDX_EN_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_IDX_EN_enable_w                      ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_IDX_EN_enable_h1                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_IDX_EN_enable_b2                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_QEI_MDS_mask_w                       ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_QEI_MDS_mask_h1                      ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define TM_TRG_QEI_MDS_mask_b2                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_TRG_QEI_MDS_no_operation_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define TM_TRG_QEI_MDS_no_operation_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define TM_TRG_QEI_MDS_no_operation_b2              ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define TM_TRG_QEI_MDS_in0pos_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):IN0POS of 32bit */
N#define TM_TRG_QEI_MDS_in0pos_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):IN0POS of 16bit */
N#define TM_TRG_QEI_MDS_in0pos_b2                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):IN0POS of 8bit */
N#define TM_TRG_QEI_MDS_in0neg_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):IN0NEG of 32bit */
N#define TM_TRG_QEI_MDS_in0neg_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(0x2):IN0NEG of 16bit */
N#define TM_TRG_QEI_MDS_in0neg_b2                    ((uint8_t )0x02)        /*!< Bit Value =(0x2):IN0NEG of 8bit */
N#define TM_TRG_QEI_MDS_both_w                       ((uint32_t)0x00050000)  /*!< Bit Value =(0x5):BOTH of 32bit */
N#define TM_TRG_QEI_MDS_both_h1                      ((uint16_t)0x0005)      /*!< Bit Value =(0x5):BOTH of 16bit */
N#define TM_TRG_QEI_MDS_both_b2                      ((uint8_t )0x05)        /*!< Bit Value =(0x5):BOTH of 8bit */
N
N#define TM_TRG_TRGO_MDS_mask_w                      ((uint32_t)0x0000F000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGO_MDS_mask_h0                     ((uint16_t)0xF000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGO_MDS_mask_b1                     ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGO_MDS_rst_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):RST of 32bit */
N#define TM_TRG_TRGO_MDS_rst_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):RST of 16bit */
N#define TM_TRG_TRGO_MDS_rst_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):RST of 8bit */
N#define TM_TRG_TRGO_MDS_en_w                        ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):EN of 32bit */
N#define TM_TRG_TRGO_MDS_en_h0                       ((uint16_t)0x1000)      /*!< Bit Value =(0x1):EN of 16bit */
N#define TM_TRG_TRGO_MDS_en_b1                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):EN of 8bit */
N#define TM_TRG_TRGO_MDS_uev_w                       ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):UEV of 32bit */
N#define TM_TRG_TRGO_MDS_uev_h0                      ((uint16_t)0x2000)      /*!< Bit Value =(0x2):UEV of 16bit */
N#define TM_TRG_TRGO_MDS_uev_b1                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):UEV of 8bit */
N#define TM_TRG_TRGO_MDS_tof_w                       ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):TOF of 32bit */
N#define TM_TRG_TRGO_MDS_tof_h0                      ((uint16_t)0x3000)      /*!< Bit Value =(0x3):TOF of 16bit */
N#define TM_TRG_TRGO_MDS_tof_b1                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):TOF of 8bit */
N#define TM_TRG_TRGO_MDS_tuf_w                       ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):TUF of 32bit */
N#define TM_TRG_TRGO_MDS_tuf_h0                      ((uint16_t)0x4000)      /*!< Bit Value =(0x4):TUF of 16bit */
N#define TM_TRG_TRGO_MDS_tuf_b1                      ((uint8_t )0x40)        /*!< Bit Value =(0x4):TUF of 8bit */
N#define TM_TRG_TRGO_MDS_en2_w                       ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):EN2 of 32bit */
N#define TM_TRG_TRGO_MDS_en2_h0                      ((uint16_t)0x5000)      /*!< Bit Value =(0x5):EN2 of 16bit */
N#define TM_TRG_TRGO_MDS_en2_b1                      ((uint8_t )0x50)        /*!< Bit Value =(0x5):EN2 of 8bit */
N#define TM_TRG_TRGO_MDS_tof2_w                      ((uint32_t)0x00006000)  /*!< Bit Value =(0x6):TOF2 of 32bit */
N#define TM_TRG_TRGO_MDS_tof2_h0                     ((uint16_t)0x6000)      /*!< Bit Value =(0x6):TOF2 of 16bit */
N#define TM_TRG_TRGO_MDS_tof2_b1                     ((uint8_t )0x60)        /*!< Bit Value =(0x6):TOF2 of 8bit */
N#define TM_TRG_TRGO_MDS_dir_w                       ((uint32_t)0x00007000)  /*!< Bit Value =(0x7):DIR of 32bit */
N#define TM_TRG_TRGO_MDS_dir_h0                      ((uint16_t)0x7000)      /*!< Bit Value =(0x7):DIR of 16bit */
N#define TM_TRG_TRGO_MDS_dir_b1                      ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIR of 8bit */
N#define TM_TRG_TRGO_MDS_uev2_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(0x8):UEV2 of 32bit */
N#define TM_TRG_TRGO_MDS_uev2_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(0x8):UEV2 of 16bit */
N#define TM_TRG_TRGO_MDS_uev2_b1                     ((uint8_t )0x80)        /*!< Bit Value =(0x8):UEV2 of 8bit */
N#define TM_TRG_TRGO_MDS_sw_w                        ((uint32_t)0x00009000)  /*!< Bit Value =(0x9):SW of 32bit */
N#define TM_TRG_TRGO_MDS_sw_h0                       ((uint16_t)0x9000)      /*!< Bit Value =(0x9):SW of 16bit */
N#define TM_TRG_TRGO_MDS_sw_b1                       ((uint8_t )0x90)        /*!< Bit Value =(0x9):SW of 8bit */
N#define TM_TRG_TRGO_MDS_os0_w                       ((uint32_t)0x0000A000)  /*!< Bit Value =(0xA):OS0 of 32bit */
N#define TM_TRG_TRGO_MDS_os0_h0                      ((uint16_t)0xA000)      /*!< Bit Value =(0xA):OS0 of 16bit */
N#define TM_TRG_TRGO_MDS_os0_b1                      ((uint8_t )0xA0)        /*!< Bit Value =(0xA):OS0 of 8bit */
N#define TM_TRG_TRGO_MDS_os1_w                       ((uint32_t)0x0000B000)  /*!< Bit Value =(0xB):OS1 of 32bit */
N#define TM_TRG_TRGO_MDS_os1_h0                      ((uint16_t)0xB000)      /*!< Bit Value =(0xB):OS1 of 16bit */
N#define TM_TRG_TRGO_MDS_os1_b1                      ((uint8_t )0xB0)        /*!< Bit Value =(0xB):OS1 of 8bit */
N#define TM_TRG_TRGO_MDS_os2_w                       ((uint32_t)0x0000C000)  /*!< Bit Value =(0xC):OS2 of 32bit */
N#define TM_TRG_TRGO_MDS_os2_h0                      ((uint16_t)0xC000)      /*!< Bit Value =(0xC):OS2 of 16bit */
N#define TM_TRG_TRGO_MDS_os2_b1                      ((uint8_t )0xC0)        /*!< Bit Value =(0xC):OS2 of 8bit */
N#define TM_TRG_TRGO_MDS_os3_w                       ((uint32_t)0x0000D000)  /*!< Bit Value =(0xD):OS3 of 32bit */
N#define TM_TRG_TRGO_MDS_os3_h0                      ((uint16_t)0xD000)      /*!< Bit Value =(0xD):OS3 of 16bit */
N#define TM_TRG_TRGO_MDS_os3_b1                      ((uint8_t )0xD0)        /*!< Bit Value =(0xD):OS3 of 8bit */
N#define TM_TRG_TRGO_MDS_trgi_w                      ((uint32_t)0x0000E000)  /*!< Bit Value =(0xE):TRGI of 32bit */
N#define TM_TRG_TRGO_MDS_trgi_h0                     ((uint16_t)0xE000)      /*!< Bit Value =(0xE):TRGI of 16bit */
N#define TM_TRG_TRGO_MDS_trgi_b1                     ((uint8_t )0xE0)        /*!< Bit Value =(0xE):TRGI of 8bit */
N#define TM_TRG_TRGO_MDS_poe_w                       ((uint32_t)0x0000F000)  /*!< Bit Value =(0xF):POE of 32bit */
N#define TM_TRG_TRGO_MDS_poe_h0                      ((uint16_t)0xF000)      /*!< Bit Value =(0xF):POE of 16bit */
N#define TM_TRG_TRGO_MDS_poe_b1                      ((uint8_t )0xF0)        /*!< Bit Value =(0xF):POE of 8bit */
N
N#define TM_TRG_ITR_MUX_mask_w                       ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define TM_TRG_ITR_MUX_mask_h0                      ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define TM_TRG_ITR_MUX_mask_b1                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_TRG_ITR_MUX_itr0_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ITR0 of 32bit */
N#define TM_TRG_ITR_MUX_itr0_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ITR0 of 16bit */
N#define TM_TRG_ITR_MUX_itr0_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):ITR0 of 8bit */
N#define TM_TRG_ITR_MUX_itr1_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):ITR1 of 32bit */
N#define TM_TRG_ITR_MUX_itr1_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):ITR1 of 16bit */
N#define TM_TRG_ITR_MUX_itr1_b1                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):ITR1 of 8bit */
N#define TM_TRG_ITR_MUX_itr2_w                       ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):ITR2 of 32bit */
N#define TM_TRG_ITR_MUX_itr2_h0                      ((uint16_t)0x0200)      /*!< Bit Value =(0x2):ITR2 of 16bit */
N#define TM_TRG_ITR_MUX_itr2_b1                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):ITR2 of 8bit */
N#define TM_TRG_ITR_MUX_itr3_w                       ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):ITR3 of 32bit */
N#define TM_TRG_ITR_MUX_itr3_h0                      ((uint16_t)0x0300)      /*!< Bit Value =(0x3):ITR3 of 16bit */
N#define TM_TRG_ITR_MUX_itr3_b1                      ((uint8_t )0x03)        /*!< Bit Value =(0x3):ITR3 of 8bit */
N#define TM_TRG_ITR_MUX_itr4_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):ITR4 of 32bit */
N#define TM_TRG_ITR_MUX_itr4_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x4):ITR4 of 16bit */
N#define TM_TRG_ITR_MUX_itr4_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):ITR4 of 8bit */
N#define TM_TRG_ITR_MUX_itr5_w                       ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):ITR5 of 32bit */
N#define TM_TRG_ITR_MUX_itr5_h0                      ((uint16_t)0x0500)      /*!< Bit Value =(0x5):ITR5 of 16bit */
N#define TM_TRG_ITR_MUX_itr5_b1                      ((uint8_t )0x05)        /*!< Bit Value =(0x5):ITR5 of 8bit */
N#define TM_TRG_ITR_MUX_itr6_w                       ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):ITR6 of 32bit */
N#define TM_TRG_ITR_MUX_itr6_h0                      ((uint16_t)0x0600)      /*!< Bit Value =(0x6):ITR6 of 16bit */
N#define TM_TRG_ITR_MUX_itr6_b1                      ((uint8_t )0x06)        /*!< Bit Value =(0x6):ITR6 of 8bit */
N#define TM_TRG_ITR_MUX_itr7_w                       ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):ITR7 of 32bit */
N#define TM_TRG_ITR_MUX_itr7_h0                      ((uint16_t)0x0700)      /*!< Bit Value =(0x7):ITR7 of 16bit */
N#define TM_TRG_ITR_MUX_itr7_b1                      ((uint8_t )0x07)        /*!< Bit Value =(0x7):ITR7 of 8bit */
N
N#define TM_TRG_TRG_MUX_mask_w                       ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRG_MUX_mask_h0                      ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRG_MUX_mask_b0                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRG_MUX_etr_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ETR of 32bit */
N#define TM_TRG_TRG_MUX_etr_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ETR of 16bit */
N#define TM_TRG_TRG_MUX_etr_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):ETR of 8bit */
N#define TM_TRG_TRG_MUX_itr_w                        ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):ITR of 32bit */
N#define TM_TRG_TRG_MUX_itr_h0                       ((uint16_t)0x0040)      /*!< Bit Value =(0x1):ITR of 16bit */
N#define TM_TRG_TRG_MUX_itr_b0                       ((uint8_t )0x40)        /*!< Bit Value =(0x1):ITR of 8bit */
N#define TM_TRG_TRG_MUX_in0_w                        ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):IN0 of 32bit */
N#define TM_TRG_TRG_MUX_in0_h0                       ((uint16_t)0x0080)      /*!< Bit Value =(0x2):IN0 of 16bit */
N#define TM_TRG_TRG_MUX_in0_b0                       ((uint8_t )0x80)        /*!< Bit Value =(0x2):IN0 of 8bit */
N#define TM_TRG_TRG_MUX_in1_w                        ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):IN1 of 32bit */
N#define TM_TRG_TRG_MUX_in1_h0                       ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):IN1 of 16bit */
N#define TM_TRG_TRG_MUX_in1_b0                       ((uint8_t )0xC0)        /*!< Bit Value =(0x3):IN1 of 8bit */
N
N#define TM_TRG_TRGI2_MDS_mask_w                     ((uint32_t)0x00000038)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGI2_MDS_mask_h0                    ((uint16_t)0x0038)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGI2_MDS_mask_b0                    ((uint8_t )0x38)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGI2_MDS_no_operation_w             ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define TM_TRG_TRGI2_MDS_no_operation_h0            ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define TM_TRG_TRGI2_MDS_no_operation_b0            ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define TM_TRG_TRGI2_MDS_trigger_r_w                ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):Trigger-R of 32bit */
N#define TM_TRG_TRGI2_MDS_trigger_r_h0               ((uint16_t)0x0008)      /*!< Bit Value =(0x1):Trigger-R of 16bit */
N#define TM_TRG_TRGI2_MDS_trigger_r_b0               ((uint8_t )0x08)        /*!< Bit Value =(0x1):Trigger-R of 8bit */
N#define TM_TRG_TRGI2_MDS_reset_r_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(0x2):Reset-R of 32bit */
N#define TM_TRG_TRGI2_MDS_reset_r_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(0x2):Reset-R of 16bit */
N#define TM_TRG_TRGI2_MDS_reset_r_b0                 ((uint8_t )0x10)        /*!< Bit Value =(0x2):Reset-R of 8bit */
N#define TM_TRG_TRGI2_MDS_gate_h_w                   ((uint32_t)0x00000018)  /*!< Bit Value =(0x3):Gate-H of 32bit */
N#define TM_TRG_TRGI2_MDS_gate_h_h0                  ((uint16_t)0x0018)      /*!< Bit Value =(0x3):Gate-H of 16bit */
N#define TM_TRG_TRGI2_MDS_gate_h_b0                  ((uint8_t )0x18)        /*!< Bit Value =(0x3):Gate-H of 8bit */
N#define TM_TRG_TRGI2_MDS_reset_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(0x4):Reset of 32bit */
N#define TM_TRG_TRGI2_MDS_reset_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(0x4):Reset of 16bit */
N#define TM_TRG_TRGI2_MDS_reset_b0                   ((uint8_t )0x20)        /*!< Bit Value =(0x4):Reset of 8bit */
N#define TM_TRG_TRGI2_MDS_trigger_f_w                ((uint32_t)0x00000028)  /*!< Bit Value =(0x5):Trigger-F of 32bit */
N#define TM_TRG_TRGI2_MDS_trigger_f_h0               ((uint16_t)0x0028)      /*!< Bit Value =(0x5):Trigger-F of 16bit */
N#define TM_TRG_TRGI2_MDS_trigger_f_b0               ((uint8_t )0x28)        /*!< Bit Value =(0x5):Trigger-F of 8bit */
N#define TM_TRG_TRGI2_MDS_reset_f_w                  ((uint32_t)0x00000030)  /*!< Bit Value =(0x6):Reset-F of 32bit */
N#define TM_TRG_TRGI2_MDS_reset_f_h0                 ((uint16_t)0x0030)      /*!< Bit Value =(0x6):Reset-F of 16bit */
N#define TM_TRG_TRGI2_MDS_reset_f_b0                 ((uint8_t )0x30)        /*!< Bit Value =(0x6):Reset-F of 8bit */
N#define TM_TRG_TRGI2_MDS_gate_l_w                   ((uint32_t)0x00000038)  /*!< Bit Value =(0x7):Gate-L of 32bit */
N#define TM_TRG_TRGI2_MDS_gate_l_h0                  ((uint16_t)0x0038)      /*!< Bit Value =(0x7):Gate-L of 16bit */
N#define TM_TRG_TRGI2_MDS_gate_l_b0                  ((uint8_t )0x38)        /*!< Bit Value =(0x7):Gate-L of 8bit */
N
N#define TM_TRG_TRGI_MDS_mask_w                      ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGI_MDS_mask_h0                     ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGI_MDS_mask_b0                     ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGI_MDS_no_operation_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define TM_TRG_TRGI_MDS_no_operation_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define TM_TRG_TRGI_MDS_no_operation_b0             ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define TM_TRG_TRGI_MDS_trigger_r_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Trigger-R of 32bit */
N#define TM_TRG_TRGI_MDS_trigger_r_h0                ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Trigger-R of 16bit */
N#define TM_TRG_TRGI_MDS_trigger_r_b0                ((uint8_t )0x01)        /*!< Bit Value =(0x1):Trigger-R of 8bit */
N#define TM_TRG_TRGI_MDS_reset_r_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Reset-R of 32bit */
N#define TM_TRG_TRGI_MDS_reset_r_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Reset-R of 16bit */
N#define TM_TRG_TRGI_MDS_reset_r_b0                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Reset-R of 8bit */
N#define TM_TRG_TRGI_MDS_gate_h_w                    ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):Gate-H of 32bit */
N#define TM_TRG_TRGI_MDS_gate_h_h0                   ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Gate-H of 16bit */
N#define TM_TRG_TRGI_MDS_gate_h_b0                   ((uint8_t )0x03)        /*!< Bit Value =(0x3):Gate-H of 8bit */
N#define TM_TRG_TRGI_MDS_reset_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):Reset of 32bit */
N#define TM_TRG_TRGI_MDS_reset_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(0x4):Reset of 16bit */
N#define TM_TRG_TRGI_MDS_reset_b0                    ((uint8_t )0x04)        /*!< Bit Value =(0x4):Reset of 8bit */
N#define TM_TRG_TRGI_MDS_trigger_f_w                 ((uint32_t)0x00000005)  /*!< Bit Value =(0x5):Trigger-F of 32bit */
N#define TM_TRG_TRGI_MDS_trigger_f_h0                ((uint16_t)0x0005)      /*!< Bit Value =(0x5):Trigger-F of 16bit */
N#define TM_TRG_TRGI_MDS_trigger_f_b0                ((uint8_t )0x05)        /*!< Bit Value =(0x5):Trigger-F of 8bit */
N#define TM_TRG_TRGI_MDS_reset_f_w                   ((uint32_t)0x00000006)  /*!< Bit Value =(0x6):Reset-F of 32bit */
N#define TM_TRG_TRGI_MDS_reset_f_h0                  ((uint16_t)0x0006)      /*!< Bit Value =(0x6):Reset-F of 16bit */
N#define TM_TRG_TRGI_MDS_reset_f_b0                  ((uint8_t )0x06)        /*!< Bit Value =(0x6):Reset-F of 8bit */
N#define TM_TRG_TRGI_MDS_gate_l_w                    ((uint32_t)0x00000007)  /*!< Bit Value =(0x7):Gate-L of 32bit */
N#define TM_TRG_TRGI_MDS_gate_l_h0                   ((uint16_t)0x0007)      /*!< Bit Value =(0x7):Gate-L of 16bit */
N#define TM_TRG_TRGI_MDS_gate_l_b0                   ((uint8_t )0x07)        /*!< Bit Value =(0x7):Gate-L of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CR0  [register's definitions]
N *              Offset[0x10]  TM Timer control register 0
N ******************************************************************************
N */
N///@{
N#define TM_CR0_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CR0 */
N#define TM_CR0_UEX_EN_mask_w                        ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_UEX_EN_mask_h0                       ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_UEX_EN_mask_b1                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CR0_UEX_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_UEX_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_UEX_EN_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_UEX_EN_enable_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_UEX_EN_enable_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_UEX_EN_enable_b1                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_USW_EN_mask_w                        ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_USW_EN_mask_h0                       ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_USW_EN_mask_b1                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CR0_USW_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_USW_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_USW_EN_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_USW_EN_enable_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_USW_EN_enable_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_USW_EN_enable_b1                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_DIR_INV_mask_w                       ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_DIR_INV_mask_h0                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_DIR_INV_mask_b1                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_CR0_DIR_INV_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_CR0_DIR_INV_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_CR0_DIR_INV_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_CR0_DIR_INV_inverted_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Inverted of 32bit */
N#define TM_CR0_DIR_INV_inverted_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Inverted of 16bit */
N#define TM_CR0_DIR_INV_inverted_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Inverted of 8bit */
N
N#define TM_CR0_UEV_DIS_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_UEV_DIS_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_UEV_DIS_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_CR0_UEV_DIS_enable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define TM_CR0_UEV_DIS_enable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define TM_CR0_UEV_DIS_enable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define TM_CR0_UEV_DIS_disable_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Disable of 32bit */
N#define TM_CR0_UEV_DIS_disable_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Disable of 16bit */
N#define TM_CR0_UEV_DIS_disable_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define TM_CR0_EX_INV_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EX_INV_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EX_INV_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EX_INV_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_CR0_EX_INV_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_CR0_EX_INV_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_CR0_EX_INV_inverted_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Inverted of 32bit */
N#define TM_CR0_EX_INV_inverted_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Inverted of 16bit */
N#define TM_CR0_EX_INV_inverted_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Inverted of 8bit */
N
N#define TM_CR0_EX_EN_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EX_EN_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EX_EN_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EX_EN_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_EX_EN_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_EX_EN_disable_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_EX_EN_enable_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_EX_EN_enable_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_EX_EN_enable_b1                      ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_ASTOP_EN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_CR0_ASTOP_EN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_CR0_ASTOP_EN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR0_ASTOP_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_ASTOP_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_ASTOP_EN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_ASTOP_EN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_ASTOP_EN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_ASTOP_EN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_DIR2_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_CR0_DIR2_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_CR0_DIR2_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CR0_DIR2_up_w                            ((uint32_t)0x00000000)  /*!< Bit Value =(0):Up of 32bit */
N#define TM_CR0_DIR2_up_h0                           ((uint16_t)0x0000)      /*!< Bit Value =(0):Up of 16bit */
N#define TM_CR0_DIR2_up_b0                           ((uint8_t )0x00)        /*!< Bit Value =(0):Up of 8bit */
N#define TM_CR0_DIR2_down_w                          ((uint32_t)0x00000080)  /*!< Bit Value =(1):Down of 32bit */
N#define TM_CR0_DIR2_down_h0                         ((uint16_t)0x0080)      /*!< Bit Value =(1):Down of 16bit */
N#define TM_CR0_DIR2_down_b0                         ((uint8_t )0x80)        /*!< Bit Value =(1):Down of 8bit */
N
N#define TM_CR0_DIR_mask_w                           ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_CR0_DIR_mask_h0                          ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_CR0_DIR_mask_b0                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CR0_DIR_up_w                             ((uint32_t)0x00000000)  /*!< Bit Value =(0):Up of 32bit */
N#define TM_CR0_DIR_up_h0                            ((uint16_t)0x0000)      /*!< Bit Value =(0):Up of 16bit */
N#define TM_CR0_DIR_up_b0                            ((uint8_t )0x00)        /*!< Bit Value =(0):Up of 8bit */
N#define TM_CR0_DIR_down_w                           ((uint32_t)0x00000040)  /*!< Bit Value =(1):Down of 32bit */
N#define TM_CR0_DIR_down_h0                          ((uint16_t)0x0040)      /*!< Bit Value =(1):Down of 16bit */
N#define TM_CR0_DIR_down_b0                          ((uint8_t )0x40)        /*!< Bit Value =(1):Down of 8bit */
N
N#define TM_CR0_MDS_mask_w                           ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define TM_CR0_MDS_mask_h0                          ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_CR0_MDS_mask_b0                          ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_CR0_MDS_cascade_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Cascade of 32bit */
N#define TM_CR0_MDS_cascade_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Cascade of 16bit */
N#define TM_CR0_MDS_cascade_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):Cascade of 8bit */
N#define TM_CR0_MDS_separate_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Separate of 32bit */
N#define TM_CR0_MDS_separate_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Separate of 16bit */
N#define TM_CR0_MDS_separate_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):Separate of 8bit */
N#define TM_CR0_MDS_full_counter_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Full-Counter of 32bit */
N#define TM_CR0_MDS_full_counter_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Full-Counter of 16bit */
N#define TM_CR0_MDS_full_counter_b0                  ((uint8_t )0x20)        /*!< Bit Value =(0x2):Full-Counter of 8bit */
N
N#define TM_CR0_EN2_mask_w                           ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EN2_mask_h0                          ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EN2_mask_b0                          ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EN2_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_EN2_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_EN2_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_EN2_enable_w                         ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_EN2_enable_h0                        ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_EN2_enable_b0                        ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_EN_mask_w                            ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EN_mask_h0                           ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EN_mask_b0                           ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EN_disable_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_EN_disable_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_EN_disable_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_EN_enable_w                          ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_EN_enable_h0                         ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_EN_enable_b0                         ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CR1  [register's definitions]
N *              Offset[0x14]  TM Timer control register 1
N ******************************************************************************
N */
N///@{
N#define TM_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CR1 */
N#define TM_CR1_CC3B_SEN_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC3B_SEN_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC3B_SEN_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC3B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC3B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC3B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC3B_SEN_enable_w                    ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC3B_SEN_enable_h0                   ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC3B_SEN_enable_b1                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC2B_SEN_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC2B_SEN_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC2B_SEN_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC2B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC2B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC2B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC2B_SEN_enable_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC2B_SEN_enable_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC2B_SEN_enable_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC1B_SEN_mask_w                      ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC1B_SEN_mask_h0                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC1B_SEN_mask_b1                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC1B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC1B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC1B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC1B_SEN_enable_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC1B_SEN_enable_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC1B_SEN_enable_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC0B_SEN_mask_w                      ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC0B_SEN_mask_h0                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC0B_SEN_mask_b1                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC0B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC0B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC0B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC0B_SEN_enable_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC0B_SEN_enable_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC0B_SEN_enable_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC3A_SEN_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC3A_SEN_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC3A_SEN_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC3A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC3A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC3A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC3A_SEN_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC3A_SEN_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC3A_SEN_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC2A_SEN_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC2A_SEN_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC2A_SEN_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC2A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC2A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC2A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC2A_SEN_enable_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC2A_SEN_enable_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC2A_SEN_enable_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC1A_SEN_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC1A_SEN_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC1A_SEN_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC1A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC1A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC1A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC1A_SEN_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC1A_SEN_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC1A_SEN_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC0A_SEN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC0A_SEN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC0A_SEN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC0A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC0A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC0A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC0A_SEN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC0A_SEN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC0A_SEN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_OVR3_MDS_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR3_MDS_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR3_MDS_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR3_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR3_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR3_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR3_MDS_keep_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR3_MDS_keep_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR3_MDS_keep_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define TM_CR1_OVR2_MDS_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR2_MDS_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR2_MDS_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR2_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR2_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR2_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR2_MDS_keep_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR2_MDS_keep_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR2_MDS_keep_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define TM_CR1_OVR1_MDS_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR1_MDS_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR1_MDS_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR1_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR1_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR1_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR1_MDS_keep_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR1_MDS_keep_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR1_MDS_keep_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define TM_CR1_OVR0_MDS_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR0_MDS_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR0_MDS_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR0_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR0_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR0_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR0_MDS_keep_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR0_MDS_keep_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR0_MDS_keep_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Keep of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CKO  [register's definitions]
N *              Offset[0x18]  TM Timer CKO control register
N ******************************************************************************
N */
N///@{
N#define TM_CKO_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CKO */
N#define TM_CKO_CKO_LCK_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_LCK_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_LCK_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_LCK_locked_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_CKO_CKO_LCK_locked_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_CKO_CKO_LCK_locked_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_CKO_CKO_LCK_un_locked_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_CKO_CKO_LCK_un_locked_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_CKO_CKO_LCK_un_locked_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_CKO_CKO_STA_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_STA_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_STA_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_CKO_CKO_STA_0_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_CKO_CKO_STA_0_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_CKO_CKO_STA_1_w                          ((uint32_t)0x00000004)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_CKO_CKO_STA_1_h0                         ((uint16_t)0x0004)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_CKO_CKO_STA_1_b0                         ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_CKO_CKO_SEL_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_SEL_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_SEL_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_SEL_2nd_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):2nd of 32bit */
N#define TM_CKO_CKO_SEL_2nd_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):2nd of 16bit */
N#define TM_CKO_CKO_SEL_2nd_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):2nd of 8bit */
N#define TM_CKO_CKO_SEL_main_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Main of 32bit */
N#define TM_CKO_CKO_SEL_main_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Main of 16bit */
N#define TM_CKO_CKO_SEL_main_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Main of 8bit */
N
N#define TM_CKO_CKO_EN_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_EN_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_EN_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CKO_CKO_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CKO_CKO_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CKO_CKO_EN_enable_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CKO_CKO_EN_enable_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CKO_CKO_EN_enable_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CNT  [register's definitions]
N *              Offset[0x20]  TM Timer main counter register
N ******************************************************************************
N */
N///@{
N#define TM_CNT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CNT */
N#define TM_CNT_CNT_mask_w                           ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CNT_CNT_mask_h0                          ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CNT_CNT_shift_w                          (0)                     /*!< Bit Shift of 32bit */
N#define TM_CNT_CNT_shift_h0                         (0)                     /*!< Bit Shift of 16bit */
N#define TM_CNT_CNT_shift_b0                         (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_ARR  [register's definitions]
N *              Offset[0x24]  TM Timer main counter auto-reload value register
N ******************************************************************************
N */
N///@{
N#define TM_ARR_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_ARR */
N#define TM_ARR_ARR_mask_w                           ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_ARR_ARR_mask_h0                          ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_PSCNT  [register's definitions]
N *              Offset[0x28]  TM Timer prescaler register
N ******************************************************************************
N */
N///@{
N#define TM_PSCNT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_PSCNT */
N#define TM_PSCNT_CNTA_mask_w                        ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define TM_PSCNT_CNTA_mask_h1                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_PSCNT_CNTA_shift_w                       (16)                    /*!< Bit Shift of 32bit */
N#define TM_PSCNT_CNTA_shift_h1                      (0)                     /*!< Bit Shift of 16bit */
N#define TM_PSCNT_CNTA_shift_b2                      (0)                     /*!< Bit Shift of 8bit */
N
N#define TM_PSCNT_PSCNT_mask_w                       ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_PSCNT_PSCNT_mask_h0                      ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_PSCNT_PSCNT_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define TM_PSCNT_PSCNT_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define TM_PSCNT_PSCNT_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_PSARR  [register's definitions]
N *              Offset[0x2C]  TM Timer prescaler auto-reload register
N ******************************************************************************
N */
N///@{
N#define TM_PSARR_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_PSARR */
N#define TM_PSARR_PSARR_mask_w                       ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_PSARR_PSARR_mask_h0                      ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_PSARR_PSARR_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define TM_PSARR_PSARR_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define TM_PSARR_PSARR_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CCMDS  [register's definitions]
N *              Offset[0x30]  TM Timer capture and compare mode select register
N ******************************************************************************
N */
N///@{
N#define TM_CCMDS_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CCMDS */
N#define TM_CCMDS_DMA_CC3E_mask_w                    ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC3E_mask_h1                   ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC3E_mask_b3                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC3E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC3E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC3E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC3E_enable_w                  ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC3E_enable_h1                 ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC3E_enable_b3                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_CC2E_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC2E_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC2E_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC2E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC2E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC2E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC2E_enable_w                  ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC2E_enable_h1                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC2E_enable_b3                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_CC1E_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC1E_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC1E_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC1E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC1E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC1E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC1E_enable_w                  ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC1E_enable_h1                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC1E_enable_b3                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_CC0E_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC0E_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC0E_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC0E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC0E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC0E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC0E_enable_w                  ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC0E_enable_h1                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC0E_enable_b3                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_OMDS_mask_w                    ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_OMDS_mask_h1                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_OMDS_mask_b2                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_OMDS_uev_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):UEV of 32bit */
N#define TM_CCMDS_DMA_OMDS_uev_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):UEV of 16bit */
N#define TM_CCMDS_DMA_OMDS_uev_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):UEV of 8bit */
N#define TM_CCMDS_DMA_OMDS_itr_w                     ((uint32_t)0x00800000)  /*!< Bit Value =(1):ITR of 32bit */
N#define TM_CCMDS_DMA_OMDS_itr_h1                    ((uint16_t)0x0080)      /*!< Bit Value =(1):ITR of 16bit */
N#define TM_CCMDS_DMA_OMDS_itr_b2                    ((uint8_t )0x80)        /*!< Bit Value =(1):ITR of 8bit */
N
N#define TM_CCMDS_OC_LCK_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_OC_LCK_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_OC_LCK_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_OC_LCK_un_locked_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):un-Locked of 32bit */
N#define TM_CCMDS_OC_LCK_un_locked_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):un-Locked of 16bit */
N#define TM_CCMDS_OC_LCK_un_locked_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):un-Locked of 8bit */
N#define TM_CCMDS_OC_LCK_locked_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Locked of 32bit */
N#define TM_CCMDS_OC_LCK_locked_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Locked of 16bit */
N#define TM_CCMDS_OC_LCK_locked_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Locked of 8bit */
N
N#define TM_CCMDS_CC3_MDS_mask_w                     ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC3_MDS_mask_h0                    ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC3_MDS_mask_b1                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC3_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC3_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC3_MDS_nop_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC3_MDS_16bit_ic_w                 ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC3_MDS_16bit_ic_h0                ((uint16_t)0x1000)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC3_MDS_16bit_ic_b1                ((uint8_t )0x10)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC3_MDS_16bit_oc_w                 ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC3_MDS_16bit_oc_h0                ((uint16_t)0x2000)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC3_MDS_16bit_oc_b1                ((uint8_t )0x20)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_oc_w                ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_oc_h0               ((uint16_t)0x3000)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_oc_b1               ((uint8_t )0x30)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC3_MDS_16bit_pwm_w                ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC3_MDS_16bit_pwm_h0               ((uint16_t)0x4000)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC3_MDS_16bit_pwm_b1               ((uint8_t )0x40)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_pwm_w               ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_pwm_h0              ((uint16_t)0x5000)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_pwm_b1              ((uint8_t )0x50)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N
N#define TM_CCMDS_CC2_MDS_mask_w                     ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC2_MDS_mask_h0                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC2_MDS_mask_b1                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC2_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC2_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC2_MDS_nop_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_ic_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_ic_h0                ((uint16_t)0x0100)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_ic_b1                ((uint8_t )0x01)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_oc_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_oc_h0                ((uint16_t)0x0200)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_oc_b1                ((uint8_t )0x02)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_oc_w                ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_oc_h0               ((uint16_t)0x0300)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_oc_b1               ((uint8_t )0x03)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_w                ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_h0               ((uint16_t)0x0400)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_b1               ((uint8_t )0x04)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_w               ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_h0              ((uint16_t)0x0500)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_b1              ((uint8_t )0x05)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_dtg_w            ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):16bit_PWM_DTG of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_dtg_h0           ((uint16_t)0x0600)      /*!< Bit Value =(0x6):16bit_PWM_DTG of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_dtg_b1           ((uint8_t )0x06)        /*!< Bit Value =(0x6):16bit_PWM_DTG of 8bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_dtg_w           ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 32bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_dtg_h0          ((uint16_t)0x0700)      /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 16bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_dtg_b1          ((uint8_t )0x07)        /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 8bit */
N
N#define TM_CCMDS_CC1_MDS_mask_w                     ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC1_MDS_mask_h0                    ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC1_MDS_mask_b0                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC1_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC1_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC1_MDS_nop_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_ic_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_ic_h0                ((uint16_t)0x0010)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_ic_b0                ((uint8_t )0x10)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_oc_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_oc_h0                ((uint16_t)0x0020)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_oc_b0                ((uint8_t )0x20)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_oc_w                ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_oc_h0               ((uint16_t)0x0030)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_oc_b0               ((uint8_t )0x30)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_w                ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_h0               ((uint16_t)0x0040)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_b0               ((uint8_t )0x40)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_w               ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_h0              ((uint16_t)0x0050)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_b0              ((uint8_t )0x50)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_dtg_w            ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):16bit_PWM_DTG of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_dtg_h0           ((uint16_t)0x0060)      /*!< Bit Value =(0x6):16bit_PWM_DTG of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_dtg_b0           ((uint8_t )0x60)        /*!< Bit Value =(0x6):16bit_PWM_DTG of 8bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_dtg_w           ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 32bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_dtg_h0          ((uint16_t)0x0070)      /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 16bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_dtg_b0          ((uint8_t )0x70)        /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 8bit */
N
N#define TM_CCMDS_CC0_MDS_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC0_MDS_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC0_MDS_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC0_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC0_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC0_MDS_nop_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_ic_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_ic_h0                ((uint16_t)0x0001)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_ic_b0                ((uint8_t )0x01)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_oc_w                 ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_oc_h0                ((uint16_t)0x0002)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_oc_b0                ((uint8_t )0x02)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_oc_w                ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_oc_h0               ((uint16_t)0x0003)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_oc_b0               ((uint8_t )0x03)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_w                ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_h0               ((uint16_t)0x0004)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_b0               ((uint8_t )0x04)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_w               ((uint32_t)0x00000005)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_h0              ((uint16_t)0x0005)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_b0              ((uint8_t )0x05)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_dtg_w            ((uint32_t)0x00000006)  /*!< Bit Value =(0x6):16bit_PWM_DTG of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_dtg_h0           ((uint16_t)0x0006)      /*!< Bit Value =(0x6):16bit_PWM_DTG of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_dtg_b0           ((uint8_t )0x06)        /*!< Bit Value =(0x6):16bit_PWM_DTG of 8bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_dtg_w           ((uint32_t)0x00000007)  /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 32bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_dtg_h0          ((uint16_t)0x0007)      /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 16bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_dtg_b0          ((uint8_t )0x07)        /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_ICCR  [register's definitions]
N *              Offset[0x34]  TM Timer input capture control register
N ******************************************************************************
N */
N///@{
N#define TM_ICCR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_ICCR */
N#define TM_ICCR_IC3_TRGS_mask_w                     ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC3_TRGS_mask_h1                    ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC3_TRGS_mask_b2                    ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC3_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC3_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC3_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC3_TRGS_rising_edge_w              ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC3_TRGS_rising_edge_h1             ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC3_TRGS_rising_edge_b2             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC3_TRGS_falling_edge_w             ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC3_TRGS_falling_edge_h1            ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC3_TRGS_falling_edge_b2            ((uint8_t )0x80)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC3_TRGS_dual_edge_w                ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC3_TRGS_dual_edge_h1               ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC3_TRGS_dual_edge_b2               ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC2_TRGS_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC2_TRGS_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC2_TRGS_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC2_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC2_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC2_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC2_TRGS_rising_edge_w              ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC2_TRGS_rising_edge_h1             ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC2_TRGS_rising_edge_b2             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC2_TRGS_falling_edge_w             ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC2_TRGS_falling_edge_h1            ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC2_TRGS_falling_edge_b2            ((uint8_t )0x20)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC2_TRGS_dual_edge_w                ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC2_TRGS_dual_edge_h1               ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC2_TRGS_dual_edge_b2               ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC1_TRGS_mask_w                     ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC1_TRGS_mask_h1                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC1_TRGS_mask_b2                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC1_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC1_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC1_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC1_TRGS_rising_edge_w              ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC1_TRGS_rising_edge_h1             ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC1_TRGS_rising_edge_b2             ((uint8_t )0x04)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC1_TRGS_falling_edge_w             ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC1_TRGS_falling_edge_h1            ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC1_TRGS_falling_edge_b2            ((uint8_t )0x08)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC1_TRGS_dual_edge_w                ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC1_TRGS_dual_edge_h1               ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC1_TRGS_dual_edge_b2               ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC0_TRGS_mask_w                     ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC0_TRGS_mask_h1                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC0_TRGS_mask_b2                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC0_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC0_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC0_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC0_TRGS_rising_edge_w              ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC0_TRGS_rising_edge_h1             ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC0_TRGS_rising_edge_b2             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC0_TRGS_falling_edge_w             ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC0_TRGS_falling_edge_h1            ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC0_TRGS_falling_edge_b2            ((uint8_t )0x02)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC0_TRGS_dual_edge_w                ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC0_TRGS_dual_edge_h1               ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC0_TRGS_dual_edge_b2               ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC3_MUX_mask_w                      ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC3_MUX_mask_h0                     ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC3_MUX_mask_b1                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC3_MUX_ic30_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC30 of 32bit */
N#define TM_ICCR_IC3_MUX_ic30_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC30 of 16bit */
N#define TM_ICCR_IC3_MUX_ic30_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC30 of 8bit */
N#define TM_ICCR_IC3_MUX_ic31_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):IC31 of 32bit */
N#define TM_ICCR_IC3_MUX_ic31_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(0x1):IC31 of 16bit */
N#define TM_ICCR_IC3_MUX_ic31_b1                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):IC31 of 8bit */
N#define TM_ICCR_IC3_MUX_ic32_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):IC32 of 32bit */
N#define TM_ICCR_IC3_MUX_ic32_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(0x2):IC32 of 16bit */
N#define TM_ICCR_IC3_MUX_ic32_b1                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):IC32 of 8bit */
N#define TM_ICCR_IC3_MUX_ic33_w                      ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):IC33 of 32bit */
N#define TM_ICCR_IC3_MUX_ic33_h0                     ((uint16_t)0x3000)      /*!< Bit Value =(0x3):IC33 of 16bit */
N#define TM_ICCR_IC3_MUX_ic33_b1                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):IC33 of 8bit */
N
N#define TM_ICCR_IC2_MUX_mask_w                      ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC2_MUX_mask_h0                     ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC2_MUX_mask_b1                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC2_MUX_ic20_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC20 of 32bit */
N#define TM_ICCR_IC2_MUX_ic20_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC20 of 16bit */
N#define TM_ICCR_IC2_MUX_ic20_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC20 of 8bit */
N#define TM_ICCR_IC2_MUX_ic21_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):IC21 of 32bit */
N#define TM_ICCR_IC2_MUX_ic21_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):IC21 of 16bit */
N#define TM_ICCR_IC2_MUX_ic21_b1                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):IC21 of 8bit */
N#define TM_ICCR_IC2_MUX_ic22_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):IC22 of 32bit */
N#define TM_ICCR_IC2_MUX_ic22_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):IC22 of 16bit */
N#define TM_ICCR_IC2_MUX_ic22_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):IC22 of 8bit */
N#define TM_ICCR_IC2_MUX_ic23_w                      ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):IC23 of 32bit */
N#define TM_ICCR_IC2_MUX_ic23_h0                     ((uint16_t)0x0300)      /*!< Bit Value =(0x3):IC23 of 16bit */
N#define TM_ICCR_IC2_MUX_ic23_b1                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):IC23 of 8bit */
N
N#define TM_ICCR_IC1_MUX_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC1_MUX_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC1_MUX_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC1_MUX_ic10_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC10 of 32bit */
N#define TM_ICCR_IC1_MUX_ic10_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC10 of 16bit */
N#define TM_ICCR_IC1_MUX_ic10_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC10 of 8bit */
N#define TM_ICCR_IC1_MUX_ic11_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):IC11 of 32bit */
N#define TM_ICCR_IC1_MUX_ic11_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(0x1):IC11 of 16bit */
N#define TM_ICCR_IC1_MUX_ic11_b0                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):IC11 of 8bit */
N#define TM_ICCR_IC1_MUX_ic12_w                      ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):IC12 of 32bit */
N#define TM_ICCR_IC1_MUX_ic12_h0                     ((uint16_t)0x0020)      /*!< Bit Value =(0x2):IC12 of 16bit */
N#define TM_ICCR_IC1_MUX_ic12_b0                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):IC12 of 8bit */
N#define TM_ICCR_IC1_MUX_ic13_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):IC13 of 32bit */
N#define TM_ICCR_IC1_MUX_ic13_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):IC13 of 16bit */
N#define TM_ICCR_IC1_MUX_ic13_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):IC13 of 8bit */
N
N#define TM_ICCR_IC0_MUX_mask_w                      ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC0_MUX_mask_h0                     ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC0_MUX_mask_b0                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC0_MUX_ic00_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC00 of 32bit */
N#define TM_ICCR_IC0_MUX_ic00_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC00 of 16bit */
N#define TM_ICCR_IC0_MUX_ic00_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC00 of 8bit */
N#define TM_ICCR_IC0_MUX_ic01_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):IC01 of 32bit */
N#define TM_ICCR_IC0_MUX_ic01_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):IC01 of 16bit */
N#define TM_ICCR_IC0_MUX_ic01_b0                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):IC01 of 8bit */
N#define TM_ICCR_IC0_MUX_ic02_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):IC02 of 32bit */
N#define TM_ICCR_IC0_MUX_ic02_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(0x2):IC02 of 16bit */
N#define TM_ICCR_IC0_MUX_ic02_b0                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):IC02 of 8bit */
N#define TM_ICCR_IC0_MUX_ic03_w                      ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):IC03 of 32bit */
N#define TM_ICCR_IC0_MUX_ic03_h0                     ((uint16_t)0x0003)      /*!< Bit Value =(0x3):IC03 of 16bit */
N#define TM_ICCR_IC0_MUX_ic03_b0                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):IC03 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_OSCR  [register's definitions]
N *              Offset[0x38]  TM Timer output compare state register
N ******************************************************************************
N */
N///@{
N#define TM_OSCR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_OSCR */
N#define TM_OSCR_OS3H_LCK_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3H_LCK_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3H_LCK_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS3H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS3H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS3H_LCK_un_locked_w                ((uint32_t)0x00008000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS3H_LCK_un_locked_h0               ((uint16_t)0x8000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS3H_LCK_un_locked_b1               ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS2H_LCK_mask_w                     ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2H_LCK_mask_h0                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2H_LCK_mask_b1                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS2H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS2H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS2H_LCK_un_locked_w                ((uint32_t)0x00004000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS2H_LCK_un_locked_h0               ((uint16_t)0x4000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS2H_LCK_un_locked_b1               ((uint8_t )0x40)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS1H_LCK_mask_w                     ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1H_LCK_mask_h0                    ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1H_LCK_mask_b1                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS1H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS1H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS1H_LCK_un_locked_w                ((uint32_t)0x00002000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS1H_LCK_un_locked_h0               ((uint16_t)0x2000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS1H_LCK_un_locked_b1               ((uint8_t )0x20)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS0H_LCK_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0H_LCK_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0H_LCK_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS0H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS0H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS0H_LCK_un_locked_w                ((uint32_t)0x00001000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS0H_LCK_un_locked_h0               ((uint16_t)0x1000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS0H_LCK_un_locked_b1               ((uint8_t )0x10)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS3H_STA_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3H_STA_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3H_STA_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS3H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS3H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS3H_STA_1_w                        ((uint32_t)0x00000800)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS3H_STA_1_h0                       ((uint16_t)0x0800)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS3H_STA_1_b1                       ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS2H_STA_mask_w                     ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2H_STA_mask_h0                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2H_STA_mask_b1                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS2H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS2H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS2H_STA_1_w                        ((uint32_t)0x00000400)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS2H_STA_1_h0                       ((uint16_t)0x0400)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS2H_STA_1_b1                       ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS1H_STA_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1H_STA_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1H_STA_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS1H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS1H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS1H_STA_1_w                        ((uint32_t)0x00000200)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS1H_STA_1_h0                       ((uint16_t)0x0200)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS1H_STA_1_b1                       ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS0H_STA_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0H_STA_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0H_STA_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS0H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS0H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS0H_STA_1_w                        ((uint32_t)0x00000100)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS0H_STA_1_h0                       ((uint16_t)0x0100)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS0H_STA_1_b1                       ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS3_LCK_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3_LCK_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3_LCK_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS3_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS3_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS3_LCK_un_locked_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS3_LCK_un_locked_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS3_LCK_un_locked_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS2_LCK_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2_LCK_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2_LCK_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS2_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS2_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS2_LCK_un_locked_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS2_LCK_un_locked_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS2_LCK_un_locked_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS1_LCK_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1_LCK_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1_LCK_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS1_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS1_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS1_LCK_un_locked_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS1_LCK_un_locked_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS1_LCK_un_locked_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS0_LCK_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0_LCK_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0_LCK_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS0_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS0_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS0_LCK_un_locked_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS0_LCK_un_locked_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS0_LCK_un_locked_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS3_STA_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3_STA_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3_STA_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS3_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS3_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS3_STA_1_w                         ((uint32_t)0x00000008)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS3_STA_1_h0                        ((uint16_t)0x0008)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS3_STA_1_b0                        ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS2_STA_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2_STA_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2_STA_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS2_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS2_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS2_STA_1_w                         ((uint32_t)0x00000004)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS2_STA_1_h0                        ((uint16_t)0x0004)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS2_STA_1_b0                        ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS1_STA_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1_STA_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1_STA_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS1_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS1_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS1_STA_1_w                         ((uint32_t)0x00000002)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS1_STA_1_h0                        ((uint16_t)0x0002)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS1_STA_1_b0                        ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS0_STA_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0_STA_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0_STA_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS0_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS0_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS0_STA_1_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS0_STA_1_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS0_STA_1_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_OCCR0  [register's definitions]
N *              Offset[0x3C]  TM Timer output compare control register 0
N ******************************************************************************
N */
N///@{
N#define TM_OCCR0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_OCCR0 */
N#define TM_OCCR0_OC2N_OE_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC2N_OE_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC2N_OE_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC2N_OE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC2N_OE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC2N_OE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC2N_OE_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC2N_OE_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC2N_OE_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1N_OE_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1N_OE_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1N_OE_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1N_OE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1N_OE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1N_OE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1N_OE_enable_w                   ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1N_OE_enable_h1                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1N_OE_enable_b2                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0N_OE_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0N_OE_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0N_OE_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0N_OE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0N_OE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0N_OE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0N_OE_enable_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0N_OE_enable_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0N_OE_enable_b2                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC3_OE_mask_w                      ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC3_OE_mask_h0                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC3_OE_mask_b1                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC3_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC3_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC3_OE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC3_OE_enable_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC3_OE_enable_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC3_OE_enable_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC2_OE_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC2_OE_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC2_OE_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC2_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC2_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC2_OE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC2_OE_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC2_OE_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC2_OE_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1_OE2_mask_w                     ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1_OE2_mask_h0                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1_OE2_mask_b0                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1_OE2_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1_OE2_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1_OE2_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1_OE2_enable_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1_OE2_enable_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1_OE2_enable_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1_OE1_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1_OE1_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1_OE1_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1_OE1_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1_OE1_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1_OE1_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1_OE1_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1_OE1_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1_OE1_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1_OE0_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1_OE0_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1_OE0_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1_OE0_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1_OE0_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1_OE0_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1_OE0_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1_OE0_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1_OE0_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0_OE2_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0_OE2_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0_OE2_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0_OE2_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0_OE2_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0_OE2_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0_OE2_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0_OE2_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0_OE2_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0_OE1_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0_OE1_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0_OE1_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0_OE1_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0_OE1_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0_OE1_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0_OE1_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0_OE1_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0_OE1_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0_OE0_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0_OE0_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0_OE0_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0_OE0_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0_OE0_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0_OE0_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0_OE0_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0_OE0_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0_OE0_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_OCCR1  [register's definitions]
N *              Offset[0x40]  TM Timer output compare control register 1
N ******************************************************************************
N */
N///@{
N#define TM_OCCR1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_OCCR1 */
N#define TM_OCCR1_POE_SW_mask_w                      ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_SW_mask_h1                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_SW_mask_b3                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_SW_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_SW_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_SW_disable_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_SW_enable_w                    ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_SW_enable_h1                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_SW_enable_b3                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_POE_EN2_mask_w                     ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_EN2_mask_h1                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_EN2_mask_b3                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_EN2_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_EN2_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_EN2_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_EN2_enable_w                   ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_EN2_enable_h1                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_EN2_enable_b3                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_POE_EN1_mask_w                     ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_EN1_mask_h1                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_EN1_mask_b3                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_EN1_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_EN1_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_EN1_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_EN1_enable_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_EN1_enable_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_EN1_enable_b3                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_POE_EN0_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_EN0_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_EN0_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_EN0_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_EN0_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_EN0_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_EN0_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_EN0_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_EN0_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_POE2_mask_w                    ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_POE2_mask_h1                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_POE2_mask_b2                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_POE2_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_POE2_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_POE2_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_POE2_enable_w                  ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_POE2_enable_h1                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_POE2_enable_b2                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_POE1_mask_w                    ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_POE1_mask_h1                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_POE1_mask_b2                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_POE1_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_POE1_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_POE1_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_POE1_enable_w                  ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_POE1_enable_h1                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_POE1_enable_b2                 ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_POE0_mask_w                    ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_POE0_mask_h1                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_POE0_mask_b2                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_POE0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_POE0_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_POE0_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_POE0_enable_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_POE0_enable_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_POE0_enable_b2                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_POE2_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_POE2_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_POE2_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_POE2_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_POE2_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_POE2_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_POE2_enable_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_POE2_enable_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_POE2_enable_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_POE1_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_POE1_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_POE1_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_POE1_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_POE1_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_POE1_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_POE1_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_POE1_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_POE1_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_POE0_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_POE0_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_POE0_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_POE0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_POE0_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_POE0_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_POE0_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_POE0_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_POE0_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC2N_INV_mask_w                    ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC2N_INV_mask_h0                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC2N_INV_mask_b1                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC2N_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC2N_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC2N_INV_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC2N_INV_enable_w                  ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC2N_INV_enable_h0                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC2N_INV_enable_b1                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1N_INV_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1N_INV_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1N_INV_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1N_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1N_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1N_INV_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1N_INV_enable_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1N_INV_enable_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1N_INV_enable_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0N_INV_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0N_INV_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0N_INV_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0N_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0N_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0N_INV_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0N_INV_enable_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0N_INV_enable_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0N_INV_enable_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC3H_INV_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC3H_INV_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC3H_INV_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC3H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC3H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC3H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC3H_INV_enable_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC3H_INV_enable_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC3H_INV_enable_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC2H_INV_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC2H_INV_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC2H_INV_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC2H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC2H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC2H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC2H_INV_enable_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC2H_INV_enable_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC2H_INV_enable_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1H_INV_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1H_INV_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1H_INV_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1H_INV_enable_w                  ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1H_INV_enable_h0                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1H_INV_enable_b0                 ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0H_INV_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0H_INV_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0H_INV_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0H_INV_enable_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0H_INV_enable_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0H_INV_enable_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC3_INV_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC3_INV_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC3_INV_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC3_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC3_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC3_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC3_INV_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC3_INV_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC3_INV_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC2_INV_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC2_INV_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC2_INV_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC2_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC2_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC2_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC2_INV_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC2_INV_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC2_INV_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_INV_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_INV_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_INV_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_INV_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_INV_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_INV_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_INV_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_INV_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_INV_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_INV_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_INV_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_INV_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_PWM  [register's definitions]
N *              Offset[0x44]  TM Timer PWM and DTG control register
N ******************************************************************************
N */
N///@{
N#define TM_PWM_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_PWM */
N#define TM_PWM_DTG_DY_mask_w                        ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define TM_PWM_DTG_DY_mask_h0                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define TM_PWM_DTG_DY_mask_b1                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define TM_PWM_DTG_DY_shift_w                       (8)                     /*!< Bit Shift of 32bit */
N#define TM_PWM_DTG_DY_shift_h0                      (8)                     /*!< Bit Shift of 16bit */
N#define TM_PWM_DTG_DY_shift_b1                      (0)                     /*!< Bit Shift of 8bit */
N
N#define TM_PWM_PWM_MDS_mask_w                       ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define TM_PWM_PWM_MDS_mask_h0                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_PWM_PWM_MDS_mask_b0                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_PWM_PWM_MDS_edge_left_aligned_w          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Edge Left-aligned of 32bit */
N#define TM_PWM_PWM_MDS_edge_left_aligned_h0         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Edge Left-aligned of 16bit */
N#define TM_PWM_PWM_MDS_edge_left_aligned_b0         ((uint8_t )0x00)        /*!< Bit Value =(0x0):Edge Left-aligned of 8bit */
N#define TM_PWM_PWM_MDS_center_aligned_w             ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Center-aligned of 32bit */
N#define TM_PWM_PWM_MDS_center_aligned_h0            ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Center-aligned of 16bit */
N#define TM_PWM_PWM_MDS_center_aligned_b0            ((uint8_t )0x01)        /*!< Bit Value =(0x1):Center-aligned of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_BS  [register's definitions]
N *              Offset[0x48]  TM Timer break and stop control register
N ******************************************************************************
N */
N///@{
N#define TM_BS_default                               ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_BS */
N#define TM_BS_STP2N_STA_mask_w                      ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP2N_STA_mask_h1                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP2N_STA_mask_b3                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP2N_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP2N_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP2N_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP2N_STA_1_w                         ((uint32_t)0x40000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP2N_STA_1_h1                        ((uint16_t)0x4000)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP2N_STA_1_b3                        ((uint8_t )0x40)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP1N_STA_mask_w                      ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP1N_STA_mask_h1                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP1N_STA_mask_b3                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP1N_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP1N_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP1N_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP1N_STA_1_w                         ((uint32_t)0x20000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP1N_STA_1_h1                        ((uint16_t)0x2000)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP1N_STA_1_b3                        ((uint8_t )0x20)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP0N_STA_mask_w                      ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP0N_STA_mask_h1                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP0N_STA_mask_b3                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP0N_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP0N_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP0N_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP0N_STA_1_w                         ((uint32_t)0x10000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP0N_STA_1_h1                        ((uint16_t)0x1000)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP0N_STA_1_b3                        ((uint8_t )0x10)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP3_STA_mask_w                       ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP3_STA_mask_h1                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP3_STA_mask_b3                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP3_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP3_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP3_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP3_STA_1_w                          ((uint32_t)0x08000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP3_STA_1_h1                         ((uint16_t)0x0800)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP3_STA_1_b3                         ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP2_STA_mask_w                       ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP2_STA_mask_h1                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP2_STA_mask_b3                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP2_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP2_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP2_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP2_STA_1_w                          ((uint32_t)0x04000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP2_STA_1_h1                         ((uint16_t)0x0400)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP2_STA_1_b3                         ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP1_STA_mask_w                       ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP1_STA_mask_h1                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP1_STA_mask_b3                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP1_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP1_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP1_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP1_STA_1_w                          ((uint32_t)0x02000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP1_STA_1_h1                         ((uint16_t)0x0200)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP1_STA_1_b3                         ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP0_STA_mask_w                       ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP0_STA_mask_h1                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP0_STA_mask_b3                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP0_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP0_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP0_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP0_STA_1_w                          ((uint32_t)0x01000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP0_STA_1_h1                         ((uint16_t)0x0100)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP0_STA_1_b3                         ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_BK3_CTL_mask_w                        ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK3_CTL_mask_h1                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK3_CTL_mask_b2                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK3_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK3_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK3_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK3_CTL_hold_w                        ((uint32_t)0x00800000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK3_CTL_hold_h1                       ((uint16_t)0x0080)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK3_CTL_hold_b2                       ((uint8_t )0x80)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BK2_CTL_mask_w                        ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK2_CTL_mask_h1                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK2_CTL_mask_b2                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK2_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK2_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK2_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK2_CTL_hold_w                        ((uint32_t)0x00400000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK2_CTL_hold_h1                       ((uint16_t)0x0040)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK2_CTL_hold_b2                       ((uint8_t )0x40)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BK1_CTL_mask_w                        ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK1_CTL_mask_h1                       ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK1_CTL_mask_b2                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK1_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK1_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK1_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK1_CTL_hold_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK1_CTL_hold_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK1_CTL_hold_b2                       ((uint8_t )0x20)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BK0_CTL_mask_w                        ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK0_CTL_mask_h1                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK0_CTL_mask_b2                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK0_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK0_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK0_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK0_CTL_hold_w                        ((uint32_t)0x00100000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK0_CTL_hold_h1                       ((uint16_t)0x0010)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK0_CTL_hold_b2                       ((uint8_t )0x10)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BKI_EN2_mask_w                        ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKI_EN2_mask_h1                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKI_EN2_mask_b2                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKI_EN2_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKI_EN2_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKI_EN2_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKI_EN2_enable_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKI_EN2_enable_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKI_EN2_enable_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKI_EN1_mask_w                        ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKI_EN1_mask_h1                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKI_EN1_mask_b2                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKI_EN1_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKI_EN1_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKI_EN1_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKI_EN1_enable_w                      ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKI_EN1_enable_h1                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKI_EN1_enable_b2                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKI_EN0_mask_w                        ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKI_EN0_mask_h1                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKI_EN0_mask_b2                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKI_EN0_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKI_EN0_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKI_EN0_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKI_EN0_enable_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKI_EN0_enable_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKI_EN0_enable_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN7_mask_w                        ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN7_mask_h0                       ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN7_mask_b1                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN7_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN7_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN7_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN7_enable_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN7_enable_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN7_enable_b1                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN6_mask_w                        ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN6_mask_h0                       ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN6_mask_b1                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN6_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN6_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN6_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN6_enable_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN6_enable_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN6_enable_b1                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN5_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN5_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN5_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN5_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN5_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN5_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN5_enable_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN5_enable_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN5_enable_b1                     ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN4_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN4_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN4_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN4_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN4_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN4_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN4_enable_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN4_enable_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN4_enable_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN3_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN3_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN3_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN3_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN3_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN3_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN3_enable_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN3_enable_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN3_enable_b1                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN2_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN2_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN2_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN2_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN2_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN2_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN2_enable_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN2_enable_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN2_enable_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN1_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN1_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN1_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN1_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN1_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN1_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN1_enable_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN1_enable_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN1_enable_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN0_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN0_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN0_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN0_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN0_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN0_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN0_enable_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN0_enable_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN0_enable_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKSW_EN_mask_w                        ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKSW_EN_mask_h0                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKSW_EN_mask_b0                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKSW_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKSW_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKSW_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKSW_EN_enable_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKSW_EN_enable_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKSW_EN_enable_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BK_MDS_mask_w                         ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK_MDS_mask_h0                        ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK_MDS_mask_b0                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK_MDS_latch_mode_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Latch mode of 32bit */
N#define TM_BS_BK_MDS_latch_mode_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Latch mode of 16bit */
N#define TM_BS_BK_MDS_latch_mode_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Latch mode of 8bit */
N#define TM_BS_BK_MDS_cycle_by_cycle_w               ((uint32_t)0x00000010)  /*!< Bit Value =(1):Cycle by cycle of 32bit */
N#define TM_BS_BK_MDS_cycle_by_cycle_h0              ((uint16_t)0x0010)      /*!< Bit Value =(1):Cycle by cycle of 16bit */
N#define TM_BS_BK_MDS_cycle_by_cycle_b0              ((uint8_t )0x10)        /*!< Bit Value =(1):Cycle by cycle of 8bit */
N
N#define TM_BS_BK_EN3_mask_w                         ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK_EN3_mask_h0                        ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK_EN3_mask_b0                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK_EN3_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BK_EN3_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BK_EN3_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BK_EN3_enable_w                       ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BK_EN3_enable_h0                      ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BK_EN3_enable_b0                      ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BK_EN_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK_EN_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK_EN_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK_EN_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BK_EN_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BK_EN_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BK_EN_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BK_EN_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BK_EN_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC0A  [register's definitions]
N *              Offset[0x50]  TM Timer capture and compare register 0A
N ******************************************************************************
N */
N///@{
N#define TM_CC0A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC0A */
N#define TM_CC0A_CC0A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC0A_CC0A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC0A_CC0A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC0A_CC0A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC0A_CC0A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC0B  [register's definitions]
N *              Offset[0x54]  TM Timer capture and compare register 0B
N ******************************************************************************
N */
N///@{
N#define TM_CC0B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC0B */
N#define TM_CC0B_CC0B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC0B_CC0B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC0B_CC0B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC0B_CC0B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC0B_CC0B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC1A  [register's definitions]
N *              Offset[0x58]  TM Timer capture and compare register 1A
N ******************************************************************************
N */
N///@{
N#define TM_CC1A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC1A */
N#define TM_CC1A_CC1A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC1A_CC1A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC1A_CC1A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC1A_CC1A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC1A_CC1A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC1B  [register's definitions]
N *              Offset[0x5c]  TM Timer capture and compare register 1B
N ******************************************************************************
N */
N///@{
N#define TM_CC1B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC1B */
N#define TM_CC1B_CC1B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC1B_CC1B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC1B_CC1B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC1B_CC1B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC1B_CC1B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC2A  [register's definitions]
N *              Offset[0x60]  TM Timer capture and compare register 2A
N ******************************************************************************
N */
N///@{
N#define TM_CC2A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC2A */
N#define TM_CC2A_CC2A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC2A_CC2A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC2A_CC2A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC2A_CC2A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC2A_CC2A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC2B  [register's definitions]
N *              Offset[0x64]  TM Timer capture and compare register 2B
N ******************************************************************************
N */
N///@{
N#define TM_CC2B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC2B */
N#define TM_CC2B_CC2B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC2B_CC2B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC2B_CC2B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC2B_CC2B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC2B_CC2B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC3A  [register's definitions]
N *              Offset[0x68]  TM Timer capture and compare register 3A
N ******************************************************************************
N */
N///@{
N#define TM_CC3A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC3A */
N#define TM_CC3A_CC3A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC3A_CC3A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC3A_CC3A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC3A_CC3A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC3A_CC3A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC3B  [register's definitions]
N *              Offset[0x6c]  TM Timer capture and compare register 3B
N ******************************************************************************
N */
N///@{
N#define TM_CC3B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC3B */
N#define TM_CC3B_CC3B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC3B_CC3B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC3B_CC3B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC3B_CC3B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC3B_CC3B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_TM_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_TM.h                          */
N/*----------------------------------------------------------------------------*/
L 38 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_TM_MID.h" 2
N#include "MG32x02z_DMA_MID.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_DMA_MID.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DMA_MID.H
N *
N * @brief       This file provides firmware functions to manage the following 
N *              functionalities of the DMA peripheral:
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.03
N * @date        2021/04/21
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N#ifndef _MG32x02z_DMA_MID_H
N
N/*!< _MG32x02z_DMA_DRV_H */ 
N#define _MG32x02z_DMA_MID_H
N
N#include "MG32x02z.H"
N#include "MG32x02z_Common_MID.H"
N#include "MG32x02z_DMA.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_DMA.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DMA.h
N *
N * @brief       MG32x02z DMA Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_DMA_H
N#define _MG32x02z_DMA_H
N#define _MG32x02z_DMA_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_DMA_H_VER)
S    #error "MG32x02z_DMA_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      DMA_Struct
N *              DMA  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  CH0_GIF       :1;     //[0] DMA channel-0 global interrupt flag
X            volatile const  uint8_t  CH0_GIF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_TCF       :1;     //[1] DMA channel-0 transfer complete flag
X            volatile uint8_t  CH0_TCF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_THF       :1;     //[2] DMA channel-0 transfer half flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH0_THF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_ERRF      :1;     //[3] DMA channel-0 transfer error flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH0_ERRF      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t  CH1_GIF       :1;     //[4] DMA channel-1 global interrupt flag
X            volatile const  uint8_t  CH1_GIF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_TCF       :1;     //[5] DMA channel-1 transfer complete flag
X            volatile uint8_t  CH1_TCF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_THF       :1;     //[6] DMA channel-1 transfer half flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH1_THF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_ERRF      :1;     //[7] DMA channel-1 transfer error flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH1_ERRF      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t  CH2_GIF       :1;     //[8] DMA channel-2 global interrupt flag
X            volatile const  uint8_t  CH2_GIF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_TCF       :1;     //[9] DMA channel-2 transfer complete flag
X            volatile uint8_t  CH2_TCF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_THF       :1;     //[10] DMA channel-2 transfer half flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH2_THF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_ERRF      :1;     //[11] DMA channel-2 transfer error flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH2_ERRF      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :15;    //[30..16] 
X            volatile const  uint16_t               :15;    
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  DMA status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] DMA interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :15;    //[30..16] 
X            volatile const  uint16_t               :15;    
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  DMA interrupt enable register */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] DMA controller enable.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PRI_MDS       :1;     //[1] DMA channel priority mode select.
X            volatile uint8_t  PRI_MDS       :1;     
N                                        //0 = Round : control by Round Robin method
N                                        //1 = Level : control by channel priority level
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  GPL_CHS       :2;     //[5..4] DMA channel select for extra GPL function
X            volatile uint8_t  GPL_CHS       :2;     
N                                        //0x0 = Disable : no any channel with GPL function
N                                        //0x1 = CH0
N                                        //0x2 = CH1
N                                        //0x3 = CH2
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  CH0_ENB       :1;     //[16] DMA channel-0 operation enable bit. This bit is as same as DMA_CH0_EN.
X            volatile uint8_t  CH0_ENB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_ENB       :1;     //[17] DMA channel-0 operation enable bit. This bit is as same as DMA_CH1_EN.
X            volatile uint8_t  CH1_ENB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_ENB       :1;     //[18] DMA channel-0 operation enable bit. This bit is as same as DMA_CH2_EN.
X            volatile uint8_t  CH2_ENB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  DMA global control register 0 */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x14]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  MAIN_STA      :3;     //[2..0] DMA main state machine status for debug only.
X            volatile const  uint8_t  MAIN_STA      :3;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  CH_STA        :3;     //[6..4] DMA channel state machine status for debug only.
X            volatile const  uint8_t  CH_STA        :3;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  SEL_CH0       :1;     //[8] DMA channel select channel-0 status for debug only.
X            volatile const  uint8_t  SEL_CH0       :1;     
N            __I  uint8_t  SEL_CH1       :1;     //[9] DMA channel select channel-1 status for debug only.
X            volatile const  uint8_t  SEL_CH1       :1;     
N            __I  uint8_t  SEL_CH2       :1;     //[10] DMA channel select channel-2 status for debug only.
X            volatile const  uint8_t  SEL_CH2       :1;     
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  XMDS_CH0      :3;     //[18..16] DMA channel-0 XMDA control status for debug only.
X            volatile const  uint8_t  XMDS_CH0      :3;     
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  XMDS_CH1      :3;     //[22..20] DMA channel-1 XMDA control status for debug only.
X            volatile const  uint8_t  XMDS_CH1      :3;     
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  XMDS_CH2      :3;     //[26..24] DMA channel-2 XMDA control status for debug only.
X            volatile const  uint8_t  XMDS_CH2      :3;     
N            __I  uint8_t                :1;     //[27] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  DMA global control register 2 */
N
N    __I uint32_t  RESERVED2;            /*!< RESERVED2  ~ Offset[0x1C]  Reserved */
X    volatile const uint32_t  RESERVED2;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH0_EN        :1;     //[0] DMA channel operation enable
X            volatile uint8_t  CH0_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_HOLD      :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  CH0_HOLD      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_LOOP      :1;     //[2] DMA loop mode enable
X            volatile uint8_t  CH0_LOOP      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_ADSEL     :1;     //[3] DMA address increased mode select
X            volatile uint8_t  CH0_ADSEL     :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_XMDS      :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  CH0_XMDS      :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  CH0_PLS       :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  CH0_PLS       :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  CH0_BSIZE     :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  CH0_BSIZE     :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_REQ       :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  CH0_REQ       :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_CIE       :1;     //[17] DMA channel-0 transfer complete interrupt enable.
X            volatile uint8_t  CH0_CIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_HIE       :1;     //[18] DMA channel-0 transfer half interrupt enable.
X            volatile uint8_t  CH0_HIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_EIE       :1;     //[19] DMA channel-0 transfer error interrupt enable.
X            volatile uint8_t  CH0_EIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_TC2F      :1;     //[25] DMA channel-0 transfer complete flag
X            volatile uint8_t  CH0_TC2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_TH2F      :1;     //[26] DMA channel-0 transfer half flag
X            volatile uint8_t  CH0_TH2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_ERR2F     :1;     //[27] DMA channel-0 transfer error flag
X            volatile uint8_t  CH0_ERR2F     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CH0A;                              /*!< CH0A       ~ Offset[0x20]  DMA channel-0 control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH0_SRC       :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  CH0_SRC       :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH0_DET       :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  CH0_DET       :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH0_SINC      :1;     //[16] DMA source memory transfer address auto increased enable
X            volatile uint8_t  CH0_SINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_DINC      :1;     //[17] DMA destination memory transfer address auto increased enable
X            volatile uint8_t  CH0_DINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_SSYNC     :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  CH0_SSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_DSYNC     :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  CH0_DSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH0_XPIN      :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  CH0_XPIN      :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CH0B;                              /*!< CH0B       ~ Offset[0x24]  DMA channel-0 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CH0_NUM       :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t CH0_NUM       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH0NUM;                            /*!< CH0NUM     ~ Offset[0x28]  DMA channel-0 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CH0_CNT       :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CH0_CNT       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH0CNT;                            /*!< CH0CNT     ~ Offset[0x2C]  DMA channel-0 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH0_SSA       :32;    //[31..0] DMA source memory transfer start address.
X            volatile uint32_t CH0_SSA       :32;    
N        }MBIT;
N    }CH0SSA;                            /*!< CH0SSA     ~ Offset[0x30]  DMA channel-0 source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH0_SCA       :32;    //[31..0] DMA source memory transfer current address
X            volatile const  uint32_t CH0_SCA       :32;    
N        }MBIT;
N    }CH0SCA;                            /*!< CH0SCA     ~ Offset[0x34]  DMA channel-0 source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH0_DSA       :32;    //[31..0] DMA destination memory transfer start address.
X            volatile uint32_t CH0_DSA       :32;    
N        }MBIT;
N    }CH0DSA;                            /*!< CH0DSA     ~ Offset[0x38]  DMA channel-0 destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH0_DCA       :32;    //[31..0] DMA destination memory transfer current address
X            volatile const  uint32_t CH0_DCA       :32;    
N        }MBIT;
N    }CH0DCA;                            /*!< CH0DCA     ~ Offset[0x3C]  DMA channel-0 destination current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH1_EN        :1;     //[0] DMA channel operation enable
X            volatile uint8_t  CH1_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_HOLD      :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  CH1_HOLD      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_LOOP      :1;     //[2] DMA loop mode enable
X            volatile uint8_t  CH1_LOOP      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_ADSEL     :1;     //[3] DMA address increased mode select
X            volatile uint8_t  CH1_ADSEL     :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_XMDS      :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  CH1_XMDS      :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  CH1_PLS       :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  CH1_PLS       :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  CH1_BSIZE     :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  CH1_BSIZE     :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_REQ       :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  CH1_REQ       :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_CIE       :1;     //[17] DMA channel-1 transfer complete interrupt enable.
X            volatile uint8_t  CH1_CIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_HIE       :1;     //[18] DMA channel-1 transfer half interrupt enable.
X            volatile uint8_t  CH1_HIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_EIE       :1;     //[19] DMA channel-1 transfer error interrupt enable.
X            volatile uint8_t  CH1_EIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_TC2F      :1;     //[25] DMA channel-1 transfer complete flag
X            volatile uint8_t  CH1_TC2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_TH2F      :1;     //[26] DMA channel-1 transfer half flag
X            volatile uint8_t  CH1_TH2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_ERR2F     :1;     //[27] DMA channel-1 transfer error flag
X            volatile uint8_t  CH1_ERR2F     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CH1A;                              /*!< CH1A       ~ Offset[0x40]  DMA channel-1 control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH1_SRC       :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  CH1_SRC       :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH1_DET       :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  CH1_DET       :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH1_SINC      :1;     //[16] DMA source memory transfer address auto increased enable
X            volatile uint8_t  CH1_SINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_DINC      :1;     //[17] DMA destination memory transfer address auto increased enable
X            volatile uint8_t  CH1_DINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_SSYNC     :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  CH1_SSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_DSYNC     :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  CH1_DSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH1_XPIN      :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  CH1_XPIN      :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CH1B;                              /*!< CH1B       ~ Offset[0x44]  DMA channel-1 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CH1_NUM       :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t CH1_NUM       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH1NUM;                            /*!< CH1NUM     ~ Offset[0x48]  DMA channel-1 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CH1_CNT       :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CH1_CNT       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH1CNT;                            /*!< CH1CNT     ~ Offset[0x4C]  DMA channel-1 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH1_SSA       :32;    //[31..0] DMA source memory transfer start address.
X            volatile uint32_t CH1_SSA       :32;    
N        }MBIT;
N    }CH1SSA;                            /*!< CH1SSA     ~ Offset[0x50]  DMA channel-1 source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH1_SCA       :32;    //[31..0] DMA source memory transfer current address
X            volatile const  uint32_t CH1_SCA       :32;    
N        }MBIT;
N    }CH1SCA;                            /*!< CH1SCA     ~ Offset[0x54]  DMA channel-1 source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH1_DSA       :32;    //[31..0] DMA destination memory transfer start address.
X            volatile uint32_t CH1_DSA       :32;    
N        }MBIT;
N    }CH1DSA;                            /*!< CH1DSA     ~ Offset[0x58]  DMA channel-1 destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH1_DCA       :32;    //[31..0] DMA destination memory transfer current address
X            volatile const  uint32_t CH1_DCA       :32;    
N        }MBIT;
N    }CH1DCA;                            /*!< CH1DCA     ~ Offset[0x5C]  DMA channel-1 destination current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH2_EN        :1;     //[0] DMA channel operation enable
X            volatile uint8_t  CH2_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_HOLD      :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  CH2_HOLD      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_LOOP      :1;     //[2] DMA loop mode enable
X            volatile uint8_t  CH2_LOOP      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_ADSEL     :1;     //[3] DMA address increased mode select
X            volatile uint8_t  CH2_ADSEL     :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_XMDS      :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  CH2_XMDS      :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  CH2_PLS       :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  CH2_PLS       :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  CH2_BSIZE     :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  CH2_BSIZE     :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_REQ       :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  CH2_REQ       :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_CIE       :1;     //[17] DMA channel-2 transfer complete interrupt enable.
X            volatile uint8_t  CH2_CIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_HIE       :1;     //[18] DMA channel-2 transfer half interrupt enable.
X            volatile uint8_t  CH2_HIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_EIE       :1;     //[19] DMA channel-2 transfer error interrupt enable.
X            volatile uint8_t  CH2_EIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_TC2F      :1;     //[25] DMA channel-2 transfer complete flag
X            volatile uint8_t  CH2_TC2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_TH2F      :1;     //[26] DMA channel-2 transfer half flag
X            volatile uint8_t  CH2_TH2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_ERR2F     :1;     //[27] DMA channel-2 transfer error flag
X            volatile uint8_t  CH2_ERR2F     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CH2A;                              /*!< CH2A       ~ Offset[0x60]  DMA channel-2 control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH2_SRC       :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  CH2_SRC       :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH2_DET       :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  CH2_DET       :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH2_SINC      :1;     //[16] DMA source memory transfer address auto increased enable
X            volatile uint8_t  CH2_SINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_DINC      :1;     //[17] DMA destination memory transfer address auto increased enable
X            volatile uint8_t  CH2_DINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_SSYNC     :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  CH2_SSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_DSYNC     :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  CH2_DSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH2_XPIN      :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  CH2_XPIN      :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CH2B;                              /*!< CH2B       ~ Offset[0x64]  DMA channel-2 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CH2_NUM       :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t CH2_NUM       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH2NUM;                            /*!< CH2NUM     ~ Offset[0x68]  DMA channel-2 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CH2_CNT       :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CH2_CNT       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH2CNT;                            /*!< CH2CNT     ~ Offset[0x6C]  DMA channel-2 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH2_SSA       :32;    //[31..0] DMA source memory transfer start address.
X            volatile uint32_t CH2_SSA       :32;    
N        }MBIT;
N    }CH2SSA;                            /*!< CH2SSA     ~ Offset[0x70]  DMA channel-2 source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH2_SCA       :32;    //[31..0] DMA source memory transfer current address
X            volatile const  uint32_t CH2_SCA       :32;    
N        }MBIT;
N    }CH2SCA;                            /*!< CH2SCA     ~ Offset[0x74]  DMA channel-2 source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH2_DSA       :32;    //[31..0] DMA destination memory transfer start address.
X            volatile uint32_t CH2_DSA       :32;    
N        }MBIT;
N    }CH2DSA;                            /*!< CH2DSA     ~ Offset[0x78]  DMA channel-2 destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH2_DCA       :32;    //[31..0] DMA destination memory transfer current address
X            volatile const  uint32_t CH2_DCA       :32;    
N        }MBIT;
N    }CH2DCA;                            /*!< CH2DCA     ~ Offset[0x7C]  DMA channel-2 destination current address register */
N
N} DMA_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        DMA  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define DMA_Base                        ((uint32_t)0x4BF00000)              /*!< Direct Memory Access Control */
N#define DMA                             ((DMA_Struct*) DMA_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        DMA  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        DMA_STA  [register's definitions]
N *              Offset[0x00]  DMA status register (0x4BF00000)
N ******************************************************************************
N */
N///@{
N#define DMA_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_STA */
N#define DMA_STA_CH2_ERRF_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_ERRF_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_ERRF_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_ERRF_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_ERRF_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_ERRF_normal_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_ERRF_happened_w                 ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_ERRF_happened_h0                ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_ERRF_happened_b1                ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH2_THF_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_THF_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_THF_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_THF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_THF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_THF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_THF_happened_w                  ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_THF_happened_h0                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_THF_happened_b1                 ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH2_TCF_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_TCF_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_TCF_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_TCF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_TCF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_TCF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_TCF_happened_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_TCF_happened_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_TCF_happened_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH2_GIF_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_GIF_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_GIF_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_GIF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_GIF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_GIF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_GIF_happened_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_GIF_happened_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_GIF_happened_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_ERRF_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_ERRF_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_ERRF_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_ERRF_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_ERRF_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_ERRF_normal_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_ERRF_happened_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_ERRF_happened_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_ERRF_happened_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_THF_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_THF_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_THF_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_THF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_THF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_THF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_THF_happened_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_THF_happened_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_THF_happened_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_TCF_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_TCF_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_TCF_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_TCF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_TCF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_TCF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_TCF_happened_w                  ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_TCF_happened_h0                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_TCF_happened_b0                 ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_GIF_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_GIF_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_GIF_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_GIF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_GIF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_GIF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_GIF_happened_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_GIF_happened_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_GIF_happened_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_ERRF_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_ERRF_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_ERRF_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_ERRF_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_ERRF_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_ERRF_normal_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_ERRF_happened_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_ERRF_happened_h0                ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_ERRF_happened_b0                ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_THF_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_THF_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_THF_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_THF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_THF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_THF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_THF_happened_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_THF_happened_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_THF_happened_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_TCF_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_TCF_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_TCF_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_TCF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_TCF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_TCF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_TCF_happened_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_TCF_happened_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_TCF_happened_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_GIF_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_GIF_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_GIF_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_GIF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_GIF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_GIF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_GIF_happened_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_GIF_happened_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_GIF_happened_b0                 ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_INT  [register's definitions]
N *              Offset[0x04]  DMA interrupt enable register (0x4BF00004)
N ******************************************************************************
N */
N///@{
N#define DMA_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_INT */
N#define DMA_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CR0  [register's definitions]
N *              Offset[0x10]  DMA global control register 0 (0x4BF00010)
N ******************************************************************************
N */
N///@{
N#define DMA_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CR0 */
N#define DMA_CR0_CH2_ENB_mask_w                      ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_CH2_ENB_mask_h1                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_CH2_ENB_mask_b2                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_CH2_ENB_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_CH2_ENB_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_CH2_ENB_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_CH2_ENB_enable_w                    ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_CH2_ENB_enable_h1                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_CH2_ENB_enable_b2                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CR0_CH1_ENB_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_CH1_ENB_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_CH1_ENB_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_CH1_ENB_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_CH1_ENB_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_CH1_ENB_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_CH1_ENB_enable_w                    ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_CH1_ENB_enable_h1                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_CH1_ENB_enable_b2                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CR0_CH0_ENB_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_CH0_ENB_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_CH0_ENB_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_CH0_ENB_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_CH0_ENB_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_CH0_ENB_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_CH0_ENB_enable_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_CH0_ENB_enable_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_CH0_ENB_enable_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CR0_GPL_CHS_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_GPL_CHS_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_GPL_CHS_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_GPL_CHS_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CR0_GPL_CHS_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CR0_GPL_CHS_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CR0_GPL_CHS_ch0_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):CH0 of 32bit */
N#define DMA_CR0_GPL_CHS_ch0_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):CH0 of 16bit */
N#define DMA_CR0_GPL_CHS_ch0_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):CH0 of 8bit */
N#define DMA_CR0_GPL_CHS_ch1_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):CH1 of 32bit */
N#define DMA_CR0_GPL_CHS_ch1_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):CH1 of 16bit */
N#define DMA_CR0_GPL_CHS_ch1_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):CH1 of 8bit */
N#define DMA_CR0_GPL_CHS_ch2_w                       ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):CH2 of 32bit */
N#define DMA_CR0_GPL_CHS_ch2_h0                      ((uint16_t)0x0030)      /*!< Bit Value =(0x3):CH2 of 16bit */
N#define DMA_CR0_GPL_CHS_ch2_b0                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):CH2 of 8bit */
N
N#define DMA_CR0_PRI_MDS_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_PRI_MDS_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_PRI_MDS_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_PRI_MDS_round_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Round of 32bit */
N#define DMA_CR0_PRI_MDS_round_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Round of 16bit */
N#define DMA_CR0_PRI_MDS_round_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Round of 8bit */
N#define DMA_CR0_PRI_MDS_level_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Level of 32bit */
N#define DMA_CR0_PRI_MDS_level_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Level of 16bit */
N#define DMA_CR0_PRI_MDS_level_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Level of 8bit */
N
N#define DMA_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CR2  [register's definitions]
N *              Offset[0x18]  DMA global control register 2 (0x4BF00018)
N ******************************************************************************
N */
N///@{
N#define DMA_CR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CR2 */
N#define DMA_CR2_XMDS_CH2_mask_w                     ((uint32_t)0x07000000)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_XMDS_CH2_mask_h1                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_XMDS_CH2_mask_b3                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_XMDS_CH2_shift_w                    (24)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_XMDS_CH2_shift_h1                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_XMDS_CH2_shift_b3                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_XMDS_CH1_mask_w                     ((uint32_t)0x00700000)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_XMDS_CH1_mask_h1                    ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_XMDS_CH1_mask_b2                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_XMDS_CH1_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_XMDS_CH1_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_XMDS_CH1_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_XMDS_CH0_mask_w                     ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_XMDS_CH0_mask_h1                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_XMDS_CH0_mask_b2                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_XMDS_CH0_shift_w                    (16)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_XMDS_CH0_shift_h1                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_XMDS_CH0_shift_b2                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_SEL_CH2_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_SEL_CH2_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_SEL_CH2_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_SEL_CH2_shift_w                     (10)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_SEL_CH2_shift_h0                    (10)                    /*!< Bit Shift of 16bit */
N#define DMA_CR2_SEL_CH2_shift_b1                    (2)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_SEL_CH1_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_SEL_CH1_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_SEL_CH1_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_SEL_CH1_shift_w                     (9)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_SEL_CH1_shift_h0                    (9)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_SEL_CH1_shift_b1                    (1)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_SEL_CH0_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_SEL_CH0_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_SEL_CH0_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_SEL_CH0_shift_w                     (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_SEL_CH0_shift_h0                    (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_SEL_CH0_shift_b1                    (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_CH_STA_mask_w                       ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_CH_STA_mask_h0                      ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_CH_STA_mask_b0                      ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_CH_STA_shift_w                      (4)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_CH_STA_shift_h0                     (4)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_CH_STA_shift_b0                     (4)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_MAIN_STA_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_MAIN_STA_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_MAIN_STA_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_MAIN_STA_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_MAIN_STA_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_MAIN_STA_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0A  [register's definitions]
N *              Offset[0x20]  DMA channel-0 control register 0 (0x4BF00020)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0A_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0A */
N#define DMA_CH0A_CH0_ERR2F_mask_w                   ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_ERR2F_mask_h1                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_ERR2F_mask_b3                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_ERR2F_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_ERR2F_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_ERR2F_normal_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_ERR2F_happened_w               ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH0A_CH0_ERR2F_happened_h1              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH0A_CH0_ERR2F_happened_b3              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH0A_CH0_TH2F_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_TH2F_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_TH2F_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_TH2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_TH2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_TH2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_TH2F_happened_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH0A_CH0_TH2F_happened_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH0A_CH0_TH2F_happened_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH0A_CH0_TC2F_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_TC2F_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_TC2F_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_TC2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_TC2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_TC2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_TC2F_happened_w                ((uint32_t)0x02000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH0A_CH0_TC2F_happened_h1               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH0A_CH0_TC2F_happened_b3               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH0A_CH0_EIE_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_EIE_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_EIE_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_EIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_EIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_EIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_EIE_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_EIE_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_EIE_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_HIE_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_HIE_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_HIE_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_HIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_HIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_HIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_HIE_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_HIE_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_HIE_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_CIE_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_CIE_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_CIE_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_CIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_CIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_CIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_CIE_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_CIE_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_CIE_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_REQ_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_REQ_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_REQ_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_REQ_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define DMA_CH0A_CH0_REQ_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define DMA_CH0A_CH0_REQ_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define DMA_CH0A_CH0_REQ_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_REQ_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_REQ_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_BSIZE_mask_w                   ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_BSIZE_mask_h0                  ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_BSIZE_mask_b1                  ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_BSIZE_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define DMA_CH0A_CH0_BSIZE_one_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define DMA_CH0A_CH0_BSIZE_one_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define DMA_CH0A_CH0_BSIZE_two_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Two of 32bit */
N#define DMA_CH0A_CH0_BSIZE_two_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Two of 16bit */
N#define DMA_CH0A_CH0_BSIZE_two_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):Two of 8bit */
N#define DMA_CH0A_CH0_BSIZE_four_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Four of 32bit */
N#define DMA_CH0A_CH0_BSIZE_four_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Four of 16bit */
N#define DMA_CH0A_CH0_BSIZE_four_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):Four of 8bit */
N
N#define DMA_CH0A_CH0_PLS_mask_w                     ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_PLS_mask_h0                    ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_PLS_mask_b1                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_PLS_lv0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):LV0 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):LV0 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv0_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):LV0 of 8bit */
N#define DMA_CH0A_CH0_PLS_lv1_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):LV1 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv1_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LV1 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv1_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):LV1 of 8bit */
N#define DMA_CH0A_CH0_PLS_lv2_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):LV2 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv2_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):LV2 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv2_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):LV2 of 8bit */
N#define DMA_CH0A_CH0_PLS_lv3_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):LV3 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv3_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):LV3 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv3_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):LV3 of 8bit */
N
N#define DMA_CH0A_CH0_XMDS_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_XMDS_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_XMDS_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_XMDS_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CH0A_CH0_XMDS_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CH0A_CH0_XMDS_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CH0A_CH0_XMDS_single_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Single of 32bit */
N#define DMA_CH0A_CH0_XMDS_single_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Single of 16bit */
N#define DMA_CH0A_CH0_XMDS_single_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):Single of 8bit */
N#define DMA_CH0A_CH0_XMDS_block_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Block of 32bit */
N#define DMA_CH0A_CH0_XMDS_block_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Block of 16bit */
N#define DMA_CH0A_CH0_XMDS_block_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Block of 8bit */
N#define DMA_CH0A_CH0_XMDS_demand_w                  ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Demand of 32bit */
N#define DMA_CH0A_CH0_XMDS_demand_h0                 ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Demand of 16bit */
N#define DMA_CH0A_CH0_XMDS_demand_b1                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):Demand of 8bit */
N
N#define DMA_CH0A_CH0_ADSEL_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_ADSEL_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_ADSEL_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_ADSEL_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_ADSEL_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_ADSEL_normal_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_ADSEL_skip3_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):SKIP3 of 32bit */
N#define DMA_CH0A_CH0_ADSEL_skip3_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):SKIP3 of 16bit */
N#define DMA_CH0A_CH0_ADSEL_skip3_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):SKIP3 of 8bit */
N
N#define DMA_CH0A_CH0_LOOP_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_LOOP_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_LOOP_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_LOOP_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_LOOP_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_LOOP_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_LOOP_enable_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_LOOP_enable_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_LOOP_enable_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_HOLD_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_HOLD_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_HOLD_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_HOLD_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_HOLD_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_HOLD_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_HOLD_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_HOLD_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_HOLD_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0B  [register's definitions]
N *              Offset[0x24]  DMA channel-0 control register 1 (0x4BF00024)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0B_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0B */
N#define DMA_CH0B_CH0_XPIN_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_XPIN_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_XPIN_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_XPIN_trg0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define DMA_CH0B_CH0_XPIN_trg0_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define DMA_CH0B_CH0_XPIN_trg0_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define DMA_CH0B_CH0_XPIN_trg1_w                    ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define DMA_CH0B_CH0_XPIN_trg1_h1                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define DMA_CH0B_CH0_XPIN_trg1_b3                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N
N#define DMA_CH0B_CH0_DSYNC_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_DSYNC_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_DSYNC_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_DSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_DSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_DSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_DSYNC_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_DSYNC_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_DSYNC_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_SSYNC_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_SSYNC_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_SSYNC_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_SSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_SSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_SSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_SSYNC_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_SSYNC_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_SSYNC_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_DINC_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_DINC_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_DINC_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_DINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_DINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_DINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_DINC_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_DINC_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_DINC_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_SINC_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_SINC_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_SINC_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_SINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_SINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_SINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_SINC_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_SINC_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_SINC_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_DET_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_DET_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_DET_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_DET_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0B_CH0_DET_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0B_CH0_DET_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CH0B_CH0_SRC_mask_w                     ((uint32_t)0x0000000F)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_SRC_mask_h0                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_SRC_mask_b0                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_SRC_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0B_CH0_SRC_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0B_CH0_SRC_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0NUM  [register's definitions]
N *              Offset[0x28]  DMA channel-0 control register 1 (0x4BF00028)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0NUM_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0NUM */
N#define DMA_CH0NUM_CH0_NUM_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0NUM_CH0_NUM_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH0NUM_CH0_NUM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0NUM_CH0_NUM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0NUM_CH0_NUM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0CNT  [register's definitions]
N *              Offset[0x2C]  DMA channel-0 control register 1 (0x4BF0002C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0CNT_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0CNT */
N#define DMA_CH0CNT_CH0_CNT_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0CNT_CH0_CNT_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH0CNT_CH0_CNT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0CNT_CH0_CNT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0CNT_CH0_CNT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0SSA  [register's definitions]
N *              Offset[0x30]  DMA channel-0 source start address register (0x4BF00030)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0SSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0SSA */
N#define DMA_CH0SSA_CH0_SSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0SSA_CH0_SSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0SSA_CH0_SSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0SSA_CH0_SSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0SCA  [register's definitions]
N *              Offset[0x34]  DMA channel-0 source current address register (0x4BF00034)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0SCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0SCA */
N#define DMA_CH0SCA_CH0_SCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0SCA_CH0_SCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0SCA_CH0_SCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0SCA_CH0_SCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0DSA  [register's definitions]
N *              Offset[0x38]  DMA channel-0 destination start address register (0x4BF00038)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0DSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0DSA */
N#define DMA_CH0DSA_CH0_DSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0DSA_CH0_DSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0DSA_CH0_DSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0DSA_CH0_DSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0DCA  [register's definitions]
N *              Offset[0x3C]  DMA channel-0 destination current address register (0x4BF0003C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0DCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0DCA */
N#define DMA_CH0DCA_CH0_DCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0DCA_CH0_DCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0DCA_CH0_DCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0DCA_CH0_DCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1A  [register's definitions]
N *              Offset[0x40]  DMA channel-1 control register 0 (0x4BF00040)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1A_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1A */
N#define DMA_CH1A_CH1_ERR2F_mask_w                   ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_ERR2F_mask_h1                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_ERR2F_mask_b3                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_ERR2F_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_ERR2F_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_ERR2F_normal_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_ERR2F_happened_w               ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH1A_CH1_ERR2F_happened_h1              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH1A_CH1_ERR2F_happened_b3              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH1A_CH1_TH2F_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_TH2F_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_TH2F_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_TH2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_TH2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_TH2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_TH2F_happened_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH1A_CH1_TH2F_happened_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH1A_CH1_TH2F_happened_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH1A_CH1_TC2F_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_TC2F_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_TC2F_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_TC2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_TC2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_TC2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_TC2F_happened_w                ((uint32_t)0x02000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH1A_CH1_TC2F_happened_h1               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH1A_CH1_TC2F_happened_b3               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH1A_CH1_EIE_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_EIE_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_EIE_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_EIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_EIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_EIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_EIE_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_EIE_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_EIE_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_HIE_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_HIE_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_HIE_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_HIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_HIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_HIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_HIE_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_HIE_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_HIE_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_CIE_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_CIE_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_CIE_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_CIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_CIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_CIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_CIE_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_CIE_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_CIE_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_REQ_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_REQ_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_REQ_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_REQ_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define DMA_CH1A_CH1_REQ_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define DMA_CH1A_CH1_REQ_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define DMA_CH1A_CH1_REQ_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_REQ_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_REQ_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_BSIZE_mask_w                   ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_BSIZE_mask_h0                  ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_BSIZE_mask_b1                  ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_BSIZE_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define DMA_CH1A_CH1_BSIZE_one_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define DMA_CH1A_CH1_BSIZE_one_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define DMA_CH1A_CH1_BSIZE_two_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Two of 32bit */
N#define DMA_CH1A_CH1_BSIZE_two_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Two of 16bit */
N#define DMA_CH1A_CH1_BSIZE_two_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):Two of 8bit */
N#define DMA_CH1A_CH1_BSIZE_four_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Four of 32bit */
N#define DMA_CH1A_CH1_BSIZE_four_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Four of 16bit */
N#define DMA_CH1A_CH1_BSIZE_four_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):Four of 8bit */
N
N#define DMA_CH1A_CH1_PLS_mask_w                     ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_PLS_mask_h0                    ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_PLS_mask_b1                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_PLS_lv0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):LV0 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):LV0 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv0_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):LV0 of 8bit */
N#define DMA_CH1A_CH1_PLS_lv1_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):LV1 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv1_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LV1 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv1_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):LV1 of 8bit */
N#define DMA_CH1A_CH1_PLS_lv2_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):LV2 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv2_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):LV2 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv2_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):LV2 of 8bit */
N#define DMA_CH1A_CH1_PLS_lv3_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):LV3 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv3_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):LV3 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv3_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):LV3 of 8bit */
N
N#define DMA_CH1A_CH1_XMDS_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_XMDS_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_XMDS_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_XMDS_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CH1A_CH1_XMDS_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CH1A_CH1_XMDS_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CH1A_CH1_XMDS_single_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Single of 32bit */
N#define DMA_CH1A_CH1_XMDS_single_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Single of 16bit */
N#define DMA_CH1A_CH1_XMDS_single_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):Single of 8bit */
N#define DMA_CH1A_CH1_XMDS_block_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Block of 32bit */
N#define DMA_CH1A_CH1_XMDS_block_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Block of 16bit */
N#define DMA_CH1A_CH1_XMDS_block_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Block of 8bit */
N#define DMA_CH1A_CH1_XMDS_demand_w                  ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Demand of 32bit */
N#define DMA_CH1A_CH1_XMDS_demand_h0                 ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Demand of 16bit */
N#define DMA_CH1A_CH1_XMDS_demand_b1                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):Demand of 8bit */
N
N#define DMA_CH1A_CH1_ADSEL_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_ADSEL_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_ADSEL_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_ADSEL_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_ADSEL_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_ADSEL_normal_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_ADSEL_skip3_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):SKIP3 of 32bit */
N#define DMA_CH1A_CH1_ADSEL_skip3_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):SKIP3 of 16bit */
N#define DMA_CH1A_CH1_ADSEL_skip3_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):SKIP3 of 8bit */
N
N#define DMA_CH1A_CH1_LOOP_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_LOOP_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_LOOP_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_LOOP_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_LOOP_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_LOOP_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_LOOP_enable_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_LOOP_enable_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_LOOP_enable_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_HOLD_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_HOLD_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_HOLD_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_HOLD_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_HOLD_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_HOLD_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_HOLD_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_HOLD_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_HOLD_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1B  [register's definitions]
N *              Offset[0x44]  DMA channel-1 control register 1 (0x4BF00044)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1B_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1B */
N#define DMA_CH1B_CH1_XPIN_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_XPIN_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_XPIN_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_XPIN_trg0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define DMA_CH1B_CH1_XPIN_trg0_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define DMA_CH1B_CH1_XPIN_trg0_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define DMA_CH1B_CH1_XPIN_trg1_w                    ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define DMA_CH1B_CH1_XPIN_trg1_h1                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define DMA_CH1B_CH1_XPIN_trg1_b3                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N
N#define DMA_CH1B_CH1_DSYNC_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_DSYNC_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_DSYNC_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_DSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_DSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_DSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_DSYNC_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_DSYNC_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_DSYNC_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_SSYNC_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_SSYNC_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_SSYNC_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_SSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_SSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_SSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_SSYNC_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_SSYNC_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_SSYNC_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_DINC_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_DINC_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_DINC_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_DINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_DINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_DINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_DINC_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_DINC_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_DINC_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_SINC_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_SINC_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_SINC_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_SINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_SINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_SINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_SINC_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_SINC_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_SINC_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_DET_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_DET_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_DET_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_DET_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1B_CH1_DET_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1B_CH1_DET_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CH1B_CH1_SRC_mask_w                     ((uint32_t)0x0000000F)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_SRC_mask_h0                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_SRC_mask_b0                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_SRC_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1B_CH1_SRC_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1B_CH1_SRC_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1NUM  [register's definitions]
N *              Offset[0x48]  DMA channel-1 control register 1 (0x4BF00048)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1NUM_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1NUM */
N#define DMA_CH1NUM_CH1_NUM_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1NUM_CH1_NUM_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH1NUM_CH1_NUM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1NUM_CH1_NUM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1NUM_CH1_NUM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1CNT  [register's definitions]
N *              Offset[0x4C]  DMA channel-1 control register 1 (0x4BF0004C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1CNT_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1CNT */
N#define DMA_CH1CNT_CH1_CNT_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1CNT_CH1_CNT_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH1CNT_CH1_CNT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1CNT_CH1_CNT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1CNT_CH1_CNT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1SSA  [register's definitions]
N *              Offset[0x50]  DMA channel-1 source start address register (0x4BF00050)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1SSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1SSA */
N#define DMA_CH1SSA_CH1_SSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1SSA_CH1_SSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1SSA_CH1_SSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1SSA_CH1_SSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1SCA  [register's definitions]
N *              Offset[0x54]  DMA channel-1 source current address register (0x4BF00054)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1SCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1SCA */
N#define DMA_CH1SCA_CH1_SCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1SCA_CH1_SCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1SCA_CH1_SCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1SCA_CH1_SCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1DSA  [register's definitions]
N *              Offset[0x58]  DMA channel-1 destination start address register (0x4BF00058)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1DSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1DSA */
N#define DMA_CH1DSA_CH1_DSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1DSA_CH1_DSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1DSA_CH1_DSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1DSA_CH1_DSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1DCA  [register's definitions]
N *              Offset[0x5C]  DMA channel-1 destination current address register (0x4BF0005C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1DCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1DCA */
N#define DMA_CH1DCA_CH1_DCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1DCA_CH1_DCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1DCA_CH1_DCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1DCA_CH1_DCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2A  [register's definitions]
N *              Offset[0x60]  DMA channel-2 control register 0 (0x4BF00060)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2A_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2A */
N#define DMA_CH2A_CH2_ERR2F_mask_w                   ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_ERR2F_mask_h1                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_ERR2F_mask_b3                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_ERR2F_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_ERR2F_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_ERR2F_normal_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_ERR2F_happened_w               ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH2A_CH2_ERR2F_happened_h1              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH2A_CH2_ERR2F_happened_b3              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH2A_CH2_TH2F_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_TH2F_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_TH2F_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_TH2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_TH2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_TH2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_TH2F_happened_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH2A_CH2_TH2F_happened_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH2A_CH2_TH2F_happened_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH2A_CH2_TC2F_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_TC2F_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_TC2F_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_TC2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_TC2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_TC2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_TC2F_happened_w                ((uint32_t)0x02000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH2A_CH2_TC2F_happened_h1               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH2A_CH2_TC2F_happened_b3               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH2A_CH2_EIE_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_EIE_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_EIE_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_EIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_EIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_EIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_EIE_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_EIE_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_EIE_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_HIE_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_HIE_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_HIE_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_HIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_HIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_HIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_HIE_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_HIE_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_HIE_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_CIE_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_CIE_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_CIE_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_CIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_CIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_CIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_CIE_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_CIE_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_CIE_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_REQ_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_REQ_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_REQ_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_REQ_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define DMA_CH2A_CH2_REQ_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define DMA_CH2A_CH2_REQ_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define DMA_CH2A_CH2_REQ_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_REQ_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_REQ_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_BSIZE_mask_w                   ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_BSIZE_mask_h0                  ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_BSIZE_mask_b1                  ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_BSIZE_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define DMA_CH2A_CH2_BSIZE_one_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define DMA_CH2A_CH2_BSIZE_one_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define DMA_CH2A_CH2_BSIZE_two_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Two of 32bit */
N#define DMA_CH2A_CH2_BSIZE_two_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Two of 16bit */
N#define DMA_CH2A_CH2_BSIZE_two_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):Two of 8bit */
N#define DMA_CH2A_CH2_BSIZE_four_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Four of 32bit */
N#define DMA_CH2A_CH2_BSIZE_four_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Four of 16bit */
N#define DMA_CH2A_CH2_BSIZE_four_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):Four of 8bit */
N
N#define DMA_CH2A_CH2_PLS_mask_w                     ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_PLS_mask_h0                    ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_PLS_mask_b1                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_PLS_lv0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):LV0 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):LV0 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv0_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):LV0 of 8bit */
N#define DMA_CH2A_CH2_PLS_lv1_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):LV1 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv1_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LV1 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv1_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):LV1 of 8bit */
N#define DMA_CH2A_CH2_PLS_lv2_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):LV2 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv2_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):LV2 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv2_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):LV2 of 8bit */
N#define DMA_CH2A_CH2_PLS_lv3_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):LV3 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv3_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):LV3 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv3_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):LV3 of 8bit */
N
N#define DMA_CH2A_CH2_XMDS_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_XMDS_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_XMDS_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_XMDS_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CH2A_CH2_XMDS_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CH2A_CH2_XMDS_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CH2A_CH2_XMDS_single_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Single of 32bit */
N#define DMA_CH2A_CH2_XMDS_single_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Single of 16bit */
N#define DMA_CH2A_CH2_XMDS_single_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):Single of 8bit */
N#define DMA_CH2A_CH2_XMDS_block_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Block of 32bit */
N#define DMA_CH2A_CH2_XMDS_block_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Block of 16bit */
N#define DMA_CH2A_CH2_XMDS_block_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Block of 8bit */
N#define DMA_CH2A_CH2_XMDS_demand_w                  ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Demand of 32bit */
N#define DMA_CH2A_CH2_XMDS_demand_h0                 ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Demand of 16bit */
N#define DMA_CH2A_CH2_XMDS_demand_b1                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):Demand of 8bit */
N
N#define DMA_CH2A_CH2_ADSEL_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_ADSEL_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_ADSEL_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_ADSEL_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_ADSEL_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_ADSEL_normal_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_ADSEL_skip3_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):SKIP3 of 32bit */
N#define DMA_CH2A_CH2_ADSEL_skip3_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):SKIP3 of 16bit */
N#define DMA_CH2A_CH2_ADSEL_skip3_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):SKIP3 of 8bit */
N
N#define DMA_CH2A_CH2_LOOP_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_LOOP_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_LOOP_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_LOOP_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_LOOP_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_LOOP_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_LOOP_enable_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_LOOP_enable_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_LOOP_enable_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_HOLD_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_HOLD_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_HOLD_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_HOLD_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_HOLD_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_HOLD_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_HOLD_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_HOLD_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_HOLD_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2B  [register's definitions]
N *              Offset[0x64]  DMA channel-2 control register 1 (0x4BF00064)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2B_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2B */
N#define DMA_CH2B_CH2_XPIN_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_XPIN_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_XPIN_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_XPIN_trg0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define DMA_CH2B_CH2_XPIN_trg0_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define DMA_CH2B_CH2_XPIN_trg0_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define DMA_CH2B_CH2_XPIN_trg1_w                    ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define DMA_CH2B_CH2_XPIN_trg1_h1                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define DMA_CH2B_CH2_XPIN_trg1_b3                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N
N#define DMA_CH2B_CH2_DSYNC_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_DSYNC_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_DSYNC_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_DSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_DSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_DSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_DSYNC_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_DSYNC_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_DSYNC_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_SSYNC_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_SSYNC_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_SSYNC_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_SSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_SSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_SSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_SSYNC_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_SSYNC_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_SSYNC_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_DINC_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_DINC_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_DINC_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_DINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_DINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_DINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_DINC_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_DINC_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_DINC_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_SINC_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_SINC_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_SINC_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_SINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_SINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_SINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_SINC_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_SINC_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_SINC_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_DET_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_DET_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_DET_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_DET_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2B_CH2_DET_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2B_CH2_DET_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CH2B_CH2_SRC_mask_w                     ((uint32_t)0x0000000F)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_SRC_mask_h0                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_SRC_mask_b0                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_SRC_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2B_CH2_SRC_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2B_CH2_SRC_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2NUM  [register's definitions]
N *              Offset[0x68]  DMA channel-2 control register 1 (0x4BF00068)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2NUM_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2NUM */
N#define DMA_CH2NUM_CH2_NUM_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2NUM_CH2_NUM_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH2NUM_CH2_NUM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2NUM_CH2_NUM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2NUM_CH2_NUM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2CNT  [register's definitions]
N *              Offset[0x6C]  DMA channel-2 control register 1 (0x4BF0006C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2CNT_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2CNT */
N#define DMA_CH2CNT_CH2_CNT_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2CNT_CH2_CNT_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH2CNT_CH2_CNT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2CNT_CH2_CNT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2CNT_CH2_CNT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2SSA  [register's definitions]
N *              Offset[0x70]  DMA channel-2 source start address register (0x4BF00070)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2SSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2SSA */
N#define DMA_CH2SSA_CH2_SSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2SSA_CH2_SSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2SSA_CH2_SSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2SSA_CH2_SSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2SCA  [register's definitions]
N *              Offset[0x74]  DMA channel-2 source current address register (0x4BF00074)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2SCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2SCA */
N#define DMA_CH2SCA_CH2_SCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2SCA_CH2_SCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2SCA_CH2_SCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2SCA_CH2_SCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2DSA  [register's definitions]
N *              Offset[0x78]  DMA channel-2 destination start address register (0x4BF00078)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2DSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2DSA */
N#define DMA_CH2DSA_CH2_DSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2DSA_CH2_DSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2DSA_CH2_DSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2DSA_CH2_DSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2DCA  [register's definitions]
N *              Offset[0x7C]  DMA channel-2 destination current address register (0x4BF0007C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2DCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2DCA */
N#define DMA_CH2DCA_CH2_DCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2DCA_CH2_DCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2DCA_CH2_DCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2DCA_CH2_DCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_DMA_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_DMA.h                         */
N/*----------------------------------------------------------------------------*/
L 38 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_DMA_MID.h" 2
N#include "MG32x02z__ExtraStruct.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z__ExtraStruct.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z__ExtraStruct.h
N *
N * @brief       MG32x02z Extra Structure Definition File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:42 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z__ExtraStruct_H
N#define _MG32x02z__ExtraStruct_H
N#define _MG32x02z__ExtraStruct_H_VER                3.9     /*!< File Version */
N
N/**
N ******************************************************************************
N *
N * @struct      DMAChannel_Struct
N *              DMAChannel  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] DMA channel operation enable.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  HOLD          :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  HOLD          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LOOP          :1;     //[2] DMA destination or peripheral transfer address auto increased enable.
X            volatile uint8_t  LOOP          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ADSEL         :1;     //[3] DMA address increased mode select
X            volatile uint8_t  ADSEL         :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  XMDS          :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  XMDS          :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  PLS           :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  PLS           :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  BSIZE         :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  BSIZE         :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  REQ           :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  REQ           :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CIE           :1;     //[17] DMA channel-x transfer complete interrupt enable.
X            volatile uint8_t  CIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  HIE           :1;     //[18] DMA channel-x transfer half interrupt enable.
X            volatile uint8_t  HIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EIE           :1;     //[19] DMA channel-x transfer error interrupt enable.
X            volatile uint8_t  EIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TC2F          :1;     //[25] DMA channel-x transfer complete flag
X            volatile uint8_t  TC2F          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  TH2F          :1;     //[26] DMA channel-x transfer half flag
X            volatile uint8_t  TH2F          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  ERR2F         :1;     //[27] DMA channel-x transfer error flag
X            volatile uint8_t  ERR2F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }A;                                 /*!< A          ~ Offset[0x20]  DMA channel-x control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SRC           :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  SRC           :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DET           :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  DET           :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SINC          :1;     //[16] DMA source or memory transfer address auto increased enable
X            volatile uint8_t  SINC          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DINC          :1;     //[17] DMA destination or peripheral transfer address auto increased enable
X            volatile uint8_t  DINC          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SSYNC         :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  SSYNC         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DSYNC         :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  DSYNC         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  XPIN          :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  XPIN          :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }B;                                 /*!< B          ~ Offset[0x24]  DMA channel-x control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t NUM           :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t NUM           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }NUM;                               /*!< NUM        ~ Offset[0x28]  DMA channel-x control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CNT           :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CNT           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x2C]  DMA channel-x control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t SSA           :32;    //[31..0] DMA source or memory transfer start address.
X            volatile uint32_t SSA           :32;    
N        }MBIT;
N    }SSA;                               /*!< SSA        ~ Offset[0x30]  DMA channel-x source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t SCA           :32;    //[31..0] DMA source or memory transfer current address
X            volatile const  uint32_t SCA           :32;    
N        }MBIT;
N    }SCA;                               /*!< SCA        ~ Offset[0x34]  DMA channel-x source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t DSA           :32;    //[31..0] DMA destination or peripheral transfer start address.
X            volatile uint32_t DSA           :32;    
N        }MBIT;
N    }DSA;                               /*!< DSA        ~ Offset[0x38]  DMA channel-x destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t DCA           :32;    //[31..0] DMA destination or peripheral transfer current address
X            volatile const  uint32_t DCA           :32;    
N        }MBIT;
N    }DCA;                               /*!< DCA        ~ Offset[0x3C]  DMA channel-x destination current address register */
N
N} DMAChannel_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        DMAChannel  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define DMAChannel0_Base                ((uint32_t)0x4BF00020)              /*!< Direct Memory Access Channel Control */
N#define DMAChannel1_Base                ((uint32_t)0x4BF00040)              /*!< Direct Memory Access Channel Control */
N#define DMAChannel2_Base                ((uint32_t)0x4BF00060)              /*!< Direct Memory Access Channel Control */
N#define DMAChannel0                     ((DMAChannel_Struct*) DMAChannel0_Base)
N#define DMAChannel1                     ((DMAChannel_Struct*) DMAChannel1_Base)
N#define DMAChannel2                     ((DMAChannel_Struct*) DMAChannel2_Base)
N///@}
N/**
N ******************************************************************************
N *
N * @struct      CMPAC_Struct
N *              CMPAC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] Analog comparator CMPx power-on enable bit
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RES           :1;     //[3] CMPx compare response time select.
X            volatile uint8_t  RES           :1;     
N                                        //0x0 = 200ns 
N                                        //0x1 = 10us (5~10us)
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  PMUX          :3;     //[10..8] CMPx Analog input positive channel selection.
X            volatile uint8_t  PMUX          :3;     
N                                        //0x0 =  IVREF
N                                        //0x1 = CMPx_I0
N                                        //0x2 = CMPx_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  NMUX          :3;     //[14..12] CMPx Analog input negative channel selection.
X            volatile uint8_t  NMUX          :3;     
N                                        //0x0 =  IVREF
N                                        //0x1 = CMPx_I0
N                                        //0x2 = CMPx_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  INV           :1;     //[16] CMPx analog comparator output signal polarity select.
X            volatile uint8_t  INV           :1;     
N                                        //0 = Positive
N                                        //1 = Negative
N            __IO uint8_t  PINV          :1;     //[17] CMPx output to pins' signal inverse enable.
X            volatile uint8_t  PINV          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  FSEL          :2;     //[19..18] CMPx analog comparator output signal select with synchronized filter
X            volatile uint8_t  FSEL          :2;     
N                                        //0x0 = Bypass
N                                        //0x1 = CMP_CK : filter with CMP_CLK 
N                                        //0x2 = TM00_TRGO : filter with TM00_TRGO
N                                        //0x3 = TM01_TRGO : filter with TM01_TRGO
N            __IO uint8_t  FDIV          :2;     //[21..20] CMPx analog comparator output synchronized filter divider.
X            volatile uint8_t  FDIV          :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CR;                                /*!< CR         ~ Offset[0x10]  CMP Analog comparator-x control register */
N
N} CMPAC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        CMPAC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define CMPAC0_Base                     ((uint32_t)0x5C000010)              /*!< Analog Comparator Control */
N#define CMPAC1_Base                     ((uint32_t)0x5C000014)              /*!< Analog Comparator Control */
N#define CMPAC2_Base                     ((uint32_t)0x5C000018)              /*!< Analog Comparator Control */
N#define CMPAC3_Base                     ((uint32_t)0x5C00001C)              /*!< Analog Comparator Control */
N#define CMPAC0                          ((CMPAC_Struct*) CMPAC0_Base)
N#define CMPAC1                          ((CMPAC_Struct*) CMPAC1_Base)
N#define CMPAC2                          ((CMPAC_Struct*) CMPAC2_Base)
N#define CMPAC3                          ((CMPAC_Struct*) CMPAC3_Base)
N///@}
N/**
N ******************************************************************************
N *
N * @struct      OBM_Struct
N *              OBM  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  MDS           :2;     //[1..0] OBMx break operation mode select
X            volatile uint8_t  MDS           :2;     
N                                        //0x0 = AND : AND signal of all break channels' output
N                                        //0x1 = CLR : STA bit is cleared by falling edge of OR signal
N                                        //0x2 = SET : STA bit is set by falling edge of OR signal
N                                        //0x3 = TOGGLE : STA bit is toggle by falling edge of OR signal
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  STA           :1;     //[4] OBMx break switching signal initial state
X            volatile uint8_t  STA           :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  LCK           :1;     //[5] OBMx break switching signal initial state write control
X            volatile uint8_t  LCK           :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BKN0          :1;     //[8] OBMx break source-0 signal inverse enable bit.
X            volatile uint8_t  BKN0          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  BKN1          :1;     //[9] OBMx break source-1 signal inverse enable bit.
X            volatile uint8_t  BKN1          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  BKN2          :1;     //[10] OBMx break source-2 signal inverse enable bit.
X            volatile uint8_t  BKN2          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  BKS0          :4;     //[19..16] OBMx break signal source channel-0 select.
X            volatile uint8_t  BKS0          :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __IO uint8_t  BKS1          :4;     //[23..20] OBMx break signal source channel-1 select.
X            volatile uint8_t  BKS1          :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __IO uint8_t  BKS2          :4;     //[27..24] OBMx break signal source channel-2 select.
X            volatile uint8_t  BKS2          :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }OBMx0;                             /*!< OBMx0      ~ Offset[0x20]  APB OBMx control register-0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  INV0          :1;     //[0] OBMx source channel-0 signal inverse enable bit.
X            volatile uint8_t  INV0          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  INV1          :1;     //[1] OBMx source channel-1 signal inverse enable bit.
X            volatile uint8_t  INV1          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  POL           :1;     //[2] OBMx output signal inverse enable bit.
X            volatile uint8_t  POL           :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  FCKS          :2;     //[5..4] OBMx output deglitch filter clock source select
X            volatile uint8_t  FCKS          :2;     
N                                        //0x0 = Disable
N                                        //0x1 = APB : CLK_APB
N                                        //0x2 = APB_DIV8 : CLK_APB divide by 8
N                                        //0x3 = TM00_TRGO
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  MUX0          :4;     //[19..16] OBMx output source channel-0 signal select.
X            volatile uint8_t  MUX0          :4;     
N                                        //0x0 = SR0 : Output 0
N                                        //0x1 = SR1
N                                        //0x2 = SR2
N                                        //0x3 = SR3
N                                        //0x4 = SR4
N                                        //0x5 = SR5
N                                        //0x6 = SR6
N                                        //0x7 = SR7
N                                        //0x8 = SR8
N                                        //0x9 = SR9
N                                        //0xA = SR10
N                                        //0xB = SR11
N                                        //0xC = SR12
N                                        //0xD = SR13
N                                        //0xE = SR14
N                                        //0xF = SR15
N            __IO uint8_t  MUX1          :4;     //[23..20] OBMx output source channel-1 signal select.
X            volatile uint8_t  MUX1          :4;     
N                                        //0x0 = SR0 : Output 0
N                                        //0x1 = SR1
N                                        //0x2 = SR2
N                                        //0x3 = SR3
N                                        //0x4 = SR4
N                                        //0x5 = SR5
N                                        //0x6 = SR6
N                                        //0x7 = SR7
N                                        //0x8 = SR8
N                                        //0x9 = SR9
N                                        //0xA = SR10
N                                        //0xB = SR11
N                                        //0xC = SR12
N                                        //0xD = SR13
N                                        //0xE = SR14
N                                        //0xF = SR15
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OBMx1;                             /*!< OBMx1      ~ Offset[0x24]  APB OBMx control register-1 */
N
N} OBM_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        OBM  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define OBM0_Base                       ((uint32_t)0x5F000020)              /*!< APB OBM Control */
N#define OBM1_Base                       ((uint32_t)0x5F000028)              /*!< APB OBM Control */
N#define OBM0                            ((OBM_Struct*) OBM0_Base)
N#define OBM1                            ((OBM_Struct*) OBM1_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @struct      EXIC_PX_Struct
N *              EXIC_PX  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PIN0_PF        :1;     /*!< [0] EXIC pin input interrupt pending flag x for external input interrupt pin of PX*/ 
X            volatile uint8_t  PIN0_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN1_PF        :1;     /*!< [1] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN1_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN2_PF        :1;     /*!< [2] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN2_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN3_PF        :1;     /*!< [3] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN3_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN4_PF        :1;     /*!< [4] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN4_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN5_PF        :1;     /*!< [5] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN5_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN6_PF        :1;     /*!< [6] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN6_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN7_PF        :1;     /*!< [7] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN7_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN8_PF        :1;     /*!< [8] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN8_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN9_PF        :1;     /*!< [9] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN9_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN10_PF       :1;     /*!< [10] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN10_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN11_PF       :1;     /*!< [11] Refer to EXIC_PX0_PF. */ 
X            volatile uint8_t  PIN11_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN12_PF       :1;     /*!< [12] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN12_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN13_PF       :1;     /*!< [13] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN13_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN14_PF       :1;     /*!< [14] Refer to EXIC_PX0_PF. */ 
X            volatile uint8_t  PIN14_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN15_PF       :1;     /*!< [15] Refer to EXIC_PX0_PF. */ 
X            volatile uint8_t  PIN15_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __I  uint16_t               :16;     /*!< [31..16] */ 
X            volatile const  uint16_t               :16;       
N        }MBIT;
N    }PF;                                        /*!< PX_PF      ~ Offset[0x20]  EXIC PX input interrupt pending flag register */                           
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PIN0_TRGS      :2;     /*!<[1..0] External interrupt pin edge/level trigger event select */ 
X            volatile uint8_t  PIN0_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN1_TRGS      :2;     /*!<[3..2] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN1_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN2_TRGS      :2;     /*!<[5..4] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN2_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN3_TRGS      :2;     /*!<[7..6] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN3_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN4_TRGS      :2;     /*!<[9..8] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN4_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN5_TRGS      :2;     /*!<[11..10] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN5_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN6_TRGS      :2;     /*!<[13..12] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN6_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN7_TRGS      :2;     /*!<[15..14] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN7_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN8_TRGS      :2;     /*!<[17..16] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN8_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN9_TRGS      :2;     /*!<[19..18] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN9_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN10_TRGS     :2;     /*!<[21..20] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN10_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN11_TRGS     :2;     /*!<[23..22] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN11_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN12_TRGS     :2;     /*!<[25..24] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN12_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN13_TRGS     :2;     /*!<[27..26] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN13_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN14_TRGS     :2;     /*!<[29..28] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN14_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN15_TRGS     :2;     /*!<[31..30] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN15_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N        }MBIT;
N    }TRGS;                                       /*!< PX_TRGS    ~ Offset[0x24]  EXIC PX Pad input trigger select register */        
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PIN0_OM        :1;    /*!<[0] External interrupt pin of PX OR mask bit x */
X            volatile uint8_t  PIN0_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN1_OM        :1;    /*!<[1] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN1_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN2_OM        :1;    /*!<[2] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN2_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN3_OM        :1;    /*!<[3] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN3_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN4_OM        :1;    /*!<[4] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN4_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN5_OM        :1;    /*!<[5] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN5_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN6_OM        :1;    /*!<[6] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN6_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN7_OM        :1;    /*!<[7] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN7_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN8_OM        :1;    /*!<[8] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN8_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN9_OM        :1;    /*!<[9] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN9_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN10_OM       :1;    /*!<[10] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN10_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN11_OM       :1;    /*!<[11] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN11_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN12_OM       :1;    /*!<[12] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN12_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN13_OM       :1;    /*!<[13] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN13_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN14_OM       :1;    /*!<[14] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN14_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN15_OM       :1;    /*!<[15] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN15_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN0_AM        :1;    /*!<[16] External interrupt pin of PX AND mask bit x */
X            volatile uint8_t  PIN0_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable  */
N            __IO uint8_t  PIN1_AM        :1;    /*!<[17] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN1_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN2_AM        :1;    /*!<[18] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN2_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN3_AM        :1;    /*!<[19] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN3_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN4_AM        :1;    /*!<[20] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN4_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN5_AM        :1;    /*!<[21] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN5_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN6_AM        :1;    /*!<[22] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN6_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN7_AM        :1;    /*!<[23] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN7_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN8_AM        :1;    /*!<[24] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN8_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN9_AM        :1;    /*!<[25] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN9_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN10_AM       :1;    /*!<[26] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN10_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN11_AM       :1;    /*!<[27] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN11_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN12_AM       :1;    /*!<[28] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN12_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN13_AM       :1;    /*!<[29] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN13_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN14_AM       :1;    /*!<[30] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN14_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN15_AM       :1;    /*!<[31] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN15_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable    */
N                                        
N        }MBIT;                                  
N    }MSK;                                       /*!< PX_MSK     ~ Offset[0x28]  EXIC PX AOI Mask register */
N}EXIC_PX_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        EXIC_PX  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define EXIC_PA_Base    ((uint32_t)(0x50000000+0x20))   /*!< EXIC PA Register Control Definitions base address*/
N#define EXIC_PB_Base    ((uint32_t)(0x50000000+0x30))   /*!< EXIC PB Register Control Definitions base address*/
N#define EXIC_PC_Base    ((uint32_t)(0x50000000+0x40))   /*!< EXIC PC Register Control Definitions bass address*/
N#define EXIC_PD_Base    ((uint32_t)(0x50000000+0x50))   /*!< EXIC PD Register Control Definitions bass address*/
N
N#define EXIC_PA         ((EXIC_PX_Struct*) EXIC_PA_Base)    /*!< EXIC PA Register Control Definitions */
N#define EXIC_PB         ((EXIC_PX_Struct*) EXIC_PB_Base)    /*!< EXIC PB Register Control Definitions */
N#define EXIC_PC         ((EXIC_PX_Struct*) EXIC_PC_Base)    /*!< EXIC PC Register Control Definitions */
N#define EXIC_PD         ((EXIC_PX_Struct*) EXIC_PD_Base)    /*!< EXIC PD Register Control Definitions */
N///@}
N
N
N#endif  // _MG32x02z__ExtraStruct_H
N
N/*----------------------------------------------------------------------------*/
N/*                    End of file MG32x02z__ExtraStruct.h                     */
N/*----------------------------------------------------------------------------*/
L 39 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_DMA_MID.h" 2
N#include "MG32x02z_SYS.H"
N
N
N/** 
N * @enum		MID_DMA_CallbackIDTypeDef
N * @brief		MID DMA Callback ID structure definition
N */        
Ntypedef enum
N{
N  MID_DMA_XFER_CPLT_CB_ID          = 0x00U,                 /*!< Full transfer.                             */
N  MID_DMA_XFER_HALFCPLT_CB_ID      = 0x01U,                 /*!< Half transfer.                             */
N  MID_DMA_XFER_ERROR_CB_ID         = 0x02U,                 /*!< Error.                                     */ 
N  MID_DMA_XFER_ABORT_CB_ID         = 0x03U,                 /*!< Abort.                                     */ 
N  MID_DMA_XFER_ALL_CB_ID           = 0x04U                  /*!< All.                                       */ 
N    
N}MID_DMA_CallbackIDTypeDef;                                                                 
N
N
N/** 
N * @enum		MID_DMA_StateTypeDef
N * @brief		MID State structures definition 
N */        
Ntypedef enum 
N{ 
N    MID_DMA_STATE_BUSY,                                     /*!< An internal process is running.            */ 
N    MID_DMA_STATE_READY,                                    /*!< Peripheral Initialized and ready for use.  */
N    MID_DMA_STATE_RESET,                                    /*!< DMA not yet initialized or disabled.       */    
N} MID_DMA_StateTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition  
N  */ 
Ntypedef enum
N{
N  MID_DMA_FULL_TRANSFER      = 0x00U,                       /*!< Full transfer.                             */
N  MID_DMA_HALF_TRANSFER      = 0x01U                        /*!< Half Transfer.                             */
N}MID_DMA_LevelCompleteTypeDef;      
N
N/**
N * @name	DMA_Error_Code
N *   		DMA Error Code
N */ 
N//!@{
N#define MID_DMA_ERROR_NONE          (0x00000000U)           /*!< No error.                                  */
N#define MID_DMA_ERROR_TE            (0x00000001U)           /*!< Transfer error.                            */
N#define MID_DMA_ERROR_NO_XFER       (0x00000004U)           /*!< no ongoin transfer.                        */
N#define MID_DMA_ERROR_TIMEOUT       (0x00000020U)           /*!< Timeout error.                             */
N#define MID_DMA_ERROR_NOT_SUPPORTED (0x00000100U)           /*!< Not supported mode.                        */     
N//!@}
N
N
N/**
N * @name	DMA_Destination_incremented_mode
N *   		DMA Peripheral incremented mode
N */ 
N//!@{
N#define DMA_DINC_ENABLE         DMA_CH0B_CH0_DINC_enable_w  /*!< Peripheral increment mode Enable.          */
N#define DMA_DINC_DISABLE        DMA_CH0B_CH0_DINC_disable_w /*!< Peripheral increment mode Disable.         */
N//!@}
N
N/**
N * @name	DMA_Source_incremented_mode
N *   		DMA Memory incremented mode
N */ 
N//!@{
N#define DMA_SINC_ENABLE         DMA_CH0B_CH0_SINC_enable_w  /*!< Peripheral increment mode Enable.          */
N#define DMA_SINC_DISABLE        DMA_CH0B_CH0_SINC_disable_w /*!< Peripheral increment mode Disable.         */
N//!@}
N
N/**
N * @name	DMA_BurstSize_Mode
N *   		DMA transfer burst size
N */ 
N//!@{
N#define DMA_BSIZE_1BYTE         DMA_CH0A_CH0_BSIZE_one_w    /*!< Burst size setting : 1 byte.               */ 
N#define DMA_BSIZE_2BYTE         DMA_CH0A_CH0_BSIZE_two_w    /*!< Burst size setting : 2 byte.               */
N#define DMA_BSIZE_4BYTE         DMA_CH0A_CH0_BSIZE_four_w   /*!< Burst size setting : 4 byte.               */
N//!@}
N
N#if defined(MG32_1ST)
X#if 1L
N/**
N * @name	DMA_Source_MemPeri
N *   		DMA source from memory or peripheral
N */ 
N//!@{
N#define MID_DMA_MEMORY_READ         (0x0000U)               /*!< DMA source from memory.                    */                  
N#define MID_DMA_ADC0_SAMPLE         (0x0001U)               /*!< DMA source from ADC0.                      */
N#define MID_DMA_I2C0_READ           (0x0002U)               /*!< DMA source from I2C0_RX.                   */
N#define MID_DMA_I2C1_READ           (0x0003U)               /*!< DMA source from I2C1_RX.                   */
N#define MID_DMA_URT0_READ           (0x0004U)               /*!< DMA source from URT0_RX.                   */
N#define MID_DMA_URT1_READ           (0x0005U)               /*!< DMA source from URT1_RX.                   */
N#define MID_DMA_URT2_READ           (0x0006U)               /*!< DMA source from URT2_RX.                   */
N#define MID_DMA_URT3_READ           (0x0007U)               /*!< DMA source from URT3_RX.                   */
N#define MID_DMA_SPI0_READ           (0x0008U)               /*!< DMA source from SPI0_RX.                   */
N#define MID_DMA_TM36_CAPTURE3       (0x000FU)               /*!< DMA source from TM36 channel3 capture data.*/
N//!@}
N
N/**
N * @name	DMA_Destination_MemPeri
N *   		DMA destination can be memory or peripheral
N */ 
N//!@{
N#define MID_DMA_MEMORY_WRITE        (0x0000U)               /*!< DMA destination is memory.                 */           
N#define MID_DMA_DAC_WRITE           (0x0100U)               /*!< DMA destination is DAC0.                   */
N#define MID_DMA_I2C0_WRITE          (0x0200U)               /*!< DMA destination is I2C0_TX.                */
N#define MID_DMA_I2C1_WRITE          (0x0300U)               /*!< DMA destination is I2C1_TX.                */
N#define MID_DMA_URT0_WRITE          (0x0400U)               /*!< DMA destination is URT0_TX.                */
N#define MID_DMA_URT1_WRITE          (0x0500U)               /*!< DMA destination is URT1_TX.                */
N#define MID_DMA_URT2_WRITE          (0x0600U)               /*!< DMA destination is URT2_TX.                */
N#define MID_DMA_URT3_WRITE          (0x0700U)               /*!< DMA destination is URT3_TX.                */
N#define MID_DMA_SPI0_WRITE          (0x0800U)               /*!< DMA destination is SPI0_TX.                */
N#define MID_DMA_GPL_WRITE           (0x0B00U)               /*!< DMA destination is GPL.                    */
N#define MID_DMA_TM36_CC0B_WRITE     (0x0C00U)               /*!< DMA destination is TM36's CC0B.            */
N#define MID_DMA_TM36_CC1B_WRITE     (0x0D00U)               /*!< DMA destination is TM36's CC1B.            */
N#define MID_DMA_TM36_CC2B_WRITE     (0x0E00U)               /*!< DMA destination is TM36's CC2B.            */
N//!@}
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/**
S * @name	DMA_Source_MemPeri
S *   		DMA source from memory or peripheral
S */ 
S//!@{
S#define MID_DMA_MEMORY_READ         (0x0000U)               /*!< DMA source from memory.                    */                  
S#define MID_DMA_ADC0_SAMPLE         (0x0001U)               /*!< DMA source from ADC0.                      */
S#define MID_DMA_I2C0_READ           (0x0002U)               /*!< DMA source from I2C0_RX.                   */
S#define MID_DMA_URT0_READ           (0x0004U)               /*!< DMA source from URT0_RX.                   */
S#define MID_DMA_URT1_READ           (0x0005U)               /*!< DMA source from URT1_RX.                   */
S#define MID_DMA_SPI0_READ           (0x0008U)               /*!< DMA source from SPI0_RX.                   */
S#define MID_DMA_TM36_CAPTURE3       (0x000FU)               /*!< DMA source from TM36 channel3 capture data.*/
S//!@}
S
S/**
S * @name	DMA_Destination_MemPeri
S *   		DMA destination can be memory or peripheral
S */ 
S//!@{
S#define MID_DMA_MEMORY_WRITE        (0x0000U)               /*!< DMA destination is memory.                 */           
S#define MID_DMA_I2C0_WRITE          (0x0200U)               /*!< DMA destination is I2C0_TX.                */
S#define MID_DMA_URT0_WRITE          (0x0400U)               /*!< DMA destination is URT0_TX.                */
S#define MID_DMA_URT1_WRITE          (0x0500U)               /*!< DMA destination is URT1_TX.                */
S#define MID_DMA_SPI0_WRITE          (0x0800U)               /*!< DMA destination is SPI0_TX.                */
S#define MID_DMA_GPL_WRITE           (0x0B00U)               /*!< DMA destination is GPL.                    */
S#define MID_DMA_TM36_CC0B_WRITE     (0x0C00U)               /*!< DMA destination is TM36's CC0B.            */
S#define MID_DMA_TM36_CC1B_WRITE     (0x0D00U)               /*!< DMA destination is TM36's CC1B.            */
S#define MID_DMA_TM36_CC2B_WRITE     (0x0E00U)               /*!< DMA destination is TM36's CC2B.            */
S//!@}
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/**
S * @name	DMA_Source_MemPeri
S *   		DMA source from memory or peripheral
S */ 
S//!@{
S#define MID_DMA_MEMORY_READ         (0x0000U)               /*!< DMA source from memory */                  
S#define MID_DMA_ADC0_SAMPLE         (0x0001U)               /*!< DMA source from ADC0 */
S#define MID_DMA_I2C0_READ           (0x0002U)               /*!< DMA source from I2C0_RX */
S#define MID_DMA_I2C1_READ           (0x0003U)               /*!< DMA source from I2C1_RX */
S#define MID_DMA_URT0_READ           (0x0004U)               /*!< DMA source from URT0_RX */
S#define MID_DMA_URT1_READ           (0x0005U)               /*!< DMA source from URT1_RX */
S#define MID_DMA_URT2_READ           (0x0006U)               /*!< DMA source from URT2_RX */
S#define MID_DMA_SPI0_READ           (0x0008U)               /*!< DMA source from SPI0_RX */
S#define MID_DMA_USB_READ            (0x000AU)               /*!< DMA source from USB_RX */
S#define MID_DMA_TM36_CAPTURE3       (0x000FU)               /*!< DMA source from TM36 channel3 capture data */
S//!@}
S
S/**
S * @name	DMA_Destination_MemPeri
S *   		DMA destination can be memory or peripheral
S */ 
S//!@{
S#define MID_DMA_MEMORY_WRITE        (0x0000U)               /*!< DMA destination is memory */           
S#define MID_DMA_DAC_WRITE           (0x0100U)               /*!< DMA destination is DAC0 */
S#define MID_DMA_I2C0_WRITE          (0x0200U)               /*!< DMA destination is I2C0_TX */
S#define MID_DMA_I2C1_WRITE          (0x0300U)               /*!< DMA destination is I2C1_TX */
S#define MID_DMA_URT0_WRITE          (0x0400U)               /*!< DMA destination is URT0_TX */
S#define MID_DMA_URT1_WRITE          (0x0500U)               /*!< DMA destination is URT1_TX */
S#define MID_DMA_URT2_WRITE          (0x0600U)               /*!< DMA destination is URT2_TX */
S#define MID_DMA_SPI0_WRITE          (0x0800U)               /*!< DMA destination is SPI0_TX */
S#define MID_DMA_USB_WRITE           (0x000AU)               /*!< DMA destination from USB_TX */
S#define MID_DMA_GPL_WRITE           (0x0B00U)               /*!< DMA destination is GPL */
S#define MID_DMA_TM36_CC0B_WRITE     (0x0C00U)               /*!< DMA destination is TM36's CC0B */
S#define MID_DMA_TM36_CC1B_WRITE     (0x0D00U)               /*!< DMA destination is TM36's CC1B */
S#define MID_DMA_TM36_CC2B_WRITE     (0x0E00U)               /*!< DMA destination is TM36's CC2B */
S//!@}
N#endif
N
N
N/**
N * @name	DMA_Memory_AddressMode
N *   		DMA memory address increase mode
N */ 
N//!@{
N#define MID_DMA_MEMORY_NORMAL       DMA_CH0A_CH0_ADSEL_normal_w /*!< DMA memory access in one by one.       */
N#define MID_DMA_MEMORY_SKIP3        DMA_CH0A_CH0_ADSEL_skip3_w  /*!< Enable memory access with SKIP3 mode.  */
N//!@}
N
N/**
N * @name	DMA_Priority_level
N *   		DMA Priority level
N */ 
N//!@{
N#define DMA_PRIORITY_LOW            DMA_CH0A_CH0_PLS_lv0_w  /*!< Priority level : Low.                      */
N#define DMA_PRIORITY_MEDIUM         DMA_CH0A_CH0_PLS_lv1_w  /*!< Priority level : Medium.                   */
N#define DMA_PRIORITY_HIGH           DMA_CH0A_CH0_PLS_lv2_w  /*!< Priority level : High.                     */
N#define DMA_PRIORITY_VERY_HIGH      DMA_CH0A_CH0_PLS_lv3_w  /*!< Priority level : Very_High.                */
N//!@}
N
N#if !defined(MG32_2ND)
X#if !0L
N/**
N * @name	DMA_Priority_Mode
N *   		DMA Priority mode
N */ 
N//!@{
N#define DMA_ROUND_ROBIN             DMA_CR0_PRI_MDS_round_w  /*!< Priority mode : round robin.              */
N#define DMA_LEVEL                   DMA_CR0_PRI_MDS_level_w  /*!< Priority mode : Priority level.           */
N//!@}
N#endif
N
N/**
N * @name	DMA_ChannelFlag
N *   		DMA flag Definition
N */ 
N//!@{
N#define DMA_CH_FLAG_ERRF            DMA_CH0A_CH0_ERR2F_mask_w   /*!< DMA Channel Error Flag.                */
N#define DMA_CH_FLAG_HALF            DMA_CH0A_CH0_TH2F_mask_w    /*!< DMA Channel Half Flag.                 */
N#define DMA_CH_FLAG_COMPLETE        DMA_CH0A_CH0_TC2F_mask_w    /*!< DMA Channel Complete Flag.             */
N#define DMA_CH_ALL_FLAG             (DMA_CH_FLAG_ERRF | DMA_CH_FLAG_HALF | DMA_CH_FLAG_COMPLETE)    /*!< DMA channel flag (include ERRF, HALF, COMPLETE). */
N//!@}
N
N/**
N * @name	DMA_interrupt_enable_definitions
N *   		DMA interrupt enable definitions
N */ 
N//!@{
N#define DMA_IT_TC                   DMA_CH0A_CH0_CIE_enable_w   /*!< DMA Channel complete interrupt.        */
N#define DMA_IT_HT                   DMA_CH0A_CH0_HIE_enable_w   /*!< DMA Channel half interrupt.            */
N#define DMA_IT_TE                   DMA_CH0A_CH0_EIE_enable_w   /*!< DMA Channel error interrupt.           */    
N//!@}
N
N/**
N * @name	DMA_LoopMode_Active
N *   		DMA loop mode enable definitions
N */ 
N//!@{
N#define DMA_LOOP_ENABLE             DMA_CH0A_CH0_LOOP_enable_w  /*!< Enable DMA loop mode.                  */
N#define DMA_LOOP_DISABLE            DMA_CH0A_CH0_LOOP_disable_w /*!< DMA access once cycle.                 */  
N//!@}
N
N
N
N/** 
N * @struct  DMA_InitTypeDef
N * @brief   DMA Configuration Structure definition
N */        
Ntypedef struct {				
N    uint32_t SrcPeri;               /*!< Specifies the source from memory or peripheral.
N                                         This parameter can be a value of reference DMA_Source_MemPeri */
N                                    
N    uint32_t DesPeri;               /*!< Specifies the destination to memory or peripheral.
N                                         This parameter can be a value of reference DMA_Destination_MemPeri */
N                                    
N    uint32_t BSize;                 /*!< Specifies the Peripheral data width.
N                                         This parameter can be a value of reference DMA_BurstSize_Mode */
N                    
N    uint32_t MEMMode;               /*!< Specifies the operation mode of the DMA Channelx.
N                                         This parameter can be a value of reference DMA_Memory_AddressMode */
N                                    
N#if defined(MG32_1ST) || defined(MG32_3RD)    
X#if 1L || 0L    
N    uint32_t Priority;              /*!< Specifies the software priority for the DMA Channelx.
N                                         This parameter can be a value of reference DMA_Priority_level only apply in Priority level mode */
N#endif
N                                        
N    uint32_t LoopMode;              /*!< Specifies the loop mode for the DMA Channelx.
N                                         This parameter can be a value of reference DMA_LoopMode_Active */
N} DMA_InitTypeDef;				
N
N
N
N/** 
N * @struct  DMA_HandleTypeDef
N * @brief   DMA handle Structure definition
N */        
Ntypedef struct __DMA_HandleTypeDef 
N{  
N    DMA_Struct            *Instance;                                                      /*!< Register base address                  */
N                                                                                            
N    DMA_InitTypeDef       Init;                                                           /*!< DMA communication parameters           */ 
N                                                                                            
N    MID_LockTypeDef       Lock;                                                           /*!< DMA locking object                     */  
N                                                                                            
N    MID_DMA_StateTypeDef  State;                                                          /*!< DMA transfer state                     */
N
N#if defined(MG32_1ST) || defined(MG32_3RD)    
X#if 1L || 0L    
N    uint32_t              PriorityMode;                                                   /*!< DMA Priority Mode select .                
N                                                                                                This parameter can be a value of reference DMA_Priority_Mode */
N#endif
N    
N    uint32_t              ExtraGPL_Channel;                                               /*!< DMA data send to GPL calculating
N                                                                                               0 : Disable data to GPL.
N                                                                                               1 : GPL data from DMA channel-0.
N                                                                                               2 : GPL data from DMA channel-1.
N                                                                                               3 : GPL data from DMA channel-2.
N                                                                                               */  
N                                                                                            
N    void                  *Parent;                                                        /*!< Parent object state                    */  
N                                                                                            
N    void                  (* XferCpltCallback)( struct __DMA_HandleTypeDef * mDMA);       /*!< DMA transfer complete callback         */
N                                                                                            
N    void                  (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * mDMA);   /*!< DMA Half transfer complete callback    */
N                                                                                            
N    void                  (* XferErrorCallback)( struct __DMA_HandleTypeDef * mDMA);      /*!< DMA transfer error callback            */
N                                                                                            
N    void                  (* XferAbortCallback)( struct __DMA_HandleTypeDef * mDMA);      /*!< DMA transfer abort callback            */  
N                                                                                            
N    __IO uint32_t         ErrorCode;                                                      /*!< DMA Error code                         */
X    volatile uint32_t         ErrorCode;                                                       
N                                                                                            
N    DMAChannel_Struct     *DMAChannelIndex;                                                /*!< DMA Channel Struct                     */
N    
N} DMA_HandleTypeDef;    
N
N
N
N/**
N *******************************************************************************
N * @brief       Clear the DMA interrupt pending bits.
N * @param[in]   "__HANDLECH__" : pointer to a DMAChannel_Struct.
N * @param[in]   "__FLAG__" : specifies the DMA interrupt flag to clear.
N *  @arg\b	    DMA_CH_FLAG_ERRF : DMA Channel Error Flag.
N *  @arg\b	    DMA_CH_FLAG_HALF : DMA Channel Half Flag.
N *  @arg\b	    DMA_CH_FLAG_COMPLETE : DMA Channel Complete Flag.
N*  @arg\b	    DMA_CH_ALL_FLAG :  Any flag of ERRF, HALF, COMPLETE  
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_CLEAR_FLAG(hADC.DMA_Handle->DMAChannelIndex, DMA_CH_FLAG_COMPLETE);
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_CLEAR_FLAG(__HANDLECH__,__FLAG__)     ((__HANDLECH__)->A.W |= (__FLAG__))
N
N/**
N *******************************************************************************
N * @brief       Get the DMA interrupt pending bits.
N * @param[in]   "__HANDLECH__" : pointer to a DMAChannel_Struct.
N * @param[in]   "__FLAG__" : specifies the DMA interrupt flag to clear.
N *  @arg\b	    DMA_CH_FLAG_ERRF : DMA Channel Error Flag.
N *  @arg\b	    DMA_CH_FLAG_HALF : DMA Channel Half Flag.
N *  @arg\b	    DMA_CH_FLAG_COMPLETE : DMA Channel Complete Flag.
N*  @arg\b	    DMA_CH_ALL_FLAG :  Any flag of ERRF, HALF, COMPLETE  
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_GET_FLAG(hADC.DMA_Handle->DMAChannelIndex, DMA_CH_FLAG_COMPLETE);
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_GET_FLAG(__HANDLECH__,__FLAG__)      (((__HANDLECH__)->A.W & (__FLAG__)) == (__FLAG__))
N
N
N/**
N *******************************************************************************
N * @brief       Enables the specified DMA All interrupt.
N * @param[in]   "__HANDLE__" : pointer to a DMA_HandleTypeDef
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_ENABLE_ITEA(&DMA_Handle);
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_ENABLE_ITEA(__HANDLE__)    ((__HANDLE__)->Instance->INT.W |= DMA_INT_IEA_enable_w)
N
N/**
N *******************************************************************************
N * @brief       Disables the specified DMA All interrupt.
N * @param[in]   "__HANDLE__" : pointer to a DMA_HandleTypeDef
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_DISABLE_ITEA(&DMA_Handle);
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_DISABLE_ITEA(__HANDLE__)    ((__HANDLE__)->Instance->INT.W &= ~DMA_INT_IEA_enable_w)
N
N/**
N *******************************************************************************
N * @brief       Enables the specified DMA interrupt.
N * @param[in]   "__HANDLECH__" : pointer to a DMAChannel_Struct.
N * @param[in]   "__INTERRUPT__" : specifies the DMA interrupt source to enable.
N *  @arg\b      DMA_IT_TC : Complete flag.
N *  @arg\b      DMA_IT_HT : Half size flag.
N *  @arg\b      DMA_IT_TE : Error flag.
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_ENABLE_IT(hADC.DMA_Handle->DMAChannelIndex, DMA_IT_HT);
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_ENABLE_IT(__HANDLECH__,__INTERRUPT__)  \
N        ((__HANDLECH__)->A.W  |= (__INTERRUPT__)) 
X#define __DRV_DMA_ENABLE_IT(__HANDLECH__,__INTERRUPT__)          ((__HANDLECH__)->A.W  |= (__INTERRUPT__)) 
N
N/**
N *******************************************************************************
N * @brief       Disables the specified DMA interrupt.
N * @param[in]   "__HANDLECH__" : pointer to a DMAChannel_Struct.
N * @param[in]   "__INTERRUPT__" : specifies the DMA interrupt source to disable.
N *  @arg\b      DMA_IT_TC : Complete flag.
N *  @arg\b      DMA_IT_HT : Half size flag.
N *  @arg\b      DMA_IT_TE : Error flag.
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_DISABLE_IT(hADC.DMA_Handle->DMAChannelIndex, DMA_IT_HT);
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_DISABLE_IT(__HANDLECH__,__INTERRUPT__)  \
N        ((__HANDLECH__)->A.W  &= ~(__INTERRUPT__)) 
X#define __DRV_DMA_DISABLE_IT(__HANDLECH__,__INTERRUPT__)          ((__HANDLECH__)->A.W  &= ~(__INTERRUPT__)) 
N
N/**
N *******************************************************************************
N * @brief       Start the DMA request.
N * @param[in]   "__HANDLECH__" : pointer to a DMAChannel_Struct.
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_START_REQUEST(hADC.DMA_Handle->DMAChannelIndex);;
N * @endcode
N *******************************************************************************
N */
N#define __DRV_DMA_START_REQUEST(__HANDLECH__)    ((__HANDLECH__)->A.W |= DMA_CH0A_CH0_REQ_mask_w)
N
N/**
N *******************************************************************************
N * @brief       Set DMA with the last transmission.
N * @return		None
N * @note 
N * @par         Example
N * @code
N    __DRV_DMA_SET_LASTCYCLE(hADC.DMA_Handle->DMAChannelIndex);
N * @endcode
N *******************************************************************************
N */
N#if defined(MG32_1ST)
X#if 1L
N#define __DRV_DMA_SET_LASTCYCLE(__HANDLECH__)       \
N    do{                                             \
N        if((__HANDLECH__) == DMAChannel0)           \
N            SYS->CR0.W |= (SYS_CR0_CH0_LAST_yes_w); \
N        else if ((__HANDLECH__) == DMAChannel1)     \
N            SYS->CR0.W |= (SYS_CR0_CH1_LAST_yes_w); \
N        else if ((__HANDLECH__) == DMAChannel2)     \
N            SYS->CR0.W |= (SYS_CR0_CH2_LAST_yes_w); \
N    }while (0)
X#define __DRV_DMA_SET_LASTCYCLE(__HANDLECH__)           do{                                                     if((__HANDLECH__) == DMAChannel0)                       SYS->CR0.W |= (SYS_CR0_CH0_LAST_yes_w);         else if ((__HANDLECH__) == DMAChannel1)                 SYS->CR0.W |= (SYS_CR0_CH1_LAST_yes_w);         else if ((__HANDLECH__) == DMAChannel2)                 SYS->CR0.W |= (SYS_CR0_CH2_LAST_yes_w);     }while (0)
N#else
S    #define __DRV_DMA_SET_LASTCYCLE(__HANDLECH__)       ((__HANDLECH__)->A.W |= (DMA_CH0A_CH0_LAST_yes_w))
N#endif 
N
N
N/**
N * @name    Function announce
N * @brief   DMA base initial/Deinitial	
N */ 
N///@{
NMID_StatusTypeDef MID_DMA_Init(DMA_HandleTypeDef *mDMA);
NMID_StatusTypeDef MID_DMA_DeInit(DMA_HandleTypeDef *mDMA);
NMID_StatusTypeDef MID_DMA_Start(DMA_HandleTypeDef *mDMA, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NMID_StatusTypeDef MID_DMA_Start_IT(DMA_HandleTypeDef *mDMA, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NMID_StatusTypeDef MID_DMA_Abort(DMA_HandleTypeDef *mDMA);
NMID_StatusTypeDef MID_DMA_Abort_IT(DMA_HandleTypeDef *mDMA);
NMID_StatusTypeDef MID_DMA_PollForTransfer(DMA_HandleTypeDef *mDMA, uint32_t CompleteLevel, uint32_t Timeout);
Nvoid MID_DMA_IRQHandler(DMA_HandleTypeDef *mDMA);
NMID_StatusTypeDef MID_DMA_RegisterCallback(DMA_HandleTypeDef *mDMA, MID_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _mDMA));
NMID_StatusTypeDef MID_DMA_UnRegisterCallback(DMA_HandleTypeDef *mDMA, MID_DMA_CallbackIDTypeDef CallbackID);
NMID_DMA_StateTypeDef MID_DMA_GetState(DMA_HandleTypeDef *mDMA);
Nuint32_t MID_DMA_GetError(DMA_HandleTypeDef *mDMA);
N///@}
N
N
N
N/**
N * @name    Function announce
N * @brief   addtogroup TM_Private_Functions
N */ 
N///@{
Nstatic void DMA_SetConfig(DMA_HandleTypeDef *mDMA, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
N///@}
N
N#endif
L 39 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include\MG32x02z_TM_MID.h" 2
N
N
N
N/**
N * @name	TM_Interrupt_definition
N *   		TM Interrupt Definition
N */ 
N//!@{
N#define TM_IT_CC0                   TM_INT_CC0_IE_enable_w      /*!< TM CC0 interrupt.                              */
N#define TM_IT_CC1                   TM_INT_CC1_IE_enable_w      /*!< TM CC1 interrupt.                              */
N#define TM_IT_CC2                   TM_INT_CC2_IE_enable_w      /*!< TM CC2 interrupt.                              */
N#define TM_IT_CC3                   TM_INT_CC3_IE_enable_w      /*!< TM CC3 interrupt.                              */
N#define TM_IT_UPDATE                TM_INT_TIE_enable_w         /*!< TM main counter interrupt.                     */
N#define TM_IT_UPDATE2               TM_INT_TIE2_enable_w        /*!< TM prescaler interrupt.                        */
N#define TM_IT_BREAK                 TM_INT_BKIE_enable_w        /*!< TM break event interrupt.                      */
N#define TM_IT_EXTERNAL              TM_INT_EXIE_enable_w        /*!< TM external trigger interrupt.                 */
N#define TM_IT_QEI_DIRCHANGE         TM_INT_DIRC_IE_enable_w     /*!< TM QEI change direction interrupt.             */
N#define TM_IT_QEI_INDEX             TM_INT_IDX_IE_enable_w      /*!< TM QEI reset index interrupt.                  */
N#define TM_IT_QEI_ERROR             TM_INT_QPE_IE_enable_w      /*!< TM QEI error interrupt.                        */
N#if defined(MG32_3RD)
X#if 0L
S#define TM_IT_ONEPULSE              TM_INT_RTU_IE_enable_w      /*!< Repetition timer underflow interrupt enable.   */
N#endif
N//!@}
N
N/**
N * @name	TM_Flag_definition
N *   		TM Flag Definition
N */ 
N//!@{
N#define TM_FLAG_CC0A                TM_STA_CF0A_happened_w      /*!< TM CC0A flag.                                  */
N#define TM_FLAG_CC1A                TM_STA_CF1A_happened_w      /*!< TM CC1A flag.                                  */
N#define TM_FLAG_CC2A                TM_STA_CF2A_happened_w      /*!< TM CC2A flag.                                  */
N#define TM_FLAG_CC3A                TM_STA_CF3A_happened_w      /*!< TM CC3A flag.                                  */
N#define TM_FLAG_CC0B                TM_STA_CF0B_happened_w      /*!< TM CC0B flag.                                  */
N#define TM_FLAG_CC1B                TM_STA_CF1B_happened_w      /*!< TM CC1B flag.                                  */
N#define TM_FLAG_CC2B                TM_STA_CF2B_happened_w      /*!< TM CC2B flag.                                  */
N#define TM_FLAG_CC3B                TM_STA_CF3B_happened_w      /*!< TM CC3B flag.                                  */
N#define TM_FLAG_UPDATE_UP           TM_STA_TOF_happened_w       /*!< TM main counter overflow flag.                 */
N#define TM_FLAG_UPDATE_DOWN         TM_STA_TUF_happened_w       /*!< TM main counter undefflow flag.                */
N#define TM_FLAG_UPDATE2_UP          TM_STA_TOF2_happened_w      /*!< TM prescaler counter overflow flag.            */
N#define TM_FLAG_UPDATE2_DOWN        TM_STA_TUF2_happened_w      /*!< TM prescaler counter undefflow flag.           */
N#define TM_FLAG_BREAK               TM_STA_BKF_happened_w       /*!< TM break event flag.                           */
N#define TM_FLAG_EXTERNAL            TM_STA_EXF_happened_w       /*!< TM external trigger event flag.                */
N#define TM_FLAG_QEI_DIRCHANGE       TM_STA_DIRCF_happened_w     /*!< TM QEI change direction flag.                  */
N#define TM_FLAG_QEI_INDEX           TM_STA_IDXF_happened_w      /*!< TM QEI reset index flag.                       */
N#define TM_FLAG_QEI_ERROR           TM_STA_QPEF_happened_w      /*!< TM QEI error flag.                             */
N#define TM_FLAG_DIRECTION           TM_STA_DIRF_down_counting_w /*!< TM QEI count down flag.                        */
N#if defined(MG32_3RD)      
X#if 0L      
S#define TM_FLAG_ONEPULSE            TM_STA_RTUF_happened_w      /*!< TM Repetition timer underflow flag.            */
N#endif
N//!@}
N
N/**
N * @name	TM_Event_Groupdef
N *   		TM Event Group Definition
N */ 
N//!@{
N#define TM_EVENT_UPDATE             (TM_FLAG_UPDATE_UP | TM_FLAG_UPDATE_DOWN)       /*!< TM main counter event (overflow or underflow).     */
N#define TM_EVENT_UPDATE2            (TM_FLAG_UPDATE2_UP | TM_FLAG_UPDATE2_DOWN)     /*!< TM prescaler counter event (overflow or underflow).*/
N#define TM_EVENT_CH0                (TM_FLAG_CC0A | TM_FLAG_CC0B)                   /*!< TM channel0 IC/OC event.                           */
N#define TM_EVENT_CH1                (TM_FLAG_CC1A | TM_FLAG_CC1B)                   /*!< TM channel1 IC/OC event.                           */
N#define TM_EVENT_CH2                (TM_FLAG_CC2A | TM_FLAG_CC2B)                   /*!< TM channel2 IC/OC event.                           */
N#define TM_EVENT_CH3                (TM_FLAG_CC3A | TM_FLAG_CC3B)                   /*!< TM channel3 IC/OC event.                           */
N#define TM_EVENT_QEI                (TM_FLAG_QEI_DIRCHANGE | TM_FLAG_QEI_INDEX | TM_FLAG_QEI_ERROR) /*!< TM QEI event (DIRC/IDX/QPE).       */
N#define TM_EVENT_ONEPULSE           (TM_FLAG_ONEPULSE)                              /*!< TM Repetition timer underflow event.               */
N//!@}
N
N
N/** 
N * @enum        MID_TM_ChannelSelectDef
N * @brief       declare Timer channel selection
N */        
Ntypedef enum
N{
N    MID_TM_Channel0=0,                                          /*!< Specifies the TM Channel0.                     */
N    MID_TM_Channel1=1,                                          /*!< Specifies the TM Channel1.                     */
N    MID_TM_Channel2=2,                                          /*!< Specifies the TM Channel2.                     */
N    MID_TM_Channel3=3,                                          /*!< Specifies the TM Channel3.                     */
N    MID_TM_Channel_ALL,                                         /*!< Specifies the TM channels.                     */
N    MID_TM_ACTIVE_CHANNEL_CLEARED,                              /*!< All active channels cleared.                   */
N} MID_TM_ChannelSelectDef;
N
N/**
N * @enum        MID_TM_StateTypeDef
N * @brief       MID State structures definition
N */
Ntypedef enum
N{
N    MID_TM_STATE_BUSY,                                          /*!< An internal process is running.                */
N    MID_TM_STATE_READY,                                         /*!< Peripheral Initialized and ready for use.      */
N    MID_TM_STATE_RESET,                                         /*!< DMA not yet initialized or disabled.           */
N} MID_TM_StateTypeDef;
N
N/**
N * @name	TM_CounterMode
N *   		TM Counter Mode
N */ 
N//!@{
N#define TM_CASCADE_UP               (0x0000U)                   /*!< TM main+prescaler all up count in cascade mode.        */
N#define TM_SEPARATE_UP              (0x0010U)                   /*!< TM main+prescaler all up count in separate mode.       */
N#define TM_FULLCOUNTER_UP           (0x0020U)                   /*!< TM main+prescaler all up count in full counter mode.   */
N#define TM_CASCADE_DOWN             (0x0000U)                   /*!< TM main+prescaler all down count in cascade mode.      */
N#define TM_SEPARATE_DOWN            (0x00D0U)                   /*!< TM main+prescaler all down count in separate mode.     */
N#define TM_FULLCOUNTER_DOWN         (0x00E0U)                   /*!< TM main+prescaler all down count in full counter mode. */
N//!@}
N
N/**
N * @name	TM_ClockSource
N *   		TM Clock Source 
N */ 
N//!@{
N#define TM_MainCounter_InteralClock (TM_CLK_CKS_SEL_ck_int_w)    /*!< TM main counter clock from internal clock.            */
N#define TM_MainCounter_ExteralClock (TM_CLK_CKS_SEL_ck_ext_w)    /*!< TM main counter clock from external clock.            */
N#define TM_Prescaler_InteralClock   (TM_CLK_CKS2_SEL_ck_int_w)   /*!< TM prescaler counter clock from internal clock.       */
N#define TM_Prescaler_ExteralClock   (TM_CLK_CKS2_SEL_ck_ext_w)   /*!< TM prescaler counter clock from external clock.       */
N    
N#define TM_INTERNAL_CLOCK           (TM_MainCounter_InteralClock | TM_Prescaler_InteralClock)   /*!< TM main+prescaler clock from internal clock. */  
N#define TM_EXTERNAL_CLOCK           (TM_MainCounter_ExteralClock | TM_Prescaler_ExteralClock)   /*!< TM main+prescaler clock from external clock. */  
N//!@}
N
N/**
N * @name	TM_InterClockSource
N *   		TM internal clock Source 
N */ 
N//!@{
N#define TM_INTERNALCLOCK_PROC       (TM_CLK_CKI_SEL_proc_w)     /*!< TM internal clock from CK_PROC.                        */
N#define TM_INTERNALCLOCK_ILRCO      (TM_CLK_CKI_SEL_ck_ls_w)    /*!< TM internal clock from CK_LS.                          */
N//!@}
N
N/**
N * @name	TM_ExterClockSource
N *   		TM internal clock Source 
N */ 
N//!@{
N#define TM_EXTERNAL_ETR             (TM_CLK_CKE_SEL_etr_w)                          /*!< TM external clock from ETR pin.                        */
N#define TM_EXTERNAL_IN0             (TM_CLK_CKE_SEL_in0_w)                          /*!< TM external clock from IN0.                            */
N#define TM_EXTERNAL_IN1             (TM_CLK_CKE_SEL_in1_w)                          /*!< TM external clock from IN1.                            */
N#define TM_EXTERNAL_ITR0            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr0_w)  /*!< TM external clock from ITR0 (reference funcion table). */
N#define TM_EXTERNAL_ITR1            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr1_w)  /*!< TM external clock from ITR1 (reference funcion table). */
N#define TM_EXTERNAL_ITR2            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr2_w)  /*!< TM external clock from ITR2 (reference funcion table). */
N#define TM_EXTERNAL_ITR3            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr3_w)  /*!< TM external clock from ITR3 (reference funcion table). */
N#define TM_EXTERNAL_ITR4            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr4_w)  /*!< TM external clock from ITR4 (reference funcion table). */
N#define TM_EXTERNAL_ITR5            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr5_w)  /*!< TM external clock from ITR5 (reference funcion table). */
N#define TM_EXTERNAL_ITR6            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr6_w)  /*!< TM external clock from ITR6 (reference funcion table). */
N#define TM_EXTERNAL_ITR7            (TM_CLK_CKE_SEL_itr_w | TM_TRG_ITR_MUX_itr7_w)  /*!< TM external clock from ITR7 (reference funcion table). */
N//!@}
N
N/**
N * @name	TM_ClockDivision
N *   		TM Clock Division
N */ 
N//!@{
N#define TM_INTERNALCLOCK_DIVDER_DIV1    (0x0000U)               /*!< TM internal clock divide 1.                            */
N#define TM_INTERNALCLOCK_DIVDER_DIV2    (0x1000U)               /*!< TM internal clock divide 2.                            */
N#define TM_INTERNALCLOCK_DIVDER_DIV4    (0x2000U)               /*!< TM internal clock divide 4.                            */
N#define TM_INTERNALCLOCK_DIVDER_DIV8    (0x3000U)               /*!< TM internal clock divide 8.                            */
N//!@}       
N        
N/**     
N * @name	TM_Channel_Mode     
N *   		TM Channel Mode Select      
N */        
N//!@{       
N#define TM_CH_Disable               (0x0000U)                   /*!< Disable channel function.                              */
N#define TM_CH_InputCapture          (0x0001U)                   /*!< TM channel function set in input capture mode.         */
N#define TM_CH_16bit_OutputCompare   (0x0002U)                   /*!< TM channel function set in 16bit output compare mode.  */
N#define TM_CH_8bitx2_OutputCompare  (0x0003U)                   /*!< TM channel function set in 8bitx2 output compare mode. */
N#define TM_CH_16bit_PWM             (0x0004U)                   /*!< TM channel function set in 16bit PWM mode.             */
N#define TM_CH_8bitx2_PWM            (0x0005U)                   /*!< TM channel function set in 8bitx2 PWM mode.            */
N#define TM_CH_16bit_PWM_COMPLEMENT  (0x0006U)                   /*!< TM channel function set in 16bit PWM mode with deadtime control. */
N#define TM_CH_8bitx2_PWM_COMPLEMENT (0x0007U)                   /*!< TM channel function set in 8bitx2 PWM mode with deadtime control. */
N#define TM_ALLCH_PWMMode            (0x4444U)                   /*!< TM all channel function set in 16bit PWM mode.         */
N//!@}
N
N
N/** 
N * @struct  TM_Base_InitTypeDef
N * @brief   TM Time Base Init structure definition
N */ 
Ntypedef struct
N{
N    uint32_t TM_CounterMode;        /*!< Specifies the counter mode.
N                                         This parameter can be a value of Cascade/Separate/Full_Counter with Up/Down count */
N        
N    uint16_t TM_Prescaler;          /*!< Specifies the prescaler value used to divide the TM clock.
N                                         This parameter can be a number between 0x0000 and 0xFFFF
N                                         PS: TM00 & TM01 only 8 bits (0x00~0xFF) */
N        
N    uint16_t TM_Period;             /*!< Specifies the period value to be loaded into the active Auto-Reload
N                                         Register at the next update event.This parameter must be a number
N                                         between 0x0000 and 0xFFFF.
N                                         PS: TM00 & TM01 only 8 bits (0x00~0xFF) */
N    
N} TM_Base_InitTypeDef;
N
N/** 
N * @struct  TM_ClockConfigTypeDef
N * @brief   TM Clock Configuration Handle Structure definition
N */ 
Ntypedef struct
N{
N    uint32_t TM_ClockSource;            /*!< Specifies the main/prescaler clock source from Internal/External clock.
N                                             This parameter can be a value of reference TM_ClockSource */
N    
N    uint32_t TM_InternalClockSource;    /*!< Specifies the internal clock source.
N                                             This parameter can be a value of reference TM_InterClockSource */
N    
N    uint32_t TM_INTClockDivision;       /*!< Specifies the clock division.
N                                             This parameter can be a value of reference TM_ClockDivision */
N    
N    uint32_t TM_ExternalClockSource;    /*!< Specifies the external clock source.
N                                             This parameter can be a value of reference TM_ExterClockSource */    
N} TM_ClockConfigTypeDef;
N
N
N/** 
N * @struct  TM_HandleTypeDef
N * @brief   TM's timebase/procedure control
N */ 
Ntypedef struct
N{
N    TM_Struct*              Instance;   /*!< Register base address. e.g TM00, TM01 ... TM36 */
N        
N    TM_Base_InitTypeDef     Init;       /*!< TM Time Base required parameters */
N        
N    MID_TM_ChannelSelectDef Channel;    /*!< Active channel  */
N        
N    DMA_HandleTypeDef       *hDMA[4];   /*!< DMA Handlers array
N                                             This array is accessed by a reference TM_DMA_Handle_index */
N         
N    MID_LockTypeDef         Lock;       /*!< Locking object */
N        
N    MID_TM_StateTypeDef     State;      /*!< TM operation state  */
N
N} TM_HandleTypeDef;
N
N
N
N/**
N * @name	TM_Output_Compare_Polarity
N *   		TM Output Compare Polarity
N */ 
N//!@{
N#define TM_OCPOLARITY_HIGH          (0x0000U)                   /*!< Normal output OCx.                             */
N#define TM_OCPOLARITY_LOW           (0x0001U)                   /*!< Invert TM OCx output.                          */
N//!@}
N
N/**
N * @name	TM_Output_Compare_N_Polarity
N *   		TM Complementary Output Compare Polarity
N */ 
N//!@{
N#define TM_OCNPOLARITY_HIGH         (0x0000U)                   /*!< Normal output OCxN.                            */
N#define TM_OCNPOLARITY_LOW          (0x0100U)                   /*!< Invert TM OCxN output.                         */
N//!@}   
N    
N/** 
N * @name	TM_Output_Compare_H_Polarity    
N *   		TM Complementary Output Compare Polarity    
N */     
N//!@{   
N#define TM_OCHPOLARITY_HIGH         (0x0000U)                   /*!< Normal output OCxH.                            */
N#define TM_OCHPOLARITY_LOW          (0x0010U)                   /*!< Invert TM OCxH output.                         */
N//!@}   
N    
N/** 
N * @name	TM_Output_Compare_Idle_State    
N *   		TM Output Compare Idle State    
N */     
N//!@{   
N#define TM_OCIDLESTATE_SET          (0x01000000U)               /*!< TM OCx output 'H' in idle mode.                */
N#define TM_OCIDLESTATE_RESET        (0x00000000U)               /*!< TM OCx output 'L' in idle mode.                */
N//!@}   
N    
N/** 
N * @name	TM_Output_Compare_N_Idle_State  
N *   		TM Complementary Output Compare Idle State  
N */     
N//!@{   
N#define TM_OCNIDLESTATE_SET         (0x10000000U)               /*!< TM OCxN output 'H' in idle mode.               */
N#define TM_OCNIDLESTATE_RESET       (0x00000000U)               /*!< TM OCxN output 'L' in idle mode.               */
N//!@}   
N    
N/** 
N * @name	TM_Output_Compare_H_Idle_State  
N *   		TM Output Compare H Idle State  
N */     
N//!@{   
N#define TM_OCHIDLESTATE_SET         (0x00000100U)               /*!< TM OCxH output 'H' in idle mode.               */     
N#define TM_OCHIDLESTATE_RESET       (0x00000000U)               /*!< TM OCxH output 'L' in idle mode.               */  
N//!@}   
N    
N/** 
N * @name	TM_DMA_Handle_index 
N *   		TM DMA Handle Index 
N */     
N//!@{   
N#define TM_DMA_ID_CC0               ((uint16_t) 0x0U)           /*!< Index of the DMA handle used for Compare 0 DMA requests. */
N#define TM_DMA_ID_CC1               ((uint16_t) 0x1U)           /*!< Index of the DMA handle used for Compare 1 DMA requests. */
N#define TM_DMA_ID_CC2               ((uint16_t) 0x2U)           /*!< Index of the DMA handle used for Compare 2 DMA requests. */
N#define TM_DMA_ID_CC3               ((uint16_t) 0x3U)           /*!< Index of the DMA handle used for Capture 3 DMA requests. */
N//!@}
N
N/**
N * @name	TM_DMA_Channel_Enable
N *   		TM DMA channel enable
N */ 
N//!@{
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
N#define TM_DMA_CH0_OC               TM_CCMDS_DMA_CC0E_enable_w  /*!< Enable TM36 channel0 with DMA access (PWM/OC). */
N#define TM_DMA_CH1_OC               TM_CCMDS_DMA_CC1E_enable_w  /*!< Enable TM36 channel1 with DMA access (PWM/OC). */
N#define TM_DMA_CH2_OC               TM_CCMDS_DMA_CC2E_enable_w  /*!< Enable TM36 channel2 with DMA access (PWM/OC). */
N#define TM_DMA_CH3_IC               TM_CCMDS_DMA_CC3E_enable_w  /*!< Enable TM36 channel3 with DMA access (IC).     */
N#endif
N//!@}
N
N
N
N/** 
N * @struct  TM_OC_InitTypeDef
N * @brief   TM Output Compare Configuration Structure definition
N */ 
Ntypedef struct
N{
N    uint32_t OCMode;                /*!< Specifies the TM mode.
N                                         This parameter can be a value of reference TM_Channel_Mode */
N                            
N    uint16_t Pulse;                 /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
N                                         This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N                            
N    uint32_t OCPolarity;            /*!< Specifies the output polarity.
N                                         This parameter can be a value of reference TM_Output_Compare_Polarity */
N                            
N    uint32_t OCNPolarity;           /*!< Specifies the complementary output polarity.
N                                         This parameter can be a value of reference TM_Output_Compare_N_Polarity */
N                            
N    uint32_t OCHPolarity;           /*!< Specifies the output polarity.
N                                         This parameter can be a value of reference TM_Output_Compare_H_Polarity */
N                            
N    uint32_t OCIdleState;           /*!< Specifies the TM Output Compare pin state during Idle state.
N                                         This parameter can be a value of reference TM_Output_Compare_Idle_State */
N                            
N    uint32_t OCNIdleState;          /*!< Specifies the TM Output Compare pin state during Idle state.
N                                         This parameter can be a value of reference TM_Output_Compare_N_Idle_State */
N                            
N    uint32_t OCHIdleState;          /*!< Specifies the TM Output Compare pin state during Idle state.
N                                         This parameter can be a value of reference TM_Output_Compare_H_Idle_State */
N        
N} TM_OC_InitTypeDef;
N
N
N/**
N * @name	TM_Input_Capture_Polarity
N *   		TM Input Capture Polarity
N */ 
N//!@{
N#define TM_ICPOLARITY_DISABLE       TM_ICCR_IC0_TRGS_disable_w      /*!< Disable input capture.                     */
N#define TM_ICPOLARITY_RISING        TM_ICCR_IC0_TRGS_rising_edge_w  /*!< TM accept rising edge event to capture.    */
N#define TM_ICPOLARITY_FALLING       TM_ICCR_IC0_TRGS_falling_edge_w /*!< TM accept falling edge event to capture.   */
N#define TM_ICPOLARITY_DUALEDGE      TM_ICCR_IC0_TRGS_dual_edge_w    /*!< TM accept dual edge event to capture.      */
N//!@}
N
N/**
N * @name	TM_Input_Capture_Selection
N *   		TM Input Capture Selection
N */ 
N//!@{
N#define MID_TM_INPUTMUX_PIN         TM_ICCR_IC0_MUX_ic00_w         /*!< TM channel input source from pin.                                       */
N#define MID_TM_INPUTMUX_ITR         TM_ICCR_IC0_MUX_ic01_w         /*!< TM channel input source from ITR.                                       */
N#define MID_TM_INPUTMUX_LINE2       TM_ICCR_IC0_MUX_ic02_w         /*!< TM channel input source from Line2 (please reference function table).   */
N#define MID_TM_INPUTMUX_LINE3       TM_ICCR_IC0_MUX_ic03_w         /*!< TM channel input source from Line3 (please reference function table).   */
N//!@}
N
N
N/**
N * @name	TM_IC_DataMode
N *   		TM Input Capture Data Mode
N */ 
N//!@{
N#define MID_TM_IC_OVERWRITTEN       TM_CR1_OVR0_MDS_overwritten_w   /*!< Overwritten (Overwritten by new data).     */
N#define MID_TM_IC_KEEPDATA          TM_CR1_OVR0_MDS_keep_w          /*!< Keep (Preserved old data).                 */
N//!@}
N
N/** 
N * @struct  TM_IC_InitTypeDef
N * @brief   TM Input Capture Configuration Structure definition
N */ 
Ntypedef struct
N{
N    uint32_t ICPolarity;            /*!< Specifies the active edge of the input signal.
N                                         This parameter can be a value of reference TM_Input_Capture_Polarity */
N                    
N    uint32_t ICSelection;           /*!< Specifies the input.
N                                         This parameter can be a value of reference TM_Input_Capture_Selection */
N
N    uint32_t ICDataMode;            /*!< Specifies the input.
N                                         This parameter can be a value of reference TM_IC_DataMode */
N
N} TM_IC_InitTypeDef;
N
N
N/**
N * @name	TM_Slave_Mode
N *   		TM Slave Mode
N */ 
N//!@{
N#define TM_SLAVEMODE_DISABLE                TM_TRG_TRGI_MDS_no_operation_w + TM_TRG_TRGI2_MDS_no_operation_w    /*!< No function when TM external trigger happened in slave mode.   */
N#define TM_SLAVEMODE_TRIGGER_RISINGEDGE     TM_TRG_TRGI_MDS_trigger_r_w + TM_TRG_TRGI2_MDS_trigger_r_w          /*!< TM start count when rising edge event happened in slave mode.  */
N#define TM_SLAVEMODE_RESET_RISINGEDGE       TM_TRG_TRGI_MDS_reset_r_w + TM_TRG_TRGI2_MDS_reset_r_w              /*!< TM reset count when rising edge event happened in slave mode.  */
N#define TM_SLAVEMODE_GATED_HIGHLEVEL        TM_TRG_TRGI_MDS_gate_h_w + TM_TRG_TRGI2_MDS_gate_h_w                /*!< TM gating counter when high level state in slave mode.         */
N#define TM_SLAVEMODE_RESET_DUALEDGE         TM_TRG_TRGI_MDS_reset_w + TM_TRG_TRGI2_MDS_reset_w                  /*!< TM reset counter when dual edge event happened in slave mode.  */
N#define TM_SLAVEMODE_TRIGGER_FALLINGEDGE    TM_TRG_TRGI_MDS_trigger_f_w + TM_TRG_TRGI2_MDS_trigger_f_w          /*!< TM start count when falling edge event happened in slave mode. */
N#define TM_SLAVEMODE_RESET_FALLINGEDGE      TM_TRG_TRGI_MDS_reset_f_w + TM_TRG_TRGI2_MDS_reset_f_w              /*!< TM start count when falling edge event happened in slave mode. */
N#define TM_SLAVEMODE_GATED_LOWLEVEL         TM_TRG_TRGI_MDS_gate_l_w + TM_TRG_TRGI2_MDS_gate_l_w                /*!< TM gating count when low level state in slave mode.            */
N//!@}
N
N/**
N * @name	TM_Trigger_Selection
N *   		TM Trigger Selection
N */ 
N//!@{
N#define TM_TS_ETR                   TM_TRG_TRG_MUX_etr_w                            /*!< TM external trigger from ETR pin.                          */
N#define TM_TS_ITR0                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr0_w    /*!< TM external trigger from ITR0 (reference funcion table).   */
N#define TM_TS_ITR1                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr1_w    /*!< TM external trigger from ITR1 (reference funcion table).   */
N#define TM_TS_ITR2                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr2_w    /*!< TM external trigger from ITR2 (reference funcion table).   */
N#define TM_TS_ITR3                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr3_w    /*!< TM external trigger from ITR3 (reference funcion table).   */
N#define TM_TS_ITR4                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr4_w    /*!< TM external trigger from ITR4 (reference funcion table).   */
N#define TM_TS_ITR5                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr5_w    /*!< TM external trigger from ITR5 (reference funcion table).   */
N#define TM_TS_ITR6                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr6_w    /*!< TM external trigger from ITR6 (reference funcion table).   */
N#define TM_TS_ITR7                  TM_TRG_TRG_MUX_itr_w + TM_TRG_ITR_MUX_itr7_w    /*!< TM external trigger from ITR7 (reference funcion table).   */
N#define TM_TS_IN0                   TM_TRG_TRG_MUX_in0_w                            /*!< TM external trigger from IN0.                              */
N#define TM_TS_IN1                   TM_TRG_TRG_MUX_in1_w                            /*!< TM external trigger from IN1.                              */
N//!@}
N
N/** 
N * @struct  TM_SlaveConfigTypeDef
N * @brief   TM Slave configuration Structure definition                             
N */                                                                                
Ntypedef struct
N{
N    uint32_t  SlaveMode;            /*!< Slave mode selection
N                                         This parameter can be a value of reference TM_Slave_Mode */
N    uint32_t  InputTrigger;         /*!< Input Trigger source
N                                         This parameter can be a value of reference TM_Trigger_Selection */
N        
N} TM_SlaveConfigTypeDef;
N
N
N/**
N * @name	TM_Encoder_ModeDef
N *   		TM Encoder Mode definition
N */ 
N//!@{
N//! defgroup TM_Encoder_Mode TM Encoder Mode
N#define TM_ENCODERDISABLE           TM_TRG_QEI_MDS_no_operation_w   /*!< Disable TM QEI function.                   */
N#define TM_ENCODERMODE_IN0POS       TM_TRG_QEI_MDS_in0pos_w         /*!< Set TM QEI with IN0POS mode.               */
N#define TM_ENCODERMODE_IN0NEG       TM_TRG_QEI_MDS_in0neg_w         /*!< Set TM QEI with IN0NEG mode.               */
N#if defined(MG32_2ND) || defined(MG32_3RD)              
X#if 0L || 0L              
S#define TM_ENCODERMODE_IN0TRG       TM_TRG_QEI_MDS_in0trg_w         /*!< Set TM QEI with IN0TRG mode.               */
S#define TM_ENCODERMODE_IN1TRG       TM_TRG_QEI_MDS_in1trg_w         /*!< Set TM QEI with IN1TRG mode.               */
N#endif      
N#define TM_ENCODERMODE_BOTHEDGE     TM_TRG_QEI_MDS_both_w           /*!< Set TM QEI with BOTH mode.                 */    
N//!@}
N
N/**
N * @name	TM_Encoder_ResetMode
N *   		TM Encode Reset Enable/Disable and Reset IDX
N */ 
N//!@{
N#define TM_ENCODER_RESET_DISABLE    TM_TRG_IDX_EN_disable_w                         /*!< Disable QEI reset function.                                */ 
N#define TM_ENCODER_RESET_1T2        TM_TRG_IDX_EN_enable_w + TM_TRG_IDX_MDS_1t2_w   /*!< QEI reset when QEI state between 1 & 2 and IDX happened.   */
N#define TM_ENCODER_RESET_2T3        TM_TRG_IDX_EN_enable_w + TM_TRG_IDX_MDS_2t3_w   /*!< QEI reset when QEI state between 2 & 3 and IDX happened.   */
N#define TM_ENCODER_RESET_3T4        TM_TRG_IDX_EN_enable_w + TM_TRG_IDX_MDS_3t4_w   /*!< QEI reset when QEI state between 3 & 4 and IDX happened.   */
N#define TM_ENCODER_RESET_4T1        TM_TRG_IDX_EN_enable_w + TM_TRG_IDX_MDS_4t1_w   /*!< QEI reset when QEI state between 4 & 1 and IDX happened.   */
N//!@}
N
N/**
N * @name	TM_Encoder_Direction_Polarity
N *   		TM Encoder direction polarity
N */ 
N//!@{
N#define TM_ENCODER_DIRECTION_NORMAL     TM_CR0_DIR_INV_normal_w     /*!< Normal QEI direction.                      */         
N#define TM_ENCODER_DIRECTION_INVERT     TM_CR0_DIR_INV_inverted_w   /*!< Invert QEI direction.                      */
N//!@}
N
N/**
N * @name	TM_Break_Channel_Switch_Mode
N *   		TM break channel switch mode
N */ 
N//!@{
N#define MID_BREAK_HOLD_STATE        (TM_BS_BK0_CTL_hold_w | TM_BS_BK1_CTL_hold_w | TM_BS_BK2_CTL_hold_w | TM_BS_BK3_CTL_hold_w) /*!< Output hold state when break event happened. */ 
N#define MID_BREAK_STOP_STATE        (TM_BS_BK0_CTL_stop_w | TM_BS_BK1_CTL_stop_w | TM_BS_BK2_CTL_stop_w | TM_BS_BK3_CTL_stop_w) /*!< Output stop state when break event happened. */ 
N//!@}
N
N/**
N * @name	TM_Break_Input_enable_disable
N *   		TM Break Input Enable Disable
N */ 
N//!@{
N#define TM_BREAK_ENABLE             (TM_BS_BK_EN_enable_w | TM_BS_BK_EN3_enable_w)  /*!< Enable TM36 break function.            */
N#define TM_BREAK_DISABLE            (0x0000U)                                       /*!< Disable TM36 break function (Default). */
N//!@}
N
N
N/**
N * @name	TM_Break_Mode
N *   		TM Break mode
N */ 
N//!@{
N#define TM_BK_CYCLE_BY_CYCLE        (TM_BS_BK_MDS_cycle_by_cycle_w) /*!< Set TM36 break function with cycle-by-cycle mode.  */
N#define TM_BK_LATCH                 (TM_BS_BK_MDS_latch_mode_w)     /*!< Set TM36 break function with latch mode.           */
N//!@}
N
N
N/**
N * @name	MID_TM_CKDTG_DividerDef
N *   		Timer internal dead time CK_DTG divider
N */ 
N//!@{
N#define MID_TM_CKDTG_DIV1           TM_CLK_DTG_DIV_div1_w       /*!< TM36 dead time clock divide 1.                 */
N#define MID_TM_CKDTG_DIV2           TM_CLK_DTG_DIV_div2_w       /*!< TM36 dead time clock divide 2.                 */
N#define MID_TM_CKDTG_DIV4           TM_CLK_DTG_DIV_div4_w       /*!< TM36 dead time clock divide 4.                 */
N#define MID_TM_CKDTG_DIV8           TM_CLK_DTG_DIV_div8_w       /*!< TM36 dead time clock divide 8.                 */
N//!@}
N
N
N/**
N * @name	MID_TM_BreakSourceDef
N *   		Timer Break Source
N */ 
N//!@{
N#define MID_BK_ExtPin               TM_BS_BKE_EN0_enable_w      /*!< TM36 Break External trigger pin.                           */
N#define MID_BK_BOD1                 TM_BS_BKE_EN1_enable_w      /*!< TM36 Break External trigger event from BOD1 event.         */
N#define MID_BK_INTPB                TM_BS_BKE_EN2_enable_w      /*!< TM36 Break External trigger event from INT_PB.             */
N#define MID_BK_ADC0OUT              TM_BS_BKE_EN3_enable_w      /*!< TM36 Break External trigger event from ADC0_OUT (Window detect). */
N#define MID_BK_COMP0OUT             TM_BS_BKE_EN4_enable_w      /*!< TM36 Break External trigger event from Comparator0 output. */
N#define MID_BK_COMP1OUT             TM_BS_BKE_EN5_enable_w      /*!< TM36 Break External trigger event from Comparator1 output. */
N#define MID_BK_COMP2OUT             TM_BS_BKE_EN6_enable_w      /*!< TM36 Break External trigger event from Comparator2 output. */
N#define MID_BK_COMP3OUT             TM_BS_BKE_EN7_enable_w      /*!< TM36 Break External trigger event from Comparator3 output. */
N#define MID_BK_ClockFailure         TM_BS_BKI_EN0_enable_w      /*!< Clock failure event.                                       */
N#define MID_BK_CPULOCKUP            TM_BS_BKI_EN2_enable_w      /*!< CPU LOCKUP.                                                */
N//!@}
N
N
N/** 
N * @struct  TM_BreakDeadTimeConfigTypeDef
N * @brief   TM Break and Dead time configuration Structure definition  
N */ 
Ntypedef struct
N{
N  uint32_t BreakCHxOutputMode;      /*!< TM channel output switch control when break event happened.
N                                         This parameter can be a value of reference TM_Break_Channel_Switch_Mode */
N                    
N  uint32_t BreakMode;                /*!< TM dead Time 
N                                          This parameter can be a value of reference TM_Break_Mode (TM_BK_CYCLE_BY_CYCLE or TM_BK_LATCH)  */
N                    
N  uint32_t DeatTimeClockDivision;   /*!< Specifies the clock division.
N                                         This parameter can be a value of reference MID_TM_CKDTG_DividerDef */
N                    
N  uint32_t DeadTime;                 /*!< TM dead Time 
N                                          This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF */
N                    
N  uint32_t BreakSourceSel;           /*!< TM dead Time 
N                                          This parameter can be a value of reference MID_TM_BreakSourceDef */
N} TM_BreakDeadTimeConfigTypeDef;
N
N
N/**
N * @name	TM_Master_Mode_Selection
N *   		TM Master Mode Selection
N */ 
N//!@{
N#define	TM_TRGO_RESET               (TM_TRG_TRGO_MDS_mask_w)    /*!< TM TRGO source from reset event.               */
N#define	TM_TRGO_ENABLE              (TM_TRG_TRGO_MDS_en_w)      /*!< TM TRGO source from main counter enable state. */
N#define	TM_TRGO_UPDATE              (TM_TRG_TRGO_MDS_uev_w)     /*!< TM TRGO source from update event.              */
N#define	TM_TRGO_UPDATE_UPFLAG       (TM_TRG_TRGO_MDS_tof_w)     /*!< TM TRGO source from overflow flag state.       */
N#define	TM_TRGO_UPDATE_DOWNFLAG     (TM_TRG_TRGO_MDS_tuf_w)     /*!< TM TRGO source from underflow flag state.      */
N#define	TM_TRGO_ENABLE2             (TM_TRG_TRGO_MDS_en2_w)     /*!< TM TRGO source from prescaler counter enable state. */
N#define	TM_TRGO_UPDATE_UPFLAG2      (TM_TRG_TRGO_MDS_tof2_w)    /*!< TM TRGO source from prescaler overflow flag state. */
N#define	TM_TRGO_DIRECTION           (TM_TRG_TRGO_MDS_dir_w)     /*!< TM TRGO source from direction state.           */
N#define	TM_TRGO_UPDATE2             (TM_TRG_TRGO_MDS_uev2_w)    /*!< TM TRGO source from prescaler update event.    */
N#define	TM_TRGO_SOFTWARE            (TM_TRG_TRGO_MDS_sw_w)      /*!< TM TRGO source from software control state.    */
N#define	TM_TRGO_OC0                 (TM_TRG_TRGO_MDS_os0_w)     /*!< TM TRGO source from OC0 state.                 */
N#define	TM_TRGO_OC1                 (TM_TRG_TRGO_MDS_os1_w)     /*!< TM TRGO source from OC1 state.                 */
N#define	TM_TRGO_OC2                 (TM_TRG_TRGO_MDS_os2_w)     /*!< TM TRGO source from OC2 state.                 */
N#define	TM_TRGO_OC3                 (TM_TRG_TRGO_MDS_os3_w)     /*!< TM TRGO source from OC3 state.                 */
N#define	TM_TRGO_TRGI                (TM_TRG_TRGO_MDS_trgi_w)    /*!< TM TRGO source from TRGI.                      */
N#define	TM_TRGO_PRELOAD             (TM_TRG_TRGO_MDS_poe_w)     /*!< TM TRGO source from preload event.             */
N//!@}
N
N/**
N * @name	TM_Master_Output_Polarity
N *   		TM Master output polarity
N */ 
N//!@{
N#define TM_MASTEROUTPUT_BYPASS      (TM_TRG_TRGO_INV_disable_w) /*!< Notmal output TM TRGO.                         */
N#define TM_MASTEROUTPUT_INVERT      (TM_TRG_TRGO_INV_enable_w)  /*!< Invert TM TRGO.                                */
N//!@}
N
N
N/**
N * @name	TM_TRGO_Update_Control
N *   		TM TRGO Update event source/control
N */ 
N//!@{
N#define TM_UPDATE_DISABLE           (0xFFFFFFFF)                /*!< Disable TM update event.                       */
N#define TM_UPDATE_BOTH              (TM_TRG_UEV_SEL_all_w)      /*!< Accept TM update event (Overflow or underflow). */
N#define TM_UPDATE_OVERFLOW          (TM_TRG_UEV_SEL_tof_w)      /*!< Accept TM overflow event.                      */
N#define TM_UPDATE_UNDERFLOW         (TM_TRG_UEV_SEL_udf_w)      /*!< Accept TM underflow event.                     */
N//!@}
N
N
N/** 
N * @struct  TM_MasterConfigTypeDef
N * @brief   TM Master configuration Structure definition  
N */ 
Ntypedef struct {
N    uint32_t MasterOutputTrigger;   /*!< Trigger output (TRGO) selection 
N                                         This parameter can be a value of reference TM_Master_Mode_Selection */ 
N        
N    uint32_t MasterOutputPolarity;  /*!< Specifies the polarity of the output signal.
N                                         This parameter can be a value of reference TM_Master_Output_Polarity */
N            
N    uint32_t MasterUpdateEvent;     /*!< Source selection of TM_TRGO_UPDATE
N                                         This parameter can be a value of reference TM_TRGO_Update_Control */ 
N    
N}TM_MasterConfigTypeDef;
N
N
N/** 
N * @struct TM_Encoder_InitTypeDef
N * @brief  TM Encoder Configuration Structure definition
N */ 
Ntypedef struct
N{
N    uint32_t EncoderMode;           /*!< Specifies the QEI mode.
N                                         This parameter can be a value of reference TM_Encoder_Mode */
N                
N    uint32_t EncoderReset;          /*!< Specifies the index of the input signal.
N                                         This parameter can be a value of reference TM_Encoder_ResetMode */
N                
N    uint32_t EncoderDirection;      /*!< Specifies the active direction of the input signal.
N                                         This parameter can be a value of reference TM_Encoder_Direction_Polarity */
N                
N    uint32_t IC0Selection;          /*!< Specifies the input of channel0.
N                                         This parameter can be a value of reference TM_Input_Capture_Selection */
N                
N    uint32_t IC1Selection;          /*!< Specifies the input of channel1.
N                                         This parameter can be a value of reference TM_Input_Capture_Selection */
N    
N} TM_Encoder_InitTypeDef;
N
N/**
N * @name	TM_Event_Source
N *   		TM Event Source
N */ 
N//!@{
N#define TM_EVENTSOURCE_CC0A         0x0U                        /*!< Software generate CC0A event.                  */
N#define TM_EVENTSOURCE_CC0B         0x1U                        /*!< Software generate CC0B event.                  */
N#define TM_EVENTSOURCE_CC1A         0x2U                        /*!< Software generate CC1A event.                  */
N#define TM_EVENTSOURCE_CC1B         0x3U                        /*!< Software generate CC1B event.                  */
N#define TM_EVENTSOURCE_CC2A         0x4U                        /*!< Software generate CC2A event.                  */
N#define TM_EVENTSOURCE_CC2B         0x5U                        /*!< Software generate CC2B event.                  */
N#define TM_EVENTSOURCE_CC3A         0x6U                        /*!< Software generate CC3A event.                  */
N#define TM_EVENTSOURCE_CC3B         0x7U                        /*!< Software generate CC3B event.                  */
N#define TM_EVENTSOURCE_TRIGGER      0x8U                        /*!< Software generate external trigger event.      */
N#define TM_EVENTSOURCE_BREAK        TM_BS_BKSW_EN_enable_w      /*!< Software generate break event.                 */
N//!@}
N
N/**
N * @name	TM_PreLoad_CH0
N *   		TM preload channel0 control
N */ 
N//!@{
N#define TM_PRELOADOC00_ENABLE       (TM_OCCR1_OC0_POE0_mask_b2) /*!< Channel0-0 preload control (enable output).    */
N#define TM_PRELOADOC01_ENABLE       (TM_OCCR1_OC0_POE1_mask_b2) /*!< Channel0-1 preload control (enable output).    */
N#define TM_PRELOADOC02_ENABLE       (TM_OCCR1_OC0_POE2_mask_b2) /*!< Channel0-2 preload control (enable output).    */
N#define TM_PRELOADOC0_ALL_ENABLE    (TM_PRELOADOC00_ENABLE | TM_PRELOADOC01_ENABLE | TM_PRELOADOC02_ENABLE) /*!< Channel0-0/1/2 preload control (all enable output). */
N//!@}
N
N/**
N * @name	TM_PreLoad_CH1
N *   		TM preload channel1 control
N */ 
N//!@{
N#define TM_PRELOADOC10_ENABLE       (TM_OCCR1_OC1_POE0_mask_b2) /*!< Channel1-0 preload control (enable output).    */
N#define TM_PRELOADOC11_ENABLE       (TM_OCCR1_OC1_POE1_mask_b2) /*!< Channel1-1 preload control (enable output).    */
N#define TM_PRELOADOC12_ENABLE       (TM_OCCR1_OC1_POE2_mask_b2) /*!< Channel1-2 preload control (enable output).    */
N#define TM_PRELOADOC1_ALL_ENABLE    (TM_PRELOADOC10_ENABLE | TM_PRELOADOC11_ENABLE | TM_PRELOADOC12_ENABLE) /*!< Channel1-0/1/2 preload control (all enable output). */
N//!@}
N
N/**
N * @name	TM_PreLoad_CH0
N *   		TM preload channel0 control
N */ 
N//!@{
N#define TM_PRELOAD_3XOR             (TM_OCCR1_POE_EN0_enable_w) /*!< Preload control signal event from 3-XOR.       */
N#define TM_PRELOAD_INTPB            (TM_OCCR1_POE_EN1_enable_w) /*!< Preload control signal event from INT-PB.      */
N#define TM_PRELOAD_INTPD            (TM_OCCR1_POE_EN2_enable_w) /*!< Preload control signal event from INT-PD.      */
N//!@}
N
N/**
N * @name	TM_One_Pulse_Mode
N *   		TM One Pulse Mode
N */ 
N//!@{
N#define TM_OPMODE_SINGLE            (TM_CR0_ASTOP_EN_enable_w)                              /*!< Only generate One-plus.    */
N#define TM_OPMODE_REPETITIVE        (TM_CR0_ASTOP_EN_enable_w | TM_CR0_ACLEAR_EN_enable_w)  /*!< REPETITIVE generate plus.  */
N//!@}
N
N/**
N * @name	TM_Software_Break_state
N *   		Software control break state
N */ 
N//!@{
N#define TM_SOFTWARE_ENABLE_BREAK    (TM_BS_BKSW_EN_enable_w)    /*!< Enable software break state.                   */
N#define TM_SOFTWARE_DISABLE_BREAK   (TM_SOFTWARE_ENABLE_BREAK)  /*!< Disable software break state.                  */
N//!@}
N
N/**
N * @name	TM_DMAUpdateTiming
N *   		Software control break state
N */ 
N//!@{
N#define TM_UPDATEG_EVENT_TIMING     (TM_CCMDS_DMA_OMDS_uev_w)   /*!< Every TM main counter update event 
N                                                                     will update OC/PWM's channel-X compare-B.      */
N#define TM_ITR_EVENT_TIMING         (TM_CCMDS_DMA_OMDS_itr_w)   /*!< Both UEV (update event) and ITR input event 
N                                                                     has occurred then trigger DMA to update.       */
N//!@}
N
N/**
N * @name	TM_CKO_InitialState
N *   		TM Clockout initial state
N */ 
N//!@{
N#define TM_CKOINIT_RESET            (TM_CKO_CKO_STA_0_w)        /*!< TM CKO initial state is 0 (Output 0).          */
N#define TM_CKOINIT_SET              (TM_CKO_CKO_STA_1_w)        /*!< TM CKO initial state is 1 (Output 1).          */
N//!@}
N
N/**
N * @name	TM_CKO_Source
N *   		TM Clockout clock source definit
N */ 
N//!@{
N#define TM_CKOSOURCE_PRESCALER      (TM_CKO_CKO_SEL_2nd_w)      /*!< TM CKO clock source from prescaler counter overflow/underflow. */
N#define TM_CKOSOURCE_MAIN           (TM_CKO_CKO_SEL_main_w)     /*!< TM CKO clock source from main counter overflow/underflow.      */
N//!@}
N
N
N/** 
N * @struct  TM_CKOConfigTypeDef
N * @brief   TM clockout Configuration Structure definition
N */ 
Ntypedef struct
N{
N    uint32_t CKOInitState;          /*!< Specifies the timer CKO output signal initial state. 
N                                         This parameter can be a value of reference TM_CKO_InitialState. */
N                    
N    uint32_t CKOSource;             /*!< Specifies the timer clock out source event.
N                                         This parameter can be a value of reference TM_CKO_Source. */
N
N    uint32_t CKOCmd;                /*!< Specifies the timer clockout function.
N                                         This parameter can be: ENABLE or DISABLE. */
N
N} TM_CKOConfigTypeDef;
N
N
N#if defined(MG32_3RD)
X#if 0L
S
S/**
S * @name	TM_RCNT_ClockSource
S *   		TM RCNT clock source definit
S */ 
S//!@{
S#define TM_RCNT_MAIN_EVENT          (TM_CLK_RC_CKS_main_w)                          /*!< TM RCNT clock source from main counter overflow/underflow.             */
S#define TM_RCNT_CKO_MAIN_EVENT      (TM_CLK_RC_CKS_cko_w | TM_CKO_CKO_SEL_main_w)   /*!< TM RCNT clock source from CKO's main counter overflow/underflow.       */
S#define TM_RCNT_CKO_PRESCALER_EVENT (TM_CLK_RC_CKS_cko_w | TM_CKO_CKO_SEL_2nd_w)    /*!< TM RCNT clock source from CKO's prescaler counter overflow/underflow.  */
S//!@}
S
S
S/** 
S * @struct  TM_RCNTConfigTypeDef
S * @brief   TM RCNT Configuration Structure definition
S */ 
Stypedef struct
S{
S    uint32_t RCNTClkSrc;            /*!< Specifies the timer's RCNT clock source event.
S                                         This parameter can be a value of reference TM_RCNT_ClockSource. */
S                    
S    uint8_t  RCNTCounter;           /*!< Specifies the RCNT counter value. RCNT is normal downcount.
S                                         This parameter can be a number between 0x00 and 0xFF. */
S
S    uint8_t  RCNTReload;            /*!< Specifies the RCNT reload value. Used to reload RCNT when RCNT underflow.
S                                         This parameter can be a number between 0x00 and 0xFF. */
S
S} TM_RCNTConfigTypeDef;
S
N#endif
N
N/**
N * @name	TM_SOFTWARE_TRGOSTATE
N *   		Timer software control TRGO state
N */ 
N//!@{
N#define TM_SWTRGO_HIGH              (TM_TRG_TRGO_SW_1_w)        /*!< Timer control TRGO output 1.                   */
N#define TM_SWTRGO_LOW               (TM_TRG_TRGO_SW_0_w)        /*!< Timer control TRGO output 0.                   */
N//!@}
N
N
N
N
N
N
N
N
N/**
N *******************************************************************************
N * @brief       Software enable break state.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SOFTWARE_ENABLE_BREAK(__HANDLE__)  \
N    ((__HANDLE__)->Instance->BS.W |= (TM_SOFTWARE_ENABLE_BREAK))
X#define __DRV_TM_SOFTWARE_ENABLE_BREAK(__HANDLE__)      ((__HANDLE__)->Instance->BS.W |= (TM_SOFTWARE_ENABLE_BREAK))
N
N/**
N *******************************************************************************
N * @brief       Software disable break state.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SOFTWARE_DISABLE_BREAK(__HANDLE__) \
N    ((__HANDLE__)->Instance->BS.W &= (~(TM_SOFTWARE_DISABLE_BREAK)))
X#define __DRV_TM_SOFTWARE_DISABLE_BREAK(__HANDLE__)     ((__HANDLE__)->Instance->BS.W &= (~(TM_SOFTWARE_DISABLE_BREAK)))
N
N/**
N *******************************************************************************
N * @brief       Sets the TM break mode.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__BKMODE__ specifies the Break Mode.
N *  @arg\b      TM_BK_CYCLE_BY_CYCLE : Cycle by cycle mode.
N *  @arg\b      TM_BK_LATCH : Latch mode.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SET_BREAK_MODE(__HANDLE__, __BKMODE__)             \
N        ((__HANDLE__)->Instance->BS.W &= ~(TM_BS_BK_MDS_mask_w));   \
N        ((__HANDLE__)->Instance->BS.W |= (__BKMODE__))
X#define __DRV_TM_SET_BREAK_MODE(__HANDLE__, __BKMODE__)                     ((__HANDLE__)->Instance->BS.W &= ~(TM_BS_BK_MDS_mask_w));           ((__HANDLE__)->Instance->BS.W |= (__BKMODE__))
N
N
N/**
N *******************************************************************************
N * @brief       Enables the specified TM Break Source.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__BKSRC__" : specifies the TM break source to enable.
N *  @arg\b      MID_BK_ExtPin : TM36 Break External trigger pin.
N *  @arg\b      MID_BK_BOD1 : TM36 Break External trigger event from BOD1 event.
N *  @arg\b      MID_BK_INTPB : TM36 Break External trigger event from INT_PB.
N *  @arg\b      MID_BK_ADC0OUT : TM36 Break External trigger event from ADC0_OUT (Window detect).
N *  @arg\b      MID_BK_COMP0OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_COMP1OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_COMP2OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_COMP3OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_ClockFailure : Clock failure event.
N *  @arg\b      MID_BK_CPULOCKUP : CPU LOCKUP.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_BREAKSOURCE(__HANDLE__, __BKSRC__)  \
N    ((__HANDLE__)->Instance->BS.W |= (__BKSRC__))
X#define __DRV_TM_ENABLE_BREAKSOURCE(__HANDLE__, __BKSRC__)      ((__HANDLE__)->Instance->BS.W |= (__BKSRC__))
N
N/**
N *******************************************************************************
N * @brief       Disables the specified TM Break Source.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__BKSRC__" : specifies the TM break source to disable.
N *  @arg\b      MID_BK_ExtPin : TM36 Break External trigger pin.
N *  @arg\b      MID_BK_BOD1 : TM36 Break External trigger event from BOD1 event.
N *  @arg\b      MID_BK_INTPB : TM36 Break External trigger event from INT_PB.
N *  @arg\b      MID_BK_ADC0OUT : TM36 Break External trigger event from ADC0_OUT (Window detect).
N *  @arg\b      MID_BK_COMP0OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_COMP1OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_COMP2OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_COMP3OUT : Break External trigger event from Comparator0 output.
N *  @arg\b      MID_BK_ClockFailure : Clock failure event.
N *  @arg\b      MID_BK_CPULOCKUP : CPU LOCKUP.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_BREAKSOURCE(__HANDLE__, __BKSRC__) \
N    ((__HANDLE__)->Instance->BS.W &= ~(__BKSRC__))
X#define __DRV_TM_DISABLE_BREAKSOURCE(__HANDLE__, __BKSRC__)     ((__HANDLE__)->Instance->BS.W &= ~(__BKSRC__))
N
N/**
N *******************************************************************************
N * @brief       Enables the break function on PWM output channel.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N * @note        Break function uses only with TM36.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_BREAK(__HANDLE__)   \
N    ((__HANDLE__)->Instance->BS.W |= (TM_BREAK_ENABLE))
X#define __DRV_TM_ENABLE_BREAK(__HANDLE__)       ((__HANDLE__)->Instance->BS.W |= (TM_BREAK_ENABLE))
N
N/**
N *******************************************************************************
N * @brief       Disables the break function on PWM output channel.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N * @note        Break function uses only with TM36.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_BREAK(__HANDLE__)  \
N    ((__HANDLE__)->Instance->BS.W &= ~(TM_BREAK_ENABLE))
X#define __DRV_TM_DISABLE_BREAK(__HANDLE__)      ((__HANDLE__)->Instance->BS.W &= ~(TM_BREAK_ENABLE))
N
N/**
N *******************************************************************************
N * @brief       Disables the specified TM interrupt.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__INTERRUPT__" : specifies the TM interrupt source to enable.
N *  @arg\b      TM_IT_CC0 : Capture/Compare 0 interrupt.
N *  @arg\b      TM_IT_CC1 : Capture/Compare 1 interrupt.
N *  @arg\b      TM_IT_CC2 : Capture/Compare 2 interrupt.
N *  @arg\b      TM_IT_CC3 : Capture/Compare 3 interrupt.
N *  @arg\b      TM_IT_UPDATE : Main Counter update interrupt.
N *  @arg\b      TM_IT_UPDATE2 : Prescaler Counter update interrupt.
N *  @arg\b      TM_IT_BREAK : Break interrupt.
N *  @arg\b      TM_IT_EXTERNAL : External Trigger interrupt.
N *  @arg\b      TM_IT_QEI_DIRC : QEI direction change interrupt.
N *  @arg\b      TM_IT_QEI_INDEX : QEI Index interrupt.
N *  @arg\b      TM_IT_QEI_ERROR : QEI Error Position interrupt.
N *  @arg\b      TM_IT_ONEPULSE : Repetition timer underflow interrupt enable.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_IT(__HANDLE__, __INTERRUPT__)  \
N    ((__HANDLE__)->Instance->INT.W &= ~(__INTERRUPT__))
X#define __DRV_TM_DISABLE_IT(__HANDLE__, __INTERRUPT__)      ((__HANDLE__)->Instance->INT.W &= ~(__INTERRUPT__))
N
N
N/**
N *******************************************************************************
N * @brief       Reset TM handle state.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_RESET_HANDLE_STATE(__HANDLE__) \
N    ((__HANDLE__)->State = MID_TM_STATE_RESET)
X#define __DRV_TM_RESET_HANDLE_STATE(__HANDLE__)     ((__HANDLE__)->State = MID_TM_STATE_RESET)
N
N/**
N *******************************************************************************
N * @brief       Enable the TM peripheral.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE(__HANDLE__) \
N    ((__HANDLE__)->Instance->CR0.W |= TM_CR0_EN_enable_w | TM_CR0_EN2_enable_w)
X#define __DRV_TM_ENABLE(__HANDLE__)     ((__HANDLE__)->Instance->CR0.W |= TM_CR0_EN_enable_w | TM_CR0_EN2_enable_w)
N
N/**
N *******************************************************************************
N * @brief       Disable the TM peripheral.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE(__HANDLE__)                        \
N    do{                                                     \
N        if((__HANDLE__)->Instance->CCMDS.H[0] == 0x0000)    \
N        { \
N            (__HANDLE__)->Instance->CR0.W &= ~(TM_CR0_EN_enable_w | TM_CR0_EN2_enable_w); \
N        } \
N    }while (0)
X#define __DRV_TM_DISABLE(__HANDLE__)                            do{                                                             if((__HANDLE__)->Instance->CCMDS.H[0] == 0x0000)            {             (__HANDLE__)->Instance->CR0.W &= ~(TM_CR0_EN_enable_w | TM_CR0_EN2_enable_w);         }     }while (0)
N
N/**
N *******************************************************************************
N * @brief       Enables the specified TM interrupt.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__INTERRUPT__" : specifies the TM interrupt source to enable.
N *  @arg\b      TM_IT_CC0 : Capture/Compare 0 interrupt.
N *  @arg\b      TM_IT_CC1 : Capture/Compare 1 interrupt.
N *  @arg\b      TM_IT_CC2 : Capture/Compare 2 interrupt.
N *  @arg\b      TM_IT_CC3 : Capture/Compare 3 interrupt.
N *  @arg\b      TM_IT_UPDATE : Main Counter update interrupt.
N *  @arg\b      TM_IT_UPDATE2 : Prescaler Counter update interrupt.
N *  @arg\b      TM_IT_BREAK : Break interrupt.
N *  @arg\b      TM_IT_EXTERNAL : External Trigger interrupt.
N *  @arg\b      TM_IT_QEI_DIRC : QEI direction change interrupt.
N *  @arg\b      TM_IT_QEI_INDEX : QEI Index interrupt.
N *  @arg\b      TM_IT_QEI_ERROR : QEI Error Position interrupt.
N *  @arg\b      TM_IT_ONEPULSE : Repetition timer underflow interrupt enable.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_IT(__HANDLE__, __INTERRUPT__)   \
N    ((__HANDLE__)->Instance->INT.W |= (__INTERRUPT__))
X#define __DRV_TM_ENABLE_IT(__HANDLE__, __INTERRUPT__)       ((__HANDLE__)->Instance->INT.W |= (__INTERRUPT__))
N
N/**
N *******************************************************************************
N * @brief       Checks whether the specified TM interrupt has occurred or not.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__INTERRUPT__" : specifies the TM interrupt source to enable.
N *  @arg\b      TM_IT_CC0 : Capture/Compare 0 interrupt.
N *  @arg\b      TM_IT_CC1 : Capture/Compare 1 interrupt.
N *  @arg\b      TM_IT_CC2 : Capture/Compare 2 interrupt.
N *  @arg\b      TM_IT_CC3 : Capture/Compare 3 interrupt.
N *  @arg\b      TM_IT_UPDATE : Main Counter update interrupt.
N *  @arg\b      TM_IT_UPDATE2 : Prescaler Counter update interrupt.
N *  @arg\b      TM_IT_BREAK : Break interrupt.
N *  @arg\b      TM_IT_EXTERNAL : External Trigger interrupt.
N *  @arg\b      TM_IT_QEI_DIRC : QEI direction change interrupt.
N *  @arg\b      TM_IT_QEI_INDEX : QEI Index interrupt.
N *  @arg\b      TM_IT_QEI_ERROR : QEI Error Position interrupt.
N *  @arg\b      TM_IT_ONEPULSE : Repetition timer underflow interrupt enable.
N * @return		The state of EVENT (SET or RESET).
N *******************************************************************************
N */
N#define __DRV_TM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   \
N    (((__HANDLE__)->Instance->INT.W & (__INTERRUPT__)) == (__INTERRUPT__))
X#define __DRV_TM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)       (((__HANDLE__)->Instance->INT.W & (__INTERRUPT__)) == (__INTERRUPT__))
N
N
N/**
N *******************************************************************************
N * @brief       Enables the specified TM All interrupt.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_ITEA(__HANDLE__)    \
N    ((__HANDLE__)->Instance->INT.W |= TM_INT_IEA_enable_w)
X#define __DRV_TM_ENABLE_ITEA(__HANDLE__)        ((__HANDLE__)->Instance->INT.W |= TM_INT_IEA_enable_w)
N
N/**
N *******************************************************************************
N * @brief       Disables the specified TM All interrupt.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_ITEA(__HANDLE__)               \
N    do{                                                 \
N        if((__HANDLE__)->Instance->INT.W != 0x00000000) \
N        { \
N            ((__HANDLE__)->Instance->INT.W &= ~TM_INT_IEA_enable_w); \
N        } \
N    }while (0)
X#define __DRV_TM_DISABLE_ITEA(__HANDLE__)                   do{                                                         if((__HANDLE__)->Instance->INT.W != 0x00000000)         {             ((__HANDLE__)->Instance->INT.W &= ~TM_INT_IEA_enable_w);         }     }while (0)
N    
N
N/**
N *******************************************************************************
N * @brief       Enables the specified DMA request.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__DMA__" : specifies the TM DMA request to enable.
N *  @arg\b      TM_DMA_CH0_OC.
N *  @arg\b      TM_DMA_CH1_OC.
N *  @arg\b      TM_DMA_CH2_OC.
N *  @arg\b      TM_DMA_CH3_IC.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_DMA(__HANDLE__, __DMA__)    \
N    ((__HANDLE__)->Instance->CCMDS.W |= (__DMA__))
X#define __DRV_TM_ENABLE_DMA(__HANDLE__, __DMA__)        ((__HANDLE__)->Instance->CCMDS.W |= (__DMA__))
N
N/**
N *******************************************************************************
N * @brief       Disables the specified DMA request.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__DMA__" : specifies the TM DMA request to enable.
N *  @arg\b      TM_DMA_CH0_OC.
N *  @arg\b      TM_DMA_CH1_OC.
N *  @arg\b      TM_DMA_CH2_OC.
N *  @arg\b      TM_DMA_CH3_IC.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_DMA(__HANDLE__, __DMA__)   \
N    ((__HANDLE__)->Instance->CCMDS.W &= ~(__DMA__))
X#define __DRV_TM_DISABLE_DMA(__HANDLE__, __DMA__)       ((__HANDLE__)->Instance->CCMDS.W &= ~(__DMA__))
N
N/**
N *******************************************************************************
N * @brief       Get the TM interrupt pending bits.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__FLAG__" : specifies the TM interrupt flag to clear.
N *  @arg\b      TM_FLAG_CC0A : Capture/Compare-A 0 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC1A : Capture/Compare-A 1 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC2A : Capture/Compare-A 2 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC3A : Capture/Compare-A 3 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC0B : Capture/Compare-B 0 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC1B : Capture/Compare-B 1 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC2B : Capture/Compare-B 2 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC3B : Capture/Compare-B 3 interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE_UP : Main counter overflow interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE_DOWN : Main counter underflow interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE2_UP : Prescaler counter overflow interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE2_DOWN : Prescaler counter underflow interrupt pending bit.
N *  @arg\b      TM_FLAG_BREAK : TM receive break interrupt pending bit.
N *  @arg\b      TM_FLAG_EXTERNAL : TM receive external trigger interrupt pending bit.
N *  @arg\b      TM_FLAG_QEI_DIRCHANGE : QEI change directiuon interrupt pending bit.
N *  @arg\b      TM_FLAG_QEI_INDEX : QEI index signal interrupt pending bit.
N *  @arg\b      TM_FLAG_QEI_ERROR : QEI error interrupt pending bit.
N *  @arg\b      TM_FLAG_DIRECTION : TM counter direction state.
N *  @arg\b      TM_FLAG_ONEPULSE : TM Repetition timer underflow flag.
N * @return      The state of FLAG (SET or RESET).
N *******************************************************************************
N */
N#define __DRV_TM_GET_FLAG(__HANDLE__,__FLAG__)  \
N    (((__HANDLE__)->Instance->STA.W & (__FLAG__)) == (__FLAG__))
X#define __DRV_TM_GET_FLAG(__HANDLE__,__FLAG__)      (((__HANDLE__)->Instance->STA.W & (__FLAG__)) == (__FLAG__))
N
N/**
N *******************************************************************************
N * @brief       Get the TM event interrupt pending bits.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__EVENT__" : specifies the TM interrupt flag to clear.
N *  @arg\b      TM_EVENT_UPDATE. 
N *  @arg\b      TM_EVENT_UPDATE2.
N *  @arg\b      TM_EVENT_CH0.    
N *  @arg\b      TM_EVENT_CH1.    
N *  @arg\b      TM_EVENT_CH2.    
N *  @arg\b      TM_EVENT_CH3.    
N *  @arg\b      TM_EVENT_QEI.    
N *  @arg\b      TM_EVENT_ONEPULSE.    
N * @return      The state of FLAG (SET or RESET).
N *******************************************************************************
N */
N#define __DRV_TM_GET_EVENT(__HANDLE__,__EVENT__)  \
N    (((__HANDLE__)->Instance->STA.W & (__EVENT__)) != (0))
X#define __DRV_TM_GET_EVENT(__HANDLE__,__EVENT__)      (((__HANDLE__)->Instance->STA.W & (__EVENT__)) != (0))
N
N/**
N *******************************************************************************
N * @brief       Clear the TM interrupt pending bits.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__FLAG__" : specifies the TM interrupt flag to clear.
N *  @arg\b      TM_FLAG_CC0A : Capture/Compare-A 0 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC1A : Capture/Compare-A 1 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC2A : Capture/Compare-A 2 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC3A : Capture/Compare-A 3 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC0B : Capture/Compare-B 0 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC1B : Capture/Compare-B 1 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC2B : Capture/Compare-B 2 interrupt pending bit.
N *  @arg\b      TM_FLAG_CC3B : Capture/Compare-B 3 interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE_UP : Main counter overflow interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE_DOWN : Main counter underflow interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE2_UP : Prescaler counter overflow interrupt pending bit.
N *  @arg\b      TM_FLAG_UPDATE2_DOWN : Prescaler counter underflow interrupt pending bit.
N *  @arg\b      TM_FLAG_BREAK : TM receive break interrupt pending bit.
N *  @arg\b      TM_FLAG_EXTERNAL : TM receive external trigger interrupt pending bit.
N *  @arg\b      TM_FLAG_QEI_DIRCHANGE : QEI change directiuon interrupt pending bit.
N *  @arg\b      TM_FLAG_QEI_INDEX : QEI index signal interrupt pending bit.
N *  @arg\b      TM_FLAG_QEI_ERROR : QEI error interrupt pending bit.
N *  @arg\b      TM_FLAG_DIRECTION : TM counter direction state.
N *  @arg\b      TM_FLAG_ONEPULSE : TM Repetition timer underflow flag.
N * @return      None
N *******************************************************************************
N */
N#define __DRV_TM_CLEAR_FLAG(__HANDLE__,__FLAG__)    \
N    ((__HANDLE__)->Instance->STA.W = (__FLAG__))
X#define __DRV_TM_CLEAR_FLAG(__HANDLE__,__FLAG__)        ((__HANDLE__)->Instance->STA.W = (__FLAG__))
N
N
N/**
N *******************************************************************************
N * @brief       Sets the TM active prescaler register value on update event.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__PRESC__" : specifies the active prescaler register new value.
N * @return      None
N *******************************************************************************
N */
N#define __DRV_TM_SET_PRESCALER(__HANDLE__, __PRESC__)   \
N    ((__HANDLE__)->Instance->PSCNT.W = (__PRESC__))
X#define __DRV_TM_SET_PRESCALER(__HANDLE__, __PRESC__)       ((__HANDLE__)->Instance->PSCNT.W = (__PRESC__))
N
N/**
N *******************************************************************************
N * @brief       Sets the TM Capture Compare Register value on run time without
N *              calling another TMe ConfigChannel function.t.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__CHANNEL__" : TM Channels to be configured.
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   "__COMPARE__ specifies the Capture Compare register new value.
N * @return      None
N *******************************************************************************
N */
N#define __DRV_TM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \
N    (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0A.W) + (__CHANNEL__ << 1)) = (__COMPARE__))
X#define __DRV_TM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__)     (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0A.W) + (__CHANNEL__ << 1)) = (__COMPARE__))
N
N/**
N *******************************************************************************
N * @brief       Sets the TM Capture Compare Register-B value on run time without
N *              calling another TMe ConfigChannel function.t.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__CHANNEL__" TM Channels to be configured.
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   "__COMPARE__" : specifies the Capture Compare register new value.
N * @return      None
N *******************************************************************************
N */
N#define __DRV_TM_SET_COMPARE_B(__HANDLE__, __CHANNEL__, __COMPARE__) \
N    (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0B.W) + (__CHANNEL__ << 1)) = (__COMPARE__))
X#define __DRV_TM_SET_COMPARE_B(__HANDLE__, __CHANNEL__, __COMPARE__)     (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0B.W) + (__CHANNEL__ << 1)) = (__COMPARE__))
N
N
N/**
N *******************************************************************************
N * @brief       Gets the TM Capture Compare Register value on run time
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__CHANNEL__" : TM Channels to be configured.
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      16-bit value of the capture/compare register
N *******************************************************************************
N */
N#define __DRV_TM_GET_COMPARE(__HANDLE__, __CHANNEL__) \
N    (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0A.W) + (__CHANNEL__ << 1)))
X#define __DRV_TM_GET_COMPARE(__HANDLE__, __CHANNEL__)     (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0A.W) + (__CHANNEL__ << 1)))
N
N/**
N *******************************************************************************
N * @brief       Gets the TM Capture Compare Register-B value on run time
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__CHANNEL__" : TM Channels to be configured.
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt.
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt.
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt.
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt.
N * @return      16-bit value of the capture/compare register.
N *******************************************************************************
N */
N#define __DRV_TM_GET_COMPARE_B(__HANDLE__, __CHANNEL__) \
N    (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0B.W) + (__CHANNEL__ << 1)))
X#define __DRV_TM_GET_COMPARE_B(__HANDLE__, __CHANNEL__)     (*(__IO uint32_t *)(&((__HANDLE__)->Instance->CC0B.W) + (__CHANNEL__ << 1)))
N
N
N/**
N *******************************************************************************
N * @brief       Sets the TM Counter Register value on run time.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__COUNTER__" : specifies the Counter register new value.
N * @return      None
N *******************************************************************************
N */
N#define __DRV_TM_SET_COUNTER(__HANDLE__, __COUNTER__)   \
N    ((__HANDLE__)->Instance->CNT.W = (__COUNTER__))
X#define __DRV_TM_SET_COUNTER(__HANDLE__, __COUNTER__)       ((__HANDLE__)->Instance->CNT.W = (__COUNTER__))
N
N/**
N *******************************************************************************
N * @brief       Gets the TM Counter Register value on run time.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @return      8-bit or 16-bit value of the timer counter register (TMx_CNT).
N *******************************************************************************
N */
N#define __DRV_TM_GET_COUNTER(__HANDLE__)    \
N    ((__HANDLE__)->Instance->CNT.W)
X#define __DRV_TM_GET_COUNTER(__HANDLE__)        ((__HANDLE__)->Instance->CNT.W)
N
N/**
N *******************************************************************************
N * @brief       Sets the TM Autoreload Register value on runTMe without calling
N *              another time any Init function.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__AUTORELOAD__" : specifies the Counter register new value.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__) \
N    (__HANDLE__)->Instance->ARR.W = (__AUTORELOAD__);       \
N    (__HANDLE__)->Init.TM_Period = (__AUTORELOAD__)
X#define __DRV_TM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__)     (__HANDLE__)->Instance->ARR.W = (__AUTORELOAD__);           (__HANDLE__)->Init.TM_Period = (__AUTORELOAD__)
N
N/**
N *******************************************************************************
N * @brief       Gets the TM Autoreload Register value on run time.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @return      8-bit or 16-bit value of the timer counter register (TMx_ARR).
N *******************************************************************************
N */
N#define __DRV_TM_GET_AUTORELOAD(__HANDLE__) \
N    ((__HANDLE__)->Instance->ARR.W)
X#define __DRV_TM_GET_AUTORELOAD(__HANDLE__)     ((__HANDLE__)->Instance->ARR.W)
N
N/**
N *******************************************************************************
N * @brief       Sets the TM Clock Division value on run time without calling
N *              another initial function.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__CKD__" : specifies the clock division value.
N *              This parameter can be one of the following value:
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV1: tDTS=tCK_INT.
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV2: tDTS=2*tCK_INT.
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV4: tDTS=4*tCK_INT.
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV8: tDTS=8*tCK_INT.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SET_CLOCKDIVISION(__HANDLE__, __CKD__) \
N    (__HANDLE__)->Instance->CLK.W &= ~(0x00003000U);    \
N    ((__HANDLE__)->Instance->CLK.W |= (__CKD__))
X#define __DRV_TM_SET_CLOCKDIVISION(__HANDLE__, __CKD__)     (__HANDLE__)->Instance->CLK.W &= ~(0x00003000U);        ((__HANDLE__)->Instance->CLK.W |= (__CKD__))
N    
N
N/**
N *******************************************************************************
N * @brief       Gets the TM Clock Division value on run time.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @return      The clock division can be one of the following values:
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV1: tDTS=tCK_INT.
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV2: tDTS=2*tCK_INT.
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV4: tDTS=4*tCK_INT.
N *  @arg\b      TM_INTERNALCLOCK_DIVDER_DIV8: tDTS=8*tCK_INT.
N * @return      The state of FLAG (TM_INTERNALCLOCK_DIVDER_DIV1~8).
N *******************************************************************************
N */
N#define __DRV_TM_GET_CLOCKDIVISION(__HANDLE__)  \
N    ((__HANDLE__)->Instance->CLK.W & 0x3000)
X#define __DRV_TM_GET_CLOCKDIVISION(__HANDLE__)      ((__HANDLE__)->Instance->CLK.W & 0x3000)
N    
N
N/**
N *******************************************************************************
N * @brief       Sets the TM Capture x input polarity on run time.
N * @param[in]   "__HANDLE__" : specifies the TM Handle.
N * @param[in]   "__CHANNEL__" : TM Channels to be configured.
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt.
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt.
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt.
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt.
N * @param[in]   "__POLARITY__" : Polarity for ICx source.
N *  @arg\b      TM_ICPOLARITY_DISABLE : Disable input catpure trigger.
N *  @arg\b      TM_ICPOLARITY_RISING : Accept external rising edge trigger.
N *  @arg\b      TM_ICPOLARITY_FALLING : Accept external falling edge trigger.
N *  @arg\b      TM_ICPOLARITY_DUALEDGE : Accept external dual edge trigger.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__,__POLARITY__)           \
N    ((__HANDLE__)->Instance->ICCR &= ~(TM_ICCR_IC0_TRGS_mask_w << (__CHANNEL__)));  \
N    ((__HANDLE__)->Instance->ICCR &= ~((__POLARITY__) << (__CHANNEL__)))
X#define __DRV_TM_SET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__,__POLARITY__)               ((__HANDLE__)->Instance->ICCR &= ~(TM_ICCR_IC0_TRGS_mask_w << (__CHANNEL__)));      ((__HANDLE__)->Instance->ICCR &= ~((__POLARITY__) << (__CHANNEL__)))
N
N
N/**
N *******************************************************************************
N * @brief       Enables the specified TM PWM with Central-Align.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_PWM_CENTRAL(__HANDLE__)   \
N    ((__HANDLE__)->Instance->PWM.W |= TM_PWM_PWM_MDS_center_aligned_w)
X#define __DRV_TM_ENABLE_PWM_CENTRAL(__HANDLE__)       ((__HANDLE__)->Instance->PWM.W |= TM_PWM_PWM_MDS_center_aligned_w)
N
N/**
N *******************************************************************************
N * @brief       Disables the specified TM PWM with Central-Align.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_PWM_CENTRAL(__HANDLE__)   \
N    ((__HANDLE__)->Instance->PWM.W &= ~TM_PWM_PWM_MDS_mask_w)
X#define __DRV_TM_DISABLE_PWM_CENTRAL(__HANDLE__)       ((__HANDLE__)->Instance->PWM.W &= ~TM_PWM_PWM_MDS_mask_w)
N
N/**
N *******************************************************************************
N * @brief       Reset TM timer depend on counter direction.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_RESET_TIMER(__HANDLE__) \
N    ((__HANDLE__)->Instance->TRG.W |= (TM_TRG_RST2_SW_enable_w | TM_TRG_RST_SW_enable_w)); \
N    ((__HANDLE__)->Instance->TRG.W &= ~(TM_TRG_RST2_SW_enable_w | TM_TRG_RST_SW_enable_w))
X#define __DRV_TM_RESET_TIMER(__HANDLE__)     ((__HANDLE__)->Instance->TRG.W |= (TM_TRG_RST2_SW_enable_w | TM_TRG_RST_SW_enable_w));     ((__HANDLE__)->Instance->TRG.W &= ~(TM_TRG_RST2_SW_enable_w | TM_TRG_RST_SW_enable_w))
N
N
N/**
N *******************************************************************************
N * @brief       Set OC0x & OC1x the output state when Preload trigger event happened.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__PRELOADOUTPUT__" : specifies the TM_PreLoad_CH0 & TM_PreLoad_CH1.
N *  @arg\b      TM_PRELOADOC00_ENABLE : It will replace OC00 output control.
N *  @arg\b      TM_PRELOADOC01_ENABLE : It will replace OC01 output control.
N *  @arg\b      TM_PRELOADOC02_ENABLE : It will replace OC02 output control.
N *  @arg\b      TM_PRELOADOC10_ENABLE : It will replace OC10 output control.
N *  @arg\b      TM_PRELOADOC11_ENABLE : It will replace OC11 output control.
N *  @arg\b      TM_PRELOADOC12_ENABLE : It will replace OC12 output control.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SET_PRELOAD_OUTPUT(__HANDLE__, __PRELOADOUTPUT__)  \
N    ((__HANDLE__)->Instance->OCCR1.B[2] = (__PRELOADOUTPUT__))
X#define __DRV_TM_SET_PRELOAD_OUTPUT(__HANDLE__, __PRELOADOUTPUT__)      ((__HANDLE__)->Instance->OCCR1.B[2] = (__PRELOADOUTPUT__))
N
N
N/**
N *******************************************************************************
N * @brief       Software output enable preload function.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SOFTWARE_PRELOAD(__HANDLE__)   \
N    ((__HANDLE__)->Instance->OCCR1.W |= TM_OCCR1_POE_SW_enable_w)
X#define __DRV_TM_SOFTWARE_PRELOAD(__HANDLE__)       ((__HANDLE__)->Instance->OCCR1.W |= TM_OCCR1_POE_SW_enable_w)
N
N
N/**
N *******************************************************************************
N * @brief       Enable preload trigger source.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__PRELOADTRGSOURCE__" : specifies the TM_PreloadTrgSource.
N *  @arg\b      TM_PRELOAD_3XOR : Preload trigger source from 3-line XOR.
N *  @arg\b      TM_PRELOAD_INTPB : It will replace OC01 output control.
N *  @arg\b      TM_PRELOAD_INTPD : It will replace OC02 output control.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_ENABLE_PRELOAD(__HANDLE__, __PRELOADTRGSOURCE__)         \
N            ((__HANDLE__)->Instance->OCCR1.W |= (__PRELOADTRGSOURCE__))
X#define __DRV_TM_ENABLE_PRELOAD(__HANDLE__, __PRELOADTRGSOURCE__)                     ((__HANDLE__)->Instance->OCCR1.W |= (__PRELOADTRGSOURCE__))
N
N
N/**
N *******************************************************************************
N * @brief       Disable preload trigger source.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef.
N * @param[in]   "__PRELOADTRGSOURCE__" : specifies the TM_PreloadTrgSource.
N *  @arg\b      TM_PRELOAD_3XOR : Preload trigger source from 3-line XOR.
N *  @arg\b      TM_PRELOAD_INTPB : It will replace OC01 output control.
N *  @arg\b      TM_PRELOAD_INTPD : It will replace OC02 output control.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_DISABLE_PRELOAD(__HANDLE__, __PRELOADTRGSOURCE__)      \
N            ((__HANDLE__)->Instance->OCCR1.W &= ~(__PRELOADTRGSOURCE__))
X#define __DRV_TM_DISABLE_PRELOAD(__HANDLE__, __PRELOADTRGSOURCE__)                  ((__HANDLE__)->Instance->OCCR1.W &= ~(__PRELOADTRGSOURCE__))
N
N
N/**
N *******************************************************************************
N * @brief       Set DMA update timing.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef
N * @param[in]   "__UPLOADTIMING__" : specifies the TM_DMAUpdateTiming.
N *  @arg\b      TM_UPDATEG_EVENT_TIMING : Every TM main counter update 
N *              event will update OC/PWM's channel-X compare-B.
N *  @arg\b      TM_ITR_EVENT_TIMING : Both UEV (update event) and ITR input event 
N *              has occurred then trigger DMA to update.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SET_DMA_UPLOAD_TIMING(__HANDLE__, __UPLOADTIMING__)            \
N            ((__HANDLE__)->Instance->CCMDS.W &= ~(TM_CCMDS_DMA_OMDS_mask_w));   \
N            ((__HANDLE__)->Instance->CCMDS.W |= (__UPLOADTIMING__))
X#define __DRV_TM_SET_DMA_UPLOAD_TIMING(__HANDLE__, __UPLOADTIMING__)                        ((__HANDLE__)->Instance->CCMDS.W &= ~(TM_CCMDS_DMA_OMDS_mask_w));               ((__HANDLE__)->Instance->CCMDS.W |= (__UPLOADTIMING__))
N
N
N/**
N *******************************************************************************
N * @brief       Software control Timer TRGO state.
N * @param[in]   "__HANDLE__" : pointer to a TM_HandleTypeDef
N * @param[in]   "__TRGOSTATE__" : specifies the TM_SOFTWARE_TRGOSTATE.
N *  @arg\b      TM_SWTRGO_HIGH : Timer TRGO will output high state.
N *  @arg\b      TM_SWTRGO_LOW : Timer TRGO will output low state.
N * @return      None.
N *******************************************************************************
N */
N#define __DRV_TM_SOFTWARE_TRGO(__HANDLE__, __TRGOSTATE__)                       \
N            ((__HANDLE__)->Instance->TRG.W = ((__HANDLE__)->Instance->TRG.W & ~(TM_TRG_TRGO_SW_mask_w)) | (__TRGOSTATE__))
X#define __DRV_TM_SOFTWARE_TRGO(__HANDLE__, __TRGOSTATE__)                                   ((__HANDLE__)->Instance->TRG.W = ((__HANDLE__)->Instance->TRG.W & ~(TM_TRG_TRGO_SW_mask_w)) | (__TRGOSTATE__))
N
N
N
N
N
N
N
N/**
N * @name    Function announce
N * @brief   Time base initial/Deinitial`
N */
N///@{
NMID_StatusTypeDef MID_TM_Base_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_Base_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_Base_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_Base_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_Base_Start(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_Base_Stop(TM_HandleTypeDef* mTM);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_Base_Start_IT(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_Base_Stop_IT(TM_HandleTypeDef* mTM);
N/* Non-Blocking mode: DMA (no support)*/
N///@}
N
N/**
N * @name    Function announce
N * @brief   Timer 16bit Output Compare functions
N */
N///@{
NMID_StatusTypeDef MID_TM_OC_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_OC_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_OC_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_OC_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_OC_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_OC_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_OC_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_OC_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_OC_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_OC_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N/**
N * @name    Function announce
N * @brief   Timer 8bitx2 Output Compare functions
N */
N///@{
NMID_StatusTypeDef MID_TM_8Bx2OC_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_8Bx2OC_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_8Bx2OC_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_8Bx2OC_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_8Bx2OC_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_8Bx2OC_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_8Bx2OC_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_8Bx2OC_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_8Bx2OC_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_8Bx2OC_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N/**
N * @name    Function announce
N * @brief   Timer 16 bit PWM functions
N */
N///@{
NMID_StatusTypeDef MID_TM_PWM_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_PWM_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_PWM_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_PWM_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_PWM_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_PWM_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_PWM_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_PWM_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_PWM_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_PWM_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   Timer 8bitx2 bit PWM functions
N */
N///@{
NMID_StatusTypeDef MID_TM_8Bx2PWM_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_8Bx2PWM_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_8Bx2PWM_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_8Bx2PWM_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_8Bx2PWM_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_8Bx2PWM_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_8Bx2PWM_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   Timer 16 bit PWM with Dead-Time functions
N */
N///@{
NMID_StatusTypeDef MID_TM_PWM_DTG_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_PWM_DTG_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_PWM_DTG_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_PWM_DTG_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_PWM_DTG_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_PWM_DTG_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_PWM_DTG_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_PWM_DTG_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_PWM_DTG_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_PWM_DTG_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N/**
N * @name    Function announce
N * @brief   Timer 8bitx2 bit PWM with Dead-Time functions
N */
N///@{
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_8Bx2PWM_DTG_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_8Bx2PWM_DTG_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   Timer Input Capture functions
N */
N///@{
NMID_StatusTypeDef MID_TM_IC_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_IC_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_IC_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_IC_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_IC_Start(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_IC_Stop(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_IC_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
NMID_StatusTypeDef MID_TM_IC_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NMID_StatusTypeDef MID_TM_IC_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length);
NMID_StatusTypeDef MID_TM_IC_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   Timer One-plus functions (for MG32F02A128/U128/A064/U064)
N */
N///@{
N#if defined(MG32_3RD)
X#if 0L
SMID_StatusTypeDef MID_TM_OnePulse_Init(TM_HandleTypeDef *mTM, TM_RCNTConfigTypeDef* sRCNTConfig);
SMID_StatusTypeDef MID_TM_OnePulse_DeInit(TM_HandleTypeDef* mTM);
Svoid MID_TM_OnePulse_MspInit(TM_HandleTypeDef *mTM);
Svoid MID_TM_OnePulse_MspDeInit(TM_HandleTypeDef* mTM);
S/* Blocking mode: Polling */
SMID_StatusTypeDef MID_TM_OnePulse_Start(TM_HandleTypeDef* mTMX);
SMID_StatusTypeDef MID_TM_OnePulse_Stop(TM_HandleTypeDef* mTM);
S/* Non-Blocking mode: Interrupt */
SMID_StatusTypeDef MID_TM_OnePulse_Start_IT(TM_HandleTypeDef* mTM);
SMID_StatusTypeDef MID_TM_OnePulse_Stop_IT(TM_HandleTypeDef* mTM);
N#endif
N///@}
N
N
N
N/**
N * @name    Function announce
N * @brief   Timer Encoder functions
N */
N///@{
NMID_StatusTypeDef MID_TM_Encoder_Init(TM_HandleTypeDef* mTM);
NMID_StatusTypeDef MID_TM_Encoder_DeInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_Encoder_MspInit(TM_HandleTypeDef* mTM);
Nvoid MID_TM_Encoder_MspDeInit(TM_HandleTypeDef* mTM);
N/* Blocking mode: Polling */
NMID_StatusTypeDef MID_TM_Encoder_Start(TM_HandleTypeDef* mTM,  TM_Encoder_InitTypeDef* sConfig);
NMID_StatusTypeDef MID_TM_Encoder_Stop(TM_HandleTypeDef* mTM);
N/* Non-Blocking mode: Interrupt */
NMID_StatusTypeDef MID_TM_Encoder_Start_IT(TM_HandleTypeDef* mTM, TM_Encoder_InitTypeDef* sConfig, uint32_t ITSrc);
NMID_StatusTypeDef MID_TM_Encoder_Stop_IT(TM_HandleTypeDef* mTM, uint32_t ITSrc);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   addtogroup TM_Exported_Functions_Group7
N */
N///@{
NMID_TM_StateTypeDef MID_TM_Base_GetState(TM_HandleTypeDef* mTM);
NMID_TM_StateTypeDef MID_TM_OC_GetState(TM_HandleTypeDef* mTM);
NMID_TM_StateTypeDef MID_TM_PWM_GetState(TM_HandleTypeDef* mTM);
NMID_TM_StateTypeDef MID_TM_IC_GetState(TM_HandleTypeDef* mTM);
NMID_TM_StateTypeDef MID_TM_Encoder_GetState(TM_HandleTypeDef* mTM);
N#if defined(MG32_3RD)
X#if 0L
SMID_TM_StateTypeDef MID_TM_OnePulse_GetState(TM_HandleTypeDef* mTM);
N#endif
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   addtogroup TM_Exported_Functions_Group8
N */
N///@{
Nvoid MID_TM_OC_Struct_Init(TM_OC_InitTypeDef* sConfig);
NMID_StatusTypeDef MID_TM_OC_ConfigChannel(TM_HandleTypeDef* mTM, TM_OC_InitTypeDef* sConfig, uint32_t Channel);
NMID_StatusTypeDef MID_TM_IC_ConfigChannel(TM_HandleTypeDef* mTM, TM_IC_InitTypeDef* sConfig, uint32_t Channel);
NMID_StatusTypeDef MID_TM_PWM_ConfigChannel(TM_HandleTypeDef* mTM, TM_OC_InitTypeDef* sConfig, uint32_t Channel);
NMID_StatusTypeDef MID_TM_GenerateEvent(TM_HandleTypeDef* mTM, uint32_t EventSource);
NMID_StatusTypeDef MID_TM_ConfigClockSource(TM_HandleTypeDef* mTM, TM_ClockConfigTypeDef * sClockSourceConfig);
NMID_StatusTypeDef MID_TM_MasterConfigSynchronization(TM_HandleTypeDef* mTM, TM_MasterConfigTypeDef * sMasterConfig);
NMID_StatusTypeDef MID_TM_ConfigBreakDeadTime(TM_HandleTypeDef* mTM, TM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig);
NMID_StatusTypeDef MID_TM_SlaveConfigSynchronization(TM_HandleTypeDef* mTM, TM_SlaveConfigTypeDef* sSlaveConfig);
NMID_StatusTypeDef MID_TM_SlaveConfigSynchronization_IT(TM_HandleTypeDef* mTM, TM_SlaveConfigTypeDef* sSlaveConfig);
NMID_StatusTypeDef MID_TM_ClockOut(TM_HandleTypeDef* mTM, TM_CKOConfigTypeDef* sClockConfig);
Nuint32_t MID_TM_ReadCapturedValue(TM_HandleTypeDef *mTM, uint32_t Channel);
N///@}
N
N/**
N * @name    Function announce
N * @brief   Callback in non blocking modes (Interrupt and DMA)
N */
N///@{
Nvoid TM_DMAError(DMA_HandleTypeDef* hDMA);
Nvoid TM_DMADelayPulseCplt(DMA_HandleTypeDef* hDMA);
Nvoid TM_DMACaptureCplt(DMA_HandleTypeDef* hDMA);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   Callback in non blocking modes (Interrupt and DMA)
N */
N///@{
Nvoid MID_TM_IRQHandler(TM_HandleTypeDef* mTM);
Nvoid MID_TM_PeriodElapsedCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_OC_DelayElapsedCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_IC_CaptureCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_PWM_PulseFinishedCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_TriggerCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_ErrorCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_BreakCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_QEI_DIRCHANGECallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_QEI_INDEXCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_QEI_ErrorCallback(TM_HandleTypeDef* mTM);
Nvoid MID_TM_OnePulseCallback(TM_HandleTypeDef* mTM);
N///@}
N
N
N/**
N * @name    Function announce
N * @brief   addtogroup TM_Private_Functions
N */
N///@{
Nvoid TM_Base_SetConfig(TM_Struct* TMx, TM_Base_InitTypeDef* Structure);
Nstatic void TM_OC0_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config);
Nstatic void TM_OC1_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config);
Nstatic void TM_OC2_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config);
Nstatic void TM_OC3_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config);
Nstatic void TM_SlaveTimer_SetConfig(TM_HandleTypeDef* mTM, TM_SlaveConfigTypeDef* sSlaveConfig);
Nvoid TM_CCxChannelCmd(TM_Struct* TMx, uint32_t Channel, uint32_t ChannelMode);
Nvoid MID_TM_OC_SetDeadTimeDivider(TM_HandleTypeDef* mTM,  uint32_t DeadTimeDivider);
Nvoid MID_TM_OC_SetDeadTime(TM_HandleTypeDef* mTM,  uint32_t DeadTime);
N///@}
N
N#endif
N
L 33 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_TM_MID.c" 2
N
N
N/**
N* @name    Initial/Deinitial TM with TM_HandleTypeDef
N*
N*/
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM base Unit according to the specified
N *              parameters in the TM_HandleTypeDef and create the associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    
N    mTM36.Instance = TM36;
N    mTM36.Init.TM_CounterMode = TM_CASCADE_UP;
N    mTM36.Init.TM_Period = 1023;
N    mTM36.Init.TM_Prescaler = 0;
N    mTM36.State = MID_TM_STATE_RESET;
N
N    MID_TM_Base_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Base_Init(TM_HandleTypeDef* mTM)
N{
N    /* Check the TM handle allocation */
N    if(mTM == NULL)
X    if(mTM == 0)
N        return MID_FAILURE;
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC */
N        MID_TM_Base_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Set the Time Base configuration */
N    TM_Base_SetConfig(mTM->Instance, &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State = MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM Base peripheral
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N
N    MID_TM_Base_DeInit(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Base_DeInit(TM_HandleTypeDef* mTM)
N{
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
N    MID_TM_Base_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM Base MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_Base_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_Base_MspInit could be implemented in the user file
N     */
N}
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM Base MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_Base_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_Base_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N* @name    Srart/Stop TM with TM_HandleTypeDef (IT, DMA)
N*
N*/
N/**
N *******************************************************************************
N * @brief       Starts the TM Base generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // to do ...
N    
N    MID_TM_Base_Start(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Base_Start(TM_HandleTypeDef* mTM)
N{
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Change the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stop the TM Base generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // to do ...
N    
N    MID_TM_Base_Stop(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Base_Stop(TM_HandleTypeDef* mTM)
N{
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Base generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // to do ...
N    
N    MID_TM_Base_Start_IT(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Base_Start_IT(TM_HandleTypeDef* mTM)
N{
N    /* Enable the TM Update interrupt */
N    __DRV_TM_ENABLE_IT(mTM, TM_IT_UPDATE);
X    ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000010)));
N    __DRV_TM_ENABLE_ITEA(mTM);
X    ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stop the TM Base generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // to do ...
N    
N    MID_TM_Base_Stop_IT(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Base_Stop_IT(TM_HandleTypeDef* mTM)
N{
N    /* Disable the TM Update interrupt */
N    __DRV_TM_DISABLE_IT(mTM, TM_IT_UPDATE);
X    ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000010)));
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N    
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N///@}
N
N
N
N
N
N/**
N * @name    Output Compare
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Starts the TM Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N    mTM36.Init.TM_CounterMode = TM_SEPARATE_UP;
N    mTM36.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM36.Init.TM_Period = 0x00FF;
N    mTM36.Init.TM_Prescaler = 0;
N    mTM36.State = MID_TM_STATE_RESET;
N    
N    MID_TM_OC_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Init(TM_HandleTypeDef* mTM)
N{
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_OC_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the Output Compare */
N    TM_Base_SetConfig(mTM->Instance,  &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N
N    MID_TM_OC_DeInit(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_DeInit(TM_HandleTypeDef* mTM)
N{
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_OC_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM Output Compare MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_OC_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_Base_MspInit could be implemented in the user file
N     */
N}
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM Output Compare MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_OC_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_Base_MspDeInit could be implemented in the user file
N     */
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N
N    // set TM channel0 in OC mode (Ouput compare mode)
N    MID_TM_OC_Start(&mTM36, MID_TM_Channel0);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_OutputCompare);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0002U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N
N    // Stop TM channel1 in OC mode (Ouput compare mode)
N    MID_TM_OC_Stop(&mTM36, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Output Compare signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N
N    // Set TM channel2 in OC mode (Ouput compare mode)
N    // And enable TM channel2 interrupt service.
N    MID_TM_OC_Start_IT(&mTM36, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000800)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_OutputCompare);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0002U));
N
N    // __MID_TM_ENABLE(mTM);
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Output Compare signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N
N    // Set TM channel2 in OC mode (Ouput compare mode)
N    // And disable TM channel2 interrupt service.
N    MID_TM_OC_Stop_IT(&mTM36, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000800)));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    // check INT to disable ITEA
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N    
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Output Compare signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N    // Modify parameters & to do ...
N
N    // Set TM channel3 in OC mode (Ouput compare mode)
N    // And update TM channel3 CC3B with DMA access.
N    MID_TM_OC_Start_DMA(&mTM36, MID_TM_Channel3);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if(((uint32_t)pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferCpltCallback = &TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferCpltCallback = &TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC0], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x0U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 0 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x01000000)));
N        
N        /* Satart the TM counter */
N        __DRV_TM_ENABLE(mTM);
X        ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC1], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x1U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x02000000)));
N        
N        /* Satart the TM counter */
N        __DRV_TM_ENABLE(mTM);
X        ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC2], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x2U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x04000000)));
N        
N        /* Satart the TM counter */
N        __DRV_TM_ENABLE(mTM);
X        ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output with DMA access
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_OutputCompare);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0002U));
N
N    // Break Control for OC mode
N    /*   if(IS_TM_BREAK_INSTANCE(mTM->Instance) != RESET)
N      {
N        // to do ...
N      }
N     */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Output Compare signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_OC_Stop_DMA(&mTM36, MID_TM_Channel3);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x01000000)));
N        break;
N
N    case MID_TM_Channel1:
N        /* Disable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x02000000)));
N        break;
N
N    case MID_TM_Channel2:
N        /* Disable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x04000000)));
N        break;
N
N    case MID_TM_Channel3:
N        // MG32x02z MCU don't support Channel3 for OC output with DMA access
N        break;
N
N    default:
N        break;
N    }
N
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N///@}
N
N
N
N/**
N * @name    8bitx2 Output Compare
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Starts the TM 8bitx2 Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Init(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Init(TM_HandleTypeDef* mTM)
N{
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_8Bx2OC_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the Output Compare */
N    TM_Base_SetConfig(mTM->Instance,  &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM 8bitx2 Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_DeInit(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_DeInit(TM_HandleTypeDef* mTM)
N{
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_8Bx2OC_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM 8bitx2 Output Compare MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_8Bx2OC_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_8Bx2OC_MspInit could be implemented in the user file
N     */
N}
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM 8bitx2 Output Compare MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_8Bx2OC_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_8Bx2OC_MspDeInit could be implemented in the user file
N     */
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM 8bitx2 Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Start(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_OutputCompare);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0003U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM 8bitx2 Output Compare signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Stop(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM 8bitx2 Output Compare signal generation in 
N *              interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Stop(&mTM, MID_TM_Channel0);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N        break;
N
N    case MID_TM_Channel1:
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N        break;
N
N    case MID_TM_Channel2:
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N        break;
N
N    case MID_TM_Channel3:
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000800)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N        break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_OutputCompare);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0003U));
N
N    // __MID_TM_ENABLE(mTM);
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM 8bitx2 Output Compare signal generation in 
N *              interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Stop(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N        break;
N
N    case MID_TM_Channel1:
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N        break;
N
N    case MID_TM_Channel2:
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N        break;
N
N    case MID_TM_Channel3:
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000800)));
N        break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM 8bitx2 Output Compare signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Start_DMA(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if(((uint32_t)pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferCpltCallback = &TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferCpltCallback = &TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC0], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x0U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 0 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x01000000)));
N        break;
N
N    case MID_TM_Channel1:
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC1], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x1U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x02000000)));
N        break;
N
N    case MID_TM_Channel2:
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC2], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x2U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x04000000)));
N        break;
N
N    case MID_TM_Channel3:
N        // MG32x02z MCU don't support Channel3 for OC output
N        break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_OutputCompare);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0003U));
N
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM 8bitx2 Output Compare signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_8Bx2OC_Start_DMA(&mTM, MID_TM_Channel3);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2OC_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x01000000)));
N        break;
N
N    case MID_TM_Channel1:
N        /* Disable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x02000000)));
N        break;
N
N    case MID_TM_Channel2:
N        /* Disable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x04000000)));
N        break;
N
N    case MID_TM_Channel3:
N        // MG32x02z MCU don't support Channel3 for OC output
N        break;
N
N    default:
N        break;
N    }
N
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N///@}
N
N
N
N
N
N/**
N * @name    PWM output configuration
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM TMe Base according to the specified
N *              parameters in the TM_HandleTypeDef and create the associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N
N    mTM36.Instance = TM36;
N    mTM36.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM36.Init.TM_CounterMode = TM_CASCADE_UP;
N    mTM36.Init.TM_Period = 1023;
N    mTM36.Init.TM_Prescaler = 0;
N    mTM36.State = MID_TM_STATE_RESET;
N    
N    MID_TM_PWM_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Init(TM_HandleTypeDef* mTM)
N{
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_PWM_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the Output Compare */
N    TM_Base_SetConfig(mTM->Instance,  &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM peripheral
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_PWM_DeInit(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DeInit(TM_HandleTypeDef* mTM)
N{
N    /* Release Lock */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N    
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_PWM_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_PWM_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_PWM_MspInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_PWM_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_PWM_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;               
N    TM_OC_InitTypeDef sConfig;
N    
N    MID_TM_OC_Struct_Init(&sConfig);               // default initial (output state)
N    sConfig.OCMode = TM_CH_Disable;
N    sConfig.Pulse = 0;                          // Duty cycle = 0%
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel0);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel1);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel2);
N
N    MID_TM_PWM_Start(&mTM, MID_TM_Channel0);    // Channel0 be 16bit PWM output  
N    MID_TM_PWM_Start(&mTM, MID_TM_Channel1);
N    MID_TM_PWM_Start(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Enable the PWM channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0004U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N    
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_Stop(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_Start_IT(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000800)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0004U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N
N    // __MID_TM_ENABLE(mTM);
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_Stop_IT(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000800)));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef        mTM;
N    TM_ClockConfigTypeDef   CKConfig;
N    TM_OC_InitTypeDef       sConfig;
N    DMA_HandleTypeDef       mTM_DMA[3];
N    
N    uint16_t Src0[] = {0x2525, 0x4000, 0x2525, 0x5000};
N    uint16_t Src1[] = {0x2525, 0x3000, 0x2525, 0x4000};
N    uint16_t Src2[] = {0x2525, 0x2000, 0x2525, 0x3000};
N    
N    // Time Base Init
N    mTM.Instance                    = TM36;
N    mTM.Init.TM_CounterMode         = TM_CASCADE_UP;
N    mTM.Init.TM_Period              = 1023;
N    mTM.Init.TM_Prescaler           = 0;
N    mTM.State                       = MID_TM_STATE_RESET;
N    MID_TM_PWM_Init(&mTM);
N    
N    // clock initial
N    CKConfig.TM_ClockSource         = TM_INTERNAL_CLOCK;
N    CKConfig.TM_ExternalClockSource = 0;
N    CKConfig.TM_INTClockDivision    = TM_INTERNALCLOCK_DIVDER_DIV1;
N    CKConfig.TM_InternalClockSource = TM_INTERNALCLOCK_PROC;
N    MID_TM_ConfigClockSource(&mTM, &CKConfig);  
N
N    // OCx pin initial
N    MID_TM_OC_Struct_Init(&sConfig);
N    sConfig.OCMode                  = TM_CH_16bit_PWM;
N    sConfig.Pulse                   = 1000;
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N
N    sConfig.Pulse                   = 2000;
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N
N    sConfig.Pulse                   = 3000;
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel2);
N    
N    sConfig.Pulse                   = 4000;
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel3);
N
N    // PWM output with DMA access (MG32F02A132 support 3 channels)
N    mTM.hDMA[0] = &mTM_DMA[0];
N    mTM.hDMA[1] = &mTM_DMA[1];
N    mTM.hDMA[2] = &mTM_DMA[2];
N    
N    MID_TM_PWM_Start_DMA(&mTM, MID_TM_Channel0, (uint32_t *) &Src0, 8);
N    MID_TM_PWM_Start_DMA(&mTM, MID_TM_Channel1, (uint32_t *) &Src1, 8);
N    MID_TM_PWM_Start_DMA(&mTM, MID_TM_Channel2, (uint32_t *) &Src2, 8);
N    
N    
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if(((uint32_t)pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferCpltCallback = &TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferCpltCallback = &TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC0], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x0U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 0 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC1], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x1U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferErrorCallback = TM_DMAError ;
N        
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC2], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x2U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0004U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N    
N    
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Stops the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_Stop_DMA(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Disable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Disable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N///@}
N
N
N
N
N
N/**
N * @name    8Bitx2 PWM output configuration
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM TMe Base according to the specified
N *              parameters in the TM_HandleTypeDef and create the associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N
N    mTM36.Instance = TM36;
N    mTM36.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM36.Init.TM_CounterMode = TM_CASCADE_UP;
N    mTM36.Init.TM_Period = 0x00FF;
N    mTM36.Init.TM_Prescaler = 0;
N    mTM36.State = MID_TM_STATE_RESET;
N    
N    MID_TM_8Bx2PWM_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Init(TM_HandleTypeDef* mTM)
N{
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_8Bx2PWM_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the Output Compare */
N    TM_Base_SetConfig(mTM->Instance,  &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM peripheral
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_DeInit(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DeInit(TM_HandleTypeDef* mTM)
N{
N    /* Release Lock */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N    
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_8Bx2PWM_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_8Bx2PWM_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_8Bx2PWM_MspInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_8Bx2PWM_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_8Bx2PWM_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;               
N    TM_OC_InitTypeDef sConfig;
N    
N    MID_TM_OC_Struct_Init(&sConfig);               // default initial (output state)
N    sConfig.OCMode = TM_CH_16bit_PWM;
N    sConfig.Pulse = 0;                          // Duty cycle = 0%, 0%
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel0);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel1);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel2);
N
N    MID_TM_8Bx2PWM_Start(&mTM, MID_TM_Channel0);    // Channel0 be 8bit x 2 PWM output  
N    MID_TM_8Bx2PWM_Start(&mTM, MID_TM_Channel1);
N    MID_TM_8Bx2PWM_Start(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N
N    /* Enable the Capture compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_PWM);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0005U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_Stop(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_OC_InitTypeDef sConfig;
N    
N    // Time Base Init
N    mTM.Instance = TM36;
N    
N    mTM.Init.TM_CounterMode = TM_SEPARATE_UP;
N    mTM.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM.Init.TM_Period = 0x00FF;
N    mTM.Init.TM_Prescaler = 0;
N    mTM.State = MID_TM_STATE_RESET;
N    
N    MID_TM_OC_Init(&mTM);
N    
N    // OCx pin initial
N    MID_TM_OC_Struct_Init(&sConfig);
N    sConfig.OCMode = TM_CH_16bit_OutputCompare;
N    sConfig.Pulse = 1020;                       // H-Duty cycle=16/256, L-Duty cycle=32/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N
N    sConfig.Pulse = 2030;                       // H-Duty cycle=32/256, L-Duty cycle=48/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N
N    sConfig.Pulse = 3040;                       // H-Duty cycle=48/256, L-Duty cycle=64/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel2);
N
N    // PWM output with DMA access
N    MID_TM_8Bx2PWM_Start_IT(&mTM, MID_TM_Channel0, (uint32_t *) &Src0, 8);
N    MID_TM_8Bx2PWM_Start_IT(&mTM, MID_TM_Channel1, (uint32_t *) &Src1, 8);
N    MID_TM_8Bx2PWM_Start_IT(&mTM, MID_TM_Channel2, (uint32_t *) &Src2, 8);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000800)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_PWM);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0005U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N
N    // __MID_TM_ENABLE(mTM);
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_Stop_IT(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000800)));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_OC_InitTypeDef sConfig;
N    
N    uint16_t Src0[] = {0x2525, 0x4010, 0x2525, 0x5080};
N    uint16_t Src1[] = {0x2525, 0x3020, 0x2525, 0x4090};
N    uint16_t Src2[] = {0x2525, 0x2030, 0x2525, 0x30C0};
N    
N    // Time Base Init
N    mTM.Instance = TM36;
N    
N    mTM.Init.TM_CounterMode = TM_SEPARATE_UP;
N    mTM.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM.Init.TM_Period = 0x00FF;
N    mTM.Init.TM_Prescaler = 0;
N    mTM.State = MID_TM_STATE_RESET;
N    
N    MID_TM_OC_Init(&mTM);
N    
N    // OCx pin initial
N    MID_TM_OC_Struct_Init(&sConfig);
N    sConfig.OCMode = TM_CH_16bit_OutputCompare;
N    sConfig.Pulse = 1020;                       // H-Duty cycle=16/256, L-Duty cycle=32/256
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N
N    sConfig.Pulse = 2030;                       // H-Duty cycle=32/256, L-Duty cycle=48/256
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N
N    sConfig.Pulse = 3040;                       // H-Duty cycle=48/256, L-Duty cycle=64/256
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel2);
N
N    // PWM output with DMA access
N    MID_TM_8Bx2PWM_Start_DMA(&mTM, MID_TM_Channel0, (uint32_t *) &Src0, 8);
N    MID_TM_8Bx2PWM_Start_DMA(&mTM, MID_TM_Channel1, (uint32_t *) &Src1, 8);
N    MID_TM_8Bx2PWM_Start_DMA(&mTM, MID_TM_Channel2, (uint32_t *) &Src2, 8);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if(((uint32_t)pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferCpltCallback = &TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferCpltCallback = &TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC0], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x0U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 0 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC1], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x1U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC2], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x2U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_PWM);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0005U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N    
N    /* update state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Stops the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_Stop_DMA(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Disable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Disable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N///@}
N
N
N
N/**
N * @name    PWM with Dead-Tinme output configuration
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM TMe Base according to the specified
N *              parameters in the TM_HandleTypeDef and create the associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N
N    mTM36.Instance = TM36;
N    mTM36.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM36.Init.TM_CounterMode = TM_CASCADE_UP;
N    mTM36.Init.TM_Period = 1023;
N    mTM36.Init.TM_Prescaler = 0;
N    
N    MID_TM_PWM_DTG_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Init(TM_HandleTypeDef* mTM)
N{
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_PWM_DTG_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the Output Compare */
N    TM_Base_SetConfig(mTM->Instance,  &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM peripheral
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_PWM_DTG_DeInit(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_DeInit(TM_HandleTypeDef* mTM)
N{
N    /* Process Lockededed */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N    
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_PWM_DTG_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_PWM_DTG_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_PWM_DTG_MspInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_PWM_DTG_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_PWM_DTG_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;               
N    TM_OC_InitTypeDef sConfig;
N    
N    MID_TM_OC_Struct_Init(&sConfig);               // default initial (output state)
N    sConfig.OCMode = TM_CH_Disable;
N    sConfig.Pulse = 0;                          // Duty cycle = 0%
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel0);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel1);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel2);
N
N    MID_TM_PWM_DTG_Start(&mTM, MID_TM_Channel0);    // Channel0 be 16bit PWM output  
N    MID_TM_PWM_DTG_Start(&mTM, MID_TM_Channel1);
N    MID_TM_PWM_DTG_Start(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N
N    /* Enable the Capture compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM_COMPLEMENT);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0006U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_DTG_Stop(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_DTG_Start_IT(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM_COMPLEMENT);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0006U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    // __MID_TM_ENABLE(mTM);
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_DTG_Stop_IT(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* update state */
N        mTM->State = MID_TM_STATE_READY;
N        // MG32x02z MCU don't support Channel3 for OC output
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_OC_InitTypeDef sConfig;
N    
N    uint16_t Src0[] = {0x2525, 0x4000, 0x2525, 0x5000};
N    uint16_t Src1[] = {0x2525, 0x3000, 0x2525, 0x4000};
N    uint16_t Src2[] = {0x2525, 0x2000, 0x2525, 0x3000};
N    
N    // Time Base Init
N    mTM.Instance = TM36;
N    
N    mTM.Init.TM_CounterMode = TM_SEPARATE_UP;
N    mTM.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM.Init.TM_Period = 0x6000;
N    mTM.Init.TM_Prescaler = 65535;
N    mTM.State = MID_TM_STATE_RESET;
N    
N    MID_TM_OC_Init(&mTM);
N    
N    // OCx pin initial
N    MID_TM_OC_Struct_Init(&sConfig);
N    sConfig.OCMode = TM_CH_16bit_OutputCompare;
N    sConfig.Pulse = 1000;
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N
N    sConfig.Pulse = 2000;
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N
N    sConfig.Pulse = 3000;
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel2);
N
N    // PWM output with DMA access
N    MID_TM_PWM_DTG_Start_DMA(&mTM, MID_TM_Channel0, (uint32_t *) &Src0, 8);
N    MID_TM_PWM_DTG_Start_DMA(&mTM, MID_TM_Channel1, (uint32_t *) &Src1, 8);
N    MID_TM_PWM_DTG_Start_DMA(&mTM, MID_TM_Channel2, (uint32_t *) &Src2, 8);
N    
N    
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if(((uint32_t)pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferCpltCallback = &TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferCpltCallback = &TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC0], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x0U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 0 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC1], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x1U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC2], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x2U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* update state */
N        mTM->State = MID_TM_STATE_READY;
N        // MG32x02z MCU don't support Channel3 for OC output
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM_COMPLEMENT);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0006U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N    
N    /* update state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Stops the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_DTG_Stop_DMA(&mTM, MID_TM_Channel0);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_DTG_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Disable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Disable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N        
N        /* Change the mTM state */
N        mTM->State = MID_TM_STATE_READY;
N        // MG32x02z MCU don't support Channel3 for OC output
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N///@}
N
N
N
N
N
N/**
N * @name    8Bitx2 PWM with Dead-Tinme output configuration
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM TMe Base according to the specified
N *              parameters in the TM_HandleTypeDef and create the associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N
N    mTM36.Instance = TM36;
N    mTM36.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM36.Init.TM_CounterMode = TM_CASCADE_UP;
N    mTM36.Init.TM_Period = 0x00FF;
N    mTM36.Init.TM_Prescaler = 0;
N    
N    MID_TM_8Bx2PWM_DTG_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Init(TM_HandleTypeDef* mTM)
N{
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_8Bx2PWM_DTG_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the Output Compare */
N    TM_Base_SetConfig(mTM->Instance,  &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM peripheral
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_DTG_DeInit(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_DeInit(TM_HandleTypeDef* mTM)
N{
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_8Bx2PWM_DTG_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_8Bx2PWM_DTG_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_8Bx2PWM_DTG_MspInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM PWM MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_8Bx2PWM_DTG_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_8Bx2PWM_DTG_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;               
N    TM_OC_InitTypeDef sConfig;
N    
N    MID_TM_OC_Struct_Init(&sConfig);               // default initial (output state)
N    sConfig.OCMode = TM_CH_Disable;
N    sConfig.Pulse = 0;                          // Duty cycle = 0%, 0%
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel0);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel1);
N    MID_TM_PWM_ConfigChannel(&mTM36, &sConfig, MID_TM_Channel2);
N
N    MID_TM_8Bx2PWM_Start(&mTM, MID_TM_Channel0);    // Channel0 be 8bit x 2 PWM output  
N    MID_TM_8Bx2PWM_Start(&mTM, MID_TM_Channel1);
N    MID_TM_8Bx2PWM_Start(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N
N    /* Enable the Capture compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_PWM_COMPLEMENT);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0007U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_DTG_Stop(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_OC_InitTypeDef sConfig;
N    
N    // Time Base Init
N    mTM.Instance = TM36;
N    
N    mTM.Init.TM_CounterMode = TM_SEPARATE_UP;
N    mTM.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM.Init.TM_Period = 0x00FF;
N    mTM.Init.TM_Prescaler = 0;
N    mTM.State = MID_TM_STATE_RESET;
N    
N    MID_TM_OC_Init(&mTM);
N    
N    // OCx pin initial
N    MID_TM_OC_Struct_Init(&sConfig);
N    sConfig.OCMode = TM_CH_16bit_OutputCompare;
N    sConfig.Pulse = 1020;                       // H-Duty cycle=16/256, L-Duty cycle=32/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N
N    sConfig.Pulse = 2030;                       // H-Duty cycle=32/256, L-Duty cycle=48/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N
N    sConfig.Pulse = 3040;                       // H-Duty cycle=48/256, L-Duty cycle=64/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel2);
N
N    // PWM output with DMA access
N    MID_TM_8Bx2PWM_Start_IT(&mTM, MID_TM_Channel0, (uint32_t *) &Src0, 8);
N    MID_TM_8Bx2PWM_Start_IT(&mTM, MID_TM_Channel1, (uint32_t *) &Src1, 8);
N    MID_TM_8Bx2PWM_Start_IT(&mTM, MID_TM_Channel2, (uint32_t *) &Src2, 8);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_16bit_PWM_COMPLEMENT);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0006U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    // __MID_TM_ENABLE(mTM);
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the PWM signal generation in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_DTG_Stop_IT(&mTM, MID_TM_Channel2);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Enable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_OC_InitTypeDef sConfig;
N    
N    uint16_t Src0[] = {0x2525, 0x4010, 0x2525, 0x5080};
N    uint16_t Src1[] = {0x2525, 0x3020, 0x2525, 0x4090};
N    uint16_t Src2[] = {0x2525, 0x2030, 0x2525, 0x30C0};
N    
N    // Time Base Init
N    mTM.Instance = TM36;
N    
N    mTM.Init.TM_CounterMode = TM_SEPARATE_UP;
N    mTM.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM.Init.TM_Period = 0x00FF;
N    mTM.Init.TM_Prescaler = 0;
N    mTM.State = MID_TM_STATE_RESET;
N    
N    MID_TM_OC_Init(&mTM);
N    
N    // OCx pin initial
N    MID_TM_OC_Struct_Init(&sConfig);
N    sConfig.OCMode = TM_CH_16bit_OutputCompare;
N    sConfig.Pulse = 1020;                       // H-Duty cycle=16/256, L-Duty cycle=32/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N
N    sConfig.Pulse = 2030;                       // H-Duty cycle=32/256, L-Duty cycle=48/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N
N    sConfig.Pulse = 3040;                       // H-Duty cycle=48/256, L-Duty cycle=64/256
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel2);
N
N    // PWM output with DMA access
N    MID_TM_8Bx2PWM_Start_DMA(&mTM, MID_TM_Channel0, (uint32_t *) &Src0, 8);
N    MID_TM_8Bx2PWM_Start_DMA(&mTM, MID_TM_Channel1, (uint32_t *) &Src1, 8);
N    MID_TM_8Bx2PWM_Start_DMA(&mTM, MID_TM_Channel2, (uint32_t *) &Src2, 8);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if(((uint32_t)pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferCpltCallback = &TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferCpltCallback = &TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC0]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x0U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC0], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x0U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 0 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC1]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x1U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC1], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x1U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferCpltCallback = TM_DMADelayPulseCplt;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferCpltCallback = TM_DMADelayPulseCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC2]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x2U)]->XferErrorCallback = TM_DMAError ;
N        
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC2], (uint32_t)pData, NULL, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x2U)], (uint32_t)pData, 0, Length);
N
N        /* Enable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N        mTM->State = MID_TM_STATE_READY;
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Enable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_8bitx2_PWM_COMPLEMENT);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0007U));
N
N    // Enable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        __DRV_TM_ENABLE_BREAK(mTM);
X        ((mTM)->Instance ->BS . W |= ((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N    
N    /* update state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Stops the TM PWM signal generation in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N * @note
N * @par         Example
N * @code
N    MID_TM_8Bx2PWM_DTG_Stop_DMA(&mTM, MID_TM_Channel0);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_8Bx2PWM_DTG_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH0_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x01000000)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Disable the TM Capture/Compare 1 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH1_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x02000000)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Disable the TM Capture/Compare 2 DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH2_OC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x04000000)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        // MG32x02z MCU don't support Channel3 for OC output
N        mTM->State = MID_TM_STATE_READY;
N        return MID_FAILURE;
N    }
N
N    default:
N        break;
N    }
N
N    /* Disable the Output compare channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    // Disable Break Control for PWM mode 
N    if(mTM->Instance == TM36) 
X    if(mTM->Instance == ((TM_Struct*) ((uint32_t)0x56860000))) 
N    {
N        // control TM36_BK_EN & TM36_BK_EN3
N        if((mTM->Instance->CCMDS.H[0] & TM_ALLCH_PWMMode) == 0x0000)
X        if((mTM->Instance->CCMDS.H[0] & (0x4444U)) == 0x0000)
N            __DRV_TM_DISABLE_BREAK(mTM);
X            ((mTM)->Instance ->BS . W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000008))));
N    }
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N///@}
N
N
N
N
N
N/**
N * @name    Time Input Capture functions
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM Input Capture TMe base according to the
N *              specified parameters in the TM_HandleTypeDef and create the
N *              associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM36;
N
N    mTM36.Instance = TM36;
N    mTM36.Init.TM_ClockSource = TM_INTERNAL_CLOCK;
N    mTM36.Init.TM_CounterMode = TM_CASCADE_UP;
N    mTM36.Init.TM_Period = 0xFFFF;
N    mTM36.Init.TM_Prescaler = 0;
N    
N    MID_TM_IC_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Init(TM_HandleTypeDef* mTM)
N{
N    /* Check the TM handle allocation */
N    if(mTM == NULL)
X    if(mTM == 0)
N        return MID_FAILURE;
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_IC_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Init the base time for the input capture */
N    TM_Base_SetConfig(mTM->Instance, &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM peripheral.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_PWM_Init(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_DeInit(TM_HandleTypeDef* mTM)
N{
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
N    MID_TM_IC_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM Input Capture MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_IC_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_IC_MspInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM Input Capture MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_IC_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_IC_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Input Capture measurement.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    iConfig.ICSelection = MID_TM_INPUTMUX_PIN;        
N    iConfig.ICPolarity  = TM_ICPOLARITY_DUALEDGE;
N    iConfig.ICDataMode  = MID_TM_IC_KEEPDATA;
N    MID_TM_IC_ConfigChannel(&mTM36, &iConfig, MID_TM_Channel3);
N
N    MID_TM_IC_Start(&mTM36, MID_TM_Channel3);   
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Start(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Enable the Input Capture channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_InputCapture);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0001U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Input Capture measurement.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_IC_Stop(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Stop(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    /* Disable the Input Capture channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Input Capture measurement in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    iConfig.ICSelection = MID_TM_INPUTMUX_PIN;
N    iConfig.ICPolarity  = TM_ICPOLARITY_DISABLE;
N    iConfig.ICDataMode  = MID_TM_IC_OVERWRITTEN;
N
N    MID_TM_IC_ConfigChannel(&mTM36, &iConfig, MID_TM_Channel0);
N    MID_TM_IC_ConfigChannel(&mTM36, &iConfig, MID_TM_Channel1);
N    MID_TM_IC_ConfigChannel(&mTM36, &iConfig, MID_TM_Channel2);
N    
N    iConfig.ICSelection = MID_TM_INPUTMUX_LINE3;        // TM36_XOR trigger signal connect IC channel
N    iConfig.ICPolarity = TM_ICPOLARITY_DUALEDGE;
N
N    MID_TM_IC_ConfigChannel(&mTM36, &iConfig, MID_TM_Channel3);
N    MID_TM_IC_Start_IT(&mTM36, MID_TM_Channel3);   
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Start_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Enable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000100)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Enable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000200)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Enable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000400)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Enable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_ENABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000800)));
N        __DRV_TM_ENABLE_ITEA(mTM);
X        ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N    }
N    break;
N
N    default:
N        break;
N    }
N    /* Enable the Input Capture channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_InputCapture);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0001U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N    __DRV_TM_ENABLE_ITEA(mTM);
X    ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Input Capture measurement in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_IC_Stop_IT(&mTM, MID_TM_Channel3);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Stop_IT(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Disable the TM Capture/Compare 0 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC0);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000100)));
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Disable the TM Capture/Compare 1 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC1);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000200)));
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Disable the TM Capture/Compare 2 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC2);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000400)));
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Disable the TM Capture/Compare 3 interrupt */
N        __DRV_TM_DISABLE_IT(mTM, TM_IT_CC3);
X        ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000800)));
N    }
N    break;
N
N    default:
N        break;
N    }
N
N    /* Disable the Input Capture channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Input Capture measurement in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   pData : The source Buffer address.
N * @param[in]   Length : The length of data to be transferred.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_IC_Start_DMA(&mTM, MID_TM_Channel3, &Dest, 10);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Start_DMA(TM_HandleTypeDef* mTM, uint32_t Channel, uint32_t* pData, uint16_t Length)
N{
N    if((mTM->State) == (MID_TM_STATE_BUSY))
N        return MID_BUSY;
N    else if((mTM->State) == (MID_TM_STATE_READY))
N    {
N        if((pData == 0U) && (Length > 0U))
N            return MID_FAILURE;
N        else
N            mTM->State = MID_TM_STATE_BUSY;
N    }
N
N    switch(Channel)
N    {
N    case MID_TM_Channel3:
N    {
N        /* Set the DMA Period elapsed callback */
N        mTM->hDMA[TM_DMA_ID_CC3]->XferCpltCallback = TM_DMACaptureCplt;
X        mTM->hDMA[((uint16_t) 0x3U)]->XferCpltCallback = TM_DMACaptureCplt;
N
N        /* Set the DMA error callback */
N        mTM->hDMA[TM_DMA_ID_CC3]->XferErrorCallback = TM_DMAError ;
X        mTM->hDMA[((uint16_t) 0x3U)]->XferErrorCallback = TM_DMAError ;
N
N        MID_DMA_Start_IT(mTM->hDMA[TM_DMA_ID_CC3], NULL, (uint32_t) pData, Length);
X        MID_DMA_Start_IT(mTM->hDMA[((uint16_t) 0x3U)], 0, (uint32_t) pData, Length);
N
N        /* Enable the TM Capture/Compare 3  DMA request */
N        __DRV_TM_ENABLE_DMA(mTM, TM_DMA_CH3_IC);
X        ((mTM)->Instance ->CCMDS . W |= (((uint32_t)0x08000000)));
N    }
N    break;
N
N    default:
N        /* Change TM state */
N        mTM->State = MID_TM_STATE_READY;
N        return MID_FAILURE;
N    }
N
N    /* Enable the Input Capture channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_InputCapture);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0001U));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Input Capture measurement in DMA mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_IC_Stop_DMA(&mTM, MID_TM_Channel3);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_Stop_DMA(TM_HandleTypeDef* mTM, uint32_t Channel)
N{
N    switch(Channel)
N    {
N    case MID_TM_Channel3:
N    {
N        /* Disable the TM Capture/Compare 3  DMA request */
N        __DRV_TM_DISABLE_DMA(mTM, TM_DMA_CH3_IC);
X        ((mTM)->Instance ->CCMDS . W &= ~(((uint32_t)0x08000000)));
N    }
N    break;
N
N    default:
N        /* Change TM state */
N        mTM->State = MID_TM_STATE_READY;
N        return MID_FAILURE;
N    }
N
N    /* Disable the Input Capture channel */
N    TM_CCxChannelCmd(mTM->Instance, Channel, TM_CH_Disable);
X    TM_CCxChannelCmd(mTM->Instance, Channel, (0x0000U));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N///@}
N
N
N/**
N * @name  Time One Pulse functions
N *
N */
N///@{
N#if defined(MG32_3RD)
X#if 0L
S/**
S *******************************************************************************
S * @brief       Initializes the TM One Pulse TMe Base according to the specified
S *              parameters in the TM_HandleTypeDef and create the associated handle.
S *              User can control OC/PWM times by this function with every trigger event.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @param[in]   sRCNTConfig : pointer to a TM_RCNTConfigTypeDef
S *  @arg\b      RCNTClkSrc : Specifies the timer's RCNT clock source event.
S *  @arg\b      RCNTCounter : Specifies the RCNT counter value.
S *  @arg\b      RCNTReload : Specifies the RCNT reload value.
S * @return      MID_StatusTypeDef
S * @note
S * @par         Example
S * @code
S    TM_RCNTConfigTypeDef    TMRCNT;
S 
S    TMRCNT.RCNTClkSrc   = TM_RCNT_MAIN_EVENT;
S    TMRCNT.RCNTCounter  = 9;
S    TMRCNT.RCNTReload   = 9;
S 
S    MID_TM_OnePulse_Init(&mTM, &TMRCNT);
S * @endcode
S *******************************************************************************
S */
SMID_StatusTypeDef MID_TM_OnePulse_Init(TM_HandleTypeDef *mTM, TM_RCNTConfigTypeDef* sRCNTConfig)
S{
S    /* Check input state */
S    __MID_LOCK(mTM);
S    
S    // check mTM or TM2x, TM3x
S    if(mTM == NULL)
S    {
S        return MID_FAILURE;
S    }
S    if((mTM->Instance != TM20) && (mTM->Instance != TM26) && (mTM->Instance != TM36))
S    {
S        /* Release Lock */
S        __MID_UNLOCK(mTM);
S
S        return MID_FAILURE;
S    }
S
S    //
S    if(mTM->State == MID_TM_STATE_RESET)
S    {
S        /* Allocate lock resource and initialize it */
S        __MID_UNLOCK(mTM);
S      
S        /* Init the low level hardware : GPIO, CLOCK, NVIC */
S        MID_TM_OnePulse_MspInit(mTM);
S    }
S
S    /* Set the TM state */
S    mTM->State= MID_TM_STATE_BUSY;
S    
S    /* Set RCNT clock source */
S    mTM->Instance->CLK.W &= ~(TM_CLK_RC_CKS_mask_w);
S    mTM->Instance->CLK.W |= (sRCNTConfig->RCNTClkSrc & ~(TM_CLK_RC_CKS_mask_w));
S    
S    /* Set RCNT clock source from CKO */
S    if (sRCNTConfig->RCNTClkSrc != TM_RCNT_MAIN_EVENT)
S    {   
S        //
S        mTM->Instance->CKO.W &= ~(TM_CKO_CKO_SEL_mask_w);
S        mTM->Instance->CLK.W |= (sRCNTConfig->RCNTClkSrc & ~(TM_CKO_CKO_SEL_mask_w));
S    }
S    
S    /* Cancel ASTOP + ACLEAN_EN function  */
S    mTM->Instance->CR0.W &= ~(TM_OPMODE_REPETITIVE);                
S    
S    /* Config RCNT  */
S    mTM->Instance->RCNT.W = ((sRCNTConfig->RCNTCounter & 0x000000FF) | 
S                            ((sRCNTConfig->RCNTReload & 0x000000FF) << 16));
S    
S    /* Initialize the TM state*/
S    mTM->State= MID_TM_STATE_READY;
S
S    /* Release Lock */
S    __MID_UNLOCK(mTM);
S
S    /* Return function status */
S    return MID_SUCCESS;
S}
S
S
S/**
S *******************************************************************************
S * @brief       DeInitializes the TM One Pulse.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @return      MID_StatusTypeDef
S * @note
S * @par         Example
S * @code
S    MID_TM_OnePulse_DeInit(&mTM);
S * @endcode
S *******************************************************************************
S */
SMID_StatusTypeDef MID_TM_OnePulse_DeInit(TM_HandleTypeDef *mTM)
S{
S    /* Check input state */
S    __MID_LOCK(mTM);
S    mTM->State = MID_TM_STATE_BUSY;
S
S    /* Disable the TM Peripheral Clock */
S    __DRV_TM_DISABLE(mTM);
S    mTM->Instance->CR0.W &= ~(TM_CR0_RC_STP_enable_w | TM_CR0_RC_EN_enable_w);
S
S    /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
S    MID_TM_OnePulse_MspDeInit(mTM);
S
S    /* Change TM state */
S    mTM->State = MID_TM_STATE_RESET;
S
S    /* Release Lock */
S    __MID_UNLOCK(mTM);
S
S    return MID_SUCCESS;
S}
S
S
S/**
S *******************************************************************************
S * @brief       Initializes the TM One Pulse MSP.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @return      None
S *******************************************************************************
S */
S__weak void MID_TM_OnePulse_MspInit(TM_HandleTypeDef *mTM)
S{
S    /* Prevent unused argument(s) compilation warning */
S    UNUSED(mTM);
S    /* NOTE : This function Should not be modified, when the callback is needed,
S            the MID_TM_OnePulse_MspInit could be implemented in the user file
S    */
S}
S
S
S/**
S *******************************************************************************
S * @brief       DeInitializes TM One Pulse MSP.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @return      None
S *******************************************************************************
S */
S__weak void MID_TM_OnePulse_MspDeInit(TM_HandleTypeDef *mTM)
S{
S    /* Prevent unused argument(s) compilation warning */
S    UNUSED(mTM);
S    /* NOTE : This function Should not be modified, when the callback is needed,
S            the MID_TM_OnePulse_MspDeInit could be implemented in the user file
S    */
S}
S
S
S/**
S *******************************************************************************
S * @brief       Starts the TM One Pulse signal generation with PWM output.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @note        Caution: The Timer must active with TM slave mode. 
S * @par         Example
S * @code
S    TM_HandleTypeDef mTM;
S
S    MID_TM_OnePulse_Start(&mTM);
S * @endcode
S *******************************************************************************
S */
SMID_StatusTypeDef MID_TM_OnePulse_Start(TM_HandleTypeDef *mTM)
S{
S    /* Main Timer/Counter stop enable when repetition counter underflow.  */
S    mTM->Instance->CR0.W |= (TM_CR0_RC_STP_enable_w | TM_CR0_RC_EN_enable_w);
S    
S    /* Return function status */
S    return MID_SUCCESS;
S}
S
S
S/**
S *******************************************************************************
S * @brief       Stops the TM One Pulse signal generation.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @return        MID_StatusTypeDef
S * @note
S * @par         Example
S * @code
S    TM_HandleTypeDef mTM;
S
S    MID_TM_OnePulse_Stop(&mTM, MID_TM_Channel3);
S * @endcode
S *******************************************************************************
S */
SMID_StatusTypeDef MID_TM_OnePulse_Stop(TM_HandleTypeDef *mTM)
S{
S    /* Disable the Peripheral */
S    mTM->Instance->CR0.W &= ~(TM_CR0_RC_STP_enable_w | TM_CR0_RC_EN_enable_w);
S    
S    /* Return function status */
S    return MID_SUCCESS;
S}
S
S
S/**
S *******************************************************************************
S * @brief       Starts the TM One Pulse signal generation in interrupt mode.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @return        MID_StatusTypeDef
S * @note
S * @par         Example
S * @code
S    MID_TM_OnePulse_Start_IT(&mTM);
S * @endcode
S *******************************************************************************
S */
SMID_StatusTypeDef MID_TM_OnePulse_Start_IT(TM_HandleTypeDef *mTM)
S{
S    /* Main Timer/Counter stop enable when repetition counter underflow.  */
S    mTM->Instance->CR0.W |= (TM_CR0_RC_STP_enable_w | TM_CR0_RC_EN_enable_w);
S    
S    /* Enable the TM external trigger interrupt */
S    __DRV_TM_ENABLE_IT(mTM, TM_IT_ONEPULSE);
S    __DRV_TM_ENABLE_ITEA(mTM);
S
S    /* Enable the Peripheral */
S    __DRV_TM_ENABLE(mTM);
S
S    /* Return function status */
S    return MID_SUCCESS;
S}
S
S
S/**
S *******************************************************************************
S * @brief       Stops the TM One Pulse signal generation in interrupt mode.
S * @param[in]   mTM : pointer to a TM_HandleTypeDef
S * @return      MID_StatusTypeDef
S * @note
S * @par         Example
S * @code
S    MID_TM_OnePulse_Stop_IT(&mTM, MID_TM_Channel3);
S * @endcode
S *******************************************************************************
S */
SMID_StatusTypeDef MID_TM_OnePulse_Stop_IT(TM_HandleTypeDef *mTM)
S{
S    /* Disable the TM Peripheral Clock */
S    mTM->Instance->CR0.W &= ~(TM_CR0_RC_STP_enable_w | TM_CR0_RC_EN_enable_w);
S    
S    /* Disable the TM external trigger interrupt */
S    __DRV_TM_DISABLE_IT(mTM, TM_IT_ONEPULSE);
S    
S    /* check IT for ITEA */
S    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
S        __DRV_TM_DISABLE_ITEA(mTM);
S
S    /* Return function status */
S    return MID_SUCCESS;
S}
S
N#endif
N///@}
N
N
N
N/**
N * @name    Time Encoder functions
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM Encoder Interface and create the associated handle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    mTM36.Instance                  = TM36;
N    mTM36.Init.TM_CounterMode       = TM_CASCADE_UP;
N    mTM36.Init.TM_Period            = 0xFFFF;                   // 12, 18 or 24 Pulses per 360 ?Rotation
N    mTM36.Init.TM_Prescaler         = 3;
N    mTM36.State                     = MID_TM_STATE_RESET;
N    
N    MID_TM_Encoder_Init(&mTM36);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Encoder_Init(TM_HandleTypeDef* mTM)
N{
N
N    /* Check the TM handle allocation */
N    if(mTM == NULL)
X    if(mTM == 0)
N        return MID_FAILURE;
N
N    if(mTM->State == MID_TM_STATE_RESET)
N    {
N        /* Allocate lock resource and initialize it */
N        mTM->Lock = MID_UnLocked;
N
N        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
N        MID_TM_Encoder_MspInit(mTM);
N    }
N
N    /* Set the TM state */
N    mTM->State= MID_TM_STATE_BUSY;
N
N    /* Set the Time Base configuration */
N    TM_Base_SetConfig(mTM->Instance, &mTM->Init);
N
N    /* Initialize the TM state*/
N    mTM->State= MID_TM_STATE_READY;
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes the TM Encoder interface
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_Encoder_DeInit(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Encoder_DeInit(TM_HandleTypeDef* mTM)
N{
N    
N    /* Process Locked */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N    
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Disable the TM Peripheral Clock */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
N    MID_TM_Encoder_MspDeInit(mTM);
N
N    /* Change TM state */
N    mTM->State = MID_TM_STATE_RESET;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM Encoder Interface MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_Encoder_MspInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_Encoder_MspInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       DeInitializes TM Encoder Interface MSP.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_Encoder_MspDeInit(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_Encoder_MspDeInit could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Encoder Interface.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sConfig : pointer to a TM_Encoder_InitTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM26;
N    TM_ClockConfigTypeDef CKConfig;
N    TM_Encoder_InitTypeDef TM26Encoder;
N    // 
N    mTM26.Instance                  = TM26;
N    mTM26.Init.TM_CounterMode       = TM_CASCADE_UP;
N    mTM26.Init.TM_Period            = 20;
N    mTM26.Init.TM_Prescaler         = 3;
N    MID_TM_Encoder_Init(&mTM26);
N    // 
N    CKConfig.TM_ClockSource         = TM_INTERNAL_CLOCK;
N    CKConfig.TM_ExternalClockSource = TM_EXTERNAL_ETR;              
N    CKConfig.TM_InternalClockSource = TM_INTERNALCLOCK_PROC;
N    CKConfig.TM_INTClockDivision    = TM_INTERNALCLOCK_DIVDER_DIV1;
N    MID_TM_ConfigClockSource(&mTM26, &CKConfig);  
N    // 
N    TM26Encoder.EncoderMode         = TM_ENCODERMODE_BOTHEDGE;
N    TM26Encoder.EncoderDirection    = TM_ENCODER_DIRECTION_NORMAL;
N    TM26Encoder.EncoderReset        = TM_ENCODER_RESET_DISABLE;
N    TM26Encoder.IC0Selection        = MID_TM_INPUTMUX_PIN;
N    TM26Encoder.IC1Selection        = MID_TM_INPUTMUX_PIN;
N    MID_TM_Encoder_Start(&mTM26, &TM26Encoder); 
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Encoder_Start(TM_HandleTypeDef* mTM, TM_Encoder_InitTypeDef* sConfig)
N{
N    uint32_t tmp;
N    
N    
N    /* Config IC0 trigger source */
N    mTM->Instance->ICCR.MBIT.IC0_MUX = sConfig->IC0Selection;
N
N    /* Config IC1 trigger source */
N    mTM->Instance->ICCR.MBIT.IC1_MUX = sConfig->IC1Selection;
N
N    /* Config Encoder Direction polarity */
N    tmp = mTM->Instance->CR0.W & ~(TM_CR0_DIR_INV_mask_w);
X    tmp = mTM->Instance->CR0.W & ~(((uint32_t)0x00002000));
N    tmp |= sConfig->EncoderDirection;
N    mTM->Instance->CR0.W = tmp;
N
N    /* Config Encoder Mode & IDX step */
N    tmp = mTM->Instance->TRG.W & ~(TM_TRG_QEI_MDS_mask_w | TM_TRG_IDX_EN_mask_w | TM_TRG_IDX_MDS_mask_w);
X    tmp = mTM->Instance->TRG.W & ~(((uint32_t)0x00070000) | ((uint32_t)0x00080000) | ((uint32_t)0x00300000));
N    tmp |= (sConfig->EncoderMode | sConfig->EncoderReset);
N    mTM->Instance->TRG.W = tmp;
N
N    /* Encoder's index is fixed at ETR pin */
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Encoder Interface.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_Encoder_Stop(&mTM);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Encoder_Stop(TM_HandleTypeDef* mTM)
N{
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Starts the TM Encoder Interface in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sConfig : pointer to a TM_Encoder_InitTypeDef
N * @param[in]   ITSrc : Specifies the Encoder interrupt
N *  @arg\b      TM_IT_QEI_DIRCHANGE : Encoder direction change event
N *  @arg\b      TM_IT_QEI_INDEX : Encoder recive index event
N *  @arg\b      TM_IT_QEI_ERROR : Encoder recive error position
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM26;
N    TM_ClockConfigTypeDef CKConfig;
N    TM_Encoder_InitTypeDef TM26Encoder;
N    // 
N    mTM26.Instance                  = TM26;
N    mTM26.Init.TM_CounterMode       = TM_CASCADE_UP;
N    mTM26.Init.TM_Period            = 20;
N    mTM26.Init.TM_Prescaler         = 3;
N    MID_TM_Encoder_Init(&mTM26);
N    // 
N    CKConfig.TM_ClockSource         = TM_INTERNAL_CLOCK;
N    CKConfig.TM_ExternalClockSource = TM_EXTERNAL_ETR;              
N    CKConfig.TM_InternalClockSource = TM_INTERNALCLOCK_PROC;
N    CKConfig.TM_INTClockDivision    = TM_INTERNALCLOCK_DIVDER_DIV1;
N    MID_TM_ConfigClockSource(&mTM26, &CKConfig);  
N    // 
N    TM26Encoder.EncoderMode         = TM_ENCODERMODE_BOTHEDGE;
N    TM26Encoder.EncoderDirection    = TM_ENCODER_DIRECTION_NORMAL;
N    TM26Encoder.EncoderReset        = TM_ENCODER_RESET_DISABLE;
N    TM26Encoder.IC0Selection        = MID_TM_INPUTMUX_PIN;
N    TM26Encoder.IC1Selection        = MID_TM_INPUTMUX_PIN;
N    MID_TM_Encoder_Start_IT(&mTM26, &TM26Encoder, TM_IT_QEI_DIRCHANGE); 
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Encoder_Start_IT(TM_HandleTypeDef* mTM, TM_Encoder_InitTypeDef* sConfig, uint32_t ITSrc)
N{
N    MID_TM_Encoder_Start(mTM, sConfig);
N    
N    /* Enable the encoder interface channels */
N    __DRV_TM_ENABLE_IT(mTM, ITSrc);
X    ((mTM)->Instance ->INT . W |= (ITSrc));
N    __DRV_TM_ENABLE_ITEA(mTM);
X    ((mTM)->Instance ->INT . W |= ((uint32_t)0x00000001));
N
N    /* Enable the Peripheral */
N    __DRV_TM_ENABLE(mTM);
X    ((mTM)->Instance ->CR0 . W |= ((uint32_t)0x00000001) | ((uint32_t)0x00000002));
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Stops the TM Encoder Interface in interrupt mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   ITSrc : Specifies the Encoder interrupt
N *  @arg\b      TM_IT_QEI_DIRCHANGE : Encoder direction change event
N *  @arg\b      TM_IT_QEI_INDEX : Encoder recive index event
N *  @arg\b      TM_IT_QEI_ERROR : Encoder recive error position
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_Encoder_Stop_IT(&mTM, TM_IT_QEI_INDEX);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_Encoder_Stop_IT(TM_HandleTypeDef* mTM, uint32_t ITSrc)
N{
N    /* Disable the encoder interface channels */
N    __DRV_TM_DISABLE_IT(mTM, ITSrc);
X    ((mTM)->Instance ->INT . W &= ~(ITSrc));
N
N    /* Disable the Peripheral */
N    __DRV_TM_DISABLE(mTM);
X    do{ if((mTM)->Instance ->CCMDS . H[0] == 0x0000) { (mTM)->Instance ->CR0 . W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00000002)); } }while (0);
N
N    /* check IT for ITEA */
N    if((mTM->Instance->INT.W & 0xFFFFFFFE) == 0)
N        __DRV_TM_DISABLE_ITEA(mTM);
X        do{ if((mTM)->Instance ->INT . W != 0x00000000) { ((mTM)->Instance ->INT . W &= ~((uint32_t)0x00000001)); } }while (0);
N
N    /* Change the mTM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N///@}
N
N
N
N/**
N* @name IRQ handler management
N*
N*/
N///@{
N/**
N *******************************************************************************
N * @brief       This function handles TM interrupts requests.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
Nvoid MID_TM_IRQHandler(TM_HandleTypeDef* mTM)
N{
N    /* Capture compare 0 event */
N    if(__DRV_TM_GET_EVENT(mTM, TM_EVENT_CH0))
X    if((((mTM)->Instance ->STA . W & ((((uint32_t)0x00000100) | ((uint32_t)0x00001000)))) != (0)))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_CC0))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000100))) == (((uint32_t)0x00000100))))
N        {
N            {
N                mTM->Channel = MID_TM_Channel0;
N
N                /* Input capture event */
N                if(mTM->Instance->CCMDS.MBIT.CC0_MDS == TM_CH_InputCapture)
X                if(mTM->Instance->CCMDS.MBIT.CC0_MDS == (0x0001U))
N                {
N                    MID_TM_IC_CaptureCallback(mTM);
N                    __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC0A | TM_FLAG_CC0B));
X                    ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000100) | ((uint32_t)0x00001000))));
N                }
N                /* Output compare event */
N                else
N                {
N                    __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC0A | TM_FLAG_CC0B));
X                    ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000100) | ((uint32_t)0x00001000))));
N                    MID_TM_OC_DelayElapsedCallback(mTM);
N                    MID_TM_PWM_PulseFinishedCallback(mTM);
N                }
N                mTM->Channel = MID_TM_ACTIVE_CHANNEL_CLEARED;
N            }
N        }
N    }
N    /* Capture compare 1 event */
N    if(__DRV_TM_GET_EVENT(mTM, TM_EVENT_CH1))
X    if((((mTM)->Instance ->STA . W & ((((uint32_t)0x00000200) | ((uint32_t)0x00002000)))) != (0)))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_CC1))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000200))) == (((uint32_t)0x00000200))))
N        {
N            mTM->Channel = MID_TM_Channel1;
N            /* Input capture event */
N            if(mTM->Instance->CCMDS.MBIT.CC1_MDS == TM_CH_InputCapture)
X            if(mTM->Instance->CCMDS.MBIT.CC1_MDS == (0x0001U))
N            {
N                MID_TM_IC_CaptureCallback(mTM);
N                __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC1A | TM_FLAG_CC1B));
X                ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000200) | ((uint32_t)0x00002000))));
N            }
N            /* Output compare event */
N            else
N            {
N                __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC1A | TM_FLAG_CC1B));
X                ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000200) | ((uint32_t)0x00002000))));
N                MID_TM_OC_DelayElapsedCallback(mTM);
N                MID_TM_PWM_PulseFinishedCallback(mTM);
N            }
N            mTM->Channel = MID_TM_ACTIVE_CHANNEL_CLEARED;
N        }
N    }
N    /* Capture compare 2 event */
N    if(__DRV_TM_GET_EVENT(mTM, TM_EVENT_CH2))
X    if((((mTM)->Instance ->STA . W & ((((uint32_t)0x00000400) | ((uint32_t)0x00004000)))) != (0)))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_CC2))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000400))) == (((uint32_t)0x00000400))))
N        {
N            mTM->Channel = MID_TM_Channel2;
N            /* Input capture event */
N            if(mTM->Instance->CCMDS.MBIT.CC2_MDS == TM_CH_InputCapture)
X            if(mTM->Instance->CCMDS.MBIT.CC2_MDS == (0x0001U))
N            {
N                MID_TM_IC_CaptureCallback(mTM);
N                __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC2A | TM_FLAG_CC2B));
X                ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000400) | ((uint32_t)0x00004000))));
N            }
N            /* Output compare event */
N            else
N            {
N                __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC2A | TM_FLAG_CC2B));
X                ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000400) | ((uint32_t)0x00004000))));
N                MID_TM_OC_DelayElapsedCallback(mTM);
N                MID_TM_PWM_PulseFinishedCallback(mTM);
N            }
N            mTM->Channel = MID_TM_ACTIVE_CHANNEL_CLEARED;
N        }
N    }
N    /* Capture compare 3 event */
N    if(__DRV_TM_GET_EVENT(mTM, TM_EVENT_CH3))
X    if((((mTM)->Instance ->STA . W & ((((uint32_t)0x00000800) | ((uint32_t)0x00008000)))) != (0)))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_CC3))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000800))) == (((uint32_t)0x00000800))))
N        {
N            mTM->Channel = MID_TM_Channel3;
N            /* Input capture event */
N            if(mTM->Instance->CCMDS.MBIT.CC3_MDS == TM_CH_InputCapture)
X            if(mTM->Instance->CCMDS.MBIT.CC3_MDS == (0x0001U))
N            {
N                MID_TM_IC_CaptureCallback(mTM);
N                __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC3A | TM_FLAG_CC3B));
X                ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000800) | ((uint32_t)0x00008000))));
N            }
N            /* Output compare event */
N            else
N            {
N                __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_CC3A | TM_FLAG_CC3B));
X                ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000800) | ((uint32_t)0x00008000))));
N                MID_TM_OC_DelayElapsedCallback(mTM);
N                MID_TM_PWM_PulseFinishedCallback(mTM);
N            }
N            mTM->Channel = MID_TM_ACTIVE_CHANNEL_CLEARED;
N        }
N    }
N
N    #if defined(MG32_3RD)
X    #if 0L
S    /* TM One Pulse event */
S    if(__DRV_TM_GET_EVENT(mTM, (TM_EVENT_ONEPULSE)))
S    {
S        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_ONEPULSE))
S        {
S            __DRV_TM_CLEAR_FLAG(mTM, (TM_EVENT_ONEPULSE));
S            MID_TM_OnePulseCallback(mTM);
S        }
S    }
N    #endif
N
N    /* TM Update event */
N    if(__DRV_TM_GET_EVENT(mTM, (TM_FLAG_UPDATE_UP | TM_FLAG_UPDATE_DOWN)))
X    if((((mTM)->Instance ->STA . W & ((((uint32_t)0x00000010) | ((uint32_t)0x00000040)))) != (0)))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_UPDATE))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000010))) == (((uint32_t)0x00000010))))
N        {
N            __DRV_TM_CLEAR_FLAG(mTM, (TM_FLAG_UPDATE_UP | TM_FLAG_UPDATE_DOWN));
X            ((mTM)->Instance ->STA . W = ((((uint32_t)0x00000010) | ((uint32_t)0x00000040))));
N            MID_TM_PeriodElapsedCallback(mTM);
N        }
N    }
N    /* TM Break input event */
N    if(__DRV_TM_GET_FLAG(mTM, (TM_FLAG_BREAK)))
X    if((((mTM)->Instance ->STA . W & ((((uint32_t)0x00000004)))) == ((((uint32_t)0x00000004)))))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_BREAK))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000004))) == (((uint32_t)0x00000004))))
N        {
N            __DRV_TM_CLEAR_FLAG(mTM, TM_FLAG_BREAK);
X            ((mTM)->Instance ->STA . W = (((uint32_t)0x00000004)));
N            MID_TM_BreakCallback(mTM);
N        }
N    }
N    /* TM Trigger detection event */
N    if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_EXTERNAL))
X    if((((mTM)->Instance ->STA . W & (((uint32_t)0x00000008))) == (((uint32_t)0x00000008))))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_EXTERNAL))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00000008))) == (((uint32_t)0x00000008))))
N        {
N            __DRV_TM_CLEAR_FLAG(mTM, TM_FLAG_EXTERNAL);
X            ((mTM)->Instance ->STA . W = (((uint32_t)0x00000008)));
N            MID_TM_TriggerCallback(mTM);
N        }
N    }
N    /* TM QEI direction change event */
N    if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_QEI_DIRCHANGE))
X    if((((mTM)->Instance ->STA . W & (((uint32_t)0x00010000))) == (((uint32_t)0x00010000))))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_QEI_DIRCHANGE) != CLR)
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00010000))) == (((uint32_t)0x00010000))) != CLR)
N        {
N            __DRV_TM_CLEAR_FLAG(mTM, TM_FLAG_QEI_DIRCHANGE);
X            ((mTM)->Instance ->STA . W = (((uint32_t)0x00010000)));
N            MID_TM_QEI_DIRCHANGECallback(mTM);
N        }
N    }
N    /* TM QEI direction change event */
N    if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_QEI_INDEX))
X    if((((mTM)->Instance ->STA . W & (((uint32_t)0x00040000))) == (((uint32_t)0x00040000))))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_QEI_INDEX))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00040000))) == (((uint32_t)0x00040000))))
N        {
N            __DRV_TM_CLEAR_FLAG(mTM, TM_FLAG_QEI_INDEX);
X            ((mTM)->Instance ->STA . W = (((uint32_t)0x00040000)));
N            MID_TM_QEI_INDEXCallback(mTM);
N        }
N    }
N    /* TM QEI direction change event */
N    if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_QEI_ERROR))
X    if((((mTM)->Instance ->STA . W & (((uint32_t)0x00080000))) == (((uint32_t)0x00080000))))
N    {
N        if(__DRV_TM_GET_IT_SOURCE(mTM, TM_IT_QEI_ERROR))
X        if((((mTM)->Instance ->INT . W & (((uint32_t)0x00080000))) == (((uint32_t)0x00080000))))
N        {
N            __DRV_TM_CLEAR_FLAG(mTM, TM_FLAG_QEI_ERROR);
X            ((mTM)->Instance ->STA . W = (((uint32_t)0x00080000)));
N            MID_TM_QEI_ErrorCallback(mTM);
N        }
N    }
N    
N}
N///@}
N
N
N
N/**
N * @name    Peripheral Control functions
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Initializes the TM Output Compare Channels according to the
N *              specified parameters in the TM_OC_InitTypeDef.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sConfig : pointer to a TM_OC_InitTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_OC_InitTypeDef sConfig;
N    
N    MID_TM_OC_Struct_Init(&sConfig);                   // initial default parameters
N    sConfig.OCMode  = TM_CH_16bit_OutputCompare;
N    sConfig.Pulse   = 200;                          // duty cycle 
N
N    MID_TM_OC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_OC_ConfigChannel(TM_HandleTypeDef* mTM, TM_OC_InitTypeDef* sConfig, uint32_t Channel)
N{
N    /* Check input state */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    mTM->State = MID_TM_STATE_BUSY;
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Configure the TM Channel 0 in Output Compare */
N        TM_OC0_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Configure the TM Channel 1 in Output Compare */
N        TM_OC1_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Configure the TM Channel 2 in Output Compare */
N        TM_OC2_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Configure the TM Channel 3 in Output Compare */
N        TM_OC3_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    default:
N        break;
N    }
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM Input Capture Channels according to the
N *              specified parameters in the TM_IC_InitTypeDef.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sConfig : pointer to a TM_OC_InitTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_IC_InitTypeDef sConfig;
N    sConfig.ICPolarity  = TM_ICPOLARITY_RISING;
N    sConfig.ICSelection = MID_TM_INPUTMUX_PIN;                          
N    sConfig.ICDataMode  = MID_TM_IC_KEEPDATA;
N  
N    MID_TM_IC_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_IC_ConfigChannel(TM_HandleTypeDef* mTM, TM_IC_InitTypeDef* sConfig, uint32_t Channel)
N{
N    /* Process Locked */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    mTM->State = MID_TM_STATE_BUSY;
N
N    if(Channel == MID_TM_Channel0)
N    {
N        /* Config IC0 trigger source & edge */
N        mTM->Instance->ICCR.W &= ~(TM_ICCR_IC0_MUX_mask_w | TM_ICCR_IC0_TRGS_mask_w);
X        mTM->Instance->ICCR.W &= ~(((uint32_t)0x00000003) | ((uint32_t)0x00030000));
N        mTM->Instance->ICCR.W |= (sConfig->ICSelection | sConfig->ICPolarity);
N        // Overwritten or keep data for channel 0
N        mTM->Instance->CR1.W &= ~(TM_CR1_OVR0_MDS_mask_w);
X        mTM->Instance->CR1.W &= ~(((uint32_t)0x00000001));
N        mTM->Instance->CR1.W |= (sConfig->ICDataMode);
N    }
N    else if(Channel == MID_TM_Channel1)
N    {
N        /* Config IC1 trigger source & edge */
N        mTM->Instance->ICCR.W &= ~(TM_ICCR_IC1_MUX_mask_w | TM_ICCR_IC1_TRGS_mask_w);
X        mTM->Instance->ICCR.W &= ~(((uint32_t)0x00000030) | ((uint32_t)0x000C0000));
N        mTM->Instance->ICCR.W |= (sConfig->ICSelection << 4);
N        mTM->Instance->ICCR.W |= (sConfig->ICPolarity << 2);
N        // Overwritten or keep data for channel 1
N        mTM->Instance->CR1.W &= ~(TM_CR1_OVR0_MDS_mask_w << 1);
X        mTM->Instance->CR1.W &= ~(((uint32_t)0x00000001) << 1);
N        mTM->Instance->CR1.W |= (sConfig->ICDataMode << 1);
N    }
N    else if(Channel == MID_TM_Channel2)
N    {
N        /* Config IC2 trigger source & edge */
N        mTM->Instance->ICCR.W &= ~(TM_ICCR_IC2_MUX_mask_w | TM_ICCR_IC2_TRGS_mask_w);
X        mTM->Instance->ICCR.W &= ~(((uint32_t)0x00000300) | ((uint32_t)0x00300000));
N        mTM->Instance->ICCR.W |= (sConfig->ICSelection << 8);
N        mTM->Instance->ICCR.W |= (sConfig->ICPolarity << 6);
N        // Overwritten or keep data for channel 2
N        mTM->Instance->CR1.W &= ~(TM_CR1_OVR0_MDS_mask_w << 2);
X        mTM->Instance->CR1.W &= ~(((uint32_t)0x00000001) << 2);
N        mTM->Instance->CR1.W |= (sConfig->ICDataMode << 2);
N    }
N    else
N    {
N        /* Config IC3 trigger source & edge */
N        mTM->Instance->ICCR.W &= ~(TM_ICCR_IC3_MUX_mask_w | TM_ICCR_IC3_TRGS_mask_w);
X        mTM->Instance->ICCR.W &= ~(((uint32_t)0x00003000) | ((uint32_t)0x00C00000));
N        mTM->Instance->ICCR.W |= (sConfig->ICSelection << 12);
N        mTM->Instance->ICCR.W |= (sConfig->ICPolarity << 6);
N        // Overwritten or keep data for channel 3
N        mTM->Instance->CR1.W &= ~(TM_CR1_OVR0_MDS_mask_w << 3);
X        mTM->Instance->CR1.W &= ~(((uint32_t)0x00000001) << 3);
N        mTM->Instance->CR1.W |= (sConfig->ICDataMode << 3);
N    }
N
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Initializes the TM PWM  channels according to the specified
N *              parameters in the TM_OC_InitTypeDef.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sConfig : pointer to a TM_OC_InitTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_OC_InitTypeDef sConfig;
N    
N    MID_TM_OC_Struct_Init(&sConfig);                   // initial default parameters
N    sConfig.OCMode  = TM_CH_16bit_PWM;
N    sConfig.Pulse   = 200;                          // duty cycle 
N
N    MID_TM_PWM_ConfigChannel(&mTM, &sConfig, MID_TM_Channel0);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_PWM_ConfigChannel(TM_HandleTypeDef* mTM, TM_OC_InitTypeDef* sConfig, uint32_t Channel)
N{
N    /* Check input state */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    mTM->State = MID_TM_STATE_BUSY;
N
N    switch(Channel)
N    {
N    case MID_TM_Channel0:
N    {
N        /* Configure the TM Channel 0 in PWM Compare */
N        TM_OC0_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    case MID_TM_Channel1:
N    {
N        /* Configure the TM Channel 1 in PWM Compare */
N        TM_OC1_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    case MID_TM_Channel2:
N    {
N        /* Configure the TM Channel 2 in PWM Compare */
N        TM_OC2_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    case MID_TM_Channel3:
N    {
N        /* Configure the TM Channel 3 in PWM Compare */
N        TM_OC3_SetConfig(mTM->Instance, sConfig);
N    }
N    break;
N
N    default:
N        break;
N    }
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Generate a software event
N * @param       mTM : TM handle
N * @param       EventSource : specifies the event source.
N *              This parameter can be one of the following values:
N *   @arg       TM_EVENTSOURCE_CC0A: Channel0 IC/OC event-A generation.
N *   @arg       TM_EVENTSOURCE_CC0B: Channel0 IC/OC event-B generation.
N *   @arg       TM_EVENTSOURCE_CC1A: Channel1 IC/OC event-A generation.
N *   @arg       TM_EVENTSOURCE_CC1B: Channel1 IC/OC event-B generation.
N *   @arg       TM_EVENTSOURCE_CC2A: Channel2 IC/OC event-A generation.
N *   @arg       TM_EVENTSOURCE_CC2B: Channel2 IC/OC event-B generation.
N *   @arg       TM_EVENTSOURCE_CC3A: Channel3 IC/OC event-A generation.
N *   @arg       TM_EVENTSOURCE_CC3B: Channel3 IC/OC event-B generation.
N *   @arg       TM_EVENTSOURCE_TRIGGER: Timer external update event generation.
N *   @arg       TM_EVENTSOURCE_BREAK: Timer Break event source generation.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_GenerateEvent(mTM, TM_EVENTSOURCE_CC0A);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_GenerateEvent(TM_HandleTypeDef* mTM, uint32_t EventSource)
N{
N    /* Process Lockeded */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    /* Change the TM state */
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Set the event sources */
N    switch(EventSource)
N    {
N    case TM_EVENTSOURCE_CC0A:
X    case 0x0U:
N        mTM->Instance->CR1.W |= TM_CR1_CC0A_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00000100);
N        break;
N    case TM_EVENTSOURCE_CC0B:
X    case 0x1U:
N        mTM->Instance->CR1.W |= TM_CR1_CC0B_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00001000);
N        break;
N    case TM_EVENTSOURCE_CC1A:
X    case 0x2U:
N        mTM->Instance->CR1.W |= TM_CR1_CC1A_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00000200);
N        break;
N    case TM_EVENTSOURCE_CC1B:
X    case 0x3U:
N        mTM->Instance->CR1.W |= TM_CR1_CC1B_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00002000);
N        break;
N    case TM_EVENTSOURCE_CC2A:
X    case 0x4U:
N        mTM->Instance->CR1.W |= TM_CR1_CC2A_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00000400);
N        break;
N    case TM_EVENTSOURCE_CC2B:
X    case 0x5U:
N        mTM->Instance->CR1.W |= TM_CR1_CC2B_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00004000);
N        break;
N    case TM_EVENTSOURCE_CC3A:
X    case 0x6U:
N        mTM->Instance->CR1.W |= TM_CR1_CC3A_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00000800);
N        break;
N    case TM_EVENTSOURCE_CC3B:
X    case 0x7U:
N        mTM->Instance->CR1.W |= TM_CR1_CC3B_SEN_enable_w;
X        mTM->Instance->CR1.W |= ((uint32_t)0x00008000);
N        break;
N    case TM_EVENTSOURCE_TRIGGER:
X    case 0x8U:
N        mTM->Instance->CR0.W |= TM_CR0_USW_EN_enable_w;
X        mTM->Instance->CR0.W |= ((uint32_t)0x00004000);
N        break;
N    case TM_EVENTSOURCE_BREAK:
X    case ((uint32_t)0x00000080):
N        mTM->Instance->BS.W |= TM_BS_BKSW_EN_enable_w;
X        mTM->Instance->BS.W |= ((uint32_t)0x00000080);
N        mTM->Instance->BS.W &= ~(TM_BS_BKSW_EN_enable_w);
X        mTM->Instance->BS.W &= ~(((uint32_t)0x00000080));
N        break;
N    default:
N        break;
N
N    }
N
N    /* Change the TM state */
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    /* Return function status */
N    return MID_SUCCESS;
N}
N
N
N
N/**
N *******************************************************************************
N * @brief       CConfigures the clock source to be used.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sClockSourceConfig : pointer to a TM_ClockConfigTypeDef structure that
N *              contains the clock source information for the TM peripheral.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_ClockConfigTypeDef CKConfig;
N
N    CKConfig.TM_ClockSource         = TM_INTERNAL_CLOCK;
N    CKConfig.TM_ExternalClockSource = 0;
N    CKConfig.TM_INTClockDivision    = TM_INTERNALCLOCK_DIVDER_DIV1;
N    CKConfig.TM_InternalClockSource = TM_INTERNALCLOCK_PROC;
N
N    MID_TM_ConfigClockSource(&mTM20, &CKConfig);  
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_ConfigClockSource(TM_HandleTypeDef * mTM, TM_ClockConfigTypeDef * sClockSourceConfig)
N{
N    uint32_t tmpsmcr = 0U;
N
N    /* Process Lockeded */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    mTM->State = MID_TM_STATE_BUSY;
N
N    /* Config Main Counter/Prescaler Clock source from Internal or External clock */
N    /* Config Internal / External Clock source */
N    tmpsmcr = mTM->Instance->CLK.W;
N    tmpsmcr &= ~(TM_CLK_CKI_DIV_mask_w | TM_CLK_CKI_SEL_mask_w | TM_CLK_CKS2_SEL_mask_w | TM_CLK_CKS_SEL_mask_w | TM_CLK_CKE_SEL_mask_w);
X    tmpsmcr &= ~(((uint32_t)0x00003000) | ((uint32_t)0x00000300) | ((uint32_t)0x00000080) | ((uint32_t)0x00000040) | ((uint32_t)0x00000030));
N    tmpsmcr |= (sClockSourceConfig->TM_ClockSource | sClockSourceConfig->TM_INTClockDivision | sClockSourceConfig->TM_InternalClockSource);
N    tmpsmcr |= (sClockSourceConfig->TM_ExternalClockSource & ~(TM_TRG_ITR_MUX_mask_w));  
X    tmpsmcr |= (sClockSourceConfig->TM_ExternalClockSource & ~(((uint32_t)0x00000700)));  
N    mTM->Instance->CLK.W = tmpsmcr;
N
N    /* Config ITRx Clock source */
N    tmpsmcr = mTM->Instance->TRG.W;
N    tmpsmcr &= ~(TM_TRG_ITR_MUX_mask_w);
X    tmpsmcr &= ~(((uint32_t)0x00000700));
N    tmpsmcr |= (sClockSourceConfig->TM_ExternalClockSource & ~(TM_CLK_CKE_SEL_mask_w));  
X    tmpsmcr |= (sClockSourceConfig->TM_ExternalClockSource & ~(((uint32_t)0x00000030)));  
N    mTM->Instance->TRG.W = tmpsmcr;
N  
N    // Update state & unlock
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Configures the TM in master mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sMasterConfig : pointer to a TM_MasterConfigTypeDef structure that
N *              contains the selected trigger output (TRGO) and the Master.
N*   @arg        MasterOutputTrigger: TRGO source.
N*   @arg        MasterOutputPolarity: Invert TRGO or not.
N*   @arg        MasterUpdateEvent: specify option of disable, TOF, TUF or both edge.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_MasterConfigTypeDef TM_TRGOConfig;
N
N    TM_TRGOConfig.MasterOutputTrigger   = TM_TRGO_UPDATE;
N    TM_TRGOConfig.MasterOutputPolarity  = TM_MASTEROUTPUT_BYPASS;
N    TM_TRGOConfig.MasterUpdateEvent     = TM_UPDATE_OVERFLOW;
N
N    MID_TM_MasterConfigSynchronization(&mTM10, &TM_TRGOConfig);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_MasterConfigSynchronization(TM_HandleTypeDef* mTM, TM_MasterConfigTypeDef * sMasterConfig)
N{
N    uint32_t tmpTRGO;
N
N    /* Process Lockeded */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N    
N    mTM->State = MID_TM_STATE_BUSY;
N    
N    /* Load TRG reigter and mask TRGO control bit */
N    tmpTRGO = mTM->Instance->TRG.W & ~(TM_TRG_TRGO_INV_mask_w | TM_TRG_UEV_SEL_mask_w | TM_TRG_TRGO_MDS_mask_w);
X    tmpTRGO = mTM->Instance->TRG.W & ~(((uint32_t)0x02000000) | ((uint32_t)0x00C00000) | ((uint32_t)0x0000F000));
N    
N    /* Over write TRGO control parameters  */
N    tmpTRGO |= (sMasterConfig->MasterOutputTrigger | sMasterConfig->MasterOutputPolarity | sMasterConfig->MasterUpdateEvent);
N    
N    /* Reset the TRG register */
N    mTM->Instance->TRG.W = tmpTRGO;
N        
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N    
N    return MID_SUCCESS;
N}
N
N
N/**
N *******************************************************************************
N * @brief       Configures the Break feature, dead time, OCx/OCxN State
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sBreakDeadTimeConfig : pointer to a TM_ConfigBreakDeadConfigTypeDef structure that
N *              contains the BS/PWM Register configuration information for the TM peripheral.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_BreakDeadTimeConfigTypeDef BKConfig;
N 
N    BKConfig.BreakMode              = TM_BK_CYCLE_BY_CYCLE;
N    BKConfig.BreakCHxOutputMode     = MID_BREAK_STOP_STATE;
N    BKConfig.BreakSourceSel         = MID_BK_ExtPin | MID_BK_ClockFailure | MID_BK_CPULOCKUP | MID_BK_BOD1;
N    BKConfig.DeatTimeClockDivision  = MID_TM_CKDTG_DIV1;
N    BKConfig.DeadTime               = DeadTime_Set;
N    
N    MID_TM_ConfigBreakDeadTime(&mTM36, &BKConfig);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_ConfigBreakDeadTime(TM_HandleTypeDef* mTM, TM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
N{
N    uint32_t tmpBS;
N    
N    tmpBS = (mTM->Instance->BS.W) & (~0x0000000F);
N    
N    /* Process Lockeded */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    // config BreakMode, Stop State, Break source
N    tmpBS |= sBreakDeadTimeConfig->BreakMode;
N    tmpBS |= sBreakDeadTimeConfig->BreakCHxOutputMode;
N    tmpBS |= sBreakDeadTimeConfig->BreakSourceSel;
N    
N    mTM->Instance->BS.W = tmpBS;
N    
N    // config dead time clock divider
N    mTM->Instance->CLK.W &= ~(TM_CLK_DTG_DIV_mask_w);
X    mTM->Instance->CLK.W &= ~(((uint32_t)0x00030000));
N    mTM->Instance->CLK.W |= sBreakDeadTimeConfig->DeatTimeClockDivision;
N    
N    // config dead time
N    mTM->Instance->PWM.W &= ~(TM_PWM_DTG_DY_mask_w);
X    mTM->Instance->PWM.W &= ~(((uint32_t)0x0000FF00));
N    mTM->Instance->PWM.W |= (sBreakDeadTimeConfig->DeadTime << 8);
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N    
N}
N
N/**
N *******************************************************************************
N * @brief       Configures the TM in Slave mode (Disable, Reset, Gated, Trigger,K)
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sSlaveConfig : pointer to a TM_SlaveConfigTypeDef
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_SlaveConfigTypeDef TMslave;
N    
N    TMslave.SlaveMode       = TM_SLAVEMODE_TRIGGER_RISINGEDGE;
N    TMslave.InputTrigger    = TM_TS_IN0;
N
N    MID_TM_SlaveConfigSynchronization(&mTM, &TMslave);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_SlaveConfigSynchronization(TM_HandleTypeDef* mTM, TM_SlaveConfigTypeDef* sSlaveConfig)
N{
N    /* Process Lockeded */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    mTM->State = MID_TM_STATE_BUSY;
N
N    TM_SlaveTimer_SetConfig(mTM, sSlaveConfig);
N
N    /* Disable Trigger Interrupt */
N    __DRV_TM_DISABLE_IT(mTM, TM_IT_EXTERNAL);
X    ((mTM)->Instance ->INT . W &= ~(((uint32_t)0x00000008)));
N
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Configures the TM in Slave mode in interrupt mode (Disable, Reset
N *              , Gated, Trigger,K)
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sSlaveConfig : specifies Timer channel selection
N *  @arg\b      SlaveMode : This parameter can be a value of 
N *              reference TM_Slave_Mode.
N *  @arg\b      InputTrigger : This parameter can be a value of 
N *              reference TM_Trigger_Selection.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_SlaveConfigTypeDef TMslave;
N    
N    TMslave.SlaveMode       = TM_SLAVEMODE_TRIGGER_RISINGEDGE;
N    TMslave.InputTrigger    = TM_TS_IN0;
N
N    MID_TM_SlaveConfigSynchronization_IT(&mTM, &TMslave);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_SlaveConfigSynchronization_IT(TM_HandleTypeDef* mTM, TM_SlaveConfigTypeDef* sSlaveConfig)
N{
N    /* Process Lockeded */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    mTM->State = MID_TM_STATE_BUSY;
N
N    TM_SlaveTimer_SetConfig(mTM, sSlaveConfig);
N
N    /* Enable Trigger Interrupt */
N    __DRV_TM_ENABLE_IT(mTM, TM_IT_EXTERNAL);
X    ((mTM)->Instance ->INT . W |= (((uint32_t)0x00000008)));
N
N    mTM->State = MID_TM_STATE_READY;
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Configures the TM output clock with 50% duty cycle.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   sClockConfig : specifies Timer clockout configureation
N *  @arg\b      CKOInitState : The timer CKO output signal initial state. 
N *  @arg\b      CKOSource : The timer clock out source event.
N *  @arg\b      CKOCmd : The timer clockout function.
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N    TM_CKOConfigTypeDef TMCKO;
N    
N    TMCKO.CKOInitState  = TM_CKOINIT_SET;
N    TMCKO.CKOSource     = TM_CKOSOURCE_PRESCALER;
N    TMCKO.CKOCmd        = ENABLE;
N
N    MID_TM_ClockOut(&mTM, &TMCKO);
N * @endcode
N *******************************************************************************
N */
NMID_StatusTypeDef MID_TM_ClockOut(TM_HandleTypeDef* mTM, TM_CKOConfigTypeDef* sClockConfig)
N{
N    uint32_t tmpCKO;
N    
N    /* Check input state */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N    
N    mTM->State = MID_TM_STATE_BUSY;
N
N    // config CKO register
N    tmpCKO = sClockConfig->CKOInitState | sClockConfig->CKOSource | sClockConfig->CKOCmd | TM_CKO_CKO_LCK_un_locked_w;
X    tmpCKO = sClockConfig->CKOInitState | sClockConfig->CKOSource | sClockConfig->CKOCmd | ((uint32_t)0x00000008);
N    mTM->Instance->CKO.W = tmpCKO;
N
N    // release & unlock
N    mTM->State = MID_TM_STATE_READY;
N    
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N
N    return MID_SUCCESS;
N}
N
N/**
N *******************************************************************************
N * @brief       Read the captured value from Capture Compare unit.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    MID_TM_ReadCapturedValue(&mTM, MID_TM_Channel1);
N * @endcode
N *******************************************************************************
N */
Nuint32_t MID_TM_ReadCapturedValue(TM_HandleTypeDef *mTM, uint32_t Channel)
N{
N    volatile ctype tmpreg;
N    
N    tmpreg.W = 0U;
N
N    /* Process Locked */
N    __MID_LOCK(mTM);
X    do{ if((mTM)->Lock == MID_Locked) { return MID_BUSY; } else { (mTM)->Lock = MID_Locked; } }while (0);
N
N    switch (Channel)
N    {
N    case MID_TM_Channel0:
N        // Fyll counter mode (32bit)
N        if((mTM->Init.TM_CounterMode & 0x0020) != 0)
N        {
N            /* Return the capture 0 value */
N            tmpreg.H[1] = mTM->Instance->CC0A.H[0];
N            tmpreg.H[0] = mTM->Instance->CC0B.H[0];
N        }
N        else
N        {   // Separate/Cascade mode (16 bit)
N            if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_CC0B))
X            if((((mTM)->Instance ->STA . W & (((uint32_t)0x00001000))) == (((uint32_t)0x00001000))))
N                tmpreg.H[0] = mTM->Instance->CC0B.H[0];
N            else
N                tmpreg.H[0] = mTM->Instance->CC0A.H[0];
N        }
N        break;
N
N    case MID_TM_Channel1:
N        // Fyll counter mode (32bit)
N        if((mTM->Init.TM_CounterMode & 0x0020) != 0)
N        {
N            /* Return the capture 0 value */
N            tmpreg.H[1] = mTM->Instance->CC1A.H[0];
N            tmpreg.H[0] = mTM->Instance->CC1B.H[0];
N        }
N        else
N        {   // Separate/Cascade mode (16 bit)
N            if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_CC1B))
X            if((((mTM)->Instance ->STA . W & (((uint32_t)0x00002000))) == (((uint32_t)0x00002000))))
N                tmpreg.H[0] = mTM->Instance->CC1B.H[0];
N            else
N                tmpreg.H[0] = mTM->Instance->CC1A.H[0];
N        }
N        break;
N        
N    case MID_TM_Channel2:
N        // Fyll counter mode (32bit)
N        if((mTM->Init.TM_CounterMode & 0x0020) != 0)
N        {
N            /* Return the capture 0 value */
N            tmpreg.H[1] = mTM->Instance->CC2A.H[0];
N            tmpreg.H[0] = mTM->Instance->CC2B.H[0];
N        }
N        else
N        {   // Separate/Cascade mode (16 bit)
N            if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_CC2B))
X            if((((mTM)->Instance ->STA . W & (((uint32_t)0x00004000))) == (((uint32_t)0x00004000))))
N                tmpreg.H[0] = mTM->Instance->CC2B.H[0];
N            else
N                tmpreg.H[0] = mTM->Instance->CC2A.H[0];
N        }
N        break;
N
N    case MID_TM_Channel3:
N        // Fyll counter mode (32bit)
N        if((mTM->Init.TM_CounterMode & 0x0020) != 0)
N        {
N            /* Return the capture 0 value */
N            tmpreg.H[1] = mTM->Instance->CC3A.H[0];
N            tmpreg.H[0] = mTM->Instance->CC3B.H[0];
N        }
N        else
N        {   // Separate/Cascade mode (16 bit)
N            if(__DRV_TM_GET_FLAG(mTM, TM_FLAG_CC3B))
X            if((((mTM)->Instance ->STA . W & (((uint32_t)0x00008000))) == (((uint32_t)0x00008000))))
N                tmpreg.H[0] = mTM->Instance->CC3B.H[0];
N            else
N                tmpreg.H[0] = mTM->Instance->CC3A.H[0];
N        }
N        break;
N        
N    default:
N        break;
N    }
N
N    /* Release Lock */
N    __MID_UNLOCK(mTM);
X    do{ (mTM)->Lock = MID_UnLocked; }while (0);
N    
N    return tmpreg.W;
N}
N///@}
N
N
N
N/**
N * @name    TM Callbacks functions
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Period elapsed callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_PeriodElapsedCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_PeriodElapsedCallback could be implemented in the user file
N     */
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       Output Compare callback in non blocking mode
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_OC_DelayElapsedCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_OC_DelayElapsedCallback could be implemented in the user file
N     */
N
N}
N
N/**
N *******************************************************************************
N * @brief       Input Capture callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_IC_CaptureCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_IC_CaptureCallback could be implemented in the user file
N     */
N
N}
N
N
N
N/**
N *******************************************************************************
N * @brief       PWM Pulse finished callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
N__weak void MID_TM_PWM_PulseFinishedCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_PWM_PulseFinishedCallback could be implemented in the user file
N     */
N
N}
N
N
N
N/**
N *******************************************************************************
N * @brief       Hall Trigger detection callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_TriggerCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_TriggerCallback could be implemented in the user file
N     */
N
N}
N
N
N
N/**
N *******************************************************************************
N * @brief       TMer error callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_ErrorCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_ErrorCallback could be implemented in the user file
N     */
N
N}
N
N/**
N *******************************************************************************
N * @brief       Hall Break detection callback in non blocking mode
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_BreakCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_BreakCallback could be implemented in the user file
N     */
N}
N
N
N/**
N *******************************************************************************
N * @brief       QEI direction change callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_QEI_DIRCHANGECallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_QEI_DIRCHANGECallback could be implemented in the user file
N     */
N
N}
N
N/**
N *******************************************************************************
N * @brief       QEI index callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_QEI_INDEXCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_QEI_INDEXCallback could be implemented in the user file
N     */
N
N}
N
N/**
N *******************************************************************************
N * @brief       QEI receive error signal callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_QEI_ErrorCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_QEI_ErrorCallback could be implemented in the user file
N     */
N
N}
N
N/**
N *******************************************************************************
N * @brief       Repetition timer underflow signal callback in non blocking mode.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
N__weak void MID_TM_OnePulseCallback(TM_HandleTypeDef* mTM)
N{
N    /* Prevent unused argument(s) compilation warning */
N    UNUSED(mTM);
X    ((void)(mTM));
N    /* NOTE : This function Should not be modified, when the callback is needed,
N              the MID_TM_QEI_ErrorCallback could be implemented in the user file
N     */
N
N}
N///@}
N
N
N
N/**
N * @name    Peripheral State functions
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Return the TM Base state.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
NMID_TM_StateTypeDef MID_TM_Base_GetState(TM_HandleTypeDef* mTM)
N{
N    return mTM->State;
N}
N
N/**
N *******************************************************************************
N * @brief       Return the TM OC state.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
NMID_TM_StateTypeDef MID_TM_OC_GetState(TM_HandleTypeDef* mTM)
N{
N    return mTM->State;
N}
N
N/**
N *******************************************************************************
N * @brief       Return the TM PWM state.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
NMID_TM_StateTypeDef MID_TM_PWM_GetState(TM_HandleTypeDef* mTM)
N{
N    return mTM->State;
N}
N
N/**
N *******************************************************************************
N * @brief       Return the TM Input Capture state.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
NMID_TM_StateTypeDef MID_TM_IC_GetState(TM_HandleTypeDef* mTM)
N{
N    return mTM->State;
N}
N
N/**
N *******************************************************************************
N * @brief       Return the TM One Pulse Mode state.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
NMID_TM_StateTypeDef MID_TM_OnePulse_GetState(TM_HandleTypeDef* mTM)
N{
N    return mTM->State;
N}
N
N/**
N *******************************************************************************
N * @brief       Return the TM Encoder Mode state.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
NMID_TM_StateTypeDef MID_TM_Encoder_GetState(TM_HandleTypeDef* mTM)
N{
N    return mTM->State;
N}
N
N///@}
N
N
N
N/**
N * @name    PWM output config
N *
N */
N///@{
N/**
N *******************************************************************************
N * @brief       Fills each TM_OC_InitTypeDef member with its default value.
N * @param[in]   sConfig : pointer to a TM_OC_InitTypeDef
N *              structure which will be initialized.
N * @return      No
N *******************************************************************************
N */
Nvoid MID_TM_OC_Struct_Init(TM_OC_InitTypeDef* sConfig)
N{
N    sConfig->OCMode         = TM_CH_16bit_OutputCompare;
X    sConfig->OCMode         = (0x0002U);
N    sConfig->Pulse          = 1000;                         // duty cycle setting
N    sConfig->OCPolarity     = TM_OCPOLARITY_HIGH;           // No-Inverse
X    sConfig->OCPolarity     = (0x0000U);           
N    sConfig->OCNPolarity    = TM_OCNPOLARITY_HIGH;          // No-Inverse
X    sConfig->OCNPolarity    = (0x0000U);          
N    sConfig->OCHPolarity    = TM_OCHPOLARITY_HIGH;          // No-Inverse
X    sConfig->OCHPolarity    = (0x0000U);          
N    sConfig->OCIdleState    = TM_OCIDLESTATE_RESET;         // OCxx : Output low in idle state
X    sConfig->OCIdleState    = (0x00000000U);         
N    sConfig->OCNIdleState   = TM_OCNIDLESTATE_RESET;        // OCxN : Output low in idle state
X    sConfig->OCNIdleState   = (0x00000000U);        
N    sConfig->OCHIdleState   = TM_OCHIDLESTATE_RESET;        // OCxH : Output low in idle state
X    sConfig->OCHIdleState   = (0x00000000U);        
N}
N
N
N/**
N *******************************************************************************
N * @brief       TM DMA error call back.
N * @param[in]   hDMA : pointer to a DMA_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
Nvoid TM_DMAError(DMA_HandleTypeDef* hDMA)
N{
N    TM_HandleTypeDef* mTM = (TM_HandleTypeDef*)((DMA_HandleTypeDef*)hDMA)->Parent;
N
N    mTM->State= MID_TM_STATE_READY;
N
N    MID_TM_ErrorCallback(mTM);
N}
N
N
N/**
N *******************************************************************************
N * @brief       TM DMA Delay Pulse complete callback.
N * @param[in]   hDMA : pointer to a DMA_HandleTypeDef
N * @return      None
N *******************************************************************************
N */
Nvoid TM_DMADelayPulseCplt(DMA_HandleTypeDef* hDMA)
N{
N    TM_HandleTypeDef* mTM = (TM_HandleTypeDef*)((DMA_HandleTypeDef*)hDMA)->Parent;
N
N    mTM->State = MID_TM_STATE_READY;
N
N    if(hDMA == mTM->hDMA[TM_DMA_ID_CC0])
X    if(hDMA == mTM->hDMA[((uint16_t) 0x0U)])
N    {
N        mTM->Channel = MID_TM_Channel0;
N        // to do ...
N    }
N    else if(hDMA == mTM->hDMA[TM_DMA_ID_CC1])
X    else if(hDMA == mTM->hDMA[((uint16_t) 0x1U)])
N    {
N        mTM->Channel = MID_TM_Channel1;
N        // to do ...
N    }
N    else if(hDMA == mTM->hDMA[TM_DMA_ID_CC2])
X    else if(hDMA == mTM->hDMA[((uint16_t) 0x2U)])
N    {
N        mTM->Channel = MID_TM_Channel2;
N        // to do ...
N    }
N    else if(hDMA == mTM->hDMA[TM_DMA_ID_CC3])
X    else if(hDMA == mTM->hDMA[((uint16_t) 0x3U)])
N    {
N        mTM->Channel = MID_TM_Channel3;
N        // to do ...
N    }
N
N    MID_TM_PWM_PulseFinishedCallback(mTM);
N
N    mTM->Channel = MID_TM_ACTIVE_CHANNEL_CLEARED;
N}
N
N/**
N *******************************************************************************
N * @brief       TM DMA Capture complete callback.
N * @param[in]   hDMA : pointer to a DMA_HandleTypeDef
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
Nvoid TM_DMACaptureCplt(DMA_HandleTypeDef* hDMA)
N{
N    TM_HandleTypeDef* mTM = (TM_HandleTypeDef*)((DMA_HandleTypeDef*)hDMA)->Parent;
N
N    mTM->State = MID_TM_STATE_READY;
N
N    if(hDMA == mTM->hDMA[TM_DMA_ID_CC0])
X    if(hDMA == mTM->hDMA[((uint16_t) 0x0U)])
N    {
N        mTM->Channel = MID_TM_Channel0;
N        // to do ...
N    }
N    else if(hDMA == mTM->hDMA[TM_DMA_ID_CC1])
X    else if(hDMA == mTM->hDMA[((uint16_t) 0x1U)])
N    {
N        mTM->Channel = MID_TM_Channel1;
N        // to do ...
N    }
N    else if(hDMA == mTM->hDMA[TM_DMA_ID_CC2])
X    else if(hDMA == mTM->hDMA[((uint16_t) 0x2U)])
N    {
N        mTM->Channel = MID_TM_Channel2;
N        // to do ...
N    }
N    else if(hDMA == mTM->hDMA[TM_DMA_ID_CC3])
X    else if(hDMA == mTM->hDMA[((uint16_t) 0x3U)])
N    {
N        mTM->Channel = MID_TM_Channel3;
N        // to do ...
N    }
N
N    MID_TM_IC_CaptureCallback(mTM);
N
N    mTM->Channel = MID_TM_ACTIVE_CHANNEL_CLEARED;
N}
N
N/**
N *******************************************************************************
N * @brief       TM Base configuration.
N * @param[in]   TMx : pointer to a TM_Struct
N * @param[in]   Structure : pointer to a TM_Base_InitTypeDef
N * @return      None
N * @note
N * @par         Example
N * @code
N    TM_Base_SetConfig(mTM->Instance, &mTM->Init);
N * @endcode
N *******************************************************************************
N */
Nvoid TM_Base_SetConfig(TM_Struct* TMx, TM_Base_InitTypeDef* Structure)
N{
N    uint32_t tmpcr1 = 0U;
N
N    /* Set TM Time Base Unit parameters ----------------------------------------*/
N    /* TM mode & direction */
N    tmpcr1 = TMx->CR0.W & ~(TM_CR0_MDS_mask_w | TM_CR0_DIR_mask_w | TM_CR0_DIR2_mask_w);
X    tmpcr1 = TMx->CR0.W & ~(((uint32_t)0x00000030) | ((uint32_t)0x00000040) | ((uint32_t)0x00000080));
N    tmpcr1 |= Structure->TM_CounterMode;
N    TMx->CR0.W = tmpcr1;
N
N    /* Set the Autoreload value */
N    TMx->ARR.W = (uint32_t)Structure->TM_Period ;
N
N    /* Set the Prescaler value */
N    TMx->PSARR.W = (uint32_t)Structure->TM_Prescaler;
N
N    /* Generate an update event to reload the Main Counter and Prescaler  */
N    TMx->TRG.W |= (TM_TRG_RST2_SW_enable_w | TM_TRG_RST_SW_enable_w);
X    TMx->TRG.W |= (((uint32_t)0x20000000) | ((uint32_t)0x10000000));
N    TMx->TRG.W &= ~(TM_TRG_RST2_SW_enable_w | TM_TRG_RST_SW_enable_w);
X    TMx->TRG.W &= ~(((uint32_t)0x20000000) | ((uint32_t)0x10000000));
N
N}
N
N/**
N *******************************************************************************
N * @brief       TMe Ouput Compare 0 configuration.
N * @param[in]   TMx : pointer to a TM_HandleTypeDef
N * @param[in]   OC_Config : The ouput configuration structure
N * @return      None
N * @note
N * @par         Example
N * @code
N    TM_OC0_SetConfig(&mTM->Instance, sConfig);
N * @endcode
N *******************************************************************************
N */
Nstatic void TM_OC0_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config)
N{
N    /* Set the Output Idle state (Break state) */
N    TMx->BS.W &= ~(TM_BS_STP0_STA_mask_w | TM_BS_STP0N_STA_mask_w);
X    TMx->BS.W &= ~(((uint32_t)0x01000000) | ((uint32_t)0x10000000));
N    TMx->BS.W |= ((OC_Config->OCIdleState  | OC_Config->OCNIdleState) << 0);
N
N    /* Set the Output Idle state  */
N    TMx->OSCR.W |= ((TM_OSCR_OS0_LCK_un_locked_w | OC_Config->OCIdleState |
X    TMx->OSCR.W |= ((((uint32_t)0x00000010) | OC_Config->OCIdleState |
N                     TM_OSCR_OS0H_LCK_un_locked_w | OC_Config->OCHIdleState) << 0);
X                     ((uint32_t)0x00001000) | OC_Config->OCHIdleState) << 0);
N
N    /* Set the Output Polarity */
N    TMx->OCCR1.W &= ~((TM_OCCR1_OC0_INV_mask_w | TM_OCCR1_OC0H_INV_mask_w | TM_OCCR1_OC0N_INV_mask_w) << 0);
X    TMx->OCCR1.W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000010) | ((uint32_t)0x00000100)) << 0);
N    TMx->OCCR1.W |= ((OC_Config->OCPolarity | OC_Config->OCNPolarity | OC_Config->OCHPolarity) << 0);
N
N    /* Set the Capture Compare Register value */
N    TMx->CC0A.H[0] = TMx->CC0B.H[0] = OC_Config->Pulse;
N
N    // Enable Ouput OC
N    switch(OC_Config->OCMode)
N    {
N    case TM_CH_Disable:
X    case (0x0000U):
N        TMx->OCCR0.W &= ~(TM_OCCR0_OC0_OE0_enable_w | TM_OCCR0_OC0N_OE_enable_w);
X        TMx->OCCR0.W &= ~(((uint32_t)0x00000001) | ((uint32_t)0x00010000));
N        break;
N    case TM_CH_16bit_OutputCompare:
X    case (0x0002U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC0_OE0_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000001));
N        break;
N    case TM_CH_8bitx2_OutputCompare:
X    case (0x0003U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC0_OE0_enable_w | TM_OCCR0_OC0N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000001) | ((uint32_t)0x00010000));
N        break;
N    case TM_CH_16bit_PWM:
X    case (0x0004U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC0_OE0_enable_w | TM_OCCR0_OC0N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000001) | ((uint32_t)0x00010000));
N        break;
N    case TM_CH_8bitx2_PWM:
X    case (0x0005U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC0_OE0_enable_w | TM_OCCR0_OC0N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000001) | ((uint32_t)0x00010000));
N        break;
N    case TM_CH_16bit_PWM_COMPLEMENT:
X    case (0x0006U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC0_OE0_enable_w | TM_OCCR0_OC0N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000001) | ((uint32_t)0x00010000));
N        break;
N    case TM_CH_8bitx2_PWM_COMPLEMENT:
X    case (0x0007U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC0_OE0_enable_w | TM_OCCR0_OC0N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000001) | ((uint32_t)0x00010000));
N        break;
N
N    default:
N        break;
N
N    }
N
N}
N
N/**
N *******************************************************************************
N * @brief       TMe Ouput Compare 1 configuration.
N * @param[in]   TMx : pointer to a TM_HandleTypeDef
N * @param[in]   OC_Config : The ouput configuration structure
N * @return      None
N * @note
N * @par         Example
N * @code
N    TM_OC1_SetConfig(&mTM->Instance, sConfig);
N * @endcode
N *******************************************************************************
N */
Nstatic void TM_OC1_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config)
N{
N    /* Set the Output Idle state (Break state) */
N    TMx->BS.W &= ~((TM_BS_STP0_STA_mask_w | TM_BS_STP0N_STA_mask_w) << 1);
X    TMx->BS.W &= ~((((uint32_t)0x01000000) | ((uint32_t)0x10000000)) << 1);
N    TMx->BS.W |= ((OC_Config->OCIdleState | OC_Config->OCNIdleState) << 1);
N
N    /* Set the Output Idle state  */
N    TMx->OSCR.W |= ((TM_OSCR_OS0_LCK_un_locked_w | OC_Config->OCIdleState |
X    TMx->OSCR.W |= ((((uint32_t)0x00000010) | OC_Config->OCIdleState |
N                     TM_OSCR_OS0H_LCK_un_locked_w | OC_Config->OCHIdleState) << 1);
X                     ((uint32_t)0x00001000) | OC_Config->OCHIdleState) << 1);
N
N    /* Set the Output Polarity */
N    TMx->OCCR1.W &= ~((TM_OCCR1_OC0_INV_mask_w | TM_OCCR1_OC0H_INV_mask_w | TM_OCCR1_OC0N_INV_mask_w) << 1);
X    TMx->OCCR1.W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000010) | ((uint32_t)0x00000100)) << 1);
N    TMx->OCCR1.W |= ((OC_Config->OCPolarity | OC_Config->OCNPolarity | OC_Config->OCHPolarity) << 1);
N
N    /* Set the Capture Compare Register value */
N    TMx->CC1A.H[0] = TMx->CC1B.H[0] = OC_Config->Pulse;
N
N    // Enable Ouput OC
N    switch(OC_Config->OCMode)
N    {
N    case TM_CH_Disable:
X    case (0x0000U):
N        TMx->OCCR0.W &= ~(TM_OCCR0_OC1_OE0_enable_w | TM_OCCR0_OC1N_OE_enable_w);
X        TMx->OCCR0.W &= ~(((uint32_t)0x00000010) | ((uint32_t)0x00100000));
N        break;
N    case TM_CH_16bit_OutputCompare:
X    case (0x0002U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC1_OE0_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000010));
N        break;
N    case TM_CH_8bitx2_OutputCompare:
X    case (0x0003U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC1_OE0_enable_w | TM_OCCR0_OC1N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000010) | ((uint32_t)0x00100000));
N        break;
N    case TM_CH_16bit_PWM:
X    case (0x0004U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC1_OE0_enable_w | TM_OCCR0_OC1N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000010) | ((uint32_t)0x00100000));
N        break;
N    case TM_CH_8bitx2_PWM:
X    case (0x0005U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC1_OE0_enable_w | TM_OCCR0_OC1N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000010) | ((uint32_t)0x00100000));
N        break;
N    case TM_CH_16bit_PWM_COMPLEMENT:
X    case (0x0006U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC1_OE0_enable_w | TM_OCCR0_OC1N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000010) | ((uint32_t)0x00100000));
N        break;
N    case TM_CH_8bitx2_PWM_COMPLEMENT:
X    case (0x0007U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC1_OE0_enable_w | TM_OCCR0_OC1N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000010) | ((uint32_t)0x00100000));
N        break;
N
N    default:
N        break;
N
N    }
N
N}
N
N/**
N *******************************************************************************
N * @brief       TMe Ouput Compare 2 configuration.
N * @param[in]   TMx : pointer to a TM_HandleTypeDef
N * @param[in]   OC_Config : The ouput configuration structure
N * @return      None
N * @note
N * @par         Example
N * @code
N    TM_OC2_SetConfig(&mTM->Instance, sConfig);
N * @endcode
N *******************************************************************************
N */
Nstatic void TM_OC2_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config)
N{
N    /* Set the Output Idle state (Break state) */
N    TMx->BS.W &= ~((TM_BS_STP0_STA_mask_w | TM_BS_STP0N_STA_mask_w) << 2);
X    TMx->BS.W &= ~((((uint32_t)0x01000000) | ((uint32_t)0x10000000)) << 2);
N    TMx->BS.W |= ((OC_Config->OCIdleState | OC_Config->OCNIdleState) << 2);
N
N    /* Set the Output Idle state  */
N    TMx->OSCR.W |= ((TM_OSCR_OS0_LCK_un_locked_w | OC_Config->OCIdleState |
X    TMx->OSCR.W |= ((((uint32_t)0x00000010) | OC_Config->OCIdleState |
N                     TM_OSCR_OS0H_LCK_un_locked_w | OC_Config->OCHIdleState) << 2);
X                     ((uint32_t)0x00001000) | OC_Config->OCHIdleState) << 2);
N
N    /* Set the Output Polarity */
N    TMx->OCCR1.W &= ~((TM_OCCR1_OC0_INV_mask_w | TM_OCCR1_OC0H_INV_mask_w | TM_OCCR1_OC0N_INV_mask_w) << 2);
X    TMx->OCCR1.W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000010) | ((uint32_t)0x00000100)) << 2);
N    TMx->OCCR1.W |= ((OC_Config->OCPolarity | OC_Config->OCNPolarity | OC_Config->OCHPolarity) << 2);
N
N    /* Set the Capture Compare Register value */
N    TMx->CC2A.H[0] = TMx->CC2B.H[0] = OC_Config->Pulse;
N
N    // Enable Ouput OC
N    switch(OC_Config->OCMode)
N    {
N    case TM_CH_Disable:
X    case (0x0000U):
N        TMx->OCCR0.W &= ~(TM_OCCR0_OC2_OE_enable_w | TM_OCCR0_OC2N_OE_enable_w);
X        TMx->OCCR0.W &= ~(((uint32_t)0x00000100) | ((uint32_t)0x01000000));
N        break;
N    case TM_CH_16bit_OutputCompare:
X    case (0x0002U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC2_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000100));
N        break;
N    case TM_CH_8bitx2_OutputCompare:
X    case (0x0003U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC2_OE_enable_w | TM_OCCR0_OC2N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000100) | ((uint32_t)0x01000000));
N        break;
N    case TM_CH_16bit_PWM:
X    case (0x0004U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC2_OE_enable_w | TM_OCCR0_OC2N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000100) | ((uint32_t)0x01000000));
N        break;
N    case TM_CH_8bitx2_PWM:
X    case (0x0005U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC2_OE_enable_w | TM_OCCR0_OC2N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000100) | ((uint32_t)0x01000000));
N        break;
N    case TM_CH_16bit_PWM_COMPLEMENT:
X    case (0x0006U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC2_OE_enable_w | TM_OCCR0_OC2N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000100) | ((uint32_t)0x01000000));
N        break;
N    case TM_CH_8bitx2_PWM_COMPLEMENT:
X    case (0x0007U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC2_OE_enable_w | TM_OCCR0_OC2N_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00000100) | ((uint32_t)0x01000000));
N        break;
N
N    default:
N        break;
N
N    }
N
N}
N
N/**
N *******************************************************************************
N * @brief       TMe Ouput Compare 3 configuration.
N * @param[in]   TMx : pointer to a TM_HandleTypeDef
N * @param[in]   OC_Config : The ouput configuration structure
N * @return      None
N * @note
N * @par         Example
N * @code
N    TM_OC3_SetConfig(&mTM->Instance, sConfig);
N * @endcode
N *******************************************************************************
N */
Nstatic void TM_OC3_SetConfig(TM_Struct* TMx, TM_OC_InitTypeDef* OC_Config)
N{
N    /* Set the Output Idle state (Break state) */
N    TMx->BS.W &= ~((TM_BS_STP0_STA_mask_w | TM_BS_STP0N_STA_mask_w) << 3);
X    TMx->BS.W &= ~((((uint32_t)0x01000000) | ((uint32_t)0x10000000)) << 3);
N    TMx->BS.W |= ((OC_Config->OCIdleState | OC_Config->OCNIdleState) << 3);
N
N    /* Set the Output Idle state  */
N    TMx->OSCR.W |= ((TM_OSCR_OS0_LCK_un_locked_w | OC_Config->OCIdleState |
X    TMx->OSCR.W |= ((((uint32_t)0x00000010) | OC_Config->OCIdleState |
N                     TM_OSCR_OS0H_LCK_un_locked_w | OC_Config->OCHIdleState) << 3);
X                     ((uint32_t)0x00001000) | OC_Config->OCHIdleState) << 3);
N
N    /* Set the Output Polarity */
N    TMx->OCCR1.W &= ~((TM_OCCR1_OC0_INV_mask_w | TM_OCCR1_OC0H_INV_mask_w | TM_OCCR1_OC0N_INV_mask_w) << 3);
X    TMx->OCCR1.W &= ~((((uint32_t)0x00000001) | ((uint32_t)0x00000010) | ((uint32_t)0x00000100)) << 3);
N    TMx->OCCR1.W |= ((OC_Config->OCPolarity | OC_Config->OCNPolarity | OC_Config->OCHPolarity) << 3);
N
N    /* Set the Capture Compare Register value */
N    TMx->CC3A.H[0] = TMx->CC3B.H[0] = OC_Config->Pulse;
N
N    // Enable Ouput OC
N    switch(OC_Config->OCMode)
N    {
N    case TM_CH_Disable:
X    case (0x0000U):
N        TMx->OCCR0.W &= ~(TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W &= ~(((uint32_t)0x00001000));
N        break;
N    case TM_CH_16bit_OutputCompare:
X    case (0x0002U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00001000));
N        break;
N    case TM_CH_8bitx2_OutputCompare:
X    case (0x0003U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00001000));
N        break;
N    case TM_CH_16bit_PWM:
X    case (0x0004U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00001000));
N        break;
N    case TM_CH_8bitx2_PWM:
X    case (0x0005U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00001000));
N        break;
N    case TM_CH_16bit_PWM_COMPLEMENT:
X    case (0x0006U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00001000));
N        break;
N    case TM_CH_8bitx2_PWM_COMPLEMENT:
X    case (0x0007U):
N        TMx->OCCR0.W |= (TM_OCCR0_OC3_OE_enable_w);
X        TMx->OCCR0.W |= (((uint32_t)0x00001000));
N        break;
N
N    default:
N        break;
N
N    }
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       Time Slave configuration.
N * @param[in]   mTM : pointer to a TM_HandleTypeDef structure that contains
N *                    the configuration information for TM module.
N * @param[in]   sSlaveConfig: The slave configuration structure
N * @return      MID_StatusTypeDef
N *******************************************************************************
N */
Nstatic void TM_SlaveTimer_SetConfig(TM_HandleTypeDef* mTM, TM_SlaveConfigTypeDef* sSlaveConfig)
N{
N    uint32_t tmp;
N
N    tmp = mTM->Instance->TRG.W;
N
N    if((sSlaveConfig->InputTrigger & TM_TRG_TRG_MUX_mask_w) != TM_TRG_TRG_MUX_itr_w)
X    if((sSlaveConfig->InputTrigger & ((uint32_t)0x000000C0)) != ((uint32_t)0x00000040))
N    {
N        tmp &= ~(TM_TRG_TRG_MUX_mask_w | TM_TRG_TRGI2_MDS_mask_w | TM_TRG_TRGI_MDS_mask_w);
X        tmp &= ~(((uint32_t)0x000000C0) | ((uint32_t)0x00000038) | ((uint32_t)0x00000007));
N
N        tmp |= (sSlaveConfig->InputTrigger & ~TM_TRG_ITR_MUX_mask_w) | \
N               (sSlaveConfig->SlaveMode);
X        tmp |= (sSlaveConfig->InputTrigger & ~((uint32_t)0x00000700)) |                (sSlaveConfig->SlaveMode);
N    }
N    else
N    {
N        tmp &= ~(TM_TRG_ITR_MUX_mask_w | TM_TRG_TRG_MUX_mask_w | TM_TRG_TRGI2_MDS_mask_w | \
N                 TM_TRG_TRGI_MDS_mask_w);
X        tmp &= ~(((uint32_t)0x00000700) | ((uint32_t)0x000000C0) | ((uint32_t)0x00000038) |                  ((uint32_t)0x00000007));
N
N        tmp |= (sSlaveConfig->InputTrigger)                         | \
N               (sSlaveConfig->SlaveMode);
X        tmp |= (sSlaveConfig->InputTrigger)                         |                (sSlaveConfig->SlaveMode);
N    }
N
N    mTM->Instance->TRG.W = tmp;
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       Enables or disables the TM Capture Compare Channel x..
N * @param[in]   TMx : pointer to a TM_Struct
N * @param[in]   Channel : specifies Timer channel selection
N *  @arg\b      MID_TM_Channel0 : Capture/Compare 0 interrupt
N *  @arg\b      MID_TM_Channel1 : Capture/Compare 1 interrupt
N *  @arg\b      MID_TM_Channel2 : Capture/Compare 2 interrupt
N *  @arg\b      MID_TM_Channel3 : Capture/Compare 3 interrupt
N * @param[in]   ChannelMode : specifies Timer channel mode
N *  @arg\b      TM_CH_Disable : Disable channel mode (No operation)
N *  @arg\b      TM_CH_InputCapture : Capture mode
N *  @arg\b      TM_CH_16bit_OutputCompare : 16bit Output Compare mode
N *  @arg\b      TM_CH_8bitx2_OutputCompare : 8bit Output Compare mode
N *  @arg\b      TM_CH_16bit_PWM : 16bit PWM mode
N *  @arg\b      TM_CH_8bitx2_PWM : 8bitx2 PWM mode
N *  @arg\b      TM_CH_16bit_PWM_COMPLEMENT : 16bit PWM mode with complement output
N *  @arg\b      TM_CH_8bitx2_PWM_COMPLEMENT : 8bitx2 PWM mode with complement output
N * @return      None
N * @note
N * @par         Example
N * @code
N    TM_HandleTypeDef mTM;
N
N    TM_CCxChannelCmd(&mTM, MID_TM_Channel3, TM_CH_InputCapture);
N * @endcode
N *******************************************************************************
N */
Nvoid TM_CCxChannelCmd(TM_Struct* TMx, uint32_t Channel, uint32_t ChannelMode)
N{
N    uint32_t tmp = 0U;
N
N    tmp = TM_CCMDS_CC0_MDS_mask_w << (Channel * 4);
X    tmp = ((uint32_t)0x00000007) << (Channel * 4);
N
N    /* Reset the CCxE Bit */
N    TMx->CCMDS.W &= ~tmp;
N
N    /* Set or reset the CCxE Bit */
N    TMx->CCMDS.W |= (uint32_t)(ChannelMode << (Channel * 4));
N
N
N}
N
N
N/**
N *******************************************************************************
N * @brief       Set the dead-time source clock divider. (Only foe TM36)
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   DeadTimeDivider : Timer internal dead time clock divider.
N *  @arg\b      MID_TM_CKDTG_DIV1 : divider by 1
N *  @arg\b      MID_TM_CKDTG_DIV2 : divider by 2
N *  @arg\b      MID_TM_CKDTG_DIV4 : divider by 4
N *  @arg\b      MID_TM_CKDTG_DIV8 : divider by 8
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_OC_SetDeadTimeDivider(&mTM36, MID_TM_CKDTG_DIV1);
N    MID_TM_OC_SetDeadTime(&mTM36, DeadTime_Set);
N * @endcode
N *******************************************************************************
N */
Nvoid MID_TM_OC_SetDeadTimeDivider(TM_HandleTypeDef* mTM,  uint32_t DeadTimeDivider)
N{
N    mTM->Instance->CLK.W &= ~(TM_CLK_DTG_DIV_mask_w);
X    mTM->Instance->CLK.W &= ~(((uint32_t)0x00030000));
N    mTM->Instance->CLK.W |= DeadTimeDivider;
N}
N
N
N
N/**
N *******************************************************************************
N * @brief       Set the dead-time delay. (Only foe TM36)
N * @param[in]   mTM : pointer to a TM_HandleTypeDef
N * @param[in]   DeadTime : DeadTime between Min_Data=0 to Max_Data=255
N * @return      MID_StatusTypeDef
N * @note
N * @par         Example
N * @code
N    MID_TM_OC_SetDeadTimeDivider(&mTM36, MID_TM_CKDTG_DIV1);
N    MID_TM_OC_SetDeadTime(&mTM36, DeadTime_Set);
N * @endcode
N *******************************************************************************
N */
Nvoid MID_TM_OC_SetDeadTime(TM_HandleTypeDef* mTM,  uint32_t DeadTime)
N{
N    mTM->Instance->PWM.W &= ~(TM_PWM_DTG_DY_mask_w);
X    mTM->Instance->PWM.W &= ~(((uint32_t)0x0000FF00));
N    mTM->Instance->PWM.W |= (DeadTime << 8);
N}
N
N///@}
N
N
