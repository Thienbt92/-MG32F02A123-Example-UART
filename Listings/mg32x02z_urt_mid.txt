; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_urt_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_urt_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_urt_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_URT_MID.c]
                          THUMB

                          AREA ||i.MID_URT_Abort||, CODE, READONLY, ALIGN=1

                  MID_URT_Abort PROC
;;;1219    */
;;;1220   MID_StatusTypeDef MID_URT_Abort( URT_HandleTypeDef *MURT)
000000  b510              PUSH     {r4,lr}
;;;1221   {
000002  4604              MOV      r4,r0
;;;1222       //===============================================================
;;;1223       //Disable interrupt: (TX , TC, RX, PE, ERR  interrupts
;;;1224       CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_TX | URT_IT_TC | URT_IT_RX | URT_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  21cc              MOVS     r1,#0xcc
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;1225       
;;;1226       //===============================================================
;;;1227       //Disable the UART DMA TX request if enable.
;;;1228       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  0fc0              LSRS     r0,r0,#31
000016  07c0              LSLS     r0,r0,#31
000018  2800              CMP      r0,#0
00001a  d00e              BEQ      |L1.58|
;;;1229       {
;;;1230           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
00001c  6820              LDR      r0,[r4,#0]
00001e  6900              LDR      r0,[r0,#0x10]
000020  0040              LSLS     r0,r0,#1
000022  0840              LSRS     r0,r0,#1
000024  6821              LDR      r1,[r4,#0]
000026  6108              STR      r0,[r1,#0x10]
;;;1231           //-----------------------------------------------------------
;;;1232           //Abort the URT DMA TX channel
;;;1233           if( MURT->mDMA_TX != NULL)
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  2800              CMP      r0,#0
00002c  d005              BEQ      |L1.58|
;;;1234           {
;;;1235               //-----------------------------------------------------------
;;;1236               //Set the UART DMA Abort callback to Null.
;;;1237               //No call back execution at end of DMA abort procedure
;;;1238               MURT->mDMA_TX->XferAbortCallback = NULL;
00002e  2000              MOVS     r0,#0
000030  6ba1              LDR      r1,[r4,#0x38]
000032  6388              STR      r0,[r1,#0x38]
;;;1239               
;;;1240               MID_DMA_Abort(MURT->mDMA_TX);
000034  6ba0              LDR      r0,[r4,#0x38]
000036  f7fffffe          BL       MID_DMA_Abort
                  |L1.58|
;;;1241           }
;;;1242       }
;;;1243       //===============================================================
;;;1244       //Disable the UART DMA RX request if enable.
;;;1245       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
00003a  6820              LDR      r0,[r4,#0]
00003c  6900              LDR      r0,[r0,#0x10]
00003e  2101              MOVS     r1,#1
000040  0789              LSLS     r1,r1,#30
000042  4008              ANDS     r0,r0,r1
000044  2800              CMP      r0,#0
000046  d00d              BEQ      |L1.100|
;;;1246       {
;;;1247           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
000048  6820              LDR      r0,[r4,#0]
00004a  6900              LDR      r0,[r0,#0x10]
00004c  4388              BICS     r0,r0,r1
00004e  6821              LDR      r1,[r4,#0]
000050  6108              STR      r0,[r1,#0x10]
;;;1248           //-----------------------------------------------------------
;;;1249           //Abort the UART DMA Rx channel 
;;;1250           if( MURT->mDMA_RX != NULL)
000052  6be0              LDR      r0,[r4,#0x3c]
000054  2800              CMP      r0,#0
000056  d005              BEQ      |L1.100|
;;;1251           {
;;;1252               //-----------------------------------------------------------
;;;1253               //Set the UART DMA Abort callback to Null.
;;;1254               //No call back execution at end of DMA abort procedure
;;;1255               MURT->mDMA_RX->XferAbortCallback = NULL;
000058  2000              MOVS     r0,#0
00005a  6be1              LDR      r1,[r4,#0x3c]
00005c  6388              STR      r0,[r1,#0x38]
;;;1256               
;;;1257               MID_DMA_Abort(MURT->mDMA_RX);
00005e  6be0              LDR      r0,[r4,#0x3c]
000060  f7fffffe          BL       MID_DMA_Abort
                  |L1.100|
;;;1258           }
;;;1259       }
;;;1260       //===============================================================
;;;1261       //Reset Tx and Rx transfer counters.
;;;1262       MURT->TxTransferCount = 0;
000064  2000              MOVS     r0,#0
000066  85e0              STRH     r0,[r4,#0x2e]
;;;1263       MURT->RxTransferCount = 0;
000068  86e0              STRH     r0,[r4,#0x36]
;;;1264       
;;;1265       //===============================================================
;;;1266       //Clear the error flags ( ROVR , NCE , PE , FE)
;;;1267       __DRV_URT_CLEAR_FLAG( MURT, (URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
00006a  200f              MOVS     r0,#0xf
00006c  0500              LSLS     r0,r0,#20
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
;;;1268       
;;;1269       //===============================================================
;;;1270       //Restore RxState & gState to Ready.
;;;1271       MURT->gState  = MID_URT_STATE_READY;
000072  2120              MOVS     r1,#0x20
000074  2041              MOVS     r0,#0x41
000076  5501              STRB     r1,[r0,r4]
;;;1272       MURT->RxState = MID_URT_STATE_READY;
000078  2042              MOVS     r0,#0x42
00007a  5501              STRB     r1,[r0,r4]
;;;1273       
;;;1274       //===============================================================
;;;1275       //Reset Handle ErrorCode to No Error
;;;1276       MURT->ErrorCode = MID_URT_ERROR_NONE;
00007c  2000              MOVS     r0,#0
00007e  6460              STR      r0,[r4,#0x44]
;;;1277       
;;;1278       
;;;1279       return( MID_OK);
;;;1280   }
000080  bd10              POP      {r4,pc}
;;;1281   
                          ENDP


                          AREA ||i.MID_URT_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_AbortCpltCallback PROC
;;;1965    */
;;;1966   __WEAK void MID_URT_AbortCpltCallback( URT_HandleTypeDef *MURT)
000000  4770              BX       lr
;;;1967   {           
;;;1968       //=========================================================
;;;1969       //Prevent unusesd argument compilation warning.
;;;1970       UNUSED(MURT);
;;;1971       
;;;1972       //=========================================================
;;;1973       //NOTE : This function should not be modified, when the
;;;1974       //       callback is needed, the MID_URT_AbortCpltCallback
;;;1975       //       can be implemented in user file.
;;;1976       
;;;1977   }
;;;1978   
                          ENDP


                          AREA ||i.MID_URT_AbortReceive||, CODE, READONLY, ALIGN=2

                  MID_URT_AbortReceive PROC
;;;1350    */
;;;1351   MID_StatusTypeDef MID_URT_AbortReceive( URT_HandleTypeDef * MURT)
000000  b510              PUSH     {r4,lr}
;;;1352   {
000002  4604              MOV      r4,r0
;;;1353       //===============================================================
;;;1354       //Disable  ERR (PE , FE , NE , ROV) , RX interrupt
;;;1355       CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_RX | URT_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2148              MOVS     r1,#0x48
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;1356   
;;;1357       //===============================================================
;;;1358       //Disable the UART DMA Rx request if enabled.
;;;1359       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  2101              MOVS     r1,#1
000016  0789              LSLS     r1,r1,#30
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d00d              BEQ      |L3.58|
;;;1360       {
;;;1361           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
00001e  6820              LDR      r0,[r4,#0]
000020  6900              LDR      r0,[r0,#0x10]
000022  4388              BICS     r0,r0,r1
000024  6821              LDR      r1,[r4,#0]
000026  6108              STR      r0,[r1,#0x10]
;;;1362           
;;;1363           //-----------------------------------------------------------
;;;1364           //Abort the UART DMA Rx channel
;;;1365           if( MURT->mDMA_RX != NULL)
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  2800              CMP      r0,#0
00002c  d005              BEQ      |L3.58|
;;;1366           {
;;;1367               //-----------------------------------------------------------
;;;1368               //Set the UART DMA Abort callback to Null.
;;;1369               //No call back execution at end of DMA abort procedure
;;;1370               MURT->mDMA_RX->XferAbortCallback = NULL;
00002e  2000              MOVS     r0,#0
000030  6be1              LDR      r1,[r4,#0x3c]
000032  6388              STR      r0,[r1,#0x38]
;;;1371               
;;;1372               MID_DMA_Abort( MURT->mDMA_RX);
000034  6be0              LDR      r0,[r4,#0x3c]
000036  f7fffffe          BL       MID_DMA_Abort
                  |L3.58|
;;;1373           }
;;;1374       }
;;;1375       
;;;1376       //===============================================================
;;;1377       //Reset Rx transfer counter.
;;;1378       MURT->RxTransferCount = 0U;
00003a  2000              MOVS     r0,#0
00003c  86e0              STRH     r0,[r4,#0x36]
;;;1379       
;;;1380       //===============================================================
;;;1381       //Clear the Error flags.
;;;1382       __DRV_URT_CLEAR_FLAG( MURT , (URT_IT_ROVR | URT_IT_NCE | URT_IT_FE | URT_IT_PE | URT_IT_ERR));
00003e  4804              LDR      r0,|L3.80|
000040  6821              LDR      r1,[r4,#0]
000042  6008              STR      r0,[r1,#0]
;;;1383       
;;;1384       //===============================================================
;;;1385       //Reset RxState to Ready.
;;;1386       MURT->RxState = MID_URT_STATE_READY;
000044  2120              MOVS     r1,#0x20
000046  2042              MOVS     r0,#0x42
000048  5501              STRB     r1,[r0,r4]
;;;1387       
;;;1388       
;;;1389       return( MID_OK);
00004a  2000              MOVS     r0,#0
;;;1390   }
00004c  bd10              POP      {r4,pc}
;;;1391   
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0x00f00008

                          AREA ||i.MID_URT_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_AbortReceiveCpltCallback PROC
;;;2011    */
;;;2012   __WEAK void MID_URT_AbortReceiveCpltCallback( URT_HandleTypeDef* MURT)
000000  4770              BX       lr
;;;2013   {
;;;2014       //=========================================================
;;;2015       //Prevent unused argument compilcation warning
;;;2016       UNUSED(MURT);
;;;2017       
;;;2018       //=========================================================
;;;2019       //Note : This function should not be modified, when th callback
;;;2020       //       is needed, the MID_URT_AbortReceiveCpltCallback can
;;;2021       //       be implemented in the user file.
;;;2022       
;;;2023   }
;;;2024   
                          ENDP


                          AREA ||i.MID_URT_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  MID_URT_AbortReceive_IT PROC
;;;1639    */
;;;1640   MID_StatusTypeDef MID_URT_AbortReceive_IT( URT_HandleTypeDef *MURT)
000000  b510              PUSH     {r4,lr}
;;;1641   {
000002  4604              MOV      r4,r0
;;;1642       //===============================================================
;;;1643       //Disable ERR (Frame error , noise error , overrun error) interrupt.
;;;1644       CLEAR_BIT( MURT->Instance->INT.W , ( URT_IT_RX | URT_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2148              MOVS     r1,#0x48
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;1645       
;;;1646       //===============================================================
;;;1647       //Disable the URT DMA Rx request if enabled.
;;;1648       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  2101              MOVS     r1,#1
000016  0789              LSLS     r1,r1,#30
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d020              BEQ      |L5.96|
;;;1649       {
;;;1650           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
00001e  6820              LDR      r0,[r4,#0]
000020  6900              LDR      r0,[r0,#0x10]
000022  4388              BICS     r0,r0,r1
000024  6821              LDR      r1,[r4,#0]
000026  6108              STR      r0,[r1,#0x10]
;;;1651           
;;;1652           //-----------------------------------------------------------
;;;1653           //Abort the UART DMA Rx channel : use non blocking DMA
;;;1654           //abort callback
;;;1655           if(MURT->mDMA_RX != NULL)
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  2800              CMP      r0,#0
00002c  d00b              BEQ      |L5.70|
;;;1656           {
;;;1657               //-----------------------------------------------------------
;;;1658               //Set the UART DMA abort callback : 
;;;1659               //    will lead to call MID_URT_AbortCpltCallback() at end of DMA
;;;1660               //    abort procedure.
;;;1661               MURT->mDMA_RX->XferAbortCallback = ifun_URT_DMARxOnlyAbortCallback;
00002e  4813              LDR      r0,|L5.124|
000030  6be1              LDR      r1,[r4,#0x3c]
000032  6388              STR      r0,[r1,#0x38]
;;;1662               
;;;1663               //-----------------------------------------------------------
;;;1664               //Abort DMA RX
;;;1665               if(MID_DMA_Abort_IT(MURT->mDMA_RX) != MID_OK)
000034  6be0              LDR      r0,[r4,#0x3c]
000036  f7fffffe          BL       MID_DMA_Abort_IT
00003a  2800              CMP      r0,#0
00003c  d01c              BEQ      |L5.120|
;;;1666               {
;;;1667                   //-----------------------------------------------------------
;;;1668                   //Call directly MURT->mDMA_RX->XferAbortCallback
;;;1669                   //function in case of error.
;;;1670                   MURT->mDMA_RX->XferAbortCallback( MURT->mDMA_RX);
00003e  6be0              LDR      r0,[r4,#0x3c]
000040  6b81              LDR      r1,[r0,#0x38]
000042  4788              BLX      r1
000044  e018              B        |L5.120|
                  |L5.70|
;;;1671               }
;;;1672           }
;;;1673           else
;;;1674           {
;;;1675               //-----------------------------------------------------------
;;;1676               //Reset Rx transfer counter
;;;1677               MURT->RxTransferCount = 0;
000046  2000              MOVS     r0,#0
000048  86e0              STRH     r0,[r4,#0x36]
;;;1678               //-----------------------------------------------------------
;;;1679               //Clear the Error flags 
;;;1680               __DRV_URT_CLEAR_FLAG( MURT , ( URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
00004a  200f              MOVS     r0,#0xf
00004c  0500              LSLS     r0,r0,#20
00004e  6821              LDR      r1,[r4,#0]
000050  6008              STR      r0,[r1,#0]
;;;1681               
;;;1682               
;;;1683               //-----------------------------------------------------------
;;;1684               //Restore RxState to Ready.
;;;1685               MURT->RxState = MID_URT_STATE_READY;
000052  2120              MOVS     r1,#0x20
000054  2042              MOVS     r0,#0x42
000056  5501              STRB     r1,[r0,r4]
;;;1686               //-----------------------------------------------------------
;;;1687               //As no DMA to be aborted, call directly user abort complete
;;;1688               //callback.
;;;1689               MID_URT_AbortReceiveCpltCallback( MURT);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       MID_URT_AbortReceiveCpltCallback
00005e  e00b              B        |L5.120|
                  |L5.96|
;;;1690           }            
;;;1691       }
;;;1692       else
;;;1693       {
;;;1694           //===============================================================
;;;1695           //Reset Rx transfer counter
;;;1696           MURT->RxTransferCount = 0;
000060  2000              MOVS     r0,#0
000062  86e0              STRH     r0,[r4,#0x36]
;;;1697           //===============================================================
;;;1698           //Clear the error flags 
;;;1699           __DRV_URT_CLEAR_FLAG( MURT , (URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
000064  200f              MOVS     r0,#0xf
000066  0500              LSLS     r0,r0,#20
000068  6821              LDR      r1,[r4,#0]
00006a  6008              STR      r0,[r1,#0]
;;;1700           
;;;1701           //===============================================================
;;;1702           //Restore RxState to Ready
;;;1703           MURT->RxState = MID_URT_STATE_READY;
00006c  2120              MOVS     r1,#0x20
00006e  2042              MOVS     r0,#0x42
000070  5501              STRB     r1,[r0,r4]
;;;1704           //===============================================================
;;;1705           //As no DMA to be aborted , call directly user abort complete
;;;1706           //callback.
;;;1707           MID_URT_AbortReceiveCpltCallback(MURT);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       MID_URT_AbortReceiveCpltCallback
                  |L5.120|
;;;1708       }
;;;1709       return( MID_OK);
000078  2000              MOVS     r0,#0
;;;1710   }
00007a  bd10              POP      {r4,pc}
;;;1711   /**
                          ENDP

                  |L5.124|
                          DCD      ifun_URT_DMARxOnlyAbortCallback

                          AREA ||i.MID_URT_AbortTransmit||, CODE, READONLY, ALIGN=1

                  MID_URT_AbortTransmit PROC
;;;1297    */
;;;1298   MID_StatusTypeDef MID_URT_AbortTransmit( URT_HandleTypeDef *MURT)
000000  b510              PUSH     {r4,lr}
;;;1299   {
000002  4604              MOV      r4,r0
;;;1300       //===============================================================
;;;1301       //Disable TC and TX interrupt
;;;1302       CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_TC | URT_IT_TX));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2184              MOVS     r1,#0x84
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;1303       
;;;1304       //===============================================================
;;;1305       //Disable the URT DMA Tx request if enabled
;;;1306       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  0fc0              LSRS     r0,r0,#31
000016  07c0              LSLS     r0,r0,#31
000018  2800              CMP      r0,#0
00001a  d00e              BEQ      |L6.58|
;;;1307       {
;;;1308           CLEAR_BIT( MURT->Instance->CR3.W , URT_CR0_DMA_TXEN_mask_w);
00001c  6820              LDR      r0,[r4,#0]
00001e  69c0              LDR      r0,[r0,#0x1c]
000020  0040              LSLS     r0,r0,#1
000022  0840              LSRS     r0,r0,#1
000024  6821              LDR      r1,[r4,#0]
000026  61c8              STR      r0,[r1,#0x1c]
;;;1309           
;;;1310           //-----------------------------------------------------------
;;;1311           //Abort the UART DMA TX channel
;;;1312           if( MURT->mDMA_TX != NULL)
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  2800              CMP      r0,#0
00002c  d005              BEQ      |L6.58|
;;;1313           {
;;;1314               //-----------------------------------------------------------
;;;1315               //Set the URT DMA Abort callback to Null.
;;;1316               //No call back execution at end of DMA abort procedure.
;;;1317               MURT->mDMA_TX->XferAbortCallback = NULL;
00002e  2000              MOVS     r0,#0
000030  6ba1              LDR      r1,[r4,#0x38]
000032  6388              STR      r0,[r1,#0x38]
;;;1318               
;;;1319               MID_DMA_Abort(MURT->mDMA_TX);
000034  6ba0              LDR      r0,[r4,#0x38]
000036  f7fffffe          BL       MID_DMA_Abort
                  |L6.58|
;;;1320           }
;;;1321       }
;;;1322       
;;;1323       //===============================================================
;;;1324       //Reset TX transfer counter.
;;;1325       MURT->TxTransferCount = 0U;
00003a  2000              MOVS     r0,#0
00003c  85e0              STRH     r0,[r4,#0x2e]
;;;1326       
;;;1327       //===============================================================
;;;1328       //Restore gState to READY.
;;;1329       MURT->gState = MID_URT_STATE_READY;
00003e  2120              MOVS     r1,#0x20
000040  2041              MOVS     r0,#0x41
000042  5501              STRB     r1,[r0,r4]
;;;1330       
;;;1331       
;;;1332       return( MID_OK);
000044  2000              MOVS     r0,#0
;;;1333   }
000046  bd10              POP      {r4,pc}
;;;1334   
                          ENDP


                          AREA ||i.MID_URT_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_AbortTransmitCpltCallback PROC
;;;1988    */
;;;1989   __WEAK void MID_URT_AbortTransmitCpltCallback( URT_HandleTypeDef* MURT)
000000  4770              BX       lr
;;;1990   {
;;;1991       //=========================================================
;;;1992       //Prevent unused argument compilation warning.
;;;1993       UNUSED(MURT);
;;;1994       
;;;1995       //=========================================================
;;;1996       //Note : This function should not be modified, when the callback 
;;;1997       //       is needed, the MID_URT_AbortTransmitCpltCallback can 
;;;1998       //       be implemented in the user file.
;;;1999       
;;;2000   }
;;;2001   
                          ENDP


                          AREA ||i.MID_URT_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  MID_URT_AbortTransmit_IT PROC
;;;1560    */
;;;1561   MID_StatusTypeDef MID_URT_AbortTransmit_IT( URT_HandleTypeDef *MURT)
000000  b510              PUSH     {r4,lr}
;;;1562   {
000002  4604              MOV      r4,r0
;;;1563       //===============================================================
;;;1564       //Disable interrupts
;;;1565       CLEAR_BIT(MURT->Instance->INT.W , ( URT_IT_TC | URT_IT_TX));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2184              MOVS     r1,#0x84
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;1566       //===============================================================
;;;1567       //Disable the UART DMA Tx request if enabled
;;;1568       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  0fc0              LSRS     r0,r0,#31
000016  07c0              LSLS     r0,r0,#31
000018  2800              CMP      r0,#0
00001a  d01d              BEQ      |L8.88|
;;;1569       {
;;;1570           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
00001c  6820              LDR      r0,[r4,#0]
00001e  6900              LDR      r0,[r0,#0x10]
000020  0040              LSLS     r0,r0,#1
000022  0840              LSRS     r0,r0,#1
000024  6821              LDR      r1,[r4,#0]
000026  6108              STR      r0,[r1,#0x10]
;;;1571           //-----------------------------------------------------------
;;;1572           if(MURT->mDMA_TX != NULL)
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  2800              CMP      r0,#0
00002c  d00b              BEQ      |L8.70|
;;;1573           {
;;;1574               //-----------------------------------------------------------
;;;1575               //Set the UART DMA Abort callback:
;;;1576               //    will lead to call MID_URT_AbortCpltCallback() at end
;;;1577               //    of DMA abort procedure.
;;;1578               MURT->mDMA_TX->XferAbortCallback = ifun_URT_DMATxOnlyAbortCallback;
00002e  480f              LDR      r0,|L8.108|
000030  6ba1              LDR      r1,[r4,#0x38]
000032  6388              STR      r0,[r1,#0x38]
;;;1579               
;;;1580               //-----------------------------------------------------------
;;;1581               //Abort DMA TX
;;;1582               if( MID_DMA_Abort_IT( MURT->mDMA_TX) != MID_OK)
000034  6ba0              LDR      r0,[r4,#0x38]
000036  f7fffffe          BL       MID_DMA_Abort_IT
00003a  2800              CMP      r0,#0
00003c  d014              BEQ      |L8.104|
;;;1583               {
;;;1584                   //-----------------------------------------------------------
;;;1585                   //Call Directly MURT->mDMA_TX->XferAbortCallback function
;;;1586                   //in case of error.
;;;1587                   MURT->mDMA_TX->XferAbortCallback( MURT->mDMA_TX);
00003e  6ba0              LDR      r0,[r4,#0x38]
000040  6b81              LDR      r1,[r0,#0x38]
000042  4788              BLX      r1
000044  e010              B        |L8.104|
                  |L8.70|
;;;1588               }
;;;1589           }
;;;1590           else
;;;1591           {
;;;1592               //-----------------------------------------------------------
;;;1593               //Reset TX transfer counter.
;;;1594               MURT->TxTransferCount = 0;
000046  2000              MOVS     r0,#0
000048  85e0              STRH     r0,[r4,#0x2e]
;;;1595               
;;;1596               //-----------------------------------------------------------
;;;1597               //Restore gStatus to Ready.
;;;1598               MURT->gState = MID_URT_STATE_READY;
00004a  2120              MOVS     r1,#0x20
00004c  2041              MOVS     r0,#0x41
00004e  5501              STRB     r1,[r0,r4]
;;;1599               
;;;1600               //-----------------------------------------------------------
;;;1601               //As no DMA to be aborted , call directly user abort complete
;;;1602               //callback.
;;;1603               MID_URT_AbortTransmitCpltCallback(MURT);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       MID_URT_AbortTransmitCpltCallback
000056  e007              B        |L8.104|
                  |L8.88|
;;;1604           }
;;;1605       }
;;;1606       else
;;;1607       {
;;;1608           //===============================================================
;;;1609           //Reset Tx transfer counter
;;;1610           MURT->TxTransferCount = 0;
000058  2000              MOVS     r0,#0
00005a  85e0              STRH     r0,[r4,#0x2e]
;;;1611           //===============================================================
;;;1612           //Restore gState to ready
;;;1613           MURT->gState = MID_URT_STATE_READY;
00005c  2120              MOVS     r1,#0x20
00005e  2041              MOVS     r0,#0x41
000060  5501              STRB     r1,[r0,r4]
;;;1614           //===============================================================
;;;1615           //As no DMA to be aborted, call directly user abort complete callback
;;;1616           MID_URT_AbortTransmitCpltCallback(MURT);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       MID_URT_AbortTransmitCpltCallback
                  |L8.104|
;;;1617       }
;;;1618       return( MID_OK);
000068  2000              MOVS     r0,#0
;;;1619   }
00006a  bd10              POP      {r4,pc}
;;;1620   /**
                          ENDP

                  |L8.108|
                          DCD      ifun_URT_DMATxOnlyAbortCallback

                          AREA ||i.MID_URT_Abort_IT||, CODE, READONLY, ALIGN=2

                  MID_URT_Abort_IT PROC
;;;1409    */
;;;1410   MID_StatusTypeDef MID_URT_Abort_IT( URT_HandleTypeDef *MURT)
000000  b570              PUSH     {r4-r6,lr}
;;;1411   {
000002  4604              MOV      r4,r0
;;;1412       BitAction Abortcplt = SET;
000004  2501              MOVS     r5,#1
;;;1413       
;;;1414       //===============================================================
;;;1415       //Disable interrupts
;;;1416       CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_TC | URT_IT_RX | URT_IT_TX | URT_IT_ERR));
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  21cc              MOVS     r1,#0xcc
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6048              STR      r0,[r1,#4]
;;;1417       
;;;1418       //===============================================================
;;;1419       //If DMA Tx and / or DMA Rx handles are associated to URT handle,
;;;1420       //DMA abort complete callbacks should be initialised before any
;;;1421       //call to DMA abort functions
;;;1422       
;;;1423       //-----------------------------------------------------------
;;;1424       //DMA TX Handle is valid
;;;1425       if(MURT->mDMA_TX != NULL)
000012  6ba0              LDR      r0,[r4,#0x38]
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L9.50|
;;;1426       {
;;;1427           //-----------------------------------------------------------
;;;1428           //Set DMA abort complete callback if UART DMA Tx request if
;;;1429           //enabled. Otherwise , set it to NULL
;;;1430           if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
000018  6820              LDR      r0,[r4,#0]
00001a  6900              LDR      r0,[r0,#0x10]
00001c  0fc0              LSRS     r0,r0,#31
00001e  07c0              LSLS     r0,r0,#31
000020  2800              CMP      r0,#0
000022  d003              BEQ      |L9.44|
;;;1431           {
;;;1432               MURT->mDMA_TX->XferAbortCallback = ifun_URT_DMATxAbortCallback;
000024  482f              LDR      r0,|L9.228|
000026  6ba1              LDR      r1,[r4,#0x38]
000028  6388              STR      r0,[r1,#0x38]
00002a  e002              B        |L9.50|
                  |L9.44|
;;;1433           }
;;;1434           else
;;;1435           {
;;;1436               MURT->mDMA_TX->XferAbortCallback = NULL;
00002c  2000              MOVS     r0,#0
00002e  6ba1              LDR      r1,[r4,#0x38]
000030  6388              STR      r0,[r1,#0x38]
                  |L9.50|
;;;1437           }
;;;1438       }
;;;1439       //-----------------------------------------------------------
;;;1440       //DMA RX Handle is valid
;;;1441       if( MURT->mDMA_RX != NULL)
000032  6be0              LDR      r0,[r4,#0x3c]
000034  2800              CMP      r0,#0
000036  d00d              BEQ      |L9.84|
;;;1442       {
;;;1443           //-----------------------------------------------------------
;;;1444           //Set DMA Abort Complete callback if UART DMA RX request if 
;;;1445           //enable. otherwise, set it to NULL.
;;;1446           if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
000038  6820              LDR      r0,[r4,#0]
00003a  6900              LDR      r0,[r0,#0x10]
00003c  2101              MOVS     r1,#1
00003e  0789              LSLS     r1,r1,#30
000040  4008              ANDS     r0,r0,r1
000042  2800              CMP      r0,#0
000044  d003              BEQ      |L9.78|
;;;1447           {
;;;1448               MURT->mDMA_RX->XferAbortCallback = ifun_URT_DMARxAbortCallback;
000046  4828              LDR      r0,|L9.232|
000048  6be1              LDR      r1,[r4,#0x3c]
00004a  6388              STR      r0,[r1,#0x38]
00004c  e002              B        |L9.84|
                  |L9.78|
;;;1449           }
;;;1450           else
;;;1451           {
;;;1452               MURT->mDMA_RX->XferAbortCallback = NULL;
00004e  2000              MOVS     r0,#0
000050  6be1              LDR      r1,[r4,#0x3c]
000052  6388              STR      r0,[r1,#0x38]
                  |L9.84|
;;;1453           }
;;;1454       }
;;;1455       
;;;1456       //===============================================================
;;;1457       // Disable the URT DMA Tx request if enabled 
;;;1458       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
000054  6820              LDR      r0,[r4,#0]
000056  6900              LDR      r0,[r0,#0x10]
000058  0fc0              LSRS     r0,r0,#31
00005a  07c0              LSLS     r0,r0,#31
00005c  2800              CMP      r0,#0
00005e  d012              BEQ      |L9.134|
;;;1459       {
;;;1460           //-----------------------------------------------------------
;;;1461           //Disable DMA Tx at URT level
;;;1462           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
000060  6820              LDR      r0,[r4,#0]
000062  6900              LDR      r0,[r0,#0x10]
000064  0040              LSLS     r0,r0,#1
000066  0840              LSRS     r0,r0,#1
000068  6821              LDR      r1,[r4,#0]
00006a  6108              STR      r0,[r1,#0x10]
;;;1463           
;;;1464           //----------------------------------------------------------
;;;1465           //Abort the UART DMA Tx channel : use non blocking DMA Abort
;;;1466           //callback
;;;1467           if(MURT->mDMA_TX != NULL)
00006c  6ba0              LDR      r0,[r4,#0x38]
00006e  2800              CMP      r0,#0
000070  d009              BEQ      |L9.134|
;;;1468           {
;;;1469               //-----------------------------------------------------------
;;;1470               //UART Tx DMA Abort callback has already been initialised:
;;;1471               //    will lead to call MID_URT_AbortCpltCallback() at 
;;;1472               //    end of DMA abort procedure.
;;;1473               if( MID_DMA_Abort_IT(MURT->mDMA_TX) != MID_OK)
000072  6ba0              LDR      r0,[r4,#0x38]
000074  f7fffffe          BL       MID_DMA_Abort_IT
000078  2800              CMP      r0,#0
00007a  d003              BEQ      |L9.132|
;;;1474               {
;;;1475                   MURT->mDMA_TX->XferAbortCallback = NULL;
00007c  2000              MOVS     r0,#0
00007e  6ba1              LDR      r1,[r4,#0x38]
000080  6388              STR      r0,[r1,#0x38]
000082  e000              B        |L9.134|
                  |L9.132|
;;;1476               }
;;;1477               else
;;;1478               {
;;;1479                   Abortcplt = CLR;    
000084  2500              MOVS     r5,#0
                  |L9.134|
;;;1480               }
;;;1481           }
;;;1482       }
;;;1483       
;;;1484       //===============================================================
;;;1485       // Disable the URT DMA Rx request if enabled
;;;1486       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
000086  6820              LDR      r0,[r4,#0]
000088  6900              LDR      r0,[r0,#0x10]
00008a  2101              MOVS     r1,#1
00008c  0789              LSLS     r1,r1,#30
00008e  4008              ANDS     r0,r0,r1
000090  2800              CMP      r0,#0
000092  d012              BEQ      |L9.186|
;;;1487       {
;;;1488           //-----------------------------------------------------------
;;;1489           //Disable DMA RX at UART level
;;;1490           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
000094  6820              LDR      r0,[r4,#0]
000096  6900              LDR      r0,[r0,#0x10]
000098  4388              BICS     r0,r0,r1
00009a  6821              LDR      r1,[r4,#0]
00009c  6108              STR      r0,[r1,#0x10]
;;;1491           
;;;1492           //-----------------------------------------------------------
;;;1493           //Abort the URT DMA Rx channel : use non blocking DMA Abort callback.
;;;1494           if( MURT->mDMA_RX != NULL)
00009e  6be0              LDR      r0,[r4,#0x3c]
0000a0  2800              CMP      r0,#0
0000a2  d00a              BEQ      |L9.186|
;;;1495           {
;;;1496               //-----------------------------------------------------------
;;;1497               //UART Rx DMA Abort callback has already been initialised:
;;;1498               //    will lead to call MID_URT_AbortCpltCallback() at end
;;;1499               //    of DMA abort procedure.
;;;1500               if( MID_DMA_Abort_IT(MURT->mDMA_RX) != MID_OK)
0000a4  6be0              LDR      r0,[r4,#0x3c]
0000a6  f7fffffe          BL       MID_DMA_Abort_IT
0000aa  2800              CMP      r0,#0
0000ac  d004              BEQ      |L9.184|
;;;1501               {
;;;1502                   MURT->mDMA_RX->XferAbortCallback = NULL;
0000ae  2000              MOVS     r0,#0
0000b0  6be1              LDR      r1,[r4,#0x3c]
0000b2  6388              STR      r0,[r1,#0x38]
;;;1503                   Abortcplt = SET;
0000b4  2501              MOVS     r5,#1
0000b6  e000              B        |L9.186|
                  |L9.184|
;;;1504               }
;;;1505               else
;;;1506               {
;;;1507                   Abortcplt = CLR;
0000b8  2500              MOVS     r5,#0
                  |L9.186|
;;;1508               }
;;;1509           }
;;;1510       }
;;;1511       
;;;1512       //===============================================================
;;;1513       //If no DMA abort complete callback execution is required -> 
;;;1514       //call user abort complete callback.
;;;1515       if(Abortcplt == SET)
0000ba  2d01              CMP      r5,#1
0000bc  d10f              BNE      |L9.222|
;;;1516       {
;;;1517           //-----------------------------------------------------------
;;;1518           //Reset Tx and Rx transfer counters
;;;1519           MURT->TxTransferCount = 0;
0000be  2000              MOVS     r0,#0
0000c0  85e0              STRH     r0,[r4,#0x2e]
;;;1520           MURT->RxTransferCount = 0;
0000c2  86e0              STRH     r0,[r4,#0x36]
;;;1521           
;;;1522           //-----------------------------------------------------------
;;;1523           //Reset errorCode
;;;1524           MURT->ErrorCode = MID_URT_ERROR_NONE;;
0000c4  6460              STR      r0,[r4,#0x44]
;;;1525           
;;;1526           //-----------------------------------------------------------
;;;1527           //Clear the error flags 
;;;1528           __DRV_URT_CLEAR_FLAG( MURT , (URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
0000c6  200f              MOVS     r0,#0xf
0000c8  0500              LSLS     r0,r0,#20
0000ca  6821              LDR      r1,[r4,#0]
0000cc  6008              STR      r0,[r1,#0]
;;;1529           
;;;1530           //-----------------------------------------------------------
;;;1531           //Restore gState and RxState to READY.
;;;1532           MURT->gState  = MID_URT_STATE_READY;
0000ce  2120              MOVS     r1,#0x20
0000d0  2041              MOVS     r0,#0x41
0000d2  5501              STRB     r1,[r0,r4]
;;;1533           MURT->RxState = MID_URT_STATE_READY;
0000d4  2042              MOVS     r0,#0x42
0000d6  5501              STRB     r1,[r0,r4]
;;;1534   
;;;1535           //-----------------------------------------------------------
;;;1536           //As no DMA to be aborted, call directly user Abort 
;;;1537           //complete callback.
;;;1538           MID_URT_AbortCpltCallback(MURT);
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       MID_URT_AbortCpltCallback
                  |L9.222|
;;;1539       }
;;;1540       
;;;1541       return(MID_OK);
0000de  2000              MOVS     r0,#0
;;;1542   }
0000e0  bd70              POP      {r4-r6,pc}
;;;1543   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L9.228|
                          DCD      ifun_URT_DMATxAbortCallback
                  |L9.232|
                          DCD      ifun_URT_DMARxAbortCallback

                          AREA ||i.MID_URT_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  MID_URT_AdvFeatureConfig PROC
;;;2250    */
;;;2251   void MID_URT_AdvFeatureConfig(URT_HandleTypeDef* MURT)
000000  7e01              LDRB     r1,[r0,#0x18]
;;;2252   {
;;;2253       //===========================================================
;;;2254       //* If required , Configure
;;;2255       //    * Set TX signal invert according to MURT->AdvancedInit.TxPinLevelInvert value.
;;;2256       //    * Set RX signal invert according to MURT->AdvancedInit.RxPinLevelInvert value.
;;;2257       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_TXINVERT_INIT))
000002  07c9              LSLS     r1,r1,#31
000004  0fc9              LSRS     r1,r1,#31
000006  2900              CMP      r1,#0
000008  d008              BEQ      |L10.28|
;;;2258       {
;;;2259           URT_MODIFY_REG(MURT->Instance->CR0.W, URT_CR0_TX_INV_mask_w , MURT->AdvancedInit.TxPinLevelInvert);
00000a  6801              LDR      r1,[r0,#0]
00000c  6909              LDR      r1,[r1,#0x10]
00000e  2201              MOVS     r2,#1
000010  02d2              LSLS     r2,r2,#11
000012  4391              BICS     r1,r1,r2
000014  8b82              LDRH     r2,[r0,#0x1c]
000016  4311              ORRS     r1,r1,r2
000018  6802              LDR      r2,[r0,#0]
00001a  6111              STR      r1,[r2,#0x10]
                  |L10.28|
;;;2260       }
;;;2261       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_RXINVERT_INIT))
00001c  2202              MOVS     r2,#2
00001e  6981              LDR      r1,[r0,#0x18]
000020  4011              ANDS     r1,r1,r2
000022  2900              CMP      r1,#0
000024  d007              BEQ      |L10.54|
;;;2262       {
;;;2263           URT_MODIFY_REG(MURT->Instance->CR0.W, URT_CR0_RX_INV_mask_w , MURT->AdvancedInit.RxPinLevelInvert);
000026  6801              LDR      r1,[r0,#0]
000028  6909              LDR      r1,[r1,#0x10]
00002a  0252              LSLS     r2,r2,#9
00002c  4391              BICS     r1,r1,r2
00002e  8bc2              LDRH     r2,[r0,#0x1e]
000030  4311              ORRS     r1,r1,r2
000032  6802              LDR      r2,[r0,#0]
000034  6111              STR      r1,[r2,#0x10]
                  |L10.54|
;;;2264       }
;;;2265       //===========================================================
;;;2266       //* If required , Configure
;;;2267       //    * Set TX Data bit invert according to MURT->AdvancedInit.TXDataInvert value.
;;;2268       //    * Set RX Data bit invert according to MURT->AdvancedInit.RXDataInvert value.
;;;2269       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_TXDATAINVERT_INIT))
000036  2204              MOVS     r2,#4
000038  6981              LDR      r1,[r0,#0x18]
00003a  4011              ANDS     r1,r1,r2
00003c  2900              CMP      r1,#0
00003e  d007              BEQ      |L10.80|
;;;2270       {
;;;2271           URT_MODIFY_REG(MURT->Instance->CR4.W, URT_CR4_TDAT_INV_mask_w , MURT->AdvancedInit.TXDataInvert);
000040  6801              LDR      r1,[r0,#0]
000042  6a09              LDR      r1,[r1,#0x20]
000044  2220              MOVS     r2,#0x20
000046  4391              BICS     r1,r1,r2
000048  5c12              LDRB     r2,[r2,r0]
00004a  4311              ORRS     r1,r1,r2
00004c  6802              LDR      r2,[r0,#0]
00004e  6211              STR      r1,[r2,#0x20]
                  |L10.80|
;;;2272       }
;;;2273       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_RXDATAINVERT_INIT))
000050  2208              MOVS     r2,#8
000052  6981              LDR      r1,[r0,#0x18]
000054  4011              ANDS     r1,r1,r2
000056  2900              CMP      r1,#0
000058  d008              BEQ      |L10.108|
;;;2274       {
;;;2275           URT_MODIFY_REG(MURT->Instance->CR4.W, URT_CR4_RDAT_INV_mask_w , MURT->AdvancedInit.RXDataInvert);
00005a  6801              LDR      r1,[r0,#0]
00005c  6a09              LDR      r1,[r1,#0x20]
00005e  2210              MOVS     r2,#0x10
000060  4391              BICS     r1,r1,r2
000062  2221              MOVS     r2,#0x21
000064  5c12              LDRB     r2,[r2,r0]
000066  4311              ORRS     r1,r1,r2
000068  6802              LDR      r2,[r0,#0]
00006a  6211              STR      r1,[r2,#0x20]
                  |L10.108|
;;;2276       }
;;;2277       //===========================================================
;;;2278       //* If required , Configure
;;;2279       //    * Set RX / TX pin swap according to MURT->AdvancedInit.Swap.
;;;2280       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_SWAP_INIT))
00006c  2210              MOVS     r2,#0x10
00006e  6981              LDR      r1,[r0,#0x18]
000070  4011              ANDS     r1,r1,r2
000072  2900              CMP      r1,#0
000074  d007              BEQ      |L10.134|
;;;2281       {
;;;2282           URT_MODIFY_REG(MURT->Instance->CR0.W , URT_CR0_IO_SWP_mask_w , MURT->AdvancedInit.Swap);
000076  6801              LDR      r1,[r0,#0]
000078  6909              LDR      r1,[r1,#0x10]
00007a  0112              LSLS     r2,r2,#4
00007c  4391              BICS     r1,r1,r2
00007e  8c42              LDRH     r2,[r0,#0x22]
000080  4311              ORRS     r1,r1,r2
000082  6802              LDR      r2,[r0,#0]
000084  6111              STR      r1,[r2,#0x10]
                  |L10.134|
;;;2283       }
;;;2284       //===========================================================
;;;2285       //* If required , Configure
;;;2286       //    * Set Auto baudrate detection scheme.
;;;2287       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_AUTOBAUDRATE_INIT))
000086  2240              MOVS     r2,#0x40
000088  6981              LDR      r1,[r0,#0x18]
00008a  4011              ANDS     r1,r1,r2
00008c  2900              CMP      r1,#0
00008e  d00d              BEQ      |L10.172|
;;;2288       {
;;;2289           URT_MODIFY_REG(MURT->Instance->CAL.B[0] , (URT_CAL_CAL_AUTO_mask_b0| URT_CAL_CAL_MDS_mask_b0),     \
000090  2124              MOVS     r1,#0x24
000092  5c09              LDRB     r1,[r1,r0]
000094  2225              MOVS     r2,#0x25
000096  5c12              LDRB     r2,[r2,r0]
000098  4311              ORRS     r1,r1,r2
00009a  6802              LDR      r2,[r0,#0]
00009c  3240              ADDS     r2,r2,#0x40
00009e  7c12              LDRB     r2,[r2,#0x10]
0000a0  230e              MOVS     r3,#0xe
0000a2  439a              BICS     r2,r2,r3
0000a4  4311              ORRS     r1,r1,r2
0000a6  6802              LDR      r2,[r0,#0]
0000a8  3240              ADDS     r2,r2,#0x40
0000aa  7411              STRB     r1,[r2,#0x10]
                  |L10.172|
;;;2290                          (MURT->AdvancedInit.AutoBaudRateEnable | MURT->AdvancedInit.AutoBaudRateMode));
;;;2291       }
;;;2292       //===========================================================
;;;2293       //* Configure
;;;2294       //    * Set TX data order is MSB according to MURT->AdvancedInit.TXMSBFirst.
;;;2295       //    * Set RX data order is MSB according to MURT->AdvancedInit.RXMSBFirst.
;;;2296       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_TXMSBFIRST_INIT))
0000ac  2280              MOVS     r2,#0x80
0000ae  6981              LDR      r1,[r0,#0x18]
0000b0  4011              ANDS     r1,r1,r2
0000b2  2900              CMP      r1,#0
0000b4  d008              BEQ      |L10.200|
;;;2297       {
;;;2298           URT_MODIFY_REG(MURT->Instance->CR1.B[2], URT_CR1_TXMSB_EN_mask_b2 , MURT->AdvancedInit.TXMSBFirst);
0000b6  6801              LDR      r1,[r0,#0]
0000b8  7d89              LDRB     r1,[r1,#0x16]
0000ba  2220              MOVS     r2,#0x20
0000bc  4391              BICS     r1,r1,r2
0000be  2226              MOVS     r2,#0x26
0000c0  5c12              LDRB     r2,[r2,r0]
0000c2  4311              ORRS     r1,r1,r2
0000c4  6802              LDR      r2,[r0,#0]
0000c6  7591              STRB     r1,[r2,#0x16]
                  |L10.200|
;;;2299       }
;;;2300       if(MID_URT_IS_BIT_SET(MURT->AdvancedInit.AdvFeatureInit, URT_ADVFEATURE_RXMSBFIRST_INIT))
0000c8  22ff              MOVS     r2,#0xff
0000ca  3201              ADDS     r2,#1
0000cc  6981              LDR      r1,[r0,#0x18]
0000ce  4011              ANDS     r1,r1,r2
0000d0  2900              CMP      r1,#0
0000d2  d008              BEQ      |L10.230|
;;;2301       {
;;;2302           URT_MODIFY_REG(MURT->Instance->CR1.B[0], URT_CR1_RXMSB_EN_mask_b0 , MURT->AdvancedInit.RXMSBFirst);
0000d4  6801              LDR      r1,[r0,#0]
0000d6  7d09              LDRB     r1,[r1,#0x14]
0000d8  2220              MOVS     r2,#0x20
0000da  4391              BICS     r1,r1,r2
0000dc  2227              MOVS     r2,#0x27
0000de  5c12              LDRB     r2,[r2,r0]
0000e0  4311              ORRS     r1,r1,r2
0000e2  6802              LDR      r2,[r0,#0]
0000e4  7511              STRB     r1,[r2,#0x14]
                  |L10.230|
;;;2303       }
;;;2304   }
0000e6  4770              BX       lr
;;;2305   
                          ENDP


                          AREA ||i.MID_URT_CheckIdleState||, CODE, READONLY, ALIGN=1

                  MID_URT_CheckIdleState PROC
;;;2315    */
;;;2316   MID_StatusTypeDef MID_URT_CheckIdleState(URT_HandleTypeDef* MURT)
000000  4601              MOV      r1,r0
;;;2317   {
;;;2318       //===========================================================
;;;2319       //* Initialize the URT ErrorCode.
;;;2320       MURT->ErrorCode = MID_URT_ERROR_NONE;
000002  2000              MOVS     r0,#0
000004  6448              STR      r0,[r1,#0x44]
;;;2321       
;;;2322       //===========================================================
;;;2323       //* Initialize the URT State.
;;;2324       MURT->gState  = MID_URT_STATE_READY;
000006  2220              MOVS     r2,#0x20
000008  2041              MOVS     r0,#0x41
00000a  5442              STRB     r2,[r0,r1]
;;;2325       MURT->RxState = MID_URT_STATE_READY;
00000c  2042              MOVS     r0,#0x42
00000e  5442              STRB     r2,[r0,r1]
;;;2326       
;;;2327       //===========================================================
;;;2328       //* Process Unlocked.
;;;2329       __MID_UNLOCK(MURT);
000010  bf00              NOP      
000012  2200              MOVS     r2,#0
000014  2040              MOVS     r0,#0x40
000016  5442              STRB     r2,[r0,r1]
000018  bf00              NOP      
;;;2330       
;;;2331       return(MID_SUCCESS);
00001a  2000              MOVS     r0,#0
;;;2332   }
00001c  4770              BX       lr
;;;2333   
                          ENDP


                          AREA ||i.MID_URT_DMAPause||, CODE, READONLY, ALIGN=2

                  MID_URT_DMAPause PROC
;;;1069    */
;;;1070   MID_StatusTypeDef MID_URT_DMAPause( URT_HandleTypeDef *MURT)
000000  4601              MOV      r1,r0
;;;1071   {
;;;1072       //===============================================================
;;;1073       //Process Locked 
;;;1074       __MID_LOCK(MURT);
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L12.16|
00000c  2002              MOVS     r0,#2
                  |L12.14|
;;;1075       
;;;1076       if((MURT->gState == MID_URT_STATE_BUSY_TX) &&
;;;1077           READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
;;;1078       {
;;;1079           //-----------------------------------------------------------
;;;1080           //Disable the URT DMA TX request.
;;;1081           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
;;;1082       }
;;;1083       if((MURT->gState == MID_URT_STATE_BUSY_RX) &&
;;;1084           READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
;;;1085       {
;;;1086           //-----------------------------------------------------------
;;;1087           //Disable PE & ERR interrupt.
;;;1088           CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_PE | URT_IT_ERR));
;;;1089           
;;;1090           //-----------------------------------------------------------
;;;1091           //Disable the URT DMA RX request.
;;;1092           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
;;;1093       }
;;;1094       
;;;1095       //===============================================================
;;;1096       //Process UnLocked 
;;;1097       __MID_UNLOCK(MURT);
;;;1098       
;;;1099       return( MID_OK);
;;;1100   }
00000e  4770              BX       lr
                  |L12.16|
000010  2201              MOVS     r2,#1                 ;1074
000012  2040              MOVS     r0,#0x40              ;1074
000014  5442              STRB     r2,[r0,r1]            ;1074
000016  bf00              NOP                            ;1074
000018  2041              MOVS     r0,#0x41              ;1076
00001a  5c40              LDRB     r0,[r0,r1]            ;1076
00001c  2821              CMP      r0,#0x21              ;1076
00001e  d10b              BNE      |L12.56|
000020  6808              LDR      r0,[r1,#0]            ;1077
000022  6900              LDR      r0,[r0,#0x10]         ;1077
000024  0fc0              LSRS     r0,r0,#31             ;1077
000026  07c0              LSLS     r0,r0,#31             ;1077
000028  2800              CMP      r0,#0                 ;1077
00002a  d005              BEQ      |L12.56|
00002c  6808              LDR      r0,[r1,#0]            ;1081
00002e  6900              LDR      r0,[r0,#0x10]         ;1081
000030  0040              LSLS     r0,r0,#1              ;1081
000032  0840              LSRS     r0,r0,#1              ;1081
000034  680a              LDR      r2,[r1,#0]            ;1081
000036  6110              STR      r0,[r2,#0x10]         ;1081
                  |L12.56|
000038  2041              MOVS     r0,#0x41              ;1083
00003a  5c40              LDRB     r0,[r0,r1]            ;1083
00003c  2822              CMP      r0,#0x22              ;1083
00003e  d113              BNE      |L12.104|
000040  6808              LDR      r0,[r1,#0]            ;1084
000042  6900              LDR      r0,[r0,#0x10]         ;1084
000044  2201              MOVS     r2,#1                 ;1084
000046  0792              LSLS     r2,r2,#30             ;1084
000048  4010              ANDS     r0,r0,r2              ;1084
00004a  2800              CMP      r0,#0                 ;1084
00004c  d00c              BEQ      |L12.104|
00004e  6808              LDR      r0,[r1,#0]            ;1088
000050  6840              LDR      r0,[r0,#4]            ;1088
000052  4a09              LDR      r2,|L12.120|
000054  4010              ANDS     r0,r0,r2              ;1088
000056  680a              LDR      r2,[r1,#0]            ;1088
000058  6050              STR      r0,[r2,#4]            ;1088
00005a  6808              LDR      r0,[r1,#0]            ;1092
00005c  6900              LDR      r0,[r0,#0x10]         ;1092
00005e  2201              MOVS     r2,#1                 ;1092
000060  0792              LSLS     r2,r2,#30             ;1092
000062  4390              BICS     r0,r0,r2              ;1092
000064  680a              LDR      r2,[r1,#0]            ;1092
000066  6110              STR      r0,[r2,#0x10]         ;1092
                  |L12.104|
000068  bf00              NOP                            ;1097
00006a  2200              MOVS     r2,#0                 ;1097
00006c  2040              MOVS     r0,#0x40              ;1097
00006e  5442              STRB     r2,[r0,r1]            ;1097
000070  bf00              NOP                            ;1097
000072  2000              MOVS     r0,#0                 ;1099
000074  e7cb              B        |L12.14|
;;;1101   
                          ENDP

000076  0000              DCW      0x0000
                  |L12.120|
                          DCD      0xffeffff7

                          AREA ||i.MID_URT_DMAResume||, CODE, READONLY, ALIGN=2

                  MID_URT_DMAResume PROC
;;;1111    */
;;;1112   MID_StatusTypeDef MID_URT_DMAResume( URT_HandleTypeDef *MURT)
000000  4601              MOV      r1,r0
;;;1113   {
;;;1114       //===============================================================
;;;1115       //Process Locked 
;;;1116       __MID_LOCK(MURT);
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L13.16|
00000c  2002              MOVS     r0,#2
                  |L13.14|
;;;1117       
;;;1118       if( MURT->gState == MID_URT_STATE_BUSY_TX)
;;;1119       {
;;;1120           //===============================================================
;;;1121           //Enable the URT DMA TX request
;;;1122           CLEAR_BIT( MURT->Instance->CR2.W , URT_CR2_TX_EN_mask_w);
;;;1123           SET_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
;;;1124           SET_BIT( MURT->Instance->CR2.W , URT_CR2_TX_EN_mask_w);
;;;1125       }
;;;1126       if( MURT->RxState == MID_URT_STATE_BUSY_RX)
;;;1127       {
;;;1128           //===============================================================
;;;1129           //Clear the Overrun flag and RX hold flag 
;;;1130           //before resuming the Rx transfer
;;;1131           __DRV_URT_CLEAR_FLAG( MURT , (URT_FLAG_ROVR | URT_FLAG_RHF));
;;;1132   
;;;1133           //===============================================================
;;;1134           //Reenable PE and ERR interrupt
;;;1135           SET_BIT( MURT->Instance->INT.W , (URT_IT_ERR));
;;;1136           
;;;1137           //===============================================================
;;;1138           //Enable the URT DMA RX request
;;;1139           SET_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
;;;1140       }
;;;1141       
;;;1142       
;;;1143       //===============================================================
;;;1144       //Process UnLocked 
;;;1145       __MID_UNLOCK(MURT);
;;;1146       
;;;1147       return( MID_OK);
;;;1148   }
00000e  4770              BX       lr
                  |L13.16|
000010  2201              MOVS     r2,#1                 ;1116
000012  2040              MOVS     r0,#0x40              ;1116
000014  5442              STRB     r2,[r0,r1]            ;1116
000016  bf00              NOP                            ;1116
000018  2041              MOVS     r0,#0x41              ;1118
00001a  5c40              LDRB     r0,[r0,r1]            ;1118
00001c  2821              CMP      r0,#0x21              ;1118
00001e  d112              BNE      |L13.70|
000020  6808              LDR      r0,[r1,#0]            ;1122
000022  6980              LDR      r0,[r0,#0x18]         ;1122
000024  2208              MOVS     r2,#8                 ;1122
000026  4390              BICS     r0,r0,r2              ;1122
000028  680a              LDR      r2,[r1,#0]            ;1122
00002a  6190              STR      r0,[r2,#0x18]         ;1122
00002c  6808              LDR      r0,[r1,#0]            ;1123
00002e  6900              LDR      r0,[r0,#0x10]         ;1123
000030  2201              MOVS     r2,#1                 ;1123
000032  07d2              LSLS     r2,r2,#31             ;1123
000034  4310              ORRS     r0,r0,r2              ;1123
000036  680a              LDR      r2,[r1,#0]            ;1123
000038  6110              STR      r0,[r2,#0x10]         ;1123
00003a  6808              LDR      r0,[r1,#0]            ;1124
00003c  6980              LDR      r0,[r0,#0x18]         ;1124
00003e  2208              MOVS     r2,#8                 ;1124
000040  4310              ORRS     r0,r0,r2              ;1124
000042  680a              LDR      r2,[r1,#0]            ;1124
000044  6190              STR      r0,[r2,#0x18]         ;1124
                  |L13.70|
000046  2042              MOVS     r0,#0x42              ;1126
000048  5c40              LDRB     r0,[r0,r1]            ;1126
00004a  2822              CMP      r0,#0x22              ;1126
00004c  d10f              BNE      |L13.110|
00004e  480b              LDR      r0,|L13.124|
000050  680a              LDR      r2,[r1,#0]            ;1131
000052  6010              STR      r0,[r2,#0]            ;1131
000054  6808              LDR      r0,[r1,#0]            ;1135
000056  6840              LDR      r0,[r0,#4]            ;1135
000058  2208              MOVS     r2,#8                 ;1135
00005a  4310              ORRS     r0,r0,r2              ;1135
00005c  680a              LDR      r2,[r1,#0]            ;1135
00005e  6050              STR      r0,[r2,#4]            ;1135
000060  6808              LDR      r0,[r1,#0]            ;1139
000062  6900              LDR      r0,[r0,#0x10]         ;1139
000064  2201              MOVS     r2,#1                 ;1139
000066  0792              LSLS     r2,r2,#30             ;1139
000068  4310              ORRS     r0,r0,r2              ;1139
00006a  680a              LDR      r2,[r1,#0]            ;1139
00006c  6110              STR      r0,[r2,#0x10]         ;1139
                  |L13.110|
00006e  bf00              NOP                            ;1145
000070  2200              MOVS     r2,#0                 ;1145
000072  2040              MOVS     r0,#0x40              ;1145
000074  5442              STRB     r2,[r0,r1]            ;1145
000076  bf00              NOP                            ;1145
000078  2000              MOVS     r0,#0                 ;1147
00007a  e7c8              B        |L13.14|
;;;1149   /**
                          ENDP

                  |L13.124|
                          DCD      0x00800001

                          AREA ||i.MID_URT_DMAStop||, CODE, READONLY, ALIGN=1

                  MID_URT_DMAStop PROC
;;;1158    */
;;;1159   MID_StatusTypeDef MID_URT_DMAStop( URT_HandleTypeDef *MURT)
000000  b510              PUSH     {r4,lr}
;;;1160   {
000002  4604              MOV      r4,r0
;;;1161       //===============================================================
;;;1162       //This lock in  not implemented on this function to allow the user
;;;1163       //application to call the MID URT function uneder callbcks 
;;;1164       //MID_URT_RxHalfCpltCallback:
;;;1165       //indeed , when MID_DMA_Abort() is called , the DMA Tx / Rx transfer or
;;;1166       //half transfer complete interrupt is generated if the DMA transfer 
;;;1167       //interruption occurs at the middle or at the end of the stream and the
;;;1168       //corresponding call back is executed.
;;;1169       
;;;1170       //-----------------------------------------------------------
;;;1171       //Stop UART DMA Tx request if on going
;;;1172       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0)
000004  6820              LDR      r0,[r4,#0]
000006  6900              LDR      r0,[r0,#0x10]
000008  0fc0              LSRS     r0,r0,#31
00000a  07c0              LSLS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d00e              BEQ      |L14.46|
;;;1173       {
;;;1174           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  0040              LSLS     r0,r0,#1
000016  0840              LSRS     r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6108              STR      r0,[r1,#0x10]
;;;1175           
;;;1176           //-----------------------------------------------------------
;;;1177           //Abort the URT DMA Tx channel
;;;1178           if(MURT->mDMA_TX != NULL)
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  2800              CMP      r0,#0
000020  d002              BEQ      |L14.40|
;;;1179           {
;;;1180               MID_DMA_Abort(MURT->mDMA_TX);
000022  6ba0              LDR      r0,[r4,#0x38]
000024  f7fffffe          BL       MID_DMA_Abort
                  |L14.40|
;;;1181           }            
;;;1182           
;;;1183           ifun_URT_EndTxTransfer(MURT);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       ifun_URT_EndTxTransfer
                  |L14.46|
;;;1184       }
;;;1185       //-----------------------------------------------------------
;;;1186       //Stop UART DMA Rx request if on going  
;;;1187       if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
00002e  6820              LDR      r0,[r4,#0]
000030  6900              LDR      r0,[r0,#0x10]
000032  2101              MOVS     r1,#1
000034  0789              LSLS     r1,r1,#30
000036  4008              ANDS     r0,r0,r1
000038  2800              CMP      r0,#0
00003a  d00d              BEQ      |L14.88|
;;;1188       {
;;;1189           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
00003c  6820              LDR      r0,[r4,#0]
00003e  6900              LDR      r0,[r0,#0x10]
000040  4388              BICS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  6108              STR      r0,[r1,#0x10]
;;;1190           
;;;1191           //-----------------------------------------------------------
;;;1192           //Abort the URT DMA RX channel
;;;1193           if(MURT->mDMA_RX != NULL)
000046  6be0              LDR      r0,[r4,#0x3c]
000048  2800              CMP      r0,#0
00004a  d002              BEQ      |L14.82|
;;;1194           {
;;;1195               MID_DMA_Abort(MURT->mDMA_RX);
00004c  6be0              LDR      r0,[r4,#0x3c]
00004e  f7fffffe          BL       MID_DMA_Abort
                  |L14.82|
;;;1196           }
;;;1197           
;;;1198           ifun_URT_EndTxTransfer(MURT);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       ifun_URT_EndTxTransfer
                  |L14.88|
;;;1199       }
;;;1200       
;;;1201       return( MID_OK);
000058  2000              MOVS     r0,#0
;;;1202   }
00005a  bd10              POP      {r4,pc}
;;;1203   
                          ENDP


                          AREA ||i.MID_URT_DeInit||, CODE, READONLY, ALIGN=1

                  MID_URT_DeInit PROC
;;;529     */
;;;530    MID_StatusTypeDef MID_URT_DeInit( URT_HandleTypeDef* MURT )
000000  b510              PUSH     {r4,lr}
;;;531    {
000002  4604              MOV      r4,r0
;;;532        //===========================================================    
;;;533        //Check the URT handle allocation.
;;;534        if(MURT == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L15.12|
;;;535        {
;;;536            return(MID_FAILURE);
000008  2001              MOVS     r0,#1
                  |L15.10|
;;;537        }
;;;538        //============================================================
;;;539        //Check URT register address
;;;540        switch((uint32_t)(&MURT->Instance->STA.W))
;;;541        {
;;;542            case URT0_Base:
;;;543            #if defined(URT1_Base)
;;;544            case URT1_Base:
;;;545            #endif
;;;546            #if defined(URT2_Base) 
;;;547            case URT2_Base:
;;;548            #endif   
;;;549            #if defined(URT3_Base)
;;;550            case URT3_Base:
;;;551            #endif           
;;;552            #if defined(URT4_Base)
;;;553            case URT4_Base:
;;;554            #endif           
;;;555            #if defined(URT5_Base)
;;;556            case URT5_Base:
;;;557            #endif           
;;;558            #if defined(URT6_Base)
;;;559            case URT6_Base:
;;;560            #endif           
;;;561            #if defined(URT7_Base)
;;;562            case URT7_Base:
;;;563            #endif           
;;;564                           break;
;;;565            default: 
;;;566                           return(MID_FAILURE);
;;;567        }
;;;568        
;;;569        MURT->gState = MID_URT_STATE_BUSY;
;;;570        
;;;571        //===========================================================    
;;;572        //Disable the peripheral.
;;;573        __MID_URT_DISABLE(MURT);
;;;574        
;;;575        MURT->Instance->STA.W = 0xFFFFFFFF;
;;;576        MURT->Instance->INT.W = 0;
;;;577        MURT->Instance->CLK.W = 0;
;;;578        MURT->Instance->CR0.W = 0;
;;;579        MURT->Instance->CR1.W = 0;
;;;580        MURT->Instance->CR2.W = 0;
;;;581        MURT->Instance->CR3.W = 0;
;;;582        MURT->Instance->CR4.W = (URT_CR4_RDAT_CLR_enable_w | URT_CR4_TDAT_CLR_enable_w);
;;;583        //===========================================================    
;;;584        //DeInit the low level hardware.
;;;585        MID_URT_MspDeInit(MURT);
;;;586         
;;;587        MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;588        MURT->gState    = MID_URT_STATE_RESET;
;;;589        MURT->RxState   = MID_URT_STATE_RESET;
;;;590        
;;;591        //===========================================================
;;;592        //Process Unlock.
;;;593        __MID_UNLOCK(MURT);
;;;594        
;;;595        
;;;596        return(MID_SUCCESS);
;;;597    }
00000a  bd10              POP      {r4,pc}
                  |L15.12|
00000c  2157              MOVS     r1,#0x57              ;540
00000e  0649              LSLS     r1,r1,#25             ;540
000010  6820              LDR      r0,[r4,#0]            ;540
000012  1840              ADDS     r0,r0,r1              ;540
000014  2800              CMP      r0,#0                 ;540
000016  d008              BEQ      |L15.42|
000018  2101              MOVS     r1,#1                 ;540
00001a  0409              LSLS     r1,r1,#16             ;540
00001c  1a40              SUBS     r0,r0,r1              ;540
00001e  d005              BEQ      |L15.44|
000020  1a40              SUBS     r0,r0,r1              ;540
000022  d004              BEQ      |L15.46|
000024  1a40              SUBS     r0,r0,r1              ;540
000026  d104              BNE      |L15.50|
000028  e002              B        |L15.48|
                  |L15.42|
00002a  bf00              NOP                            ;544
                  |L15.44|
00002c  bf00              NOP                            ;547
                  |L15.46|
00002e  bf00              NOP                            ;550
                  |L15.48|
000030  e001              B        |L15.54|
                  |L15.50|
000032  2001              MOVS     r0,#1                 ;566
000034  e7e9              B        |L15.10|
                  |L15.54|
000036  bf00              NOP                            ;564
000038  2124              MOVS     r1,#0x24              ;569
00003a  2041              MOVS     r0,#0x41              ;569
00003c  5501              STRB     r1,[r0,r4]            ;569
00003e  6820              LDR      r0,[r4,#0]            ;573
000040  6900              LDR      r0,[r0,#0x10]         ;573
000042  0840              LSRS     r0,r0,#1              ;573
000044  0040              LSLS     r0,r0,#1              ;573
000046  6821              LDR      r1,[r4,#0]            ;573
000048  6108              STR      r0,[r1,#0x10]         ;573
00004a  2000              MOVS     r0,#0                 ;575
00004c  43c0              MVNS     r0,r0                 ;575
00004e  6821              LDR      r1,[r4,#0]            ;575
000050  6008              STR      r0,[r1,#0]            ;575
000052  2000              MOVS     r0,#0                 ;576
000054  6821              LDR      r1,[r4,#0]            ;576
000056  6048              STR      r0,[r1,#4]            ;576
000058  6821              LDR      r1,[r4,#0]            ;577
00005a  6088              STR      r0,[r1,#8]            ;577
00005c  6821              LDR      r1,[r4,#0]            ;578
00005e  6108              STR      r0,[r1,#0x10]         ;578
000060  6821              LDR      r1,[r4,#0]            ;579
000062  6148              STR      r0,[r1,#0x14]         ;579
000064  6821              LDR      r1,[r4,#0]            ;580
000066  6188              STR      r0,[r1,#0x18]         ;580
000068  6821              LDR      r1,[r4,#0]            ;581
00006a  61c8              STR      r0,[r1,#0x1c]         ;581
00006c  20c0              MOVS     r0,#0xc0              ;582
00006e  6821              LDR      r1,[r4,#0]            ;582
000070  6208              STR      r0,[r1,#0x20]         ;582
000072  4620              MOV      r0,r4                 ;585
000074  f7fffffe          BL       MID_URT_MspDeInit
000078  2000              MOVS     r0,#0                 ;587
00007a  6460              STR      r0,[r4,#0x44]         ;587
00007c  2100              MOVS     r1,#0                 ;588
00007e  2041              MOVS     r0,#0x41              ;588
000080  5501              STRB     r1,[r0,r4]            ;588
000082  2042              MOVS     r0,#0x42              ;589
000084  5501              STRB     r1,[r0,r4]            ;589
000086  bf00              NOP                            ;593
000088  2040              MOVS     r0,#0x40              ;593
00008a  5501              STRB     r1,[r0,r4]            ;593
00008c  bf00              NOP                            ;593
00008e  2000              MOVS     r0,#0                 ;596
000090  e7bb              B        |L15.10|
;;;598    
                          ENDP


                          AREA ||i.MID_URT_DisableSleepMode||, CODE, READONLY, ALIGN=2

                  MID_URT_DisableSleepMode PROC
;;;2969    */
;;;2970   MID_StatusTypeDef MID_URT_DisableSleepMode( URT_HandleTypeDef *MURT)
000000  4601              MOV      r1,r0
;;;2971   {
;;;2972       //========================================================
;;;2973       // Process locked.
;;;2974       __MID_LOCK(MURT);
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L16.16|
00000c  2002              MOVS     r0,#2
                  |L16.14|
;;;2975       MURT->gState = MID_URT_STATE_BUSY;
;;;2976       
;;;2977       //========================================================
;;;2978       //Set CSC control
;;;2979       if(MURT->Instance == URT0)
;;;2980       {
;;;2981           CLEAR_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT0_mask_w);
;;;2982       }
;;;2983       #if defined(URT1_Base)
;;;2984       else if(MURT->Instance == URT1)
;;;2985       {
;;;2986           CLEAR_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT1_mask_w);
;;;2987       }
;;;2988       #endif
;;;2989       #if defined(URT2_Base)
;;;2990       else if(MURT->Instance == URT2)
;;;2991       {
;;;2992           CLEAR_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT2_mask_w);
;;;2993       }
;;;2994       #endif
;;;2995       #if defined(URT3_Base)
;;;2996       else if(MURT->Instance == URT3)
;;;2997       {
;;;2998           CLEAR_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT3_mask_w);
;;;2999       }
;;;3000       #endif
;;;3001       else
;;;3002       {
;;;3003           return(MID_ERROR);
;;;3004       }
;;;3005       MURT->gState = MID_URT_STATE_READY;
;;;3006       //========================================================
;;;3007       //Process Unlocked.
;;;3008       __MID_UNLOCK(MURT);
;;;3009       
;;;3010       return(MID_OK);
;;;3011   }
00000e  4770              BX       lr
                  |L16.16|
000010  2201              MOVS     r2,#1                 ;2974
000012  2040              MOVS     r0,#0x40              ;2974
000014  5442              STRB     r2,[r0,r1]            ;2974
000016  bf00              NOP                            ;2974
000018  2224              MOVS     r2,#0x24              ;2975
00001a  2041              MOVS     r0,#0x41              ;2975
00001c  5442              STRB     r2,[r0,r1]            ;2975
00001e  2229              MOVS     r2,#0x29              ;2979
000020  0652              LSLS     r2,r2,#25             ;2979
000022  6808              LDR      r0,[r1,#0]            ;2979
000024  4290              CMP      r0,r2                 ;2979
000026  d107              BNE      |L16.56|
000028  481b              LDR      r0,|L16.152|
00002a  6b00              LDR      r0,[r0,#0x30]         ;2981
00002c  2201              MOVS     r2,#1                 ;2981
00002e  0412              LSLS     r2,r2,#16             ;2981
000030  4390              BICS     r0,r0,r2              ;2981
000032  4a19              LDR      r2,|L16.152|
000034  6310              STR      r0,[r2,#0x30]         ;2981
000036  e025              B        |L16.132|
                  |L16.56|
000038  4a18              LDR      r2,|L16.156|
00003a  6808              LDR      r0,[r1,#0]            ;2984
00003c  4290              CMP      r0,r2                 ;2984
00003e  d107              BNE      |L16.80|
000040  4815              LDR      r0,|L16.152|
000042  6b00              LDR      r0,[r0,#0x30]         ;2986
000044  2201              MOVS     r2,#1                 ;2986
000046  0452              LSLS     r2,r2,#17             ;2986
000048  4390              BICS     r0,r0,r2              ;2986
00004a  4a13              LDR      r2,|L16.152|
00004c  6310              STR      r0,[r2,#0x30]         ;2986
00004e  e019              B        |L16.132|
                  |L16.80|
000050  4a13              LDR      r2,|L16.160|
000052  6808              LDR      r0,[r1,#0]            ;2990
000054  4290              CMP      r0,r2                 ;2990
000056  d107              BNE      |L16.104|
000058  480f              LDR      r0,|L16.152|
00005a  6b00              LDR      r0,[r0,#0x30]         ;2992
00005c  2201              MOVS     r2,#1                 ;2992
00005e  0492              LSLS     r2,r2,#18             ;2992
000060  4390              BICS     r0,r0,r2              ;2992
000062  4a0d              LDR      r2,|L16.152|
000064  6310              STR      r0,[r2,#0x30]         ;2992
000066  e00d              B        |L16.132|
                  |L16.104|
000068  4a0e              LDR      r2,|L16.164|
00006a  6808              LDR      r0,[r1,#0]            ;2996
00006c  4290              CMP      r0,r2                 ;2996
00006e  d107              BNE      |L16.128|
000070  4809              LDR      r0,|L16.152|
000072  6b00              LDR      r0,[r0,#0x30]         ;2998
000074  2201              MOVS     r2,#1                 ;2998
000076  04d2              LSLS     r2,r2,#19             ;2998
000078  4390              BICS     r0,r0,r2              ;2998
00007a  4a07              LDR      r2,|L16.152|
00007c  6310              STR      r0,[r2,#0x30]         ;2998
00007e  e001              B        |L16.132|
                  |L16.128|
000080  2001              MOVS     r0,#1                 ;3003
000082  e7c4              B        |L16.14|
                  |L16.132|
000084  2220              MOVS     r2,#0x20              ;3005
000086  2041              MOVS     r0,#0x41              ;3005
000088  5442              STRB     r2,[r0,r1]            ;3005
00008a  bf00              NOP                            ;3008
00008c  2200              MOVS     r2,#0                 ;3008
00008e  2040              MOVS     r0,#0x40              ;3008
000090  5442              STRB     r2,[r0,r1]            ;3008
000092  bf00              NOP                            ;3008
000094  2000              MOVS     r0,#0                 ;3010
000096  e7ba              B        |L16.14|
;;;3012   
                          ENDP

                  |L16.152|
                          DCD      0x4c010000
                  |L16.156|
                          DCD      0x52010000
                  |L16.160|
                          DCD      0x52020000
                  |L16.164|
                          DCD      0x52030000

                          AREA ||i.MID_URT_EnableSleepMode||, CODE, READONLY, ALIGN=2

                  MID_URT_EnableSleepMode PROC
;;;2915    */
;;;2916   MID_StatusTypeDef MID_URT_EnableSleepMode( URT_HandleTypeDef *MURT)
000000  4601              MOV      r1,r0
;;;2917   {
;;;2918       //========================================================
;;;2919       // Process locked.
;;;2920       __MID_LOCK(MURT);
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L17.16|
00000c  2002              MOVS     r0,#2
                  |L17.14|
;;;2921       MURT->gState = MID_URT_STATE_BUSY;
;;;2922       
;;;2923       //========================================================
;;;2924       //Set CSC control
;;;2925       if(MURT->Instance == URT0)
;;;2926       {
;;;2927           SET_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT0_mask_w);
;;;2928       }
;;;2929       #if defined(URT1_Base)
;;;2930       else if(MURT->Instance == URT1)
;;;2931       {
;;;2932           SET_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT1_mask_w);
;;;2933       }
;;;2934       #endif
;;;2935       #if defined(URT2_Base)
;;;2936       else if(MURT->Instance == URT2)
;;;2937       {
;;;2938           SET_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT2_mask_w);
;;;2939       }
;;;2940       #endif
;;;2941       #if defined(URT3_Base)
;;;2942       else if(MURT->Instance == URT3)
;;;2943       {
;;;2944           SET_BIT( CSC->SLP0.W , CSC_SLP0_SLP_URT3_mask_w);
;;;2945       }
;;;2946       #endif
;;;2947       else
;;;2948       {
;;;2949           return(MID_ERROR);
;;;2950       }
;;;2951       
;;;2952       MURT->gState = MID_URT_STATE_READY;
;;;2953       //========================================================
;;;2954       //Process Unlocked.
;;;2955       __MID_UNLOCK(MURT);
;;;2956       
;;;2957       return(MID_OK);
;;;2958   }
00000e  4770              BX       lr
                  |L17.16|
000010  2201              MOVS     r2,#1                 ;2920
000012  2040              MOVS     r0,#0x40              ;2920
000014  5442              STRB     r2,[r0,r1]            ;2920
000016  bf00              NOP                            ;2920
000018  2224              MOVS     r2,#0x24              ;2921
00001a  2041              MOVS     r0,#0x41              ;2921
00001c  5442              STRB     r2,[r0,r1]            ;2921
00001e  2229              MOVS     r2,#0x29              ;2925
000020  0652              LSLS     r2,r2,#25             ;2925
000022  6808              LDR      r0,[r1,#0]            ;2925
000024  4290              CMP      r0,r2                 ;2925
000026  d107              BNE      |L17.56|
000028  481b              LDR      r0,|L17.152|
00002a  6b00              LDR      r0,[r0,#0x30]         ;2927
00002c  2201              MOVS     r2,#1                 ;2927
00002e  0412              LSLS     r2,r2,#16             ;2927
000030  4310              ORRS     r0,r0,r2              ;2927
000032  4a19              LDR      r2,|L17.152|
000034  6310              STR      r0,[r2,#0x30]         ;2927
000036  e025              B        |L17.132|
                  |L17.56|
000038  4a18              LDR      r2,|L17.156|
00003a  6808              LDR      r0,[r1,#0]            ;2930
00003c  4290              CMP      r0,r2                 ;2930
00003e  d107              BNE      |L17.80|
000040  4815              LDR      r0,|L17.152|
000042  6b00              LDR      r0,[r0,#0x30]         ;2932
000044  2201              MOVS     r2,#1                 ;2932
000046  0452              LSLS     r2,r2,#17             ;2932
000048  4310              ORRS     r0,r0,r2              ;2932
00004a  4a13              LDR      r2,|L17.152|
00004c  6310              STR      r0,[r2,#0x30]         ;2932
00004e  e019              B        |L17.132|
                  |L17.80|
000050  4a13              LDR      r2,|L17.160|
000052  6808              LDR      r0,[r1,#0]            ;2936
000054  4290              CMP      r0,r2                 ;2936
000056  d107              BNE      |L17.104|
000058  480f              LDR      r0,|L17.152|
00005a  6b00              LDR      r0,[r0,#0x30]         ;2938
00005c  2201              MOVS     r2,#1                 ;2938
00005e  0492              LSLS     r2,r2,#18             ;2938
000060  4310              ORRS     r0,r0,r2              ;2938
000062  4a0d              LDR      r2,|L17.152|
000064  6310              STR      r0,[r2,#0x30]         ;2938
000066  e00d              B        |L17.132|
                  |L17.104|
000068  4a0e              LDR      r2,|L17.164|
00006a  6808              LDR      r0,[r1,#0]            ;2942
00006c  4290              CMP      r0,r2                 ;2942
00006e  d107              BNE      |L17.128|
000070  4809              LDR      r0,|L17.152|
000072  6b00              LDR      r0,[r0,#0x30]         ;2944
000074  2201              MOVS     r2,#1                 ;2944
000076  04d2              LSLS     r2,r2,#19             ;2944
000078  4310              ORRS     r0,r0,r2              ;2944
00007a  4a07              LDR      r2,|L17.152|
00007c  6310              STR      r0,[r2,#0x30]         ;2944
00007e  e001              B        |L17.132|
                  |L17.128|
000080  2001              MOVS     r0,#1                 ;2949
000082  e7c4              B        |L17.14|
                  |L17.132|
000084  2220              MOVS     r2,#0x20              ;2952
000086  2041              MOVS     r0,#0x41              ;2952
000088  5442              STRB     r2,[r0,r1]            ;2952
00008a  bf00              NOP                            ;2955
00008c  2200              MOVS     r2,#0                 ;2955
00008e  2040              MOVS     r0,#0x40              ;2955
000090  5442              STRB     r2,[r0,r1]            ;2955
000092  bf00              NOP                            ;2955
000094  2000              MOVS     r0,#0                 ;2957
000096  e7ba              B        |L17.14|
;;;2959   
                          ENDP

                  |L17.152|
                          DCD      0x4c010000
                  |L17.156|
                          DCD      0x52010000
                  |L17.160|
                          DCD      0x52020000
                  |L17.164|
                          DCD      0x52030000

                          AREA ||i.MID_URT_ErrorCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_ErrorCallback PROC
;;;1943    */
;;;1944   __WEAK void MID_URT_ErrorCallback( URT_HandleTypeDef *MURT)
000000  4770              BX       lr
;;;1945   {
;;;1946       //=========================================================
;;;1947       //Prevent unused argument compilation warning
;;;1948       UNUSED(MURT);
;;;1949       
;;;1950       //=========================================================
;;;1951       //NOTE : This function should not be modified , when the 
;;;1952       //       callback is needed, the MID_URT_ErrorCallback can
;;;1953       //       be implemented in the user file.    
;;;1954   }
;;;1955   
                          ENDP


                          AREA ||i.MID_URT_GetBRGClocksource||, CODE, READONLY, ALIGN=2

                  MID_URT_GetBRGClocksource PROC
;;;2105    */
;;;2106   uint32_t MID_URT_GetBRGClocksource( URT_HandleTypeDef* MURT)
000000  b570              PUSH     {r4-r6,lr}
;;;2107   {
000002  4604              MOV      r4,r0
;;;2108       uint32_t CSC_URT_SHIFT;
;;;2109       uint16_t CSC_URT_CMP = 0x0001;
000004  2601              MOVS     r6,#1
;;;2110       
;;;2111       CSC_URT_SHIFT = ((((uint32_t)(&MURT->Instance->STA.W)) & 0x000F0000)>>16);
000006  210f              MOVS     r1,#0xf
000008  0409              LSLS     r1,r1,#16
00000a  6820              LDR      r0,[r4,#0]
00000c  4008              ANDS     r0,r0,r1
00000e  0c05              LSRS     r5,r0,#16
;;;2112       CSC_URT_CMP   = (0x0001 << ( CSC_URT_SHIFT * 2));
000010  0069              LSLS     r1,r5,#1
000012  2001              MOVS     r0,#1
000014  4088              LSLS     r0,r0,r1
000016  b286              UXTH     r6,r0
;;;2113       
;;;2114       if(( CSC->CKS1.H[1] & CSC_URT_CMP) == 0)
000018  4805              LDR      r0,|L19.48|
00001a  8840              LDRH     r0,[r0,#2]
00001c  4030              ANDS     r0,r0,r6
00001e  2800              CMP      r0,#0
000020  d102              BNE      |L19.40|
;;;2115       {
;;;2116           return( MID_CSC_GetCK_APBFreq()); 
000022  f7fffffe          BL       MID_CSC_GetCK_APBFreq
                  |L19.38|
;;;2117       }
;;;2118       else
;;;2119       {
;;;2120           return(MID_CSC_GetCK_AHBFreq()); 
;;;2121       }
;;;2122   }
000026  bd70              POP      {r4-r6,pc}
                  |L19.40|
000028  f7fffffe          BL       MID_CSC_GetCK_AHBFreq
00002c  e7fb              B        |L19.38|
;;;2123   /**
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      0x4c010044

                          AREA ||i.MID_URT_GetError||, CODE, READONLY, ALIGN=1

                  MID_URT_GetError PROC
;;;2079    */
;;;2080   uint32_t MID_URT_GetError( URT_HandleTypeDef* MURT)
000000  4601              MOV      r1,r0
;;;2081   {
;;;2082       return( MURT->ErrorCode);
000002  6c48              LDR      r0,[r1,#0x44]
;;;2083   }
000004  4770              BX       lr
;;;2084   
                          ENDP


                          AREA ||i.MID_URT_GetState||, CODE, READONLY, ALIGN=1

                  MID_URT_GetState PROC
;;;2056    */
;;;2057   MID_URT_StateTypeDef MID_URT_GetState( URT_HandleTypeDef* MURT)
000000  4601              MOV      r1,r0
;;;2058   {
;;;2059       uint8_t MID_URTGetStateTmp1;
;;;2060       uint8_t MID_URTGetStateTmp2;
;;;2061       
;;;2062       MID_URTGetStateTmp1 = MURT->gState;
000002  2041              MOVS     r0,#0x41
000004  5c42              LDRB     r2,[r0,r1]
;;;2063       MID_URTGetStateTmp2 = MURT->RxState;
000006  2042              MOVS     r0,#0x42
000008  5c43              LDRB     r3,[r0,r1]
;;;2064       
;;;2065       return((MID_URT_StateTypeDef)( MID_URTGetStateTmp1 | MID_URTGetStateTmp2));
00000a  4610              MOV      r0,r2
00000c  4318              ORRS     r0,r0,r3
;;;2066   }
00000e  4770              BX       lr
;;;2067   
                          ENDP


                          AREA ||i.MID_URT_HalfDuplex_Init||, CODE, READONLY, ALIGN=2

                  MID_URT_HalfDuplex_Init PROC
;;;190     */
;;;191    MID_StatusTypeDef MID_URT_HalfDuplex_Init( URT_HandleTypeDef* MURT)
000000  b510              PUSH     {r4,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193        //===========================================================
;;;194        //Check the URT handle allocation.
;;;195        if(MURT == NULL)                                                                                                                  
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L22.12|
;;;196        {
;;;197            return(MID_FAILURE);
000008  2001              MOVS     r0,#1
                  |L22.10|
;;;198        }
;;;199        //============================================================
;;;200        //Check URT register address
;;;201        switch((uint32_t)(&MURT->Instance->STA.W))
;;;202        {
;;;203            case URT0_Base:
;;;204            #if defined(URT1_Base)
;;;205            case URT1_Base:
;;;206            #endif
;;;207            #if defined(URT2_Base) 
;;;208            case URT2_Base:
;;;209            #endif   
;;;210            #if defined(URT3_Base)
;;;211            case URT3_Base:
;;;212            #endif           
;;;213                           break;
;;;214            default: 
;;;215                           return(MID_FAILURE);
;;;216        }
;;;217        //===========================================================    
;;;218        if(MURT->gState == MID_URT_STATE_RESET)                                                
;;;219        {
;;;220            //-------------------------------------------
;;;221            //Allocate lock resource and initialize it.
;;;222            MURT->Lock = MID_UnLocked;
;;;223            
;;;224            //-------------------------------------------
;;;225            //Inital the low level hardware:
;;;226            //    * GPIO 
;;;227            //    * CLCOK         
;;;228            MID_URT_MspInit(MURT);                                                      
;;;229        }
;;;230        MURT->gState = MID_URT_STATE_BUSY;
;;;231         
;;;232        
;;;233        //===========================================================                           
;;;234        //Disable the peripheral
;;;235        __MID_URT_DISABLE(MURT);                                                                         
;;;236     
;;;237        //===========================================================                        
;;;238        //Set the URT communication parameters.
;;;239        if(MID_URT_SetConfig(MURT) == MID_FAILURE)                                                       
;;;240        {
;;;241            return(MID_FAILURE);
;;;242        }
;;;243        
;;;244        if(MURT->AdvancedInit.AdvFeatureInit != URT_ADVFEATURE_NO_INIT)                
;;;245        {
;;;246            MID_URT_AdvFeatureConfig(MURT);
;;;247        }
;;;248        //===========================================================                         
;;;249        //* In half-duplex mode, the following bits must be kept cleared and setted.
;;;250        //    * CLK_EN bit be cleared in the URT_CLK register.
;;;251        //    * IrDA mode enable (IR_EN) be cleared in the URT_IRDA register.    
;;;252        //    * Be setted URT mode (MDS) to normal URT function in the URT_CR0 register. 
;;;253        //    * Half-duplex selection (HDX_EN) be cleared in the URT_CR0 register.
;;;254        //    * Data line select 2-lines (DAT_LINE) in the URT_CR0 register.     
;;;255        CLEAR_BIT(MURT->Instance->CLK.W,URT_CLK_CLK_EN_mask_w);
;;;256        CLEAR_BIT(MURT->Instance->IRDA.W,URT_IRDA_IR_EN_mask_w);
;;;257        URT_MODIFY_REG(MURT->Instance->CR0.W , (URT_CR0_MDS_mask_w | URT_CR0_HDX_EN_mask_w |URT_CR0_DAT_LINE_mask_w) , (URT_CR0_MDS_uart_w | URT_CR0_HDX_EN_enable_w | URT_CR0_DAT_LINE_1_w));
;;;258        CLEAR_BIT( MURT->Instance->MUTE.W , URT_MUTE_MUTE_EN_mask_w);
;;;259        
;;;260        //===========================================================
;;;261        //Clear TX / RX Buffer
;;;262        SET_BIT( MURT->Instance->CR4.W , ( URT_CR4_TDAT_CLR_mask_w  | URT_CR4_RDAT_CLR_mask_w));
;;;263        #if defined(MG32_1ST)
;;;264            URT_CLEAR_BIT( MURT->Instance->MUTE.B[0] , URT_MUTE_MUTE_EN_enable_b0);
;;;265        #endif
;;;266        //=========================================================== 
;;;267        //-Clear All flag.
;;;268        //-Interrupt IE control 
;;;269        __DRV_URT_CLEAR_FLAG( MURT , (URT_FLAG_TC  | URT_FLAG_RX   | URT_FLAG_ERR | URT_FLAG_PE | URT_FLAG_FE | \
;;;270                                      URT_FLAG_NCE | URT_FLAG_ROVR | URT_FLAG_RHF));
;;;271        WRITE_REG( MURT->Instance->INT.W , (URT_IT_PE | URT_IT_FE | URT_IT_NCE | URT_IT_ROVR | URT_ITEA));      
;;;272        
;;;273        //===========================================================                            
;;;274        //Enable the peripheral.
;;;275        __MID_URT_ENABLE(MURT);
;;;276        
;;;277        //===========================================================                            
;;;278        //TEACK and/or REACK to check before moving MURT->gState and 
;;;279        //MURT->RxState to Ready.
;;;280        return(MID_URT_CheckIdleState(MURT));
;;;281        
;;;282    }
00000a  bd10              POP      {r4,pc}
                  |L22.12|
00000c  2157              MOVS     r1,#0x57              ;201
00000e  0649              LSLS     r1,r1,#25             ;201
000010  6820              LDR      r0,[r4,#0]            ;201
000012  1840              ADDS     r0,r0,r1              ;201
000014  2800              CMP      r0,#0                 ;201
000016  d008              BEQ      |L22.42|
000018  2101              MOVS     r1,#1                 ;201
00001a  0409              LSLS     r1,r1,#16             ;201
00001c  1a40              SUBS     r0,r0,r1              ;201
00001e  d005              BEQ      |L22.44|
000020  1a40              SUBS     r0,r0,r1              ;201
000022  d004              BEQ      |L22.46|
000024  1a40              SUBS     r0,r0,r1              ;201
000026  d104              BNE      |L22.50|
000028  e002              B        |L22.48|
                  |L22.42|
00002a  bf00              NOP                            ;205
                  |L22.44|
00002c  bf00              NOP                            ;208
                  |L22.46|
00002e  bf00              NOP                            ;211
                  |L22.48|
000030  e001              B        |L22.54|
                  |L22.50|
000032  2001              MOVS     r0,#1                 ;215
000034  e7e9              B        |L22.10|
                  |L22.54|
000036  bf00              NOP                            ;213
000038  2041              MOVS     r0,#0x41              ;218
00003a  5d00              LDRB     r0,[r0,r4]            ;218
00003c  2800              CMP      r0,#0                 ;218
00003e  d105              BNE      |L22.76|
000040  2100              MOVS     r1,#0                 ;222
000042  2040              MOVS     r0,#0x40              ;222
000044  5501              STRB     r1,[r0,r4]            ;222
000046  4620              MOV      r0,r4                 ;228
000048  f7fffffe          BL       MID_URT_MspInit
                  |L22.76|
00004c  2124              MOVS     r1,#0x24              ;230
00004e  2041              MOVS     r0,#0x41              ;230
000050  5501              STRB     r1,[r0,r4]            ;230
000052  6820              LDR      r0,[r4,#0]            ;235
000054  6900              LDR      r0,[r0,#0x10]         ;235
000056  0840              LSRS     r0,r0,#1              ;235
000058  0040              LSLS     r0,r0,#1              ;235
00005a  6821              LDR      r1,[r4,#0]            ;235
00005c  6108              STR      r0,[r1,#0x10]         ;235
00005e  4620              MOV      r0,r4                 ;239
000060  f7fffffe          BL       MID_URT_SetConfig
000064  2801              CMP      r0,#1                 ;239
000066  d100              BNE      |L22.106|
000068  e7cf              B        |L22.10|
                  |L22.106|
00006a  69a0              LDR      r0,[r4,#0x18]         ;244
00006c  2800              CMP      r0,#0                 ;244
00006e  d002              BEQ      |L22.118|
000070  4620              MOV      r0,r4                 ;246
000072  f7fffffe          BL       MID_URT_AdvFeatureConfig
                  |L22.118|
000076  6820              LDR      r0,[r4,#0]            ;255
000078  6880              LDR      r0,[r0,#8]            ;255
00007a  2110              MOVS     r1,#0x10              ;255
00007c  4388              BICS     r0,r0,r1              ;255
00007e  6821              LDR      r1,[r4,#0]            ;255
000080  6088              STR      r0,[r1,#8]            ;255
000082  6820              LDR      r0,[r4,#0]            ;256
000084  6d40              LDR      r0,[r0,#0x54]         ;256
000086  0840              LSRS     r0,r0,#1              ;256
000088  0040              LSLS     r0,r0,#1              ;256
00008a  6821              LDR      r1,[r4,#0]            ;256
00008c  6548              STR      r0,[r1,#0x54]         ;256
00008e  6820              LDR      r0,[r4,#0]            ;257
000090  6900              LDR      r0,[r0,#0x10]         ;257
000092  217c              MOVS     r1,#0x7c              ;257
000094  4388              BICS     r0,r0,r1              ;257
000096  300c              ADDS     r0,r0,#0xc            ;257
000098  6821              LDR      r1,[r4,#0]            ;257
00009a  6108              STR      r0,[r1,#0x10]         ;257
00009c  6820              LDR      r0,[r4,#0]            ;258
00009e  6dc0              LDR      r0,[r0,#0x5c]         ;258
0000a0  0840              LSRS     r0,r0,#1              ;258
0000a2  0040              LSLS     r0,r0,#1              ;258
0000a4  6821              LDR      r1,[r4,#0]            ;258
0000a6  65c8              STR      r0,[r1,#0x5c]         ;258
0000a8  6820              LDR      r0,[r4,#0]            ;262
0000aa  6a00              LDR      r0,[r0,#0x20]         ;262
0000ac  21c0              MOVS     r1,#0xc0              ;262
0000ae  4308              ORRS     r0,r0,r1              ;262
0000b0  6821              LDR      r1,[r4,#0]            ;262
0000b2  6208              STR      r0,[r1,#0x20]         ;262
0000b4  6820              LDR      r0,[r4,#0]            ;264
0000b6  3040              ADDS     r0,r0,#0x40           ;264
0000b8  7f00              LDRB     r0,[r0,#0x1c]         ;264
0000ba  0841              LSRS     r1,r0,#1              ;264
0000bc  0049              LSLS     r1,r1,#1              ;264
0000be  6820              LDR      r0,[r4,#0]            ;264
0000c0  3040              ADDS     r0,r0,#0x40           ;264
0000c2  7701              STRB     r1,[r0,#0x1c]         ;264
0000c4  4808              LDR      r0,|L22.232|
0000c6  6821              LDR      r1,[r4,#0]            ;269
0000c8  6008              STR      r0,[r1,#0]            ;269
0000ca  4807              LDR      r0,|L22.232|
0000cc  384c              SUBS     r0,r0,#0x4c           ;271
0000ce  6821              LDR      r1,[r4,#0]            ;271
0000d0  6048              STR      r0,[r1,#4]            ;271
0000d2  6820              LDR      r0,[r4,#0]            ;275
0000d4  6900              LDR      r0,[r0,#0x10]         ;275
0000d6  2101              MOVS     r1,#1                 ;275
0000d8  4308              ORRS     r0,r0,r1              ;275
0000da  6821              LDR      r1,[r4,#0]            ;275
0000dc  6108              STR      r0,[r1,#0x10]         ;275
0000de  4620              MOV      r0,r4                 ;280
0000e0  f7fffffe          BL       MID_URT_CheckIdleState
0000e4  e791              B        |L22.10|
;;;283    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L22.232|
                          DCD      0x00f0004d

                          AREA ||i.MID_URT_IRQHandler||, CODE, READONLY, ALIGN=2

                  MID_URT_IRQHandler PROC
;;;1720    */
;;;1721   void MID_URT_IRQHandler( URT_HandleTypeDef* MURT )
000000  b570              PUSH     {r4-r6,lr}
;;;1722   {
000002  4604              MOV      r4,r0
;;;1723       uint32_t MID_URTIRQ_Flag;
;;;1724   
;;;1725   
;;;1726       MID_URTIRQ_Flag = (READ_REG( MURT->Instance->STA.W)) & (READ_REG( MURT->Instance->INT.W));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  6849              LDR      r1,[r1,#4]
00000c  4008              ANDS     r0,r0,r1
00000e  4605              MOV      r5,r0
;;;1727       //===============================================================
;;;1728       //If no error occur
;;;1729       if((MID_URTIRQ_Flag & URT_IT_ERR) == 0)
000010  2008              MOVS     r0,#8
000012  4028              ANDS     r0,r0,r5
000014  2800              CMP      r0,#0
000016  d107              BNE      |L23.40|
;;;1730       {
;;;1731           if((MID_URTIRQ_Flag & URT_IT_RX)!=0)
000018  2040              MOVS     r0,#0x40
00001a  4028              ANDS     r0,r0,r5
00001c  2800              CMP      r0,#0
00001e  d003              BEQ      |L23.40|
;;;1732           {
;;;1733               ifun_URT_Receive_IT(MURT);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       ifun_URT_Receive_IT
                  |L23.38|
;;;1734               return;
;;;1735           }
;;;1736       }
;;;1737       //===============================================================
;;;1738       //If some error occur.
;;;1739       if( ( MID_URTIRQ_Flag & URT_IT_ERR)!=0)
;;;1740       {
;;;1741           //---------------------------------------------------------------
;;;1742           //URT parity error interrupt occurred
;;;1743           if((MID_URTIRQ_Flag & URT_IT_PE) !=0)
;;;1744           {
;;;1745               __DRV_URT_CLEAR_FLAG( MURT , URT_IT_PE);
;;;1746               
;;;1747               MURT->ErrorCode = MURT->ErrorCode | MID_URT_ERROR_PE;            
;;;1748           }  
;;;1749           //---------------------------------------------------------------
;;;1750           //URT frame error interrupt occurred
;;;1751           if((MID_URTIRQ_Flag & URT_IT_FE) !=0)
;;;1752           {
;;;1753               __DRV_URT_CLEAR_FLAG( MURT , URT_IT_FE);
;;;1754               
;;;1755               MURT->ErrorCode = MURT->ErrorCode | MID_URT_ERROR_FE;            
;;;1756           }
;;;1757           //---------------------------------------------------------------
;;;1758           //URT noise error interrupt occurred
;;;1759           if((MID_URTIRQ_Flag & URT_IT_NCE) !=0)
;;;1760           {
;;;1761               __DRV_URT_CLEAR_FLAG( MURT , URT_IT_NCE);
;;;1762               
;;;1763               MURT->ErrorCode = MURT->ErrorCode | MID_URT_ERROR_NE;            
;;;1764           }
;;;1765           //---------------------------------------------------------------
;;;1766           //URT over-run interrupt occurred
;;;1767           if((MID_URTIRQ_Flag & URT_IT_ROVR) !=0)
;;;1768           {
;;;1769               __DRV_URT_CLEAR_FLAG( MURT , URT_IT_ROVR);
;;;1770               
;;;1771               MURT->ErrorCode = MURT->ErrorCode | MID_URT_ERROR_ORE;            
;;;1772           }
;;;1773           //===============================================================
;;;1774           //Call URT Error call back function if need be
;;;1775           if( MURT->ErrorCode != MID_URT_ERROR_NONE)
;;;1776           {
;;;1777               //---------------------------------------------------------------
;;;1778               //Block error : transfer is aborted
;;;1779               //Set the URT state ready to be able to start again the process,
;;;1780               //Disable RX Interrupts, and disable Rx DMA request, if on going
;;;1781               ifun_URT_EndRxTransfer(MURT);
;;;1782               
;;;1783               //---------------------------------------------------------------
;;;1784               //URT in mode Receiver.
;;;1785               if( (MID_URTIRQ_Flag & URT_IT_RX)!=0)
;;;1786               {
;;;1787                   ifun_URT_Receive_IT(MURT);
;;;1788               }
;;;1789               //===============================================================
;;;1790               //If overrun error occurs , or if any error occurs in 
;;;1791               //DMA mode reception, consider error as blocking.
;;;1792               
;;;1793               //---------------------------------------------------------------
;;;1794               //Disable the URT DMA RX request if enabled
;;;1795               if( READ_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0)
;;;1796               {
;;;1797                   CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
;;;1798                   
;;;1799                   //---------------------------------------------------------------
;;;1800                   //Abort the URT DMA Rx channel.
;;;1801                   if( MURT->mDMA_RX != NULL)
;;;1802                   {
;;;1803                       //---------------------------------------------------------------
;;;1804                       //Set the URT DMA abort callback :
;;;1805                       //will lead to call MID_URT_ErrorCallback() at end of
;;;1806                       //DMA abort procedure
;;;1807                       MURT->mDMA_RX->XferAbortCallback = ifun_URT_DMAAbortOnError;
;;;1808                       
;;;1809                       //---------------------------------------------------------------
;;;1810                       //Abort DMA RX
;;;1811                       if( MID_DMA_Abort_IT( MURT->mDMA_RX) != MID_OK)
;;;1812                       {
;;;1813                           //---------------------------------------------------------------
;;;1814                           //Call directly MURT->mDMA_RX->XferAbortCallback 
;;;1815                           //function in case of error.
;;;1816                           MURT->mDMA_RX->XferAbortCallback( MURT->mDMA_RX);        
;;;1817                       }
;;;1818                   }
;;;1819                   else
;;;1820                   {
;;;1821                       //---------------------------------------------------------------
;;;1822                       //Call user error callback
;;;1823                       MID_URT_ErrorCallback(MURT);
;;;1824                   }
;;;1825               }
;;;1826               else
;;;1827               {
;;;1828                   //---------------------------------------------------------------
;;;1829                   //Call user error calback.
;;;1830                   MID_URT_ErrorCallback(MURT);
;;;1831               }
;;;1832           }
;;;1833       }
;;;1834       //==============================================================
;;;1835       //URT in mode Transmitter 
;;;1836       if((MID_URTIRQ_Flag & URT_IT_TX)!=0 )
;;;1837       {
;;;1838           ifun_URT_Transmit_IT( MURT);
;;;1839           return;
;;;1840       }
;;;1841       //==============================================================
;;;1842       //URT in mode transmitter (transmission end)
;;;1843       if(( MID_URTIRQ_Flag & URT_IT_TC)!=0 )
;;;1844       {
;;;1845           ifun_URT_EndTransmit_IT( MURT);
;;;1846           return;
;;;1847       }
;;;1848   }
000026  bd70              POP      {r4-r6,pc}
                  |L23.40|
000028  2008              MOVS     r0,#8                 ;1739
00002a  4028              ANDS     r0,r0,r5              ;1739
00002c  2800              CMP      r0,#0                 ;1739
00002e  d062              BEQ      |L23.246|
000030  2001              MOVS     r0,#1                 ;1743
000032  0500              LSLS     r0,r0,#20             ;1743
000034  4028              ANDS     r0,r0,r5              ;1743
000036  2800              CMP      r0,#0                 ;1743
000038  d007              BEQ      |L23.74|
00003a  2001              MOVS     r0,#1                 ;1745
00003c  0500              LSLS     r0,r0,#20             ;1745
00003e  6821              LDR      r1,[r4,#0]            ;1745
000040  6008              STR      r0,[r1,#0]            ;1745
000042  6c60              LDR      r0,[r4,#0x44]         ;1747
000044  2101              MOVS     r1,#1                 ;1747
000046  4308              ORRS     r0,r0,r1              ;1747
000048  6460              STR      r0,[r4,#0x44]         ;1747
                  |L23.74|
00004a  2001              MOVS     r0,#1                 ;1751
00004c  0540              LSLS     r0,r0,#21             ;1751
00004e  4028              ANDS     r0,r0,r5              ;1751
000050  2800              CMP      r0,#0                 ;1751
000052  d007              BEQ      |L23.100|
000054  2001              MOVS     r0,#1                 ;1753
000056  0540              LSLS     r0,r0,#21             ;1753
000058  6821              LDR      r1,[r4,#0]            ;1753
00005a  6008              STR      r0,[r1,#0]            ;1753
00005c  6c60              LDR      r0,[r4,#0x44]         ;1755
00005e  2104              MOVS     r1,#4                 ;1755
000060  4308              ORRS     r0,r0,r1              ;1755
000062  6460              STR      r0,[r4,#0x44]         ;1755
                  |L23.100|
000064  2001              MOVS     r0,#1                 ;1759
000066  0580              LSLS     r0,r0,#22             ;1759
000068  4028              ANDS     r0,r0,r5              ;1759
00006a  2800              CMP      r0,#0                 ;1759
00006c  d007              BEQ      |L23.126|
00006e  2001              MOVS     r0,#1                 ;1761
000070  0580              LSLS     r0,r0,#22             ;1761
000072  6821              LDR      r1,[r4,#0]            ;1761
000074  6008              STR      r0,[r1,#0]            ;1761
000076  6c60              LDR      r0,[r4,#0x44]         ;1763
000078  2102              MOVS     r1,#2                 ;1763
00007a  4308              ORRS     r0,r0,r1              ;1763
00007c  6460              STR      r0,[r4,#0x44]         ;1763
                  |L23.126|
00007e  2001              MOVS     r0,#1                 ;1767
000080  05c0              LSLS     r0,r0,#23             ;1767
000082  4028              ANDS     r0,r0,r5              ;1767
000084  2800              CMP      r0,#0                 ;1767
000086  d007              BEQ      |L23.152|
000088  2001              MOVS     r0,#1                 ;1769
00008a  05c0              LSLS     r0,r0,#23             ;1769
00008c  6821              LDR      r1,[r4,#0]            ;1769
00008e  6008              STR      r0,[r1,#0]            ;1769
000090  6c60              LDR      r0,[r4,#0x44]         ;1771
000092  2108              MOVS     r1,#8                 ;1771
000094  4308              ORRS     r0,r0,r1              ;1771
000096  6460              STR      r0,[r4,#0x44]         ;1771
                  |L23.152|
000098  6c60              LDR      r0,[r4,#0x44]         ;1775
00009a  2800              CMP      r0,#0                 ;1775
00009c  d02b              BEQ      |L23.246|
00009e  4620              MOV      r0,r4                 ;1781
0000a0  f7fffffe          BL       ifun_URT_EndRxTransfer
0000a4  2040              MOVS     r0,#0x40              ;1785
0000a6  4028              ANDS     r0,r0,r5              ;1785
0000a8  2800              CMP      r0,#0                 ;1785
0000aa  d002              BEQ      |L23.178|
0000ac  4620              MOV      r0,r4                 ;1787
0000ae  f7fffffe          BL       ifun_URT_Receive_IT
                  |L23.178|
0000b2  6820              LDR      r0,[r4,#0]            ;1795
0000b4  6900              LDR      r0,[r0,#0x10]         ;1795
0000b6  2101              MOVS     r1,#1                 ;1795
0000b8  0789              LSLS     r1,r1,#30             ;1795
0000ba  4008              ANDS     r0,r0,r1              ;1795
0000bc  2800              CMP      r0,#0                 ;1795
0000be  d017              BEQ      |L23.240|
0000c0  6820              LDR      r0,[r4,#0]            ;1797
0000c2  6900              LDR      r0,[r0,#0x10]         ;1797
0000c4  4388              BICS     r0,r0,r1              ;1797
0000c6  6821              LDR      r1,[r4,#0]            ;1797
0000c8  6108              STR      r0,[r1,#0x10]         ;1797
0000ca  6be0              LDR      r0,[r4,#0x3c]         ;1801
0000cc  2800              CMP      r0,#0                 ;1801
0000ce  d00b              BEQ      |L23.232|
0000d0  4812              LDR      r0,|L23.284|
0000d2  6be1              LDR      r1,[r4,#0x3c]         ;1807
0000d4  6388              STR      r0,[r1,#0x38]         ;1807
0000d6  6be0              LDR      r0,[r4,#0x3c]         ;1811
0000d8  f7fffffe          BL       MID_DMA_Abort_IT
0000dc  2800              CMP      r0,#0                 ;1811
0000de  d00a              BEQ      |L23.246|
0000e0  6be0              LDR      r0,[r4,#0x3c]         ;1816
0000e2  6b81              LDR      r1,[r0,#0x38]         ;1816
0000e4  4788              BLX      r1                    ;1816
0000e6  e006              B        |L23.246|
                  |L23.232|
0000e8  4620              MOV      r0,r4                 ;1823
0000ea  f7fffffe          BL       MID_URT_ErrorCallback
0000ee  e002              B        |L23.246|
                  |L23.240|
0000f0  4620              MOV      r0,r4                 ;1830
0000f2  f7fffffe          BL       MID_URT_ErrorCallback
                  |L23.246|
0000f6  2080              MOVS     r0,#0x80              ;1836
0000f8  4028              ANDS     r0,r0,r5              ;1836
0000fa  2800              CMP      r0,#0                 ;1836
0000fc  d003              BEQ      |L23.262|
0000fe  4620              MOV      r0,r4                 ;1838
000100  f7fffffe          BL       ifun_URT_Transmit_IT
000104  e78f              B        |L23.38|
                  |L23.262|
000106  2004              MOVS     r0,#4                 ;1843
000108  4028              ANDS     r0,r0,r5              ;1843
00010a  2800              CMP      r0,#0                 ;1843
00010c  d003              BEQ      |L23.278|
00010e  4620              MOV      r0,r4                 ;1845
000110  f7fffffe          BL       ifun_URT_EndTransmit_IT
000114  e787              B        |L23.38|
                  |L23.278|
000116  bf00              NOP      
000118  e785              B        |L23.38|
;;;1849   /**
                          ENDP

00011a  0000              DCW      0x0000
                  |L23.284|
                          DCD      ifun_URT_DMAAbortOnError

                          AREA ||i.MID_URT_Init||, CODE, READONLY, ALIGN=2

                  MID_URT_Init PROC
;;;67      */
;;;68     MID_StatusTypeDef MID_URT_Init( URT_HandleTypeDef* MURT)
000000  b510              PUSH     {r4,lr}
;;;69     {
000002  4604              MOV      r4,r0
;;;70         //===========================================================
;;;71         //Check the URT handle allocation.
;;;72         if(MURT == NULL)                                                                                                                  
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L24.12|
;;;73         {
;;;74             return(MID_FAILURE);
000008  2001              MOVS     r0,#1
                  |L24.10|
;;;75         }
;;;76         //============================================================
;;;77         //Check URT register address
;;;78         switch((uint32_t)(&MURT->Instance->STA.W))
;;;79         {
;;;80             case URT0_Base:
;;;81             #if defined(URT1_Base)
;;;82             case URT1_Base:
;;;83             #endif
;;;84             #if defined(URT2_Base)    
;;;85             case URT2_Base:
;;;86             #endif   
;;;87             #if defined(URT3_Base)
;;;88             case URT3_Base:
;;;89             #endif   
;;;90             #if defined(URT4_Base)
;;;91             case URT4_Base:
;;;92             #endif
;;;93             #if defined(URT5_Base)
;;;94             case URT5_Base:
;;;95             #endif
;;;96             #if defined(URT6_Base)
;;;97             case URT6_Base:
;;;98             #endif
;;;99             #if defined(URT7_Base)
;;;100            case URT7_Base:
;;;101            #endif         
;;;102                           break;
;;;103            default: 
;;;104                           return(MID_FAILURE);
;;;105        }
;;;106        
;;;107        //===========================================================                    
;;;108        if(MURT->gState == MID_URT_STATE_RESET)                                                
;;;109        {
;;;110            //-------------------------------------------
;;;111            //Allocate lock resource and initialize it.
;;;112            MURT->Lock = MID_UnLocked;
;;;113            
;;;114            //-------------------------------------------
;;;115            //Inital the low level hardware:
;;;116            //    * GPIO 
;;;117            //    * CLCOK         
;;;118            MID_URT_MspInit(MURT);                                                      
;;;119        }
;;;120        MURT->gState = MID_URT_STATE_BUSY;
;;;121        
;;;122        
;;;123        //===========================================================                           
;;;124        //Disable the peripheral
;;;125        __MID_URT_DISABLE(MURT);                                                                         
;;;126        
;;;127        //===========================================================                        
;;;128        //Set the URT communication parameters.
;;;129        if(MID_URT_SetConfig(MURT) == MID_FAILURE)                                                       
;;;130        {
;;;131            return(MID_FAILURE);
;;;132        }
;;;133        
;;;134        if(MURT->AdvancedInit.AdvFeatureInit != URT_ADVFEATURE_NO_INIT)                
;;;135        {
;;;136            MID_URT_AdvFeatureConfig(MURT);
;;;137        }
;;;138        
;;;139        //===========================================================                         
;;;140        //In asynchronous mode, the following bits must be kept cleared and setted.
;;;141        //    * CLK_EN bit be cleared in the URT_CLK register.
;;;142        //    * IrDA mode enable (IR_EN) be cleared in the URT_IRDA register.    
;;;143        //    * Be setted URT mode (MDS) to normal URT function in the URT_CR0 register. 
;;;144        //    * Half-duplex selection (HDX_EN) be cleared in the URT_CR0 register.
;;;145        //    * Data line select 2-lines (DAT_LINE) in the URT_CR0 register.     
;;;146        CLEAR_BIT(MURT->Instance->CLK.W,URT_CLK_CLK_EN_mask_w);
;;;147        CLEAR_BIT(MURT->Instance->IRDA.W,URT_IRDA_IR_EN_mask_w);
;;;148        URT_MODIFY_REG(MURT->Instance->CR0.W , (URT_CR0_MDS_mask_w | URT_CR0_HDX_EN_mask_w |URT_CR0_DAT_LINE_mask_w) , \
;;;149                                               (URT_CR0_MDS_uart_w | URT_CR0_HDX_EN_disable_w | URT_CR0_DAT_LINE_2_w));
;;;150        CLEAR_BIT( MURT->Instance->MUTE.W , URT_MUTE_MUTE_EN_mask_w);
;;;151        
;;;152       
;;;153        //===========================================================
;;;154        //Clear TX / RX Buffer
;;;155        SET_BIT( MURT->Instance->CR4.W , ( URT_CR4_TDAT_CLR_mask_w  | URT_CR4_RDAT_CLR_mask_w));
;;;156        #if defined(MG32_1ST)
;;;157            URT_CLEAR_BIT( MURT->Instance->MUTE.B[0] , URT_MUTE_MUTE_EN_enable_b0);
;;;158        #endif
;;;159        //=========================================================== 
;;;160        //-Clear All flag.
;;;161        //-Interrupt IE control 
;;;162        __DRV_URT_CLEAR_FLAG( MURT , (URT_FLAG_TC  | URT_FLAG_RX   | URT_FLAG_ERR | URT_FLAG_PE | URT_FLAG_FE | \
;;;163                                      URT_FLAG_NCE | URT_FLAG_ROVR | URT_FLAG_RHF));                                                                          
;;;164        WRITE_REG( MURT->Instance->INT.W , (URT_IT_PE | URT_IT_FE | URT_IT_NCE | URT_IT_ROVR | URT_ITEA));    
;;;165        
;;;166        
;;;167        
;;;168    
;;;169        //===========================================================                            
;;;170        //Enable the peripheral.
;;;171        __MID_URT_ENABLE(MURT);
;;;172        
;;;173        //===========================================================                            
;;;174        //TEACK and / or REACK to check before moving MURT->gState and 
;;;175        //MURT->RxState to Ready.    
;;;176        return(MID_URT_CheckIdleState(MURT));
;;;177    }
00000a  bd10              POP      {r4,pc}
                  |L24.12|
00000c  2157              MOVS     r1,#0x57              ;78
00000e  0649              LSLS     r1,r1,#25             ;78
000010  6820              LDR      r0,[r4,#0]            ;78
000012  1840              ADDS     r0,r0,r1              ;78
000014  2800              CMP      r0,#0                 ;78
000016  d008              BEQ      |L24.42|
000018  2101              MOVS     r1,#1                 ;78
00001a  0409              LSLS     r1,r1,#16             ;78
00001c  1a40              SUBS     r0,r0,r1              ;78
00001e  d005              BEQ      |L24.44|
000020  1a40              SUBS     r0,r0,r1              ;78
000022  d004              BEQ      |L24.46|
000024  1a40              SUBS     r0,r0,r1              ;78
000026  d104              BNE      |L24.50|
000028  e002              B        |L24.48|
                  |L24.42|
00002a  bf00              NOP                            ;82
                  |L24.44|
00002c  bf00              NOP                            ;85
                  |L24.46|
00002e  bf00              NOP                            ;88
                  |L24.48|
000030  e001              B        |L24.54|
                  |L24.50|
000032  2001              MOVS     r0,#1                 ;104
000034  e7e9              B        |L24.10|
                  |L24.54|
000036  bf00              NOP                            ;102
000038  2041              MOVS     r0,#0x41              ;108
00003a  5d00              LDRB     r0,[r0,r4]            ;108
00003c  2800              CMP      r0,#0                 ;108
00003e  d105              BNE      |L24.76|
000040  2100              MOVS     r1,#0                 ;112
000042  2040              MOVS     r0,#0x40              ;112
000044  5501              STRB     r1,[r0,r4]            ;112
000046  4620              MOV      r0,r4                 ;118
000048  f7fffffe          BL       MID_URT_MspInit
                  |L24.76|
00004c  2124              MOVS     r1,#0x24              ;120
00004e  2041              MOVS     r0,#0x41              ;120
000050  5501              STRB     r1,[r0,r4]            ;120
000052  6820              LDR      r0,[r4,#0]            ;125
000054  6900              LDR      r0,[r0,#0x10]         ;125
000056  0840              LSRS     r0,r0,#1              ;125
000058  0040              LSLS     r0,r0,#1              ;125
00005a  6821              LDR      r1,[r4,#0]            ;125
00005c  6108              STR      r0,[r1,#0x10]         ;125
00005e  4620              MOV      r0,r4                 ;129
000060  f7fffffe          BL       MID_URT_SetConfig
000064  2801              CMP      r0,#1                 ;129
000066  d100              BNE      |L24.106|
000068  e7cf              B        |L24.10|
                  |L24.106|
00006a  69a0              LDR      r0,[r4,#0x18]         ;134
00006c  2800              CMP      r0,#0                 ;134
00006e  d002              BEQ      |L24.118|
000070  4620              MOV      r0,r4                 ;136
000072  f7fffffe          BL       MID_URT_AdvFeatureConfig
                  |L24.118|
000076  6820              LDR      r0,[r4,#0]            ;146
000078  6880              LDR      r0,[r0,#8]            ;146
00007a  2110              MOVS     r1,#0x10              ;146
00007c  4388              BICS     r0,r0,r1              ;146
00007e  6821              LDR      r1,[r4,#0]            ;146
000080  6088              STR      r0,[r1,#8]            ;146
000082  6820              LDR      r0,[r4,#0]            ;147
000084  6d40              LDR      r0,[r0,#0x54]         ;147
000086  0840              LSRS     r0,r0,#1              ;147
000088  0040              LSLS     r0,r0,#1              ;147
00008a  6821              LDR      r1,[r4,#0]            ;147
00008c  6548              STR      r0,[r1,#0x54]         ;147
00008e  6820              LDR      r0,[r4,#0]            ;148
000090  6900              LDR      r0,[r0,#0x10]         ;148
000092  217c              MOVS     r1,#0x7c              ;148
000094  4388              BICS     r0,r0,r1              ;148
000096  6821              LDR      r1,[r4,#0]            ;148
000098  6108              STR      r0,[r1,#0x10]         ;148
00009a  6820              LDR      r0,[r4,#0]            ;150
00009c  6dc0              LDR      r0,[r0,#0x5c]         ;150
00009e  0840              LSRS     r0,r0,#1              ;150
0000a0  0040              LSLS     r0,r0,#1              ;150
0000a2  6821              LDR      r1,[r4,#0]            ;150
0000a4  65c8              STR      r0,[r1,#0x5c]         ;150
0000a6  6820              LDR      r0,[r4,#0]            ;155
0000a8  6a00              LDR      r0,[r0,#0x20]         ;155
0000aa  21c0              MOVS     r1,#0xc0              ;155
0000ac  4308              ORRS     r0,r0,r1              ;155
0000ae  6821              LDR      r1,[r4,#0]            ;155
0000b0  6208              STR      r0,[r1,#0x20]         ;155
0000b2  6820              LDR      r0,[r4,#0]            ;157
0000b4  3040              ADDS     r0,r0,#0x40           ;157
0000b6  7f00              LDRB     r0,[r0,#0x1c]         ;157
0000b8  0841              LSRS     r1,r0,#1              ;157
0000ba  0049              LSLS     r1,r1,#1              ;157
0000bc  6820              LDR      r0,[r4,#0]            ;157
0000be  3040              ADDS     r0,r0,#0x40           ;157
0000c0  7701              STRB     r1,[r0,#0x1c]         ;157
0000c2  4808              LDR      r0,|L24.228|
0000c4  6821              LDR      r1,[r4,#0]            ;162
0000c6  6008              STR      r0,[r1,#0]            ;162
0000c8  4806              LDR      r0,|L24.228|
0000ca  384c              SUBS     r0,r0,#0x4c           ;164
0000cc  6821              LDR      r1,[r4,#0]            ;164
0000ce  6048              STR      r0,[r1,#4]            ;164
0000d0  6820              LDR      r0,[r4,#0]            ;171
0000d2  6900              LDR      r0,[r0,#0x10]         ;171
0000d4  2101              MOVS     r1,#1                 ;171
0000d6  4308              ORRS     r0,r0,r1              ;171
0000d8  6821              LDR      r1,[r4,#0]            ;171
0000da  6108              STR      r0,[r1,#0x10]         ;171
0000dc  4620              MOV      r0,r4                 ;176
0000de  f7fffffe          BL       MID_URT_CheckIdleState
0000e2  e792              B        |L24.10|
;;;178    
                          ENDP

                  |L24.228|
                          DCD      0x00f0004d

                          AREA ||i.MID_URT_MspDeInit||, CODE, READONLY, ALIGN=1

                  MID_URT_MspDeInit PROC
;;;630     */
;;;631    __WEAK void MID_URT_MspDeInit(URT_HandleTypeDef* MURT)
000000  4770              BX       lr
;;;632    {
;;;633        //===========================================================
;;;634        //Prevent unsed argument(s) compilation warning
;;;635        UNUSED(MURT);
;;;636        
;;;637        //===========================================================
;;;638        //Note : This function should not be modified , when the callback is needed,
;;;639        //       the MID_URT_MspDeInit can be implemented in the user file.
;;;640        
;;;641    }
;;;642    
                          ENDP


                          AREA ||i.MID_URT_MspInit||, CODE, READONLY, ALIGN=1

                  MID_URT_MspInit PROC
;;;608     */
;;;609    __WEAK void MID_URT_MspInit(URT_HandleTypeDef* MURT)
000000  4770              BX       lr
;;;610    {
;;;611        //===========================================================
;;;612        //Prevent unsed argument(s) compilation warning
;;;613        UNUSED(MURT);
;;;614        
;;;615        //===========================================================
;;;616        //Note : This function should not be modified , when the callback is needed,
;;;617        //       the MID_URT_MspInit can be implemented in the user file.
;;;618        
;;;619    }
;;;620    
                          ENDP


                          AREA ||i.MID_URT_MultiProcessor_Init||, CODE, READONLY, ALIGN=2

                  MID_URT_MultiProcessor_Init PROC
;;;301     */
;;;302    MID_StatusTypeDef MID_URT_MultiProcessor_Init( URT_HandleTypeDef* MURT , uint8_t Address, uint8_t AddressMsk , uint8_t gAddressState)
000000  b5f8              PUSH     {r3-r7,lr}
;;;303    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;304        //===========================================================    
;;;305        //Check the URT handle allocation.
;;;306        if(MURT == NULL)                                                                                                                  
00000a  2c00              CMP      r4,#0
00000c  d101              BNE      |L27.18|
;;;307         {
;;;308             return(MID_FAILURE);
00000e  2001              MOVS     r0,#1
                  |L27.16|
;;;309         }
;;;310         //============================================================
;;;311         //Check URT register address
;;;312         switch((uint32_t)(&MURT->Instance->STA.W))
;;;313         {
;;;314             case URT0_Base:
;;;315            #if defined(URT1_Base)
;;;316            case URT1_Base:
;;;317            #endif
;;;318            #if defined(URT2_Base) 
;;;319            case URT2_Base:
;;;320            #endif   
;;;321            #if defined(URT3_Base)
;;;322            case URT3_Base:
;;;323            #endif           
;;;324                           break;
;;;325            default: 
;;;326                            return(MID_FAILURE);
;;;327         }
;;;328         //===========================================================                    
;;;329         if(MURT->gState == MID_URT_STATE_RESET)                                                
;;;330         {
;;;331             //-------------------------------------------
;;;332             //Allocate lock resource and initialize it.
;;;333             MURT->Lock = MID_UnLocked;
;;;334             
;;;335             //-------------------------------------------
;;;336             //Inital the low level hardware:
;;;337             //    * GPIO 
;;;338             //    * CLCOK         
;;;339             MID_URT_MspInit(MURT);                                                      
;;;340         }
;;;341         MURT->gState = MID_URT_STATE_BUSY;
;;;342         
;;;343         
;;;344        //===========================================================                           
;;;345        //Disable the peripheral
;;;346        __MID_URT_DISABLE(MURT);                                                                         
;;;347     
;;;348        //===========================================================                        
;;;349        //Set the URT communication parameters.
;;;350        if(MID_URT_SetConfig(MURT) == MID_FAILURE)                                                       
;;;351        {
;;;352            return(MID_FAILURE);
;;;353        }
;;;354        
;;;355        if(MURT->AdvancedInit.AdvFeatureInit != URT_ADVFEATURE_NO_INIT)                
;;;356        {
;;;357            MID_URT_AdvFeatureConfig(MURT);
;;;358        }
;;;359        //===========================================================                         
;;;360        //* In multiprocessor mode, the following bits must be kept cleared and setted.
;;;361        //    * CLK_EN bit be cleared in the URT_CLK register.
;;;362        //    * IrDA mode enable (IR_EN) be cleared in the URT_IRDA register.    
;;;363        //    * Be setted URT mode (MDS) to normal URT function in the URT_CR0 register. 
;;;364        //    * Half-duplex selection (HDX_EN) be cleared in the URT_CR0 register.
;;;365        //    * Data line select 2-lines (DAT_LINE) in the URT_CR0 register.     
;;;366        CLEAR_BIT(MURT->Instance->CLK.W,URT_CLK_CLK_EN_mask_w);
;;;367        CLEAR_BIT(MURT->Instance->IRDA.W,URT_IRDA_IR_EN_mask_w);
;;;368        URT_MODIFY_REG(MURT->Instance->CR0.W , (URT_CR0_MDS_mask_w | URT_CR0_HDX_EN_mask_w |URT_CR0_DAT_LINE_mask_w) , (URT_CR0_MDS_adr_w | URT_CR0_HDX_EN_disable_w | URT_CR0_DAT_LINE_2_w));
;;;369        SET_BIT( MURT->Instance->MUTE.W , URT_MUTE_MUTE_EN_mask_w);
;;;370        
;;;371        //==========================================================
;;;372        //Set the URT address node and address compare bit mask.
;;;373        
;;;374        #if defined(MG32_1ST)
;;;375            if( MURT->Init.WordLength == UART_WORDLENGTH_7B)
;;;376            {
;;;377                URT_WRITE_REG( MURT->Instance->SADR.B[0] , (Address<<1));
;;;378                URT_WRITE_REG( MURT->Instance->SADR.B[1] , (AddressMsk<<1));
;;;379            }
;;;380            else
;;;381            {
;;;382                URT_WRITE_REG(MURT->Instance->SADR.H[0], ((AddressMsk << 8) | Address));
;;;383            }
;;;384            URT_MODIFY_REG( MURT->Instance->CR0.B[0], URT_CR0_GSA_EN_mask_b0 , gAddressState);
;;;385            URT_SET_BIT( MURT->Instance->MUTE.B[0] , URT_MUTE_MUTE_EN_enable_b0);
;;;386        #else
;;;387            URT_WRITE_REG(MURT->Instance->SADR.H[0], ((AddressMsk << 8) | Address));
;;;388            URT_MODIFY_REG( MURT->Instance->CR0.B[0], URT_CR0_GSA_EN_mask_b0 , gAddressState);
;;;389        #endif
;;;390    
;;;391        //===========================================================
;;;392        //Clear TX / RX Buffer
;;;393        SET_BIT( MURT->Instance->CR4.W , ( URT_CR4_TDAT_CLR_mask_w  | URT_CR4_RDAT_CLR_mask_w));
;;;394        
;;;395        //=========================================================== 
;;;396        //-Clear All flag.
;;;397        //-Interrupt IE control 
;;;398        __DRV_URT_CLEAR_FLAG( MURT, (URT_FLAG_TC  | URT_FLAG_RX   | URT_FLAG_ERR | URT_FLAG_PE | URT_FLAG_FE | \
;;;399                                     URT_FLAG_NCE | URT_FLAG_ROVR | URT_FLAG_RHF));                                    
;;;400        WRITE_REG( MURT->Instance->INT.W , (URT_IT_PE | URT_IT_FE | URT_IT_NCE | URT_IT_ROVR | URT_ITEA));     
;;;401        
;;;402        //===========================================================                            
;;;403        //Enable the peripheral.
;;;404        __MID_URT_ENABLE(MURT);
;;;405        
;;;406        //===========================================================                            
;;;407        //TEACK and / or REACK to check before moving MURT->gState
;;;408        //and MURT->RxState to Ready.
;;;409        return(MID_URT_CheckIdleState(MURT));
;;;410    }
000010  bdf8              POP      {r3-r7,pc}
                  |L27.18|
000012  2157              MOVS     r1,#0x57              ;312
000014  0649              LSLS     r1,r1,#25             ;312
000016  6820              LDR      r0,[r4,#0]            ;312
000018  1840              ADDS     r0,r0,r1              ;312
00001a  2800              CMP      r0,#0                 ;312
00001c  d008              BEQ      |L27.48|
00001e  2101              MOVS     r1,#1                 ;312
000020  0409              LSLS     r1,r1,#16             ;312
000022  1a40              SUBS     r0,r0,r1              ;312
000024  d005              BEQ      |L27.50|
000026  1a40              SUBS     r0,r0,r1              ;312
000028  d004              BEQ      |L27.52|
00002a  1a40              SUBS     r0,r0,r1              ;312
00002c  d104              BNE      |L27.56|
00002e  e002              B        |L27.54|
                  |L27.48|
000030  bf00              NOP                            ;316
                  |L27.50|
000032  bf00              NOP                            ;319
                  |L27.52|
000034  bf00              NOP                            ;322
                  |L27.54|
000036  e001              B        |L27.60|
                  |L27.56|
000038  2001              MOVS     r0,#1                 ;326
00003a  e7e9              B        |L27.16|
                  |L27.60|
00003c  bf00              NOP                            ;324
00003e  2041              MOVS     r0,#0x41              ;329
000040  5d00              LDRB     r0,[r0,r4]            ;329
000042  2800              CMP      r0,#0                 ;329
000044  d105              BNE      |L27.82|
000046  2100              MOVS     r1,#0                 ;333
000048  2040              MOVS     r0,#0x40              ;333
00004a  5501              STRB     r1,[r0,r4]            ;333
00004c  4620              MOV      r0,r4                 ;339
00004e  f7fffffe          BL       MID_URT_MspInit
                  |L27.82|
000052  2124              MOVS     r1,#0x24              ;341
000054  2041              MOVS     r0,#0x41              ;341
000056  5501              STRB     r1,[r0,r4]            ;341
000058  6820              LDR      r0,[r4,#0]            ;346
00005a  6900              LDR      r0,[r0,#0x10]         ;346
00005c  0840              LSRS     r0,r0,#1              ;346
00005e  0040              LSLS     r0,r0,#1              ;346
000060  6821              LDR      r1,[r4,#0]            ;346
000062  6108              STR      r0,[r1,#0x10]         ;346
000064  4620              MOV      r0,r4                 ;350
000066  f7fffffe          BL       MID_URT_SetConfig
00006a  2801              CMP      r0,#1                 ;350
00006c  d100              BNE      |L27.112|
00006e  e7cf              B        |L27.16|
                  |L27.112|
000070  69a0              LDR      r0,[r4,#0x18]         ;355
000072  2800              CMP      r0,#0                 ;355
000074  d002              BEQ      |L27.124|
000076  4620              MOV      r0,r4                 ;357
000078  f7fffffe          BL       MID_URT_AdvFeatureConfig
                  |L27.124|
00007c  6820              LDR      r0,[r4,#0]            ;366
00007e  6880              LDR      r0,[r0,#8]            ;366
000080  2110              MOVS     r1,#0x10              ;366
000082  4388              BICS     r0,r0,r1              ;366
000084  6821              LDR      r1,[r4,#0]            ;366
000086  6088              STR      r0,[r1,#8]            ;366
000088  6820              LDR      r0,[r4,#0]            ;367
00008a  6d40              LDR      r0,[r0,#0x54]         ;367
00008c  0840              LSRS     r0,r0,#1              ;367
00008e  0040              LSLS     r0,r0,#1              ;367
000090  6821              LDR      r1,[r4,#0]            ;367
000092  6548              STR      r0,[r1,#0x54]         ;367
000094  6820              LDR      r0,[r4,#0]            ;368
000096  6900              LDR      r0,[r0,#0x10]         ;368
000098  217c              MOVS     r1,#0x7c              ;368
00009a  4388              BICS     r0,r0,r1              ;368
00009c  3030              ADDS     r0,r0,#0x30           ;368
00009e  6821              LDR      r1,[r4,#0]            ;368
0000a0  6108              STR      r0,[r1,#0x10]         ;368
0000a2  6820              LDR      r0,[r4,#0]            ;369
0000a4  6dc0              LDR      r0,[r0,#0x5c]         ;369
0000a6  2101              MOVS     r1,#1                 ;369
0000a8  4308              ORRS     r0,r0,r1              ;369
0000aa  6821              LDR      r1,[r4,#0]            ;369
0000ac  65c8              STR      r0,[r1,#0x5c]         ;369
0000ae  491d              LDR      r1,|L27.292|
0000b0  68a0              LDR      r0,[r4,#8]            ;375
0000b2  4288              CMP      r0,r1                 ;375
0000b4  d10a              BNE      |L27.204|
0000b6  0668              LSLS     r0,r5,#25             ;377
0000b8  0e01              LSRS     r1,r0,#24             ;377
0000ba  6820              LDR      r0,[r4,#0]            ;377
0000bc  3040              ADDS     r0,r0,#0x40           ;377
0000be  7301              STRB     r1,[r0,#0xc]          ;377
0000c0  0670              LSLS     r0,r6,#25             ;378
0000c2  0e01              LSRS     r1,r0,#24             ;378
0000c4  6820              LDR      r0,[r4,#0]            ;378
0000c6  304c              ADDS     r0,r0,#0x4c           ;378
0000c8  7041              STRB     r1,[r0,#1]            ;378
0000ca  e004              B        |L27.214|
                  |L27.204|
0000cc  0230              LSLS     r0,r6,#8              ;382
0000ce  4328              ORRS     r0,r0,r5              ;382
0000d0  6821              LDR      r1,[r4,#0]            ;382
0000d2  3140              ADDS     r1,r1,#0x40           ;382
0000d4  8188              STRH     r0,[r1,#0xc]          ;382
                  |L27.214|
0000d6  6820              LDR      r0,[r4,#0]            ;384
0000d8  7c00              LDRB     r0,[r0,#0x10]         ;384
0000da  2180              MOVS     r1,#0x80              ;384
0000dc  4388              BICS     r0,r0,r1              ;384
0000de  4338              ORRS     r0,r0,r7              ;384
0000e0  6821              LDR      r1,[r4,#0]            ;384
0000e2  7408              STRB     r0,[r1,#0x10]         ;384
0000e4  6820              LDR      r0,[r4,#0]            ;385
0000e6  3040              ADDS     r0,r0,#0x40           ;385
0000e8  7f00              LDRB     r0,[r0,#0x1c]         ;385
0000ea  2101              MOVS     r1,#1                 ;385
0000ec  4308              ORRS     r0,r0,r1              ;385
0000ee  6821              LDR      r1,[r4,#0]            ;385
0000f0  3140              ADDS     r1,r1,#0x40           ;385
0000f2  7708              STRB     r0,[r1,#0x1c]         ;385
0000f4  6820              LDR      r0,[r4,#0]            ;393
0000f6  6a00              LDR      r0,[r0,#0x20]         ;393
0000f8  21c0              MOVS     r1,#0xc0              ;393
0000fa  4308              ORRS     r0,r0,r1              ;393
0000fc  6821              LDR      r1,[r4,#0]            ;393
0000fe  6208              STR      r0,[r1,#0x20]         ;393
000100  4809              LDR      r0,|L27.296|
000102  6821              LDR      r1,[r4,#0]            ;398
000104  6008              STR      r0,[r1,#0]            ;398
000106  4808              LDR      r0,|L27.296|
000108  384c              SUBS     r0,r0,#0x4c           ;400
00010a  6821              LDR      r1,[r4,#0]            ;400
00010c  6048              STR      r0,[r1,#4]            ;400
00010e  6820              LDR      r0,[r4,#0]            ;404
000110  6900              LDR      r0,[r0,#0x10]         ;404
000112  2101              MOVS     r1,#1                 ;404
000114  4308              ORRS     r0,r0,r1              ;404
000116  6821              LDR      r1,[r4,#0]            ;404
000118  6108              STR      r0,[r1,#0x10]         ;404
00011a  4620              MOV      r0,r4                 ;409
00011c  f7fffffe          BL       MID_URT_CheckIdleState
000120  e776              B        |L27.16|
;;;411    
                          ENDP

000122  0000              DCW      0x0000
                  |L27.292|
                          DCD      0x00010001
                  |L27.296|
                          DCD      0x00f0004d

                          AREA ||i.MID_URT_RS485_Init||, CODE, READONLY, ALIGN=2

                  MID_URT_RS485_Init PROC
;;;435     */
;;;436    MID_StatusTypeDef MID_URT_RS485_Init( URT_HandleTypeDef *MURT, uint32_t URT_DE_POLARITY , uint32_t URT_DE_GT)
000000  b570              PUSH     {r4-r6,lr}
;;;437    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;438        //=========================================================
;;;439        //Check the URT handle allocation.
;;;440        if(MURT== NULL)
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L28.16|
;;;441        {
;;;442            return( MID_ERROR);
00000c  2001              MOVS     r0,#1
                  |L28.14|
;;;443        }
;;;444        //============================================================
;;;445        //Check URT register address
;;;446        switch((uint32_t)(&MURT->Instance->STA.W))
;;;447        {
;;;448            case URT0_Base:
;;;449            #if defined(URT1_Base)
;;;450            case URT1_Base:
;;;451            #endif
;;;452            #if defined(URT2_Base) 
;;;453            case URT2_Base:
;;;454            #endif   
;;;455            #if defined(URT3_Base)
;;;456            case URT3_Base:
;;;457            #endif           
;;;458                           break;
;;;459            default: 
;;;460                           return(MID_FAILURE);
;;;461        }
;;;462        //=========================================================
;;;463        if(MURT->gState == MID_URT_STATE_RESET)
;;;464        {
;;;465            //------------------------------------------------------
;;;466            //Allocate lock resource and initialize it.
;;;467            MURT->Lock = MID_UNLOCKED;
;;;468            //------------------------------------------------------
;;;469            //Init the low level hardware : (exsample for GPIO , CLOCK ......)
;;;470            MID_URT_MspInit(MURT);
;;;471        }
;;;472        
;;;473        MURT->gState = MID_URT_STATE_BUSY;
;;;474        
;;;475        //=========================================================
;;;476        // Disable the Peripheral
;;;477        __MID_URT_DISABLE(MURT);
;;;478        
;;;479        //========================================================
;;;480        //Set the UART Communication parameters.
;;;481        if( MID_URT_SetConfig( MURT) == MID_ERROR)
;;;482        {
;;;483            return(MID_ERROR);
;;;484        }
;;;485        if(MURT->AdvancedInit.AdvFeatureInit != URT_ADVFEATURE_NO_INIT)
;;;486        {
;;;487            MID_URT_AdvFeatureConfig( MURT);
;;;488        }
;;;489        
;;;490        //========================================================
;;;491        //Set : 
;;;492        //    1. Enable the DE mode  
;;;493        //    2. Set the DE polarity.
;;;494        //    3. Set the DE guard time.
;;;495        MODIFY_REG( MURT->Instance->CR0.W , ( URT_DEGUARDTIME_MASK | URT_DE_POLARITY_MASK) , ( URT_DE_POLARITY | URT_DE_GT));
;;;496        //===========================================================
;;;497        //Clear TX / RX Buffer
;;;498        SET_BIT( MURT->Instance->CR4.W , ( URT_CR4_TDAT_CLR_mask_w  | URT_CR4_RDAT_CLR_mask_w));
;;;499        #if defined(MG32_1ST)
;;;500            URT_CLEAR_BIT( MURT->Instance->MUTE.B[0] , URT_MUTE_MUTE_EN_enable_b0);
;;;501        #endif
;;;502        //=========================================================== 
;;;503        //-Clear All flag.
;;;504        //-Interrupt IE control  
;;;505        __DRV_URT_CLEAR_FLAG( MURT , (URT_FLAG_TC  | URT_FLAG_RX   | URT_FLAG_ERR | URT_FLAG_PE | URT_FLAG_FE | \
;;;506                                      URT_FLAG_NCE | URT_FLAG_ROVR | URT_FLAG_RHF));
;;;507        WRITE_REG( MURT->Instance->INT.W , (URT_IT_PE | URT_IT_FE | URT_IT_NCE | URT_IT_ROVR | URT_ITEA));     
;;;508        
;;;509        //========================================================
;;;510        //Enable the peripheral
;;;511        __MID_URT_ENABLE(MURT);
;;;512        
;;;513        //========================================================
;;;514        //MURT->gState and MURT->RxState to Ready.
;;;515        return(MID_URT_CheckIdleState(MURT));
;;;516    }
00000e  bd70              POP      {r4-r6,pc}
                  |L28.16|
000010  2157              MOVS     r1,#0x57              ;446
000012  0649              LSLS     r1,r1,#25             ;446
000014  6820              LDR      r0,[r4,#0]            ;446
000016  1840              ADDS     r0,r0,r1              ;446
000018  2800              CMP      r0,#0                 ;446
00001a  d008              BEQ      |L28.46|
00001c  2101              MOVS     r1,#1                 ;446
00001e  0409              LSLS     r1,r1,#16             ;446
000020  1a40              SUBS     r0,r0,r1              ;446
000022  d005              BEQ      |L28.48|
000024  1a40              SUBS     r0,r0,r1              ;446
000026  d004              BEQ      |L28.50|
000028  1a40              SUBS     r0,r0,r1              ;446
00002a  d104              BNE      |L28.54|
00002c  e002              B        |L28.52|
                  |L28.46|
00002e  bf00              NOP                            ;450
                  |L28.48|
000030  bf00              NOP                            ;453
                  |L28.50|
000032  bf00              NOP                            ;456
                  |L28.52|
000034  e001              B        |L28.58|
                  |L28.54|
000036  2001              MOVS     r0,#1                 ;460
000038  e7e9              B        |L28.14|
                  |L28.58|
00003a  bf00              NOP                            ;458
00003c  2041              MOVS     r0,#0x41              ;463
00003e  5d00              LDRB     r0,[r0,r4]            ;463
000040  2800              CMP      r0,#0                 ;463
000042  d105              BNE      |L28.80|
000044  2100              MOVS     r1,#0                 ;467
000046  2040              MOVS     r0,#0x40              ;467
000048  5501              STRB     r1,[r0,r4]            ;467
00004a  4620              MOV      r0,r4                 ;470
00004c  f7fffffe          BL       MID_URT_MspInit
                  |L28.80|
000050  2124              MOVS     r1,#0x24              ;473
000052  2041              MOVS     r0,#0x41              ;473
000054  5501              STRB     r1,[r0,r4]            ;473
000056  6820              LDR      r0,[r4,#0]            ;477
000058  6900              LDR      r0,[r0,#0x10]         ;477
00005a  0840              LSRS     r0,r0,#1              ;477
00005c  0040              LSLS     r0,r0,#1              ;477
00005e  6821              LDR      r1,[r4,#0]            ;477
000060  6108              STR      r0,[r1,#0x10]         ;477
000062  4620              MOV      r0,r4                 ;481
000064  f7fffffe          BL       MID_URT_SetConfig
000068  2801              CMP      r0,#1                 ;481
00006a  d100              BNE      |L28.110|
00006c  e7cf              B        |L28.14|
                  |L28.110|
00006e  69a0              LDR      r0,[r4,#0x18]         ;485
000070  2800              CMP      r0,#0                 ;485
000072  d002              BEQ      |L28.122|
000074  4620              MOV      r0,r4                 ;487
000076  f7fffffe          BL       MID_URT_AdvFeatureConfig
                  |L28.122|
00007a  6820              LDR      r0,[r4,#0]            ;495
00007c  6900              LDR      r0,[r0,#0x10]         ;495
00007e  210f              MOVS     r1,#0xf               ;495
000080  0309              LSLS     r1,r1,#12             ;495
000082  4388              BICS     r0,r0,r1              ;495
000084  4629              MOV      r1,r5                 ;495
000086  4331              ORRS     r1,r1,r6              ;495
000088  4308              ORRS     r0,r0,r1              ;495
00008a  6821              LDR      r1,[r4,#0]            ;495
00008c  6108              STR      r0,[r1,#0x10]         ;495
00008e  6820              LDR      r0,[r4,#0]            ;498
000090  6a00              LDR      r0,[r0,#0x20]         ;498
000092  21c0              MOVS     r1,#0xc0              ;498
000094  4308              ORRS     r0,r0,r1              ;498
000096  6821              LDR      r1,[r4,#0]            ;498
000098  6208              STR      r0,[r1,#0x20]         ;498
00009a  6820              LDR      r0,[r4,#0]            ;500
00009c  3040              ADDS     r0,r0,#0x40           ;500
00009e  7f00              LDRB     r0,[r0,#0x1c]         ;500
0000a0  0841              LSRS     r1,r0,#1              ;500
0000a2  0049              LSLS     r1,r1,#1              ;500
0000a4  6820              LDR      r0,[r4,#0]            ;500
0000a6  3040              ADDS     r0,r0,#0x40           ;500
0000a8  7701              STRB     r1,[r0,#0x1c]         ;500
0000aa  4808              LDR      r0,|L28.204|
0000ac  6821              LDR      r1,[r4,#0]            ;505
0000ae  6008              STR      r0,[r1,#0]            ;505
0000b0  4806              LDR      r0,|L28.204|
0000b2  384c              SUBS     r0,r0,#0x4c           ;507
0000b4  6821              LDR      r1,[r4,#0]            ;507
0000b6  6048              STR      r0,[r1,#4]            ;507
0000b8  6820              LDR      r0,[r4,#0]            ;511
0000ba  6900              LDR      r0,[r0,#0x10]         ;511
0000bc  2101              MOVS     r1,#1                 ;511
0000be  4308              ORRS     r0,r0,r1              ;511
0000c0  6821              LDR      r1,[r4,#0]            ;511
0000c2  6108              STR      r0,[r1,#0x10]         ;511
0000c4  4620              MOV      r0,r4                 ;515
0000c6  f7fffffe          BL       MID_URT_CheckIdleState
0000ca  e7a0              B        |L28.14|
;;;517    
                          ENDP

                  |L28.204|
                          DCD      0x00f0004d

                          AREA ||i.MID_URT_Receive||, CODE, READONLY, ALIGN=2

                  MID_URT_Receive PROC
;;;739     */
;;;740    MID_StatusTypeDef MID_URT_Receive(URT_HandleTypeDef* MURT, uint8_t* pDATA, uint16_t SIZE , uint32_t TIMEOUT)
000000  b5fe              PUSH     {r1-r7,lr}
;;;741    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;742        uint32_t  tickstart = 0;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;743    
;;;744        if(MURT->RxState == MID_URT_STATE_READY)
00000e  2042              MOVS     r0,#0x42
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d147              BNE      |L29.166|
;;;745        {
;;;746            //===========================================================
;;;747            //Check that a Rx process is not already on going.
;;;748            if((pDATA == NULL) || (SIZE == 0))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L29.30|
00001a  2e00              CMP      r6,#0
00001c  d101              BNE      |L29.34|
                  |L29.30|
;;;749            {
;;;750                return( MID_ERROR);
00001e  2001              MOVS     r0,#1
                  |L29.32|
;;;751            }
;;;752            
;;;753            //===========================================================
;;;754            //Process Locked
;;;755            __MID_LOCK(MURT);
;;;756            
;;;757            MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;758            MURT->RxState   = MID_URT_STATE_BUSY_RX;
;;;759            
;;;760            //===========================================================
;;;761            //Init tickstart for timeout managment
;;;762            tickstart = MID_GetTick();
;;;763            
;;;764            MURT->RxTransferSize  = SIZE;
;;;765            MURT->RxTransferCount = SIZE; 
;;;766            SET_BIT(MURT->Instance->CR4.W, URT_CR4_RDAT_CLR_mask_w);
;;;767            SET_BIT(MURT->Instance->STA.W, (URT_FLAG_RHF | URT_FLAG_RX | URT_FLAG_FE | URT_FLAG_PE | URT_FLAG_NCE | URT_FLAG_ROVR));
;;;768            
;;;769            //===========================================================
;;;770            //As long as data have to be received.
;;;771            while(MURT->RxTransferCount >0)
;;;772            {
;;;773                MURT->RxTransferCount = MURT->RxTransferCount - 1;
;;;774                
;;;775                if(MID_URT_WaitOnFlagUntilTimeout(MURT, URT_IT_RX, CLR, tickstart, TIMEOUT)!= MID_OK)
;;;776                {
;;;777                    return(MID_TIMEOUT);
;;;778                }
;;;779                
;;;780                *pDATA++ = (uint8_t)(MURT->Instance->RDAT.B[0]);
;;;781            }
;;;782            
;;;783            //===========================================================
;;;784            //At end of RX process.
;;;785            MURT->RxState = MID_URT_STATE_READY;
;;;786            
;;;787            //===========================================================
;;;788            //Process Unlocked
;;;789            __MID_UNLOCK(MURT);
;;;790            
;;;791            return(MID_OK);
;;;792        }
;;;793        else
;;;794        {
;;;795            return(MID_BUSY);
;;;796        }
;;;797    }
000020  bdfe              POP      {r1-r7,pc}
                  |L29.34|
000022  bf00              NOP                            ;755
000024  2040              MOVS     r0,#0x40              ;755
000026  5d00              LDRB     r0,[r0,r4]            ;755
000028  2801              CMP      r0,#1                 ;755
00002a  d101              BNE      |L29.48|
00002c  2002              MOVS     r0,#2                 ;755
00002e  e7f7              B        |L29.32|
                  |L29.48|
000030  2101              MOVS     r1,#1                 ;755
000032  2040              MOVS     r0,#0x40              ;755
000034  5501              STRB     r1,[r0,r4]            ;755
000036  bf00              NOP                            ;755
000038  2000              MOVS     r0,#0                 ;757
00003a  6460              STR      r0,[r4,#0x44]         ;757
00003c  2122              MOVS     r1,#0x22              ;758
00003e  2042              MOVS     r0,#0x42              ;758
000040  5501              STRB     r1,[r0,r4]            ;758
000042  f7fffffe          BL       MID_GetTick
000046  9001              STR      r0,[sp,#4]            ;762
000048  86a6              STRH     r6,[r4,#0x34]         ;764
00004a  86e6              STRH     r6,[r4,#0x36]         ;765
00004c  6820              LDR      r0,[r4,#0]            ;766
00004e  6a00              LDR      r0,[r0,#0x20]         ;766
000050  2140              MOVS     r1,#0x40              ;766
000052  4308              ORRS     r0,r0,r1              ;766
000054  6821              LDR      r1,[r4,#0]            ;766
000056  6208              STR      r0,[r1,#0x20]         ;766
000058  6820              LDR      r0,[r4,#0]            ;767
00005a  6800              LDR      r0,[r0,#0]            ;767
00005c  4913              LDR      r1,|L29.172|
00005e  4308              ORRS     r0,r0,r1              ;767
000060  6821              LDR      r1,[r4,#0]            ;767
000062  6008              STR      r0,[r1,#0]            ;767
000064  e012              B        |L29.140|
                  |L29.102|
000066  8ee0              LDRH     r0,[r4,#0x36]         ;773
000068  1e40              SUBS     r0,r0,#1              ;773
00006a  86e0              STRH     r0,[r4,#0x36]         ;773
00006c  9700              STR      r7,[sp,#0]            ;775
00006e  2200              MOVS     r2,#0                 ;775
000070  2140              MOVS     r1,#0x40              ;775
000072  4620              MOV      r0,r4                 ;775
000074  9b01              LDR      r3,[sp,#4]            ;775
000076  f7fffffe          BL       MID_URT_WaitOnFlagUntilTimeout
00007a  2800              CMP      r0,#0                 ;775
00007c  d001              BEQ      |L29.130|
00007e  2003              MOVS     r0,#3                 ;777
000080  e7ce              B        |L29.32|
                  |L29.130|
000082  6820              LDR      r0,[r4,#0]            ;780
000084  3020              ADDS     r0,r0,#0x20           ;780
000086  7c00              LDRB     r0,[r0,#0x10]         ;780
000088  7028              STRB     r0,[r5,#0]            ;780
00008a  1c6d              ADDS     r5,r5,#1              ;780
                  |L29.140|
00008c  8ee0              LDRH     r0,[r4,#0x36]         ;771
00008e  2800              CMP      r0,#0                 ;771
000090  dce9              BGT      |L29.102|
000092  2120              MOVS     r1,#0x20              ;785
000094  2042              MOVS     r0,#0x42              ;785
000096  5501              STRB     r1,[r0,r4]            ;785
000098  bf00              NOP                            ;789
00009a  2100              MOVS     r1,#0                 ;789
00009c  2040              MOVS     r0,#0x40              ;789
00009e  5501              STRB     r1,[r0,r4]            ;789
0000a0  bf00              NOP                            ;789
0000a2  2000              MOVS     r0,#0                 ;791
0000a4  e7bc              B        |L29.32|
                  |L29.166|
0000a6  2002              MOVS     r0,#2                 ;795
0000a8  e7ba              B        |L29.32|
;;;798    /**
                          ENDP

0000aa  0000              DCW      0x0000
                  |L29.172|
                          DCD      0x00f00041

                          AREA ||i.MID_URT_Receive_DMA||, CODE, READONLY, ALIGN=2

                  MID_URT_Receive_DMA PROC
;;;992     */
;;;993    MID_StatusTypeDef MID_URT_Receive_DMA( URT_HandleTypeDef *MURT , uint8_t *pDATA , uint16_t SIZE)
000000  b570              PUSH     {r4-r6,lr}
;;;994    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;995        //===============================================================
;;;996        //Check that RX process is not already on going.
;;;997        if( MURT->RxState == MID_URT_STATE_READY)
000008  2042              MOVS     r0,#0x42
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d157              BNE      |L30.192|
;;;998        {
;;;999            if(( pDATA == NULL) || (SIZE == 0U))
000010  2e00              CMP      r6,#0
000012  d001              BEQ      |L30.24|
000014  2d00              CMP      r5,#0
000016  d101              BNE      |L30.28|
                  |L30.24|
;;;1000           {
;;;1001               return( MID_ERROR);
000018  2001              MOVS     r0,#1
                  |L30.26|
;;;1002           }
;;;1003           
;;;1004           //===============================================================
;;;1005           //Process Locked 
;;;1006           __MID_LOCK(MURT);
;;;1007           
;;;1008           //===============================================================
;;;1009           MURT->pRXBuffPtr      = pDATA;
;;;1010           MURT->RxTransferSize  = SIZE;
;;;1011           
;;;1012           MURT->ErrorCode       = MID_URT_ERROR_NONE;
;;;1013           MURT->RxState         = MID_URT_STATE_BUSY_RX;
;;;1014           
;;;1015           SET_BIT(MURT->Instance->CR4.W, URT_CR4_RDAT_CLR_mask_w);
;;;1016           SET_BIT(MURT->Instance->STA.W, (URT_FLAG_RHF | URT_FLAG_RX | URT_FLAG_FE | URT_FLAG_PE | URT_FLAG_NCE | URT_FLAG_ROVR));
;;;1017           //===============================================================
;;;1018           //Set the UART DMA receive complete callback
;;;1019           MURT->mDMA_RX->XferCpltCallback     = ifun_URT_DMAReceiveCplt;
;;;1020           
;;;1021           //===============================================================
;;;1022           //Set the UART DMA Half receive complete callback
;;;1023           MURT->mDMA_RX->XferHalfCpltCallback = ifun_URT_DMARxHalfCplt; 
;;;1024           
;;;1025           //===============================================================
;;;1026           //Set the DMA error callback
;;;1027           MURT->mDMA_RX->XferErrorCallback = ifun_URT_DMAError;
;;;1028           
;;;1029           //===============================================================
;;;1030           //Set the DMA abort callback
;;;1031           MURT->mDMA_RX->XferAbortCallback = NULL;
;;;1032           
;;;1033           //===============================================================
;;;1034           //Enable the DMA channel
;;;1035           MID_DMA_Start_IT( MURT->mDMA_RX , (uint32_t)&MURT->Instance->RDAT.W, (uint32_t)MURT->pRXBuffPtr, SIZE);
;;;1036           
;;;1037           //===============================================================
;;;1038           //Process UnLocked 
;;;1039           __MID_UNLOCK(MURT);
;;;1040           
;;;1041           //===============================================================
;;;1042           //Enable the URT error interrupt ( PE , FE , NE , ROV)
;;;1043           SET_BIT( MURT->Instance->INT.W , (URT_IT_ERR));
;;;1044           
;;;1045           //===============================================================
;;;1046           //Enable the DMA transfer for the receiver request.
;;;1047           CLEAR_BIT( MURT->Instance->CR2.W , URT_CR2_RX_EN_mask_w);
;;;1048           SET_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
;;;1049           SET_BIT( MURT->Instance->CR2.W , URT_CR2_RX_EN_mask_w);
;;;1050           
;;;1051           return( MID_OK);
;;;1052       }
;;;1053       else
;;;1054       {
;;;1055           return( MID_BUSY);
;;;1056       }
;;;1057   }
00001a  bd70              POP      {r4-r6,pc}
                  |L30.28|
00001c  bf00              NOP                            ;1006
00001e  2040              MOVS     r0,#0x40              ;1006
000020  5d00              LDRB     r0,[r0,r4]            ;1006
000022  2801              CMP      r0,#1                 ;1006
000024  d101              BNE      |L30.42|
000026  2002              MOVS     r0,#2                 ;1006
000028  e7f7              B        |L30.26|
                  |L30.42|
00002a  2101              MOVS     r1,#1                 ;1006
00002c  2040              MOVS     r0,#0x40              ;1006
00002e  5501              STRB     r1,[r0,r4]            ;1006
000030  bf00              NOP                            ;1006
000032  6326              STR      r6,[r4,#0x30]         ;1009
000034  86a5              STRH     r5,[r4,#0x34]         ;1010
000036  2000              MOVS     r0,#0                 ;1012
000038  6460              STR      r0,[r4,#0x44]         ;1012
00003a  2122              MOVS     r1,#0x22              ;1013
00003c  2042              MOVS     r0,#0x42              ;1013
00003e  5501              STRB     r1,[r0,r4]            ;1013
000040  6820              LDR      r0,[r4,#0]            ;1015
000042  6a00              LDR      r0,[r0,#0x20]         ;1015
000044  2140              MOVS     r1,#0x40              ;1015
000046  4308              ORRS     r0,r0,r1              ;1015
000048  6821              LDR      r1,[r4,#0]            ;1015
00004a  6208              STR      r0,[r1,#0x20]         ;1015
00004c  6820              LDR      r0,[r4,#0]            ;1016
00004e  6800              LDR      r0,[r0,#0]            ;1016
000050  491c              LDR      r1,|L30.196|
000052  4308              ORRS     r0,r0,r1              ;1016
000054  6821              LDR      r1,[r4,#0]            ;1016
000056  6008              STR      r0,[r1,#0]            ;1016
000058  481b              LDR      r0,|L30.200|
00005a  6be1              LDR      r1,[r4,#0x3c]         ;1019
00005c  62c8              STR      r0,[r1,#0x2c]         ;1019
00005e  481b              LDR      r0,|L30.204|
000060  6be1              LDR      r1,[r4,#0x3c]         ;1023
000062  6308              STR      r0,[r1,#0x30]         ;1023
000064  481a              LDR      r0,|L30.208|
000066  6be1              LDR      r1,[r4,#0x3c]         ;1027
000068  6348              STR      r0,[r1,#0x34]         ;1027
00006a  2000              MOVS     r0,#0                 ;1031
00006c  6be1              LDR      r1,[r4,#0x3c]         ;1031
00006e  6388              STR      r0,[r1,#0x38]         ;1031
000070  6823              LDR      r3,[r4,#0]            ;1035
000072  4619              MOV      r1,r3                 ;1035
000074  3130              ADDS     r1,r1,#0x30           ;1035
000076  462b              MOV      r3,r5                 ;1035
000078  6b22              LDR      r2,[r4,#0x30]         ;1035
00007a  6be0              LDR      r0,[r4,#0x3c]         ;1035
00007c  f7fffffe          BL       MID_DMA_Start_IT
000080  bf00              NOP                            ;1039
000082  2100              MOVS     r1,#0                 ;1039
000084  2040              MOVS     r0,#0x40              ;1039
000086  5501              STRB     r1,[r0,r4]            ;1039
000088  bf00              NOP                            ;1039
00008a  6820              LDR      r0,[r4,#0]            ;1043
00008c  6840              LDR      r0,[r0,#4]            ;1043
00008e  2108              MOVS     r1,#8                 ;1043
000090  4308              ORRS     r0,r0,r1              ;1043
000092  6821              LDR      r1,[r4,#0]            ;1043
000094  6048              STR      r0,[r1,#4]            ;1043
000096  6820              LDR      r0,[r4,#0]            ;1047
000098  6980              LDR      r0,[r0,#0x18]         ;1047
00009a  2104              MOVS     r1,#4                 ;1047
00009c  4388              BICS     r0,r0,r1              ;1047
00009e  6821              LDR      r1,[r4,#0]            ;1047
0000a0  6188              STR      r0,[r1,#0x18]         ;1047
0000a2  6820              LDR      r0,[r4,#0]            ;1048
0000a4  6900              LDR      r0,[r0,#0x10]         ;1048
0000a6  2101              MOVS     r1,#1                 ;1048
0000a8  0789              LSLS     r1,r1,#30             ;1048
0000aa  4308              ORRS     r0,r0,r1              ;1048
0000ac  6821              LDR      r1,[r4,#0]            ;1048
0000ae  6108              STR      r0,[r1,#0x10]         ;1048
0000b0  6820              LDR      r0,[r4,#0]            ;1049
0000b2  6980              LDR      r0,[r0,#0x18]         ;1049
0000b4  2104              MOVS     r1,#4                 ;1049
0000b6  4308              ORRS     r0,r0,r1              ;1049
0000b8  6821              LDR      r1,[r4,#0]            ;1049
0000ba  6188              STR      r0,[r1,#0x18]         ;1049
0000bc  2000              MOVS     r0,#0                 ;1051
0000be  e7ac              B        |L30.26|
                  |L30.192|
0000c0  2002              MOVS     r0,#2                 ;1055
0000c2  e7aa              B        |L30.26|
;;;1058   
                          ENDP

                  |L30.196|
                          DCD      0x00f00041
                  |L30.200|
                          DCD      ifun_URT_DMAReceiveCplt
                  |L30.204|
                          DCD      ifun_URT_DMARxHalfCplt
                  |L30.208|
                          DCD      ifun_URT_DMAError

                          AREA ||i.MID_URT_Receive_IT||, CODE, READONLY, ALIGN=2

                  MID_URT_Receive_IT PROC
;;;865     */
;;;866    MID_StatusTypeDef MID_URT_Receive_IT( URT_HandleTypeDef* MURT, uint8_t *pDATA, uint16_t SIZE)
000000  b510              PUSH     {r4,lr}
;;;867    {
000002  4603              MOV      r3,r0
;;;868        if( MURT->RxState == MID_URT_STATE_READY)
000004  2042              MOVS     r0,#0x42
000006  5cc0              LDRB     r0,[r0,r3]
000008  2820              CMP      r0,#0x20
00000a  d131              BNE      |L31.112|
;;;869        {
;;;870            if((pDATA == NULL) || (SIZE == 0))
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L31.20|
000010  2a00              CMP      r2,#0
000012  d101              BNE      |L31.24|
                  |L31.20|
;;;871            {
;;;872                return( MID_ERROR);
000014  2001              MOVS     r0,#1
                  |L31.22|
;;;873            }
;;;874            
;;;875            __MID_LOCK(MURT);                                                                                                         // Process Locked 
;;;876            
;;;877            MURT->pRXBuffPtr      = pDATA;
;;;878            MURT->RxTransferSize  = SIZE;
;;;879            MURT->RxTransferCount = SIZE;        
;;;880            
;;;881            
;;;882            MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;883            MURT->RxState   = MID_URT_STATE_BUSY_RX;
;;;884            
;;;885            SET_BIT(MURT->Instance->CR4.W, URT_CR4_RDAT_CLR_mask_w);
;;;886            SET_BIT(MURT->Instance->STA.W, (URT_FLAG_RHF | URT_FLAG_RX | URT_FLAG_FE | URT_FLAG_PE | URT_FLAG_NCE | URT_FLAG_ROVR));
;;;887            __MID_UNLOCK(MURT);                                                                                                       // Process Unlocked
;;;888            
;;;889            //===============================================================
;;;890            //Enable 
;;;891            //    1. Enable the URT Error Interrupt : (Frame error , noise error , overrun error)
;;;892            //    2. the URT parity error interrupt .
;;;893            //    3. the URT data register not empty interrupt.
;;;894            SET_BIT( MURT->Instance->INT.W , (URT_IT_ERR | URT_IT_RX ));
;;;895            
;;;896            return(MID_OK);
;;;897        }
;;;898        else
;;;899        {
;;;900            return(MID_BUSY);
;;;901        }
;;;902    }
000016  bd10              POP      {r4,pc}
                  |L31.24|
000018  bf00              NOP                            ;875
00001a  2040              MOVS     r0,#0x40              ;875
00001c  5cc0              LDRB     r0,[r0,r3]            ;875
00001e  2801              CMP      r0,#1                 ;875
000020  d101              BNE      |L31.38|
000022  2002              MOVS     r0,#2                 ;875
000024  e7f7              B        |L31.22|
                  |L31.38|
000026  2401              MOVS     r4,#1                 ;875
000028  2040              MOVS     r0,#0x40              ;875
00002a  54c4              STRB     r4,[r0,r3]            ;875
00002c  bf00              NOP                            ;875
00002e  6319              STR      r1,[r3,#0x30]         ;877
000030  869a              STRH     r2,[r3,#0x34]         ;878
000032  86da              STRH     r2,[r3,#0x36]         ;879
000034  2000              MOVS     r0,#0                 ;882
000036  6458              STR      r0,[r3,#0x44]         ;882
000038  2422              MOVS     r4,#0x22              ;883
00003a  2042              MOVS     r0,#0x42              ;883
00003c  54c4              STRB     r4,[r0,r3]            ;883
00003e  6818              LDR      r0,[r3,#0]            ;885
000040  6a00              LDR      r0,[r0,#0x20]         ;885
000042  2440              MOVS     r4,#0x40              ;885
000044  4320              ORRS     r0,r0,r4              ;885
000046  681c              LDR      r4,[r3,#0]            ;885
000048  6220              STR      r0,[r4,#0x20]         ;885
00004a  6818              LDR      r0,[r3,#0]            ;886
00004c  6800              LDR      r0,[r0,#0]            ;886
00004e  4c09              LDR      r4,|L31.116|
000050  4320              ORRS     r0,r0,r4              ;886
000052  681c              LDR      r4,[r3,#0]            ;886
000054  6020              STR      r0,[r4,#0]            ;886
000056  bf00              NOP                            ;887
000058  2400              MOVS     r4,#0                 ;887
00005a  2040              MOVS     r0,#0x40              ;887
00005c  54c4              STRB     r4,[r0,r3]            ;887
00005e  bf00              NOP                            ;887
000060  6818              LDR      r0,[r3,#0]            ;894
000062  6840              LDR      r0,[r0,#4]            ;894
000064  2448              MOVS     r4,#0x48              ;894
000066  4320              ORRS     r0,r0,r4              ;894
000068  681c              LDR      r4,[r3,#0]            ;894
00006a  6060              STR      r0,[r4,#4]            ;894
00006c  2000              MOVS     r0,#0                 ;896
00006e  e7d2              B        |L31.22|
                  |L31.112|
000070  2002              MOVS     r0,#2                 ;900
000072  e7d0              B        |L31.22|
;;;903    
                          ENDP

                  |L31.116|
                          DCD      0x00f00041

                          AREA ||i.MID_URT_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_RxCpltCallback PROC
;;;1901    */
;;;1902   __WEAK void MID_URT_RxCpltCallback( URT_HandleTypeDef *MURT)
000000  4770              BX       lr
;;;1903   {
;;;1904       //=========================================================
;;;1905       // Prevent unused argument(s) compilation warning 
;;;1906       UNUSED( MURT);
;;;1907       
;;;1908       //=========================================================
;;;1909       //NOTE : This function should not be modifyed, when the 
;;;1910       //       callback is needed, the MID_URT_RxCpltCallback 
;;;1911       //       can be implemented in the user file.
;;;1912   }
;;;1913   /**
                          ENDP


                          AREA ||i.MID_URT_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_RxHalfCpltCallback PROC
;;;1922    */
;;;1923   __WEAK void MID_URT_RxHalfCpltCallback( URT_HandleTypeDef *MURT)
000000  4770              BX       lr
;;;1924   {
;;;1925       //=========================================================
;;;1926       // Prevent unused argument(s) compilation warning 
;;;1927       UNUSED( MURT);
;;;1928       
;;;1929       //=========================================================
;;;1930       //NOTE : This function should not be modifyed, when the 
;;;1931       //       callback is needed, the MID_URT_RxCpltCallback 
;;;1932       //       can be implemented in the user file.
;;;1933   }
;;;1934   /**
                          ENDP


                          AREA ||i.MID_URT_SetConfig||, CODE, READONLY, ALIGN=2

                  MID_URT_SetConfig PROC
;;;2132    */
;;;2133   MID_StatusTypeDef MID_URT_SetConfig(URT_HandleTypeDef* MURT)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2134   {
000002  4604              MOV      r4,r0
;;;2135       uint32_t   Tmp; 
;;;2136       uint32_t   TXRXOversampling;
;;;2137       uint32_t   URT_CLKFreq;
;;;2138       
;;;2139       uint8_t    OVSMP;
;;;2140       uint8_t    REM;
;;;2141       uint8_t    BST_SOL;
;;;2142       
;;;2143       //===========================================================
;;;2144       //* Configure:
;;;2145       //    * Set Data length according to MURT->Ini.DataLength value.
;;;2146       //    * Set pairty bit according to MURT->Init.Parity value.
;;;2147       //    * Set Stop bit according to MURT->Init.StopBits value.
;;;2148       
;;;2149       URT_MODIFY_REG( MURT->Instance->CR1.W , URT_INIT_CR1_MSK ,  (MURT->Init.WordLength | MURT->Init.Parity | MURT->Init.StopBits));
000004  6921              LDR      r1,[r4,#0x10]
000006  68a0              LDR      r0,[r4,#8]
000008  4308              ORRS     r0,r0,r1
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  4308              ORRS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6949              LDR      r1,[r1,#0x14]
000012  4a42              LDR      r2,|L34.284|
000014  4011              ANDS     r1,r1,r2
000016  4308              ORRS     r0,r0,r1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;2150       
;;;2151   
;;;2152       
;;;2153       //===========================================================
;;;2154       //* Set TX_EN and RX_EN bits according to MURT->Init.Mode.
;;;2155       URT_MODIFY_REG( MURT->Instance->CR2.W , URT_INIT_MODE_MSK ,  MURT->Init.Mode );
00001c  6820              LDR      r0,[r4,#0]
00001e  6980              LDR      r0,[r0,#0x18]
000020  210c              MOVS     r1,#0xc
000022  4388              BICS     r0,r0,r1
000024  7d21              LDRB     r1,[r4,#0x14]
000026  4308              ORRS     r0,r0,r1
000028  6821              LDR      r1,[r4,#0]
00002a  6188              STR      r0,[r1,#0x18]
;;;2156       
;;;2157       //===========================================================
;;;2158       //* Configure
;;;2159       //    * URT hardware flow control : (according to MURT->Init.HWFlowCtrl value) 
;;;2160       //        * CTS:
;;;2161       //        * RTS:
;;;2162       URT_MODIFY_REG( MURT->Instance->HFC.W , URT_INIT_HWFLOWCTRL_MSK , MURT->Init.HWFlowCtrl);
00002c  6820              LDR      r0,[r4,#0]
00002e  6d80              LDR      r0,[r0,#0x58]
000030  0900              LSRS     r0,r0,#4
000032  0100              LSLS     r0,r0,#4
000034  7d61              LDRB     r1,[r4,#0x15]
000036  4308              ORRS     r0,r0,r1
000038  6821              LDR      r1,[r4,#0]
00003a  6588              STR      r0,[r1,#0x58]
;;;2163       
;;;2164       //===========================================================
;;;2165       //* Configure one-bit sampling method.
;;;2166       URT_MODIFY_REG( MURT->Instance->CR0.B[0], URT_CR0_OS_MDS_mask_b0, MURT->Init.OneBitSampling);
00003c  6820              LDR      r0,[r4,#0]
00003e  7c00              LDRB     r0,[r0,#0x10]
000040  2102              MOVS     r1,#2
000042  4388              BICS     r0,r0,r1
000044  7da1              LDRB     r1,[r4,#0x16]
000046  4308              ORRS     r0,r0,r1
000048  6821              LDR      r1,[r4,#0]
00004a  7408              STRB     r0,[r1,#0x10]
;;;2167       
;;;2168       //===========================================================
;;;2169       //* URT baudrate configuration.
;;;2170       
;;;2171       //-----------------------------------------------------------
;;;2172       //* Operation setting parameters.
;;;2173       URT_CLKFreq = MID_URT_GetBRGClocksource( MURT);            
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       MID_URT_GetBRGClocksource
000052  9001              STR      r0,[sp,#4]
;;;2174       
;;;2175       
;;;2176       Tmp = (URT_CLKFreq / MURT->Init.BaudRate);
000054  6861              LDR      r1,[r4,#4]
000056  9801              LDR      r0,[sp,#4]
000058  f7fffffe          BL       __aeabi_uidivmod
00005c  4607              MOV      r7,r0
;;;2177       if(Tmp<8)
00005e  2f08              CMP      r7,#8
000060  d201              BCS      |L34.102|
;;;2178       {
;;;2179           return(MID_FAILURE);
000062  2001              MOVS     r0,#1
                  |L34.100|
;;;2180       }
;;;2181       else if((URT_CLKFreq % MURT->Init.BaudRate)>4)
;;;2182       {
;;;2183           Tmp = Tmp + 1;
;;;2184       } 
;;;2185       
;;;2186       BST_SOL = 0;
;;;2187       for(OVSMP=8;OVSMP<32;OVSMP++)
;;;2188       {
;;;2189           REM = Tmp % OVSMP;
;;;2190   
;;;2191           if(REM==0)
;;;2192           {
;;;2193               if((Tmp / OVSMP) < 4096)
;;;2194               {
;;;2195                   TXRXOversampling = OVSMP;
;;;2196                   break;
;;;2197               }
;;;2198           }
;;;2199           else 
;;;2200           {
;;;2201              if(REM==1 && OVSMP>15)
;;;2202              {
;;;2203                  TXRXOversampling = OVSMP;
;;;2204                  BST_SOL          = 48;
;;;2205              }
;;;2206              REM = OVSMP - REM;
;;;2207              if(REM > BST_SOL || REM==BST_SOL)
;;;2208              {
;;;2209                  BST_SOL = REM;
;;;2210                  TXRXOversampling = OVSMP;               
;;;2211              }
;;;2212           }
;;;2213       }
;;;2214       //-----------------------------------------------------------
;;;2215       //* Baud-Rate configure.
;;;2216       //    * Set RX/TX baudrate from Baud-Rate Generator (BRG)
;;;2217       //    * BRG clock source from CK_URT_PR (The URT module clock source)
;;;2218       //    * Set BRG reload data.
;;;2219       //    * Set TX / RX oversampling.
;;;2220       //    * Set BRG mode to Combined mode and enable BRG.
;;;2221       CLEAR_BIT(MURT->Instance->CLK.W , (URT_CLK_TX_CKS_mask_w| URT_CLK_RX_CKS_mask_w | URT_CLK_CK_SEL_mask_w));
;;;2222       
;;;2223       Tmp = Tmp / (TXRXOversampling);
;;;2224       if(Tmp>4096)
;;;2225       {
;;;2226           return(MID_FAILURE);
;;;2227       }
;;;2228       
;;;2229       URT_WRITE_REG(MURT->Instance->RLR.H[0], (Tmp - 1));
;;;2230       
;;;2231       TXRXOversampling = TXRXOversampling - 1;
;;;2232       URT_WRITE_REG(MURT->Instance->CR1.B[3] , TXRXOversampling);
;;;2233       URT_WRITE_REG(MURT->Instance->CR1.B[1] , TXRXOversampling);
;;;2234       
;;;2235       SET_BIT(MURT->Instance->CLK.W, (URT_CLK_BR_MDS_mask_w | URT_CLK_BR_EN_mask_w));
;;;2236       
;;;2237       
;;;2238       return(MID_SUCCESS);
;;;2239   }
000064  bdfe              POP      {r1-r7,pc}
                  |L34.102|
000066  6861              LDR      r1,[r4,#4]            ;2181
000068  9801              LDR      r0,[sp,#4]            ;2181
00006a  f7fffffe          BL       __aeabi_uidivmod
00006e  2904              CMP      r1,#4                 ;2181
000070  d900              BLS      |L34.116|
000072  1c7f              ADDS     r7,r7,#1              ;2183
                  |L34.116|
000074  2000              MOVS     r0,#0                 ;2186
000076  9000              STR      r0,[sp,#0]            ;2186
000078  2508              MOVS     r5,#8                 ;2187
00007a  e023              B        |L34.196|
                  |L34.124|
00007c  4629              MOV      r1,r5                 ;2189
00007e  4638              MOV      r0,r7                 ;2189
000080  f7fffffe          BL       __aeabi_uidivmod
000084  b2ce              UXTB     r6,r1                 ;2189
000086  2e00              CMP      r6,#0                 ;2191
000088  d109              BNE      |L34.158|
00008a  4629              MOV      r1,r5                 ;2193
00008c  4638              MOV      r0,r7                 ;2193
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  2101              MOVS     r1,#1                 ;2193
000094  0309              LSLS     r1,r1,#12             ;2193
000096  4288              CMP      r0,r1                 ;2193
000098  d212              BCS      |L34.192|
00009a  9502              STR      r5,[sp,#8]            ;2195
00009c  e014              B        |L34.200|
                  |L34.158|
00009e  2e01              CMP      r6,#1                 ;2201
0000a0  d104              BNE      |L34.172|
0000a2  2d0f              CMP      r5,#0xf               ;2201
0000a4  dd02              BLE      |L34.172|
0000a6  9502              STR      r5,[sp,#8]            ;2203
0000a8  2030              MOVS     r0,#0x30              ;2204
0000aa  9000              STR      r0,[sp,#0]            ;2204
                  |L34.172|
0000ac  1ba8              SUBS     r0,r5,r6              ;2206
0000ae  b2c6              UXTB     r6,r0                 ;2206
0000b0  9800              LDR      r0,[sp,#0]            ;2207
0000b2  4286              CMP      r6,r0                 ;2207
0000b4  dc02              BGT      |L34.188|
0000b6  9800              LDR      r0,[sp,#0]            ;2207
0000b8  4286              CMP      r6,r0                 ;2207
0000ba  d101              BNE      |L34.192|
                  |L34.188|
0000bc  9600              STR      r6,[sp,#0]            ;2209
0000be  9502              STR      r5,[sp,#8]            ;2210
                  |L34.192|
0000c0  1c68              ADDS     r0,r5,#1              ;2187
0000c2  b2c5              UXTB     r5,r0                 ;2187
                  |L34.196|
0000c4  2d20              CMP      r5,#0x20              ;2187
0000c6  dbd9              BLT      |L34.124|
                  |L34.200|
0000c8  bf00              NOP                            ;2196
0000ca  6820              LDR      r0,[r4,#0]            ;2221
0000cc  6880              LDR      r0,[r0,#8]            ;2221
0000ce  4914              LDR      r1,|L34.288|
0000d0  4008              ANDS     r0,r0,r1              ;2221
0000d2  6821              LDR      r1,[r4,#0]            ;2221
0000d4  6088              STR      r0,[r1,#8]            ;2221
0000d6  4638              MOV      r0,r7                 ;2223
0000d8  9902              LDR      r1,[sp,#8]            ;2223
0000da  f7fffffe          BL       __aeabi_uidivmod
0000de  4607              MOV      r7,r0                 ;2223
0000e0  2001              MOVS     r0,#1                 ;2224
0000e2  0300              LSLS     r0,r0,#12             ;2224
0000e4  4287              CMP      r7,r0                 ;2224
0000e6  d901              BLS      |L34.236|
0000e8  2001              MOVS     r0,#1                 ;2226
0000ea  e7bb              B        |L34.100|
                  |L34.236|
0000ec  1e78              SUBS     r0,r7,#1              ;2229
0000ee  6821              LDR      r1,[r4,#0]            ;2229
0000f0  8488              STRH     r0,[r1,#0x24]         ;2229
0000f2  9802              LDR      r0,[sp,#8]            ;2231
0000f4  1e40              SUBS     r0,r0,#1              ;2231
0000f6  9002              STR      r0,[sp,#8]            ;2231
0000f8  9802              LDR      r0,[sp,#8]            ;2232
0000fa  b2c1              UXTB     r1,r0                 ;2232
0000fc  6820              LDR      r0,[r4,#0]            ;2232
0000fe  75c1              STRB     r1,[r0,#0x17]         ;2232
000100  9802              LDR      r0,[sp,#8]            ;2233
000102  b2c1              UXTB     r1,r0                 ;2233
000104  6820              LDR      r0,[r4,#0]            ;2233
000106  7541              STRB     r1,[r0,#0x15]         ;2233
000108  6820              LDR      r0,[r4,#0]            ;2235
00010a  6880              LDR      r0,[r0,#8]            ;2235
00010c  2103              MOVS     r1,#3                 ;2235
00010e  0609              LSLS     r1,r1,#24             ;2235
000110  4308              ORRS     r0,r0,r1              ;2235
000112  6821              LDR      r1,[r4,#0]            ;2235
000114  6088              STR      r0,[r1,#8]            ;2235
000116  2000              MOVS     r0,#0                 ;2238
000118  e7a4              B        |L34.100|
;;;2240   
                          ENDP

00011a  0000              DCW      0x0000
                  |L34.284|
                          DCD      0xff20ff20
                  |L34.288|
                          DCD      0xffccfff1

                          AREA ||i.MID_URT_Transmit||, CODE, READONLY, ALIGN=1

                  MID_URT_Transmit PROC
;;;666     */
;;;667    MID_StatusTypeDef MID_URT_Transmit(URT_HandleTypeDef* MURT, uint8_t *pDATA, uint16_t SIZE , uint32_t TIMEOUT)
000000  b5fe              PUSH     {r1-r7,lr}
;;;668    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;669        uint32_t tickstart = 0;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;670        
;;;671        //===========================================================
;;;672        //Check that a TX process is not already on going.
;;;673        if(MURT->gState == MID_URT_STATE_READY)
00000e  2041              MOVS     r0,#0x41
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d146              BNE      |L35.164|
;;;674        {
;;;675            if((pDATA == NULL) || (SIZE == 0))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L35.30|
00001a  2e00              CMP      r6,#0
00001c  d101              BNE      |L35.34|
                  |L35.30|
;;;676            {
;;;677                return( MID_ERROR);
00001e  2001              MOVS     r0,#1
                  |L35.32|
;;;678            }
;;;679        
;;;680            //===========================================================
;;;681            //Process locked
;;;682            __MID_LOCK(MURT);
;;;683            
;;;684            MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;685            MURT->gState    = MID_URT_STATE_BUSY_TX;
;;;686            
;;;687            //===========================================================
;;;688            //Inital tickstart for timeout managment
;;;689            tickstart = MID_GetTick();
;;;690            
;;;691            MURT->TxTransferSize  = SIZE;
;;;692            MURT->TxTransferCount = SIZE;
;;;693    
;;;694            while(MURT->TxTransferCount >0)
;;;695            {
;;;696                MURT->TxTransferCount = MURT->TxTransferCount - 1;
;;;697                
;;;698                MURT->Instance->TDAT.B[0] = (*pDATA++);
;;;699                
;;;700                if(MID_URT_WaitOnFlagUntilTimeout( MURT, URT_IT_TX, CLR, tickstart, TIMEOUT) != MID_OK)
;;;701                {
;;;702                    return( MID_TIMEOUT);
;;;703                }
;;;704            }
;;;705            if(MID_URT_WaitOnFlagUntilTimeout( MURT, URT_IT_TC, CLR, tickstart, TIMEOUT) != MID_OK)
;;;706            {
;;;707                return(MID_TIMEOUT);
;;;708            }
;;;709            
;;;710            //===========================================================
;;;711            //At end of TX process.
;;;712            MURT->gState = MID_URT_STATE_READY;
;;;713            
;;;714            //===========================================================
;;;715            //Process Unlocked.
;;;716            __MID_UNLOCK(MURT);
;;;717            
;;;718            
;;;719            return(MID_OK);
;;;720        }
;;;721        else
;;;722        {
;;;723            return(MID_BUSY);
;;;724        }
;;;725    }
000020  bdfe              POP      {r1-r7,pc}
                  |L35.34|
000022  bf00              NOP                            ;682
000024  2040              MOVS     r0,#0x40              ;682
000026  5d00              LDRB     r0,[r0,r4]            ;682
000028  2801              CMP      r0,#1                 ;682
00002a  d101              BNE      |L35.48|
00002c  2002              MOVS     r0,#2                 ;682
00002e  e7f7              B        |L35.32|
                  |L35.48|
000030  2101              MOVS     r1,#1                 ;682
000032  2040              MOVS     r0,#0x40              ;682
000034  5501              STRB     r1,[r0,r4]            ;682
000036  bf00              NOP                            ;682
000038  2000              MOVS     r0,#0                 ;684
00003a  6460              STR      r0,[r4,#0x44]         ;684
00003c  2121              MOVS     r1,#0x21              ;685
00003e  2041              MOVS     r0,#0x41              ;685
000040  5501              STRB     r1,[r0,r4]            ;685
000042  f7fffffe          BL       MID_GetTick
000046  9001              STR      r0,[sp,#4]            ;689
000048  85a6              STRH     r6,[r4,#0x2c]         ;691
00004a  85e6              STRH     r6,[r4,#0x2e]         ;692
00004c  e012              B        |L35.116|
                  |L35.78|
00004e  8de0              LDRH     r0,[r4,#0x2e]         ;696
000050  1e40              SUBS     r0,r0,#1              ;696
000052  85e0              STRH     r0,[r4,#0x2e]         ;696
000054  7829              LDRB     r1,[r5,#0]            ;698
000056  6820              LDR      r0,[r4,#0]            ;698
000058  3020              ADDS     r0,r0,#0x20           ;698
00005a  7501              STRB     r1,[r0,#0x14]         ;698
00005c  1c6d              ADDS     r5,r5,#1              ;698
00005e  9700              STR      r7,[sp,#0]            ;700
000060  2200              MOVS     r2,#0                 ;700
000062  2180              MOVS     r1,#0x80              ;700
000064  4620              MOV      r0,r4                 ;700
000066  9b01              LDR      r3,[sp,#4]            ;700
000068  f7fffffe          BL       MID_URT_WaitOnFlagUntilTimeout
00006c  2800              CMP      r0,#0                 ;700
00006e  d001              BEQ      |L35.116|
000070  2003              MOVS     r0,#3                 ;702
000072  e7d5              B        |L35.32|
                  |L35.116|
000074  8de0              LDRH     r0,[r4,#0x2e]         ;694
000076  2800              CMP      r0,#0                 ;694
000078  dce9              BGT      |L35.78|
00007a  9700              STR      r7,[sp,#0]            ;705
00007c  2200              MOVS     r2,#0                 ;705
00007e  2104              MOVS     r1,#4                 ;705
000080  4620              MOV      r0,r4                 ;705
000082  9b01              LDR      r3,[sp,#4]            ;705
000084  f7fffffe          BL       MID_URT_WaitOnFlagUntilTimeout
000088  2800              CMP      r0,#0                 ;705
00008a  d001              BEQ      |L35.144|
00008c  2003              MOVS     r0,#3                 ;707
00008e  e7c7              B        |L35.32|
                  |L35.144|
000090  2120              MOVS     r1,#0x20              ;712
000092  2041              MOVS     r0,#0x41              ;712
000094  5501              STRB     r1,[r0,r4]            ;712
000096  bf00              NOP                            ;716
000098  2100              MOVS     r1,#0                 ;716
00009a  2040              MOVS     r0,#0x40              ;716
00009c  5501              STRB     r1,[r0,r4]            ;716
00009e  bf00              NOP                            ;716
0000a0  2000              MOVS     r0,#0                 ;719
0000a2  e7bd              B        |L35.32|
                  |L35.164|
0000a4  2002              MOVS     r0,#2                 ;723
0000a6  e7bb              B        |L35.32|
;;;726    
                          ENDP


                          AREA ||i.MID_URT_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  MID_URT_Transmit_DMA PROC
;;;915     */
;;;916    MID_StatusTypeDef MID_URT_Transmit_DMA( URT_HandleTypeDef *MURT, uint8_t *pDATA, uint16_t SIZE)
000000  b570              PUSH     {r4-r6,lr}
;;;917    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;918        //===============================================================
;;;919        //Check that TX process is not already on going.
;;;920        if(MURT->gState == MID_URT_STATE_READY)   
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d149              BNE      |L36.164|
;;;921        {
;;;922            if((pDATA == NULL) || (SIZE == 0U))
000010  2e00              CMP      r6,#0
000012  d001              BEQ      |L36.24|
000014  2d00              CMP      r5,#0
000016  d101              BNE      |L36.28|
                  |L36.24|
;;;923            {
;;;924                return(MID_ERROR);
000018  2001              MOVS     r0,#1
                  |L36.26|
;;;925            }
;;;926            
;;;927            //===============================================================
;;;928            //Process Locked 
;;;929            __MID_LOCK(MURT);
;;;930            
;;;931            //===============================================================
;;;932            MURT->pTxBuffPtr      = pDATA;
;;;933            MURT->TxTransferSize  = SIZE;
;;;934            MURT->TxTransferCount = SIZE;
;;;935            
;;;936            MURT->ErrorCode       = MID_URT_ERROR_NONE;
;;;937            MURT->gState          = MID_URT_STATE_BUSY_TX;
;;;938            
;;;939            //===============================================================
;;;940            //Set the UART DMA transfer complete callback.
;;;941            MURT->mDMA_TX->XferCpltCallback = ifun_URT_DMATransmitCplt;
;;;942            
;;;943            //===============================================================
;;;944            //Set the UART DMA Half transfer complete callback
;;;945            MURT->mDMA_TX->XferHalfCpltCallback = ifun_URT_DMATxHalfCplt;
;;;946            
;;;947            //===============================================================
;;;948            //Set the DMA error callback 
;;;949            MURT->mDMA_TX->XferErrorCallback    = ifun_URT_DMAError;
;;;950            
;;;951            //===============================================================
;;;952            //Set the DMA abort callback
;;;953            MURT->mDMA_TX->XferAbortCallback    = NULL;
;;;954            
;;;955            //===============================================================
;;;956            //Enable the URT transmit DMA channel.
;;;957            MID_DMA_Start_IT(MURT->mDMA_TX, (uint32_t)MURT->pTxBuffPtr, (uint32_t)&MURT->Instance->TDAT.W, SIZE);
;;;958            
;;;959            //==============================================================
;;;960            //Clear the TC flag 
;;;961            __DRV_URT_CLEAR_FLAG(MURT , URT_IT_TC);
;;;962            
;;;963            //===============================================================
;;;964            //Process UnLocked 
;;;965            __MID_UNLOCK(MURT);
;;;966            
;;;967            //===============================================================
;;;968            //Enable the DMA transfer for transmit request 
;;;969            CLEAR_BIT( MURT->Instance->CR2.W , URT_CR2_TX_EN_mask_w);
;;;970            SET_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w);
;;;971            SET_BIT( MURT->Instance->CR2.W , URT_CR2_TX_EN_mask_w);
;;;972            
;;;973            return( MID_OK);
;;;974        }
;;;975        else
;;;976        {
;;;977            return( MID_BUSY);
;;;978        }
;;;979    }
00001a  bd70              POP      {r4-r6,pc}
                  |L36.28|
00001c  bf00              NOP                            ;929
00001e  2040              MOVS     r0,#0x40              ;929
000020  5d00              LDRB     r0,[r0,r4]            ;929
000022  2801              CMP      r0,#1                 ;929
000024  d101              BNE      |L36.42|
000026  2002              MOVS     r0,#2                 ;929
000028  e7f7              B        |L36.26|
                  |L36.42|
00002a  2101              MOVS     r1,#1                 ;929
00002c  2040              MOVS     r0,#0x40              ;929
00002e  5501              STRB     r1,[r0,r4]            ;929
000030  bf00              NOP                            ;929
000032  62a6              STR      r6,[r4,#0x28]         ;932
000034  85a5              STRH     r5,[r4,#0x2c]         ;933
000036  85e5              STRH     r5,[r4,#0x2e]         ;934
000038  2000              MOVS     r0,#0                 ;936
00003a  6460              STR      r0,[r4,#0x44]         ;936
00003c  2121              MOVS     r1,#0x21              ;937
00003e  2041              MOVS     r0,#0x41              ;937
000040  5501              STRB     r1,[r0,r4]            ;937
000042  4819              LDR      r0,|L36.168|
000044  6ba1              LDR      r1,[r4,#0x38]         ;941
000046  62c8              STR      r0,[r1,#0x2c]         ;941
000048  4818              LDR      r0,|L36.172|
00004a  6ba1              LDR      r1,[r4,#0x38]         ;945
00004c  6308              STR      r0,[r1,#0x30]         ;945
00004e  4818              LDR      r0,|L36.176|
000050  6ba1              LDR      r1,[r4,#0x38]         ;949
000052  6348              STR      r0,[r1,#0x34]         ;949
000054  2000              MOVS     r0,#0                 ;953
000056  6ba1              LDR      r1,[r4,#0x38]         ;953
000058  6388              STR      r0,[r1,#0x38]         ;953
00005a  6823              LDR      r3,[r4,#0]            ;957
00005c  461a              MOV      r2,r3                 ;957
00005e  3234              ADDS     r2,r2,#0x34           ;957
000060  462b              MOV      r3,r5                 ;957
000062  6aa1              LDR      r1,[r4,#0x28]         ;957
000064  6ba0              LDR      r0,[r4,#0x38]         ;957
000066  f7fffffe          BL       MID_DMA_Start_IT
00006a  2004              MOVS     r0,#4                 ;961
00006c  6821              LDR      r1,[r4,#0]            ;961
00006e  6008              STR      r0,[r1,#0]            ;961
000070  bf00              NOP                            ;965
000072  2100              MOVS     r1,#0                 ;965
000074  2040              MOVS     r0,#0x40              ;965
000076  5501              STRB     r1,[r0,r4]            ;965
000078  bf00              NOP                            ;965
00007a  6820              LDR      r0,[r4,#0]            ;969
00007c  6980              LDR      r0,[r0,#0x18]         ;969
00007e  2108              MOVS     r1,#8                 ;969
000080  4388              BICS     r0,r0,r1              ;969
000082  6821              LDR      r1,[r4,#0]            ;969
000084  6188              STR      r0,[r1,#0x18]         ;969
000086  6820              LDR      r0,[r4,#0]            ;970
000088  6900              LDR      r0,[r0,#0x10]         ;970
00008a  2101              MOVS     r1,#1                 ;970
00008c  07c9              LSLS     r1,r1,#31             ;970
00008e  4308              ORRS     r0,r0,r1              ;970
000090  6821              LDR      r1,[r4,#0]            ;970
000092  6108              STR      r0,[r1,#0x10]         ;970
000094  6820              LDR      r0,[r4,#0]            ;971
000096  6980              LDR      r0,[r0,#0x18]         ;971
000098  2108              MOVS     r1,#8                 ;971
00009a  4308              ORRS     r0,r0,r1              ;971
00009c  6821              LDR      r1,[r4,#0]            ;971
00009e  6188              STR      r0,[r1,#0x18]         ;971
0000a0  2000              MOVS     r0,#0                 ;973
0000a2  e7ba              B        |L36.26|
                  |L36.164|
0000a4  2002              MOVS     r0,#2                 ;977
0000a6  e7b8              B        |L36.26|
;;;980    
                          ENDP

                  |L36.168|
                          DCD      ifun_URT_DMATransmitCplt
                  |L36.172|
                          DCD      ifun_URT_DMATxHalfCplt
                  |L36.176|
                          DCD      ifun_URT_DMAError

                          AREA ||i.MID_URT_Transmit_IT||, CODE, READONLY, ALIGN=1

                  MID_URT_Transmit_IT PROC
;;;809     */
;;;810    MID_StatusTypeDef MID_URT_Transmit_IT( URT_HandleTypeDef* MURT , uint8_t* pDATA , uint16_t SIZE) 
000000  b510              PUSH     {r4,lr}
;;;811    {
000002  4603              MOV      r3,r0
;;;812        //===========================================================
;;;813        //Check that a TX process is not already ongoing
;;;814    
;;;815        if( MURT->gState == MID_URT_STATE_READY)
000004  2041              MOVS     r0,#0x41
000006  5cc0              LDRB     r0,[r0,r3]
000008  2820              CMP      r0,#0x20
00000a  d12f              BNE      |L37.108|
;;;816        {
;;;817            if(( MURT == NULL) || ( SIZE == 0U ))
00000c  2b00              CMP      r3,#0
00000e  d001              BEQ      |L37.20|
000010  2a00              CMP      r2,#0
000012  d101              BNE      |L37.24|
                  |L37.20|
;;;818            {
;;;819                return( MID_ERROR);
000014  2001              MOVS     r0,#1
                  |L37.22|
;;;820            }
;;;821            
;;;822            
;;;823            __MID_LOCK(MURT);                                                  // Process Locked 
;;;824            
;;;825            MURT->pTxBuffPtr      = pDATA;
;;;826            MURT->TxTransferSize  = SIZE;
;;;827            MURT->TxTransferCount = SIZE;        
;;;828            
;;;829            MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;830            MURT->gState    = MID_URT_STATE_BUSY_TX;
;;;831            
;;;832            __MID_UNLOCK(MURT);                                                // Process Unlocked
;;;833            
;;;834            //=======================================================
;;;835            //Send One byte Data.
;;;836            
;;;837            MURT->Instance->TDAT.B[0] = pDATA[0];
;;;838            MURT->pTxBuffPtr          = MURT->pTxBuffPtr + 1;
;;;839            MURT->TxTransferCount     = MURT->TxTransferCount - 1;
;;;840            //=======================================================
;;;841            //Enable :
;;;842            //    1. Transmit Data Register Empty interrupt.
;;;843            //    2. URT interrupt master switch.
;;;844            SET_BIT( MURT->Instance->INT.W , ( URT_INT_TX_IE_mask_w ));
;;;845            
;;;846            return( MID_OK);     
;;;847        }
;;;848        else
;;;849        {
;;;850            return( MID_BUSY);
;;;851        }
;;;852    }
000016  bd10              POP      {r4,pc}
                  |L37.24|
000018  bf00              NOP                            ;823
00001a  2040              MOVS     r0,#0x40              ;823
00001c  5cc0              LDRB     r0,[r0,r3]            ;823
00001e  2801              CMP      r0,#1                 ;823
000020  d101              BNE      |L37.38|
000022  2002              MOVS     r0,#2                 ;823
000024  e7f7              B        |L37.22|
                  |L37.38|
000026  2401              MOVS     r4,#1                 ;823
000028  2040              MOVS     r0,#0x40              ;823
00002a  54c4              STRB     r4,[r0,r3]            ;823
00002c  bf00              NOP                            ;823
00002e  6299              STR      r1,[r3,#0x28]         ;825
000030  859a              STRH     r2,[r3,#0x2c]         ;826
000032  85da              STRH     r2,[r3,#0x2e]         ;827
000034  2000              MOVS     r0,#0                 ;829
000036  6458              STR      r0,[r3,#0x44]         ;829
000038  2421              MOVS     r4,#0x21              ;830
00003a  2041              MOVS     r0,#0x41              ;830
00003c  54c4              STRB     r4,[r0,r3]            ;830
00003e  bf00              NOP                            ;832
000040  2400              MOVS     r4,#0                 ;832
000042  2040              MOVS     r0,#0x40              ;832
000044  54c4              STRB     r4,[r0,r3]            ;832
000046  bf00              NOP                            ;832
000048  780c              LDRB     r4,[r1,#0]            ;837
00004a  6818              LDR      r0,[r3,#0]            ;837
00004c  3020              ADDS     r0,r0,#0x20           ;837
00004e  7504              STRB     r4,[r0,#0x14]         ;837
000050  6a98              LDR      r0,[r3,#0x28]         ;838
000052  1c40              ADDS     r0,r0,#1              ;838
000054  6298              STR      r0,[r3,#0x28]         ;838
000056  8dd8              LDRH     r0,[r3,#0x2e]         ;839
000058  1e40              SUBS     r0,r0,#1              ;839
00005a  85d8              STRH     r0,[r3,#0x2e]         ;839
00005c  6818              LDR      r0,[r3,#0]            ;844
00005e  6840              LDR      r0,[r0,#4]            ;844
000060  2480              MOVS     r4,#0x80              ;844
000062  4320              ORRS     r0,r0,r4              ;844
000064  681c              LDR      r4,[r3,#0]            ;844
000066  6060              STR      r0,[r4,#4]            ;844
000068  2000              MOVS     r0,#0                 ;846
00006a  e7d4              B        |L37.22|
                  |L37.108|
00006c  2002              MOVS     r0,#2                 ;850
00006e  e7d2              B        |L37.22|
;;;853    
                          ENDP


                          AREA ||i.MID_URT_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_TxCpltCallback PROC
;;;1858    */
;;;1859   __WEAK void MID_URT_TxCpltCallback(URT_HandleTypeDef *MURT)
000000  4770              BX       lr
;;;1860   {
;;;1861       //=========================================================
;;;1862       //Prevent unused argument(s) compilation warning
;;;1863       UNUSED( MURT);
;;;1864       
;;;1865       //=========================================================
;;;1866       //NOTE : This function should not be modified , when the
;;;1867       //       callback is needed, the MID_URT_TxCpltCallback can
;;;1868       //       be implemented in the user file.
;;;1869   }
;;;1870   
                          ENDP


                          AREA ||i.MID_URT_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_URT_TxHalfCpltCallback PROC
;;;1880    */
;;;1881   __WEAK void MID_URT_TxHalfCpltCallback( URT_HandleTypeDef* MURT)
000000  4770              BX       lr
;;;1882   {
;;;1883       //=========================================================
;;;1884       //Prevent unused argument(s) compilation warning
;;;1885       UNUSED( MURT);
;;;1886       
;;;1887       //=========================================================
;;;1888       //NOTE : This function should not be modified , when the
;;;1889       //       callback is needed, the MID_URT_TxHalfCpltCallback
;;;1890       //        can be implemented in the user file.    
;;;1891   }
;;;1892   /**
                          ENDP


                          AREA ||i.MID_URT_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  MID_URT_WaitOnFlagUntilTimeout PROC
;;;2348    */
;;;2349   MID_StatusTypeDef MID_URT_WaitOnFlagUntilTimeout(URT_HandleTypeDef* MURT , uint32_t FLAG , FlagStatus STATUS, uint32_t TICK_START , uint32_t TIMEOUT)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2350   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  9e0a              LDR      r6,[sp,#0x28]
;;;2351       //===========================================================
;;;2352       //Wait until flag is set.
;;;2353       while((__MID_URT_GET_FLAG( MURT , FLAG) ? SET : CLR) == STATUS) 
00000c  e01d              B        |L40.74|
                  |L40.14|
;;;2354       {
;;;2355          //===========================================================
;;;2356          //Check for the Timeout.
;;;2357          if(TIMEOUT != MID_MAX_DELAY)
00000e  1c70              ADDS     r0,r6,#1
000010  2800              CMP      r0,#0
000012  d01a              BEQ      |L40.74|
;;;2358          {
;;;2359              if((TIMEOUT == 0) || ((MID_GetTick() - TICK_START) > TIMEOUT))
000014  2e00              CMP      r6,#0
000016  d005              BEQ      |L40.36|
000018  f7fffffe          BL       MID_GetTick
00001c  9904              LDR      r1,[sp,#0x10]
00001e  1a40              SUBS     r0,r0,r1
000020  42b0              CMP      r0,r6
000022  d912              BLS      |L40.74|
                  |L40.36|
;;;2360              {
;;;2361                  //===========================================================
;;;2362                  //Disable TX_IE , TC_IE , RX_IE , and ERR ( Parity error , Frame error , noise error, overrun error) for the interrupt process
;;;2363                  CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_TX | URT_IT_TC | URT_IT_RX | URT_IT_ERR));
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  21cc              MOVS     r1,#0xcc
00002a  4388              BICS     r0,r0,r1
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;2364                  
;;;2365                  
;;;2366                  MURT->gState  = MID_URT_STATE_READY;
000030  2120              MOVS     r1,#0x20
000032  2041              MOVS     r0,#0x41
000034  5501              STRB     r1,[r0,r4]
;;;2367                  MURT->RxState = MID_URT_STATE_READY;
000036  2042              MOVS     r0,#0x42
000038  5501              STRB     r1,[r0,r4]
;;;2368                  
;;;2369                  //===========================================================
;;;2370                  //Process Unlocked.
;;;2371                  __MID_UNLOCK(MURT);
00003a  bf00              NOP      
00003c  2100              MOVS     r1,#0
00003e  2040              MOVS     r0,#0x40
000040  5501              STRB     r1,[r0,r4]
000042  bf00              NOP      
;;;2372                  
;;;2373                  return(MID_TIMEOUT);
000044  2003              MOVS     r0,#3
                  |L40.70|
;;;2374              }
;;;2375          }
;;;2376       }
;;;2377       return(MID_OK);
;;;2378   }
000046  b005              ADD      sp,sp,#0x14
000048  bdf0              POP      {r4-r7,pc}
                  |L40.74|
00004a  6820              LDR      r0,[r4,#0]            ;2353
00004c  6800              LDR      r0,[r0,#0]            ;2353
00004e  4028              ANDS     r0,r0,r5              ;2353
000050  42a8              CMP      r0,r5                 ;2353
000052  d101              BNE      |L40.88|
000054  2001              MOVS     r0,#1                 ;2353
000056  e000              B        |L40.90|
                  |L40.88|
000058  2000              MOVS     r0,#0                 ;2353
                  |L40.90|
00005a  42b8              CMP      r0,r7                 ;2353
00005c  d0d7              BEQ      |L40.14|
00005e  2000              MOVS     r0,#0                 ;2377
000060  e7f1              B        |L40.70|
;;;2379   /**
                          ENDP


                          AREA ||i.ifun_URT_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMAAbortOnError PROC
;;;2568    */
;;;2569   static void ifun_URT_DMAAbortOnError( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2570   {
000002  4605              MOV      r5,r0
;;;2571       URT_HandleTypeDef*  MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2572       
;;;2573       MURT->RxTransferCount = 0;
000006  2000              MOVS     r0,#0
000008  86e0              STRH     r0,[r4,#0x36]
;;;2574       MURT->TxTransferCount = 0;
00000a  85e0              STRH     r0,[r4,#0x2e]
;;;2575       
;;;2576       MID_URT_ErrorCallback(MURT);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       MID_URT_ErrorCallback
;;;2577   }
000012  bd70              POP      {r4-r6,pc}
;;;2578   /**
                          ENDP


                          AREA ||i.ifun_URT_DMAError||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMAError PROC
;;;2536    */
;;;2537   static void ifun_URT_DMAError( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2538   {
000002  4605              MOV      r5,r0
;;;2539       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2540       
;;;2541       if( (MURT->gState == MID_URT_STATE_BUSY_TX) && 
000006  2041              MOVS     r0,#0x41
000008  5d00              LDRB     r0,[r0,r4]
00000a  2821              CMP      r0,#0x21
00000c  d10a              BNE      |L42.36|
;;;2542           ( READ_BIT(MURT->Instance->CR0.W , URT_CR0_DMA_TXEN_mask_w)!=0))
00000e  6820              LDR      r0,[r4,#0]
000010  6900              LDR      r0,[r0,#0x10]
000012  0fc0              LSRS     r0,r0,#31
000014  07c0              LSLS     r0,r0,#31
000016  2800              CMP      r0,#0
000018  d004              BEQ      |L42.36|
;;;2543       {
;;;2544           MURT->TxTransferCount = 0;
00001a  2000              MOVS     r0,#0
00001c  85e0              STRH     r0,[r4,#0x2e]
;;;2545           ifun_URT_EndTxTransfer(MURT);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       ifun_URT_EndTxTransfer
                  |L42.36|
;;;2546       }
;;;2547       
;;;2548       if( (MURT->gState == MID_URT_STATE_BUSY_RX) && 
000024  2041              MOVS     r0,#0x41
000026  5d00              LDRB     r0,[r0,r4]
000028  2822              CMP      r0,#0x22
00002a  d10b              BNE      |L42.68|
;;;2549           ( READ_BIT(MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w)!=0))
00002c  6820              LDR      r0,[r4,#0]
00002e  6900              LDR      r0,[r0,#0x10]
000030  2101              MOVS     r1,#1
000032  0789              LSLS     r1,r1,#30
000034  4008              ANDS     r0,r0,r1
000036  2800              CMP      r0,#0
000038  d004              BEQ      |L42.68|
;;;2550       {
;;;2551           MURT->RxTransferCount = 0;
00003a  2000              MOVS     r0,#0
00003c  86e0              STRH     r0,[r4,#0x36]
;;;2552           ifun_URT_EndRxTransfer(MURT);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       ifun_URT_EndRxTransfer
                  |L42.68|
;;;2553       }
;;;2554       
;;;2555       MURT->ErrorCode = MURT->ErrorCode | MID_URT_ERROR_DMA;
000044  6c60              LDR      r0,[r4,#0x44]
000046  2110              MOVS     r1,#0x10
000048  4308              ORRS     r0,r0,r1
00004a  6460              STR      r0,[r4,#0x44]
;;;2556       MID_URT_ErrorCallback(MURT);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       MID_URT_ErrorCallback
;;;2557   }
000052  bd70              POP      {r4-r6,pc}
;;;2558   /**
                          ENDP


                          AREA ||i.ifun_URT_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMAReceiveCplt PROC
;;;2482    */
;;;2483   static void ifun_URT_DMAReceiveCplt( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2484   {
000002  4605              MOV      r5,r0
;;;2485       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2486       
;;;2487       //===============================================================
;;;2488       //DMA Normal mode
;;;2489       if( MDMA->Init.LoopMode == DMA_LOOP_DISABLE)
000006  69a8              LDR      r0,[r5,#0x18]
000008  2800              CMP      r0,#0
00000a  d110              BNE      |L43.46|
;;;2490       {
;;;2491           MURT->RxTransferCount = 0U;
00000c  86e0              STRH     r0,[r4,#0x36]
;;;2492   
;;;2493           //-----------------------------------------------------------
;;;2494           //Disable error interrupt (parity error , frame error , noise , RX overun.
;;;2495           CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_ERR));
00000e  6820              LDR      r0,[r4,#0]
000010  6840              LDR      r0,[r0,#4]
000012  2108              MOVS     r1,#8
000014  4388              BICS     r0,r0,r1
000016  6821              LDR      r1,[r4,#0]
000018  6048              STR      r0,[r1,#4]
;;;2496           
;;;2497           //-----------------------------------------------------------
;;;2498           //Disable the DMA transfer for the receiver request
;;;2499           CLEAR_BIT( MURT->Instance->CR0.W , URT_CR0_DMA_RXEN_mask_w);
00001a  6820              LDR      r0,[r4,#0]
00001c  6900              LDR      r0,[r0,#0x10]
00001e  2101              MOVS     r1,#1
000020  0789              LSLS     r1,r1,#30
000022  4388              BICS     r0,r0,r1
000024  6821              LDR      r1,[r4,#0]
000026  6108              STR      r0,[r1,#0x10]
;;;2500           
;;;2501           //----------------------------------------------------------
;;;2502           //At end of Rx process 
;;;2503           MURT->RxState = MID_URT_STATE_READY;
000028  2120              MOVS     r1,#0x20
00002a  2042              MOVS     r0,#0x42
00002c  5501              STRB     r1,[r0,r4]
                  |L43.46|
;;;2504           
;;;2505       }
;;;2506       
;;;2507       MID_URT_RxCpltCallback(MURT);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       MID_URT_RxCpltCallback
;;;2508       
;;;2509   }
000034  bd70              POP      {r4-r6,pc}
;;;2510   
                          ENDP


                          AREA ||i.ifun_URT_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMARxAbortCallback PROC
;;;2642    */
;;;2643   static void ifun_URT_DMARxAbortCallback( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2644   {
000002  4605              MOV      r5,r0
;;;2645       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2646       
;;;2647       MURT->mDMA_RX->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6be1              LDR      r1,[r4,#0x3c]
00000a  6388              STR      r0,[r1,#0x38]
;;;2648       
;;;2649       //============================================================
;;;2650       //Check if an abort process is still on going.
;;;2651       if( MURT->mDMA_TX != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L44.28|
;;;2652       {
;;;2653           if(MURT->mDMA_TX->XferAbortCallback != NULL)
000012  6ba0              LDR      r0,[r4,#0x38]
000014  6b80              LDR      r0,[r0,#0x38]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L44.28|
                  |L44.26|
;;;2654           {
;;;2655               return;
;;;2656           }
;;;2657       }
;;;2658       //============================================================
;;;2659       //No abort process still on going : All DMA channels are aborted,
;;;2660       //call user Abort complete callback.
;;;2661       MURT->TxTransferCount = 0U;
;;;2662       MURT->RxTransferCount = 0U;
;;;2663       
;;;2664       //============================================================
;;;2665       //Reset errorCode
;;;2666       MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;2667       
;;;2668       //============================================================
;;;2669       //Clear the error flags 
;;;2670       __DRV_URT_CLEAR_FLAG( MURT , (URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
;;;2671       
;;;2672       //============================================================
;;;2673       //Restore gState and RxState to READY.
;;;2674       MURT->gState  = MID_URT_STATE_READY;
;;;2675       MURT->RxState = MID_URT_STATE_READY;
;;;2676       
;;;2677       //============================================================
;;;2678       //Call user abort complete callback
;;;2679       MID_URT_AbortCpltCallback(MURT);
;;;2680   }
00001a  bd70              POP      {r4-r6,pc}
                  |L44.28|
00001c  2000              MOVS     r0,#0                 ;2661
00001e  85e0              STRH     r0,[r4,#0x2e]         ;2661
000020  86e0              STRH     r0,[r4,#0x36]         ;2662
000022  6460              STR      r0,[r4,#0x44]         ;2666
000024  200f              MOVS     r0,#0xf               ;2670
000026  0500              LSLS     r0,r0,#20             ;2670
000028  6821              LDR      r1,[r4,#0]            ;2670
00002a  6008              STR      r0,[r1,#0]            ;2670
00002c  2120              MOVS     r1,#0x20              ;2674
00002e  2041              MOVS     r0,#0x41              ;2674
000030  5501              STRB     r1,[r0,r4]            ;2674
000032  2042              MOVS     r0,#0x42              ;2675
000034  5501              STRB     r1,[r0,r4]            ;2675
000036  4620              MOV      r0,r4                 ;2679
000038  f7fffffe          BL       MID_URT_AbortCpltCallback
00003c  bf00              NOP      
00003e  e7ec              B        |L44.26|
;;;2681   
                          ENDP


                          AREA ||i.ifun_URT_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMARxHalfCplt PROC
;;;2520    */
;;;2521   static void ifun_URT_DMARxHalfCplt( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2522   {
000002  4604              MOV      r4,r0
;;;2523       URT_HandleTypeDef*  MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aa5              LDR      r5,[r4,#0x28]
;;;2524       
;;;2525       MID_URT_RxHalfCpltCallback( MURT);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MID_URT_RxHalfCpltCallback
;;;2526   }
00000c  bd70              POP      {r4-r6,pc}
;;;2527   /**
                          ENDP


                          AREA ||i.ifun_URT_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMARxOnlyAbortCallback PROC
;;;2722    */
;;;2723   static void ifun_URT_DMARxOnlyAbortCallback( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2724   {
000002  4605              MOV      r5,r0
;;;2725       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2726       
;;;2727       MURT->RxTransferCount = 0;
000006  2000              MOVS     r0,#0
000008  86e0              STRH     r0,[r4,#0x36]
;;;2728       
;;;2729       //============================================================
;;;2730       //Clear the Error flags
;;;2731       __DRV_URT_CLEAR_FLAG( MURT ,  ( URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
00000a  200f              MOVS     r0,#0xf
00000c  0500              LSLS     r0,r0,#20
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;2732       
;;;2733       //============================================================
;;;2734       //Restore RxState to Ready.
;;;2735       MURT->RxState = MID_URT_STATE_READY;
000012  2120              MOVS     r1,#0x20
000014  2042              MOVS     r0,#0x42
000016  5501              STRB     r1,[r0,r4]
;;;2736       
;;;2737       //============================================================
;;;2738       //Call user abort complete callback
;;;2739       MID_URT_AbortReceiveCpltCallback(MURT);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       MID_URT_AbortReceiveCpltCallback
;;;2740   }
00001e  bd70              POP      {r4-r6,pc}
;;;2741   /**
                          ENDP


                          AREA ||i.ifun_URT_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMATransmitCplt PROC
;;;2434    */
;;;2435   static void ifun_URT_DMATransmitCplt( DMA_HandleTypeDef *MDMA )
000000  b570              PUSH     {r4-r6,lr}
;;;2436   {
000002  4605              MOV      r5,r0
;;;2437       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2438       
;;;2439       //===============================================================
;;;2440       //DMA Normal mode
;;;2441       if( MDMA->Init.LoopMode == DMA_LOOP_DISABLE)
000006  69a8              LDR      r0,[r5,#0x18]
000008  2800              CMP      r0,#0
00000a  d107              BNE      |L47.28|
;;;2442       {
;;;2443           MURT->TxTransferCount = 0U;
00000c  85e0              STRH     r0,[r4,#0x2e]
;;;2444           
;;;2445           //-----------------------------------------------------------
;;;2446           //Enable the UART Transmit Complete Interrupt.
;;;2447           SET_BIT( MURT->Instance->INT.W , URT_IT_TC);
00000e  6820              LDR      r0,[r4,#0]
000010  6840              LDR      r0,[r0,#4]
000012  2104              MOVS     r1,#4
000014  4308              ORRS     r0,r0,r1
000016  6821              LDR      r1,[r4,#0]
000018  6048              STR      r0,[r1,#4]
00001a  e002              B        |L47.34|
                  |L47.28|
;;;2448       }
;;;2449       //
;;;2450       else
;;;2451       {
;;;2452           MID_URT_TxCpltCallback(MURT);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       MID_URT_TxCpltCallback
                  |L47.34|
;;;2453       }
;;;2454   }
000022  bd70              POP      {r4-r6,pc}
;;;2455   /**
                          ENDP


                          AREA ||i.ifun_URT_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMATxAbortCallback PROC
;;;2590    */
;;;2591   static void ifun_URT_DMATxAbortCallback( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2592   {
000002  4605              MOV      r5,r0
;;;2593       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2594       
;;;2595       MURT->mDMA_TX->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  6388              STR      r0,[r1,#0x38]
;;;2596   
;;;2597       //============================================================
;;;2598       //Check if an abort process is still on going.
;;;2599       if( MURT->mDMA_RX != NULL)
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L48.28|
;;;2600       {
;;;2601           if(MURT->mDMA_RX->XferAbortCallback != NULL)
000012  6be0              LDR      r0,[r4,#0x3c]
000014  6b80              LDR      r0,[r0,#0x38]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L48.28|
                  |L48.26|
;;;2602           {
;;;2603               return;
;;;2604           }
;;;2605       }
;;;2606       //============================================================
;;;2607       //No abort process still on going : All DMA channels are aborted,
;;;2608       //call user abort complete callback
;;;2609       MURT->TxTransferCount = 0U;
;;;2610       MURT->RxTransferCount = 0U;
;;;2611       
;;;2612       //============================================================
;;;2613       //Reset errorCode
;;;2614       MURT->ErrorCode = MID_URT_ERROR_NONE;
;;;2615       
;;;2616       //============================================================
;;;2617       //Clear the Error flags.
;;;2618       WRITE_REG( MURT->Instance->STA.W, (URT_IT_ROVR | URT_IT_NCE | URT_IT_PE | URT_IT_FE));
;;;2619       
;;;2620       //============================================================
;;;2621       //Restore gState and RxState to Ready.
;;;2622       MURT->gState  = MID_URT_STATE_READY;
;;;2623       MURT->RxState = MID_URT_STATE_READY; 
;;;2624       
;;;2625       //============================================================
;;;2626       //Call user abort complete callback.
;;;2627       MID_URT_AbortCpltCallback(MURT);
;;;2628   }
00001a  bd70              POP      {r4-r6,pc}
                  |L48.28|
00001c  2000              MOVS     r0,#0                 ;2609
00001e  85e0              STRH     r0,[r4,#0x2e]         ;2609
000020  86e0              STRH     r0,[r4,#0x36]         ;2610
000022  6460              STR      r0,[r4,#0x44]         ;2614
000024  200f              MOVS     r0,#0xf               ;2618
000026  0500              LSLS     r0,r0,#20             ;2618
000028  6821              LDR      r1,[r4,#0]            ;2618
00002a  6008              STR      r0,[r1,#0]            ;2618
00002c  2120              MOVS     r1,#0x20              ;2622
00002e  2041              MOVS     r0,#0x41              ;2622
000030  5501              STRB     r1,[r0,r4]            ;2622
000032  2042              MOVS     r0,#0x42              ;2623
000034  5501              STRB     r1,[r0,r4]            ;2623
000036  4620              MOV      r0,r4                 ;2627
000038  f7fffffe          BL       MID_URT_AbortCpltCallback
00003c  bf00              NOP      
00003e  e7ec              B        |L48.26|
;;;2629   
                          ENDP


                          AREA ||i.ifun_URT_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMATxHalfCplt PROC
;;;2464    */
;;;2465   static void ifun_URT_DMATxHalfCplt( DMA_HandleTypeDef *MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2466   {
000002  4604              MOV      r4,r0
;;;2467       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aa5              LDR      r5,[r4,#0x28]
;;;2468       
;;;2469       MID_URT_TxHalfCpltCallback(MURT);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MID_URT_TxHalfCpltCallback
;;;2470       
;;;2471   }
00000c  bd70              POP      {r4-r6,pc}
;;;2472   
                          ENDP


                          AREA ||i.ifun_URT_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  ifun_URT_DMATxOnlyAbortCallback PROC
;;;2695    */
;;;2696   static void ifun_URT_DMATxOnlyAbortCallback( DMA_HandleTypeDef* MDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;2697   {
000002  4605              MOV      r5,r0
;;;2698       URT_HandleTypeDef* MURT = (URT_HandleTypeDef*)(MDMA->Parent);
000004  6aac              LDR      r4,[r5,#0x28]
;;;2699       
;;;2700       MURT->TxTransferCount = 0;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;2701       
;;;2702       //============================================================
;;;2703       //Restore gState to Ready.
;;;2704       MURT->gState = MID_URT_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  2041              MOVS     r0,#0x41
00000e  5501              STRB     r1,[r0,r4]
;;;2705       //============================================================
;;;2706       //Call user Abort complete callback.
;;;2707       MID_URT_AbortTransmitCpltCallback(MURT);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       MID_URT_AbortTransmitCpltCallback
;;;2708   }
000016  bd70              POP      {r4-r6,pc}
;;;2709   /**
                          ENDP


                          AREA ||i.ifun_URT_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  ifun_URT_EndRxTransfer PROC
;;;2410    */
;;;2411   static void ifun_URT_EndRxTransfer( URT_HandleTypeDef* MURT)
000000  6801              LDR      r1,[r0,#0]
;;;2412   {
;;;2413       //===============================================================
;;;2414       //Disable 
;;;2415       //    1. Enable the URT Error Interrupt : (Frame error , Parity error , Noise error , Overrun error)
;;;2416       //    2. the URT data register not empty interrupt.
;;;2417       CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_ERR |  URT_IT_RX));
000002  6849              LDR      r1,[r1,#4]
000004  2248              MOVS     r2,#0x48
000006  4391              BICS     r1,r1,r2
000008  6802              LDR      r2,[r0,#0]
00000a  6051              STR      r1,[r2,#4]
;;;2418       
;;;2419       //===============================================================
;;;2420       //At end of Rx process, restore MURT->RxState to Ready.
;;;2421       MURT->RxState = MID_URT_STATE_READY;
00000c  2220              MOVS     r2,#0x20
00000e  2142              MOVS     r1,#0x42
000010  540a              STRB     r2,[r1,r0]
;;;2422       
;;;2423   }
000012  4770              BX       lr
;;;2424   
                          ENDP


                          AREA ||i.ifun_URT_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  ifun_URT_EndTransmit_IT PROC
;;;2816    */
;;;2817   static MID_StatusTypeDef ifun_URT_EndTransmit_IT( URT_HandleTypeDef* MURT)
000000  b510              PUSH     {r4,lr}
;;;2818   {
000002  4604              MOV      r4,r0
;;;2819       //=========================================================
;;;2820       //Disable the URT Transmit Complete Interrupt.
;;;2821       CLEAR_BIT( MURT->Instance->INT.W , URT_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2104              MOVS     r1,#4
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;2822       
;;;2823       //=========================================================
;;;2824       //TX process is ended, restore MURT-> gState to Ready.
;;;2825       MURT->gState = MID_URT_STATE_READY;
000010  2120              MOVS     r1,#0x20
000012  2041              MOVS     r0,#0x41
000014  5501              STRB     r1,[r0,r4]
;;;2826       
;;;2827       MID_URT_TxCpltCallback( MURT);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       MID_URT_TxCpltCallback
;;;2828       
;;;2829       return( MID_OK);
00001c  2000              MOVS     r0,#0
;;;2830   
;;;2831   }
00001e  bd10              POP      {r4,pc}
;;;2832   
                          ENDP


                          AREA ||i.ifun_URT_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  ifun_URT_EndTxTransfer PROC
;;;2389    */
;;;2390   static void ifun_URT_EndTxTransfer( URT_HandleTypeDef *MURT)
000000  6801              LDR      r1,[r0,#0]
;;;2391   {
;;;2392       //===============================================================
;;;2393       //Disable TX_IE and TC_IE interrupt
;;;2394       CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_TX | URT_IT_TC));
000002  6849              LDR      r1,[r1,#4]
000004  2284              MOVS     r2,#0x84
000006  4391              BICS     r1,r1,r2
000008  6802              LDR      r2,[r0,#0]
00000a  6051              STR      r1,[r2,#4]
;;;2395       
;;;2396       //===============================================================
;;;2397       //At end of TX process.
;;;2398       MURT->gState = MID_URT_STATE_READY;
00000c  2220              MOVS     r2,#0x20
00000e  2141              MOVS     r1,#0x41
000010  540a              STRB     r2,[r1,r0]
;;;2399   }
000012  4770              BX       lr
;;;2400   /**
                          ENDP


                          AREA ||i.ifun_URT_Receive_IT||, CODE, READONLY, ALIGN=1

                  ifun_URT_Receive_IT PROC
;;;2843    */
;;;2844   static MID_StatusTypeDef ifun_URT_Receive_IT( URT_HandleTypeDef * MURT)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2845   {
000002  4604              MOV      r4,r0
;;;2846       ctype     URT_RXITDATA;
;;;2847       uint8_t   URT_RXITCNT;
;;;2848       uint8_t   URT_RXITmp;
;;;2849       
;;;2850       //=========================================================
;;;2851       //Check that a RX process is on going.
;;;2852       if( MURT->RxState == MID_URT_STATE_BUSY_RX )
000004  2042              MOVS     r0,#0x42
000006  5d00              LDRB     r0,[r0,r4]
000008  2822              CMP      r0,#0x22
00000a  d126              BNE      |L54.90|
;;;2853       {
;;;2854           URT_RXITDATA.W = READ_REG( MURT->Instance->RDAT.W);
00000c  6820              LDR      r0,[r4,#0]
00000e  6b00              LDR      r0,[r0,#0x30]
000010  9000              STR      r0,[sp,#0]
;;;2855           URT_RXITCNT    = 1;
000012  2501              MOVS     r5,#1
;;;2856           
;;;2857           
;;;2858           URT_RXITmp = 0;
000014  2600              MOVS     r6,#0
;;;2859           MURT->RxTransferCount = MURT->RxTransferCount  - URT_RXITCNT;
000016  8ee0              LDRH     r0,[r4,#0x36]
000018  1b40              SUBS     r0,r0,r5
00001a  86e0              STRH     r0,[r4,#0x36]
;;;2860           
;;;2861           for( URT_RXITmp = 0; URT_RXITmp < URT_RXITCNT; URT_RXITmp++)
00001c  bf00              NOP      
00001e  e007              B        |L54.48|
                  |L54.32|
;;;2862           {
;;;2863               *MURT->pRXBuffPtr++ = (uint8_t) URT_RXITDATA.B[URT_RXITmp];
000020  4668              MOV      r0,sp
000022  5d81              LDRB     r1,[r0,r6]
000024  6b22              LDR      r2,[r4,#0x30]
000026  1c50              ADDS     r0,r2,#1
000028  6320              STR      r0,[r4,#0x30]
00002a  7011              STRB     r1,[r2,#0]
00002c  1c70              ADDS     r0,r6,#1              ;2861
00002e  b2c6              UXTB     r6,r0                 ;2861
                  |L54.48|
000030  42ae              CMP      r6,r5                 ;2861
000032  dbf5              BLT      |L54.32|
;;;2864           }
;;;2865           
;;;2866           
;;;2867           if( MURT->RxTransferCount == 0)
000034  8ee0              LDRH     r0,[r4,#0x36]
000036  2800              CMP      r0,#0
000038  d10d              BNE      |L54.86|
;;;2868           {
;;;2869               //===============================================================
;;;2870               //Disable 
;;;2871               //    1. Enable the URT Error Interrupt : (parity error , Frame error , noise error , overrun error)
;;;2872               //    2. the URT data register not empty interrupt.
;;;2873               CLEAR_BIT( MURT->Instance->INT.W , (URT_IT_ERR | URT_IT_RX));
00003a  6820              LDR      r0,[r4,#0]
00003c  6840              LDR      r0,[r0,#4]
00003e  2148              MOVS     r1,#0x48
000040  4388              BICS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  6048              STR      r0,[r1,#4]
;;;2874               
;;;2875               //==================================================
;;;2876               //RX process is completed , restore RXState to Ready
;;;2877               MURT->RxState = MID_URT_STATE_READY;
000046  2120              MOVS     r1,#0x20
000048  2042              MOVS     r0,#0x42
00004a  5501              STRB     r1,[r0,r4]
;;;2878   
;;;2879   
;;;2880               MID_URT_RxCpltCallback(MURT);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       MID_URT_RxCpltCallback
;;;2881               
;;;2882               return( MID_OK);
000052  2000              MOVS     r0,#0
                  |L54.84|
;;;2883           }
;;;2884           
;;;2885           return( MID_OK);
;;;2886       }
;;;2887       else
;;;2888       {
;;;2889           //==========================================
;;;2890           //Clear the URT data register not empty interrupt flag.
;;;2891           __DRV_URT_CLEAR_FLAG( MURT ,  URT_IT_RX);
;;;2892           
;;;2893           return( MID_BUSY);
;;;2894       }
;;;2895   }
000054  bdf8              POP      {r3-r7,pc}
                  |L54.86|
000056  2000              MOVS     r0,#0                 ;2885
000058  e7fc              B        |L54.84|
                  |L54.90|
00005a  2040              MOVS     r0,#0x40              ;2891
00005c  6821              LDR      r1,[r4,#0]            ;2891
00005e  6008              STR      r0,[r1,#0]            ;2891
000060  2002              MOVS     r0,#2                 ;2893
000062  e7f7              B        |L54.84|
;;;2896   
                          ENDP


                          AREA ||i.ifun_URT_Transmit_IT||, CODE, READONLY, ALIGN=1

                  ifun_URT_Transmit_IT PROC
;;;2750    */
;;;2751   static MID_StatusTypeDef ifun_URT_Transmit_IT( URT_HandleTypeDef* MURT)
000000  b508              PUSH     {r3,lr}
;;;2752   {
000002  4601              MOV      r1,r0
;;;2753       ctype   URT_ITData;
;;;2754       uint8_t URT_ITCnt = 0;
000004  2200              MOVS     r2,#0
;;;2755       
;;;2756       //============================================================
;;;2757       //Check that a TX process is on going.
;;;2758   
;;;2759       if( MURT->gState == MID_URT_STATE_BUSY_TX)
000006  2041              MOVS     r0,#0x41
000008  5c40              LDRB     r0,[r0,r1]
00000a  2821              CMP      r0,#0x21
00000c  d13f              BNE      |L55.142|
;;;2760       {
;;;2761           //======================================================
;;;2762           //
;;;2763           while( MURT->TxTransferCount !=0 && URT_ITCnt < 4) 
00000e  e00b              B        |L55.40|
                  |L55.16|
;;;2764           {
;;;2765               URT_ITData.B[URT_ITCnt] =  *(MURT->pTxBuffPtr);
000010  6a88              LDR      r0,[r1,#0x28]
000012  7800              LDRB     r0,[r0,#0]
000014  466b              MOV      r3,sp
000016  5498              STRB     r0,[r3,r2]
;;;2766               MURT->pTxBuffPtr        =  MURT->pTxBuffPtr + 1;
000018  6a88              LDR      r0,[r1,#0x28]
00001a  1c40              ADDS     r0,r0,#1
00001c  6288              STR      r0,[r1,#0x28]
;;;2767               MURT->TxTransferCount   =  MURT->TxTransferCount - 1;
00001e  8dc8              LDRH     r0,[r1,#0x2e]
000020  1e40              SUBS     r0,r0,#1
000022  85c8              STRH     r0,[r1,#0x2e]
;;;2768               URT_ITCnt               =  URT_ITCnt + 1;
000024  1c50              ADDS     r0,r2,#1
000026  b2c2              UXTB     r2,r0
                  |L55.40|
000028  8dc8              LDRH     r0,[r1,#0x2e]         ;2763
00002a  2800              CMP      r0,#0                 ;2763
00002c  d001              BEQ      |L55.50|
00002e  2a04              CMP      r2,#4                 ;2763
000030  dbee              BLT      |L55.16|
                  |L55.50|
;;;2769           }
;;;2770           //=====================================================
;;;2771           //Trigge data to transmit.
;;;2772           switch( URT_ITCnt)
000032  0013              MOVS     r3,r2
000034  f7fffffe          BL       __ARM_common_switch8
000038  0518040a          DCB      0x05,0x18,0x04,0x0a
00003c  0f131700          DCB      0x0f,0x13,0x17,0x00
;;;2773           {
;;;2774               case 1:      
;;;2775                       MURT->Instance->TDAT.B[0] =  URT_ITData.B[0];             
000040  4668              MOV      r0,sp
000042  7803              LDRB     r3,[r0,#0]
000044  6808              LDR      r0,[r1,#0]
000046  3020              ADDS     r0,r0,#0x20
000048  7503              STRB     r3,[r0,#0x14]
;;;2776                       break;                
00004a  e00e              B        |L55.106|
;;;2777               case 2:
;;;2778                       MURT->Instance->TDAT.H[0] =  URT_ITData.H[0]; 
00004c  4668              MOV      r0,sp
00004e  8800              LDRH     r0,[r0,#0]
000050  680b              LDR      r3,[r1,#0]
000052  8698              STRH     r0,[r3,#0x34]
;;;2779                       break;
000054  e009              B        |L55.106|
;;;2780               case 3:
;;;2781                       MURT->Instance->TDAT3.W   =  URT_ITData.W; 
000056  9800              LDR      r0,[sp,#0]
000058  680b              LDR      r3,[r1,#0]
00005a  6398              STR      r0,[r3,#0x38]
;;;2782                       break;
00005c  e005              B        |L55.106|
;;;2783               case 4:
;;;2784                       MURT->Instance->TDAT.W   =  URT_ITData.W;
00005e  9800              LDR      r0,[sp,#0]
000060  680b              LDR      r3,[r1,#0]
000062  6358              STR      r0,[r3,#0x34]
;;;2785               case 0:
000064  bf00              NOP      
000066  bf00              NOP      
;;;2786               default:
;;;2787                       break;                
000068  bf00              NOP      
                  |L55.106|
00006a  bf00              NOP                            ;2776
;;;2788           }
;;;2789           //=========================================================
;;;2790           //Last data have trigged.
;;;2791           if(MURT->TxTransferCount == 0)
00006c  8dc8              LDRH     r0,[r1,#0x2e]
00006e  2800              CMP      r0,#0
000070  d10b              BNE      |L55.138|
;;;2792           {
;;;2793               //------------------------------------------------------
;;;2794               //Disable transmit Data Register Empty interrupt.
;;;2795               CLEAR_BIT( MURT->Instance->INT.W , URT_IT_TX);
000072  6808              LDR      r0,[r1,#0]
000074  6840              LDR      r0,[r0,#4]
000076  2380              MOVS     r3,#0x80
000078  4398              BICS     r0,r0,r3
00007a  680b              LDR      r3,[r1,#0]
00007c  6058              STR      r0,[r3,#4]
;;;2796               //------------------------------------------------------
;;;2797               //Enable transmit complete interrupt.
;;;2798               SET_BIT( MURT->Instance->INT.W , URT_IT_TC);
00007e  6808              LDR      r0,[r1,#0]
000080  6840              LDR      r0,[r0,#4]
000082  2304              MOVS     r3,#4
000084  4318              ORRS     r0,r0,r3
000086  680b              LDR      r3,[r1,#0]
000088  6058              STR      r0,[r3,#4]
                  |L55.138|
;;;2799           }
;;;2800           return( MID_OK);
00008a  2000              MOVS     r0,#0
                  |L55.140|
;;;2801       }
;;;2802       else
;;;2803       {
;;;2804           return( MID_BUSY);
;;;2805       }
;;;2806   }
00008c  bd08              POP      {r3,pc}
                  |L55.142|
00008e  2002              MOVS     r0,#2                 ;2804
000090  e7fc              B        |L55.140|
;;;2807   /**
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  CSC_InitConfig
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00010000
                          DCD      0x00000000
                          DCD      0x00000210
                          DCD      0x00000001
                          DCD      0x00000008
                          DCD      0x0000911f
                          DCD      0x000f13ed
                          DCD      0x00008993
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L324.24|
                  |L324.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L324.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L324.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_URT_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_URT_MID_c_8174fdf7____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_URT_MID_c_8174fdf7____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_URT_MID_c_8174fdf7____REVSH|
#line 496
|__asm___18_MG32x02z_URT_MID_c_8174fdf7____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
