; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_csc_init.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_csc_init.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_csc_init.crf RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_CSC_Init.c]
                          THUMB

                          AREA ||i.CSC_EXTCK_Enable||, CODE, READONLY, ALIGN=2

                  CSC_EXTCK_Enable PROC
;;;345     */
;;;346    void CSC_EXTCK_Enable(uint32_t *CSC_CFG)
000000  4601              MOV      r1,r0
;;;347    {
;;;348        CSC->AHB.MBIT.IOPC_EN = 1;
000002  4806              LDR      r0,|L1.28|
000004  7f00              LDRB     r0,[r0,#0x1c]
000006  2204              MOVS     r2,#4
000008  4390              BICS     r0,r0,r2
00000a  1d00              ADDS     r0,r0,#4
00000c  4a03              LDR      r2,|L1.28|
00000e  7710              STRB     r0,[r2,#0x1c]
;;;349        // Set PC13 digital input and AFS PC13
;;;350        IOMC->CR13.H[0] = 0x0003;
000010  2003              MOVS     r0,#3
000012  4a03              LDR      r2,|L1.32|
000014  8290              STRH     r0,[r2,#0x14]
;;;351        // Set PC14 analog IO and AFS PC14
;;;352        IOMC->CR14.H[0] = 0x0000;
000016  2000              MOVS     r0,#0
000018  8310              STRH     r0,[r2,#0x18]
;;;353    }
00001a  4770              BX       lr
;;;354    
                          ENDP

                  |L1.28|
                          DCD      0x4c010000
                  |L1.32|
                          DCD      0x44020020

                          AREA ||i.CSC_IHRCO_Enable||, CODE, READONLY, ALIGN=2

                  CSC_IHRCO_Enable PROC
;;;252     */
;;;253    void CSC_IHRCO_Enable(uint32_t *CSC_CFG)
000000  b510              PUSH     {r4,lr}
;;;254    {
000002  b094              SUB      sp,sp,#0x50
000004  4604              MOV      r4,r0
;;;255        CSC_Struct  CSC_SET = {0};
000006  214c              MOVS     r1,#0x4c
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;256        
;;;257        // Select IHRCO frequency.
;;;258        CSC_SET.CR0.W = CSC_CFG[4];
00000e  6920              LDR      r0,[r4,#0x10]
000010  9005              STR      r0,[sp,#0x14]
;;;259        CSC->CR0.MBIT.IHRCO_SEL = CSC_SET.CR0.MBIT.IHRCO_SEL;
000012  a901              ADD      r1,sp,#4
000014  7c89              LDRB     r1,[r1,#0x12]
000016  0749              LSLS     r1,r1,#29
000018  0fc9              LSRS     r1,r1,#31
00001a  0089              LSLS     r1,r1,#2
00001c  2204              MOVS     r2,#4
00001e  4011              ANDS     r1,r1,r2
000020  4608              MOV      r0,r1
000022  490f              LDR      r1,|L2.96|
000024  7c89              LDRB     r1,[r1,#0x12]
000026  4391              BICS     r1,r1,r2
000028  4301              ORRS     r1,r1,r0
00002a  4a0d              LDR      r2,|L2.96|
00002c  7491              STRB     r1,[r2,#0x12]
;;;260        // When IHRCO_EN disable
;;;261        if(CSC->CR0.MBIT.IHRCO_EN == 0)
00002e  4610              MOV      r0,r2
000030  7c00              LDRB     r0,[r0,#0x10]
000032  0700              LSLS     r0,r0,#28
000034  0fc0              LSRS     r0,r0,#31
000036  2800              CMP      r0,#0
000038  d106              BNE      |L2.72|
;;;262        {
;;;263            // Enable IHRCO
;;;264            CSC->CR0.MBIT.IHRCO_EN = 1;
00003a  4610              MOV      r0,r2
00003c  7c00              LDRB     r0,[r0,#0x10]
00003e  2108              MOVS     r1,#8
000040  4388              BICS     r0,r0,r1
000042  3008              ADDS     r0,r0,#8
000044  4611              MOV      r1,r2
000046  7408              STRB     r0,[r1,#0x10]
                  |L2.72|
;;;265        }
;;;266        
;;;267    #if defined(CSC_STA_Ver_0)
;;;268        // Wait IHRCO ready
;;;269        while(CSC->STA.MBIT.IHRCOF == 0);
000048  bf00              NOP      
                  |L2.74|
00004a  4805              LDR      r0,|L2.96|
00004c  7800              LDRB     r0,[r0,#0]
00004e  0680              LSLS     r0,r0,#26
000050  0fc0              LSRS     r0,r0,#31
000052  2800              CMP      r0,#0
000054  d0f9              BEQ      |L2.74|
;;;270    #endif
;;;271        
;;;272    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;273        // Wait IHRCO ready
;;;274        while(CSC->STA.MBIT.IHRCO_STA == 0);
;;;275    #endif
;;;276        
;;;277                // Clear IHRCOF
;;;278        CSC->STA.B[0] = CSC_STA_IHRCOF_mask_b0;
000056  2020              MOVS     r0,#0x20
000058  4901              LDR      r1,|L2.96|
00005a  7008              STRB     r0,[r1,#0]
;;;279    }
00005c  b014              ADD      sp,sp,#0x50
00005e  bd10              POP      {r4,pc}
;;;280    
                          ENDP

                  |L2.96|
                          DCD      0x4c010000

                          AREA ||i.CSC_Init||, CODE, READONLY, ALIGN=2

                  CSC_Init PROC
;;;368     */
;;;369    void CSC_Init (uint32_t* CSC_CFG)
000000  b530              PUSH     {r4,r5,lr}
;;;370    {
000002  b093              SUB      sp,sp,#0x4c
000004  4604              MOV      r4,r0
;;;371        CSC_Struct  CSC_SET = {0};
000006  214c              MOVS     r1,#0x4c
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memclr4
;;;372    #if CONF_CSC_CKIP_EN != 0x00000001                   /*!< Un-used configuration wizard generator. */
;;;373        uint8_t fXOSC = 0;
00000e  2500              MOVS     r5,#0
;;;374    #endif
;;;375    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;376        uint8_t REG;
;;;377    #endif
;;;378        
;;;379        CSC_SET.PLL.W = CSC_CFG[2];         // Reload config data
000010  68a0              LDR      r0,[r4,#8]
000012  9002              STR      r0,[sp,#8]
;;;380        CSC_SET.CR0.W = CSC_CFG[4];
000014  6920              LDR      r0,[r4,#0x10]
000016  9004              STR      r0,[sp,#0x10]
;;;381        CSC_SET.DIV.W = CSC_CFG[5];
000018  6960              LDR      r0,[r4,#0x14]
00001a  9005              STR      r0,[sp,#0x14]
;;;382        
;;;383        // Flash waite state setting
;;;384        MEM->KEY.MBIT.KEY = 0xA217;
00001c  204d              MOVS     r0,#0x4d
00001e  0600              LSLS     r0,r0,#24
000020  8980              LDRH     r0,[r0,#0xc]
000022  4985              LDR      r1,|L3.568|
000024  4608              MOV      r0,r1
000026  214d              MOVS     r1,#0x4d
000028  0609              LSLS     r1,r1,#24
00002a  8188              STRH     r0,[r1,#0xc]
;;;385    #if defined(MG32_3RD)
;;;386        MEM->CR0.W = (MEM->CR0.W & (~MEM_CR0_FWAIT_mask_w)) | (CSC_CFG[19] | MEM_CR0_FWAIT_one_w);
;;;387    #else
;;;388        MEM->CR0.W = (MEM->CR0.W & (~MEM_CR0_FWAIT_mask_w)) | CSC_CFG[19];
00002c  4608              MOV      r0,r1
00002e  6900              LDR      r0,[r0,#0x10]
000030  2103              MOVS     r1,#3
000032  0309              LSLS     r1,r1,#12
000034  4388              BICS     r0,r0,r1
000036  6ce1              LDR      r1,[r4,#0x4c]
000038  4308              ORRS     r0,r0,r1
00003a  214d              MOVS     r1,#0x4d
00003c  0609              LSLS     r1,r1,#24
00003e  6108              STR      r0,[r1,#0x10]
;;;389    #endif
;;;390        MEM->KEY.MBIT.KEY = 0x0000;
000040  4608              MOV      r0,r1
000042  8980              LDRH     r0,[r0,#0xc]
000044  2000              MOVS     r0,#0
000046  8188              STRH     r0,[r1,#0xc]
;;;391        
;;;392        // Unprotect CSC module
;;;393        CSC->KEY.MBIT.KEY = 0xA217;
000048  487c              LDR      r0,|L3.572|
00004a  8980              LDRH     r0,[r0,#0xc]
00004c  497a              LDR      r1,|L3.568|
00004e  4608              MOV      r0,r1
000050  497a              LDR      r1,|L3.572|
000052  8188              STRH     r0,[r1,#0xc]
;;;394        // Set PLLI_DIV, PLLO_DIV, AHB_DIV, APB_DIV, USB_DIV and UT_DIV
;;;395        CSC->DIV.W = CSC_SET.DIV.W;
000054  9805              LDR      r0,[sp,#0x14]
000056  6148              STR      r0,[r1,#0x14]
;;;396        // Set PLL_MDS, PLLI_SEL, PLL_VCOS, PLL_MUL, PLL_MULX and XOSC_GN
;;;397        CSC->PLL.W = CSC_SET.PLL.W;
000058  9802              LDR      r0,[sp,#8]
00005a  6088              STR      r0,[r1,#8]
;;;398        // Missing clock detect select 125us/ 250us/ 500us/ 1ms.
;;;399        CSC->CR0.MBIT.MCD_SEL = CSC_SET.CR0.MBIT.MCD_SEL;
00005c  4669              MOV      r1,sp
00005e  7c89              LDRB     r1,[r1,#0x12]
000060  0609              LSLS     r1,r1,#24
000062  0f89              LSRS     r1,r1,#30
000064  0189              LSLS     r1,r1,#6
000066  22c0              MOVS     r2,#0xc0
000068  4011              ANDS     r1,r1,r2
00006a  4608              MOV      r0,r1
00006c  4973              LDR      r1,|L3.572|
00006e  7c89              LDRB     r1,[r1,#0x12]
000070  4391              BICS     r1,r1,r2
000072  4301              ORRS     r1,r1,r0
000074  4a71              LDR      r2,|L3.572|
000076  7491              STRB     r1,[r2,#0x12]
;;;400        
;;;401        // Missing clock detect control.
;;;402        // When XOSC gain is lowest or normal low gain, will disable "miss clock detect".
;;;403        if((CSC_SET.PLL.MBIT.XOSC_GN==0x00)&&(CSC_SET.PLL.MBIT.XOSC_GN==0x02))
000078  4668              MOV      r0,sp
00007a  7a80              LDRB     r0,[r0,#0xa]
00007c  0780              LSLS     r0,r0,#30
00007e  0f80              LSRS     r0,r0,#30
000080  2800              CMP      r0,#0
000082  d10c              BNE      |L3.158|
000084  4668              MOV      r0,sp
000086  7a80              LDRB     r0,[r0,#0xa]
000088  0780              LSLS     r0,r0,#30
00008a  0f80              LSRS     r0,r0,#30
00008c  2802              CMP      r0,#2
00008e  d106              BNE      |L3.158|
;;;404        {
;;;405            CSC->CR0.MBIT.MCD_DIS = 1;
000090  4610              MOV      r0,r2
000092  7c00              LDRB     r0,[r0,#0x10]
000094  2110              MOVS     r1,#0x10
000096  4388              BICS     r0,r0,r1
000098  3010              ADDS     r0,r0,#0x10
00009a  4611              MOV      r1,r2
00009c  7408              STRB     r0,[r1,#0x10]
                  |L3.158|
;;;406        }
;;;407        // When XOSC is medium gain, and wizard configuration enables "miss clock detect", will enable "miss clock detect".
;;;408        else
;;;409        {
;;;410            if(CONF_CSC_MCD_DIS==0x00000000)
;;;411            {
;;;412                CSC->CR0.MBIT.MCD_DIS = 0;
;;;413            }
;;;414        }
;;;415    
;;;416    #if CONF_CSC_CKIP_EN != 0x00000001                   /*!< Un-used configuration wizard generator. */
;;;417    
;;;418    #if defined(HS_SEL_Ver_0)
;;;419            /*===== Enable IHRCO =====*/
;;;420            // When CK_HS = CK_IHRCO or CK_HS2 = CK_IHRCO. enable IHRCO.
;;;421            if(CSC_SET.CR0.MBIT.HS_SEL == 0)
00009e  4668              MOV      r0,sp
0000a0  7c40              LDRB     r0,[r0,#0x11]
0000a2  0700              LSLS     r0,r0,#28
0000a4  0f80              LSRS     r0,r0,#30
0000a6  2800              CMP      r0,#0
0000a8  d102              BNE      |L3.176|
;;;422            {
;;;423                CSC_IHRCO_Enable((uint32_t *)&CSC_InitConfig);
0000aa  4865              LDR      r0,|L3.576|
0000ac  f7fffffe          BL       CSC_IHRCO_Enable
                  |L3.176|
;;;424            }
;;;425    #endif
;;;426    
;;;427    #if defined(HS2_SEL_Ver_0)
;;;428            /*!< When CK_HS2_SEL selected IHRCO, will enable IHRCO module. */
;;;429            if(CSC_SET.CR0.MBIT.HS2_SEL == 0)
;;;430            {
;;;431                CSC_IHRCO_Enable((uint32_t *)&CSC_InitConfig);
;;;432            }
;;;433    #endif
;;;434            
;;;435    #if defined(HS_SEL_Ver_0)
;;;436            /*===== Enable XOSC =====*/
;;;437            // When CK_HS = CK_XOSC or CK_HS2 = CK_XOSC or CK_LS = CK_XOSC, enable XOSC.
;;;438            if((CSC_SET.CR0.MBIT.HS_SEL == 1) || (CSC_SET.CR0.MBIT.LS_SEL == 1))
0000b0  4668              MOV      r0,sp
0000b2  7c40              LDRB     r0,[r0,#0x11]
0000b4  0700              LSLS     r0,r0,#28
0000b6  0f80              LSRS     r0,r0,#30
0000b8  2801              CMP      r0,#1
0000ba  d005              BEQ      |L3.200|
0000bc  4668              MOV      r0,sp
0000be  7c40              LDRB     r0,[r0,#0x11]
0000c0  0780              LSLS     r0,r0,#30
0000c2  0f80              LSRS     r0,r0,#30
0000c4  2801              CMP      r0,#1
0000c6  d10e              BNE      |L3.230|
                  |L3.200|
;;;439            {
;;;440                fXOSC |= 0x01;
0000c8  2001              MOVS     r0,#1
0000ca  4305              ORRS     r5,r5,r0
;;;441                if((IOMC->CR13.H[0] != 0x1000) || (IOMC->CR14.H[0] != 0x1000))
0000cc  485d              LDR      r0,|L3.580|
0000ce  8a80              LDRH     r0,[r0,#0x14]
0000d0  2101              MOVS     r1,#1
0000d2  0309              LSLS     r1,r1,#12
0000d4  4288              CMP      r0,r1
0000d6  d103              BNE      |L3.224|
0000d8  485a              LDR      r0,|L3.580|
0000da  8b00              LDRH     r0,[r0,#0x18]
0000dc  4288              CMP      r0,r1
0000de  d002              BEQ      |L3.230|
                  |L3.224|
;;;442                {
;;;443                    CSC_XOSC_Enable((uint32_t *)&CSC_InitConfig);
0000e0  4857              LDR      r0,|L3.576|
0000e2  f7fffffe          BL       CSC_XOSC_Enable
                  |L3.230|
;;;444                }
;;;445            }
;;;446    #endif
;;;447            
;;;448    #if defined(HS2_SEL_Ver_0)
;;;449            /*!< When CK_HS2_SEL selected XOSC, will enable XOSC */
;;;450            if(CSC_SET.CR0.MBIT.HS2_SEL == 1)
;;;451            {
;;;452                fXOSC |= 0x01;
;;;453                if((IOMC->CR13.H[0] != 0x1000) || (IOMC->CR14.H[0] != 0x1000))
;;;454                {
;;;455                    CSC_XOSC_Enable((uint32_t *)&CSC_InitConfig);
;;;456                }
;;;457            }
;;;458    #endif
;;;459    
;;;460            
;;;461    #if defined(HS_SEL_Ver_0)
;;;462            /*===== Enable EXTCK =====*/
;;;463            /*!< When HS selected EXTCK, will enable EXTCK. */
;;;464            if((fXOSC&0x01) != 1)
0000e6  07e8              LSLS     r0,r5,#31
0000e8  0fc0              LSRS     r0,r0,#31
0000ea  2800              CMP      r0,#0
0000ec  d112              BNE      |L3.276|
;;;465            {
;;;466                if((CSC_SET.CR0.MBIT.HS_SEL==3)||(CSC_SET.CR0.MBIT.LS_SEL==3))
0000ee  4668              MOV      r0,sp
0000f0  7c40              LDRB     r0,[r0,#0x11]
0000f2  0700              LSLS     r0,r0,#28
0000f4  0f80              LSRS     r0,r0,#30
0000f6  2803              CMP      r0,#3
0000f8  d005              BEQ      |L3.262|
0000fa  4668              MOV      r0,sp
0000fc  7c40              LDRB     r0,[r0,#0x11]
0000fe  0780              LSLS     r0,r0,#30
000100  0f80              LSRS     r0,r0,#30
000102  2803              CMP      r0,#3
000104  d106              BNE      |L3.276|
                  |L3.262|
;;;467                {
;;;468                    if(IOMC->CR13.H[0] != 0x0003)
000106  484f              LDR      r0,|L3.580|
000108  8a80              LDRH     r0,[r0,#0x14]
00010a  2803              CMP      r0,#3
00010c  d002              BEQ      |L3.276|
;;;469                        CSC_EXTCK_Enable((uint32_t *)&CSC_InitConfig);
00010e  484c              LDR      r0,|L3.576|
000110  f7fffffe          BL       CSC_EXTCK_Enable
                  |L3.276|
;;;470                }
;;;471            
;;;472    #if defined(HS2_SEL_Ver_0)
;;;473                /*!< When CK_HS2_SEL selected EXTCK, will enable EXTCK. */
;;;474                if(CSC_SET.CR0.MBIT.HS2_SEL == 3)
;;;475                {
;;;476                    if(IOMC->CR13.H[0] != 0x0003)
;;;477                        CSC_EXTCK_Enable((uint32_t *)&CSC_InitConfig);
;;;478                }
;;;479    #endif
;;;480            }
;;;481            
;;;482    #endif
;;;483            
;;;484    
;;;485    #endif                      /*!< Un-Used wizard generator END. */
;;;486        
;;;487    #if CONF_CSC_CKIP_EN == 0x00000001               /*!< Used configuration wizard generator. */
;;;488        
;;;489        /*!< When XOSC and EXTCK are enable at the same time, will just enable XOSC. */
;;;490        if(CONF_CFG_XOSC_EN == CFG_OR05_XOSC_EN_mask_w)
;;;491        {
;;;492            CSC_XOSC_Enable((uint32_t *)&CSC_InitConfig);
;;;493        }
;;;494        
;;;495        if(CONF_CFG_EXTCK_EN == (uint32_t)0x80000000)
;;;496        {
;;;497            CSC_EXTCK_Enable((uint32_t *)&CSC_InitConfig);
;;;498        }
;;;499        
;;;500        if(CONF_CSC_CR0_IHRCO_EN == CSC_CR0_IHRCO_EN_mask_w)
;;;501        {
;;;502            CSC_IHRCO_Enable((uint32_t*) &CSC_InitConfig);
;;;503        }
;;;504        
;;;505        else if((CONF_CSC_CR0_IHRCO_EN != CSC_CR0_IHRCO_EN_mask_w)&&(CONF_CFG_XOSC_EN != CFG_OR05_XOSC_EN_mask_w)&&(CONF_CFG_EXTCK_EN != (uint32_t)0x80000000))
;;;506        {
;;;507            CSC_IHRCO_Enable((uint32_t*) &CSC_InitConfig);
;;;508        }
;;;509        
;;;510        if(CONF_CSC_CR0_PLL_EN==CSC_CR0_PLL_EN_mask_w)
;;;511        {
;;;512            CSC->CR0.W |= CSC_CR0_PLL_EN_mask_w;
;;;513        }
;;;514        else
;;;515        {
;;;516            CSC->CR0.W &= ~CSC_CR0_PLL_EN_mask_w;
;;;517        }
;;;518        
;;;519    #endif                          /*!< Used configuration wizard generator END. */
;;;520        
;;;521        /*===== CK_HS, CK_HS2 and CK_LS Switch =====*/
;;;522        // Switch CK_HS
;;;523        CSC->CR0.MBIT.HS_SEL = CSC_SET.CR0.MBIT.HS_SEL;
000114  4669              MOV      r1,sp
000116  7c49              LDRB     r1,[r1,#0x11]
000118  0709              LSLS     r1,r1,#28
00011a  0f89              LSRS     r1,r1,#30
00011c  0089              LSLS     r1,r1,#2
00011e  220c              MOVS     r2,#0xc
000120  4011              ANDS     r1,r1,r2
000122  4608              MOV      r0,r1
000124  4945              LDR      r1,|L3.572|
000126  7c49              LDRB     r1,[r1,#0x11]
000128  4391              BICS     r1,r1,r2
00012a  4301              ORRS     r1,r1,r0
00012c  4a43              LDR      r2,|L3.572|
00012e  7451              STRB     r1,[r2,#0x11]
;;;524    #if defined(HS2_SEL_Ver_0)
;;;525        // Switch CK_HS2
;;;526        CSC->CR0.MBIT.HS2_SEL = CSC_SET.CR0.MBIT.HS2_SEL;
;;;527    #endif
;;;528        // Switch CK_LS
;;;529        CSC->CR0.MBIT.LS_SEL = CSC_SET.CR0.MBIT.LS_SEL;
000130  4669              MOV      r1,sp
000132  7c49              LDRB     r1,[r1,#0x11]
000134  0788              LSLS     r0,r1,#30
000136  0f80              LSRS     r0,r0,#30
000138  4611              MOV      r1,r2
00013a  7c49              LDRB     r1,[r1,#0x11]
00013c  0889              LSRS     r1,r1,#2
00013e  0089              LSLS     r1,r1,#2
000140  4301              ORRS     r1,r1,r0
000142  7451              STRB     r1,[r2,#0x11]
;;;530    
;;;531        /*!< Module clock ready status check */
;;;532    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;533        // Check CK_HS success
;;;534        REG = 0x01 << CSC_SET.CR0.MBIT.HS_SEL;
;;;535        while(CSC->STA.MBIT.HS_STA != REG);
;;;536    #endif
;;;537    
;;;538    #if defined(CSC_STA_Ver_2)
;;;539        // Check CK_HS2 success
;;;540        REG = 0x01 << CSC_SET.CR0.MBIT.HS2_SEL;
;;;541        while(CSC->STA.MBIT.HS2_STA != REG);
;;;542    #endif
;;;543        /*===== FPGA mask CK_LS and PLL check code =====*/
;;;544    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;545        // Check CK_LS success
;;;546        REG = 0x01 << CSC_SET.CR0.MBIT.LS_SEL;
;;;547        while(CSC->STA.MBIT.LS_STA != REG);
;;;548    #endif
;;;549        
;;;550    #if defined(CSC_STA_Ver_2)
;;;551        // Check PLLI success
;;;552        REG = 0x01 << CSC_SET.PLL.MBIT.PLLI_SEL;
;;;553        while(CSC->STA.MBIT.PLLI_STA != REG);
;;;554    #endif      // Wait PLLI clock STA END.
;;;555    
;;;556        /*===== CK_MAIN Select =====*/
;;;557        // When CSC_SET SYS_SEL select CK_PLLO
;;;558        if(CSC_SET.CR0.MBIT.MAIN_SEL == 2)
000144  4668              MOV      r0,sp
000146  7c40              LDRB     r0,[r0,#0x11]
000148  0980              LSRS     r0,r0,#6
00014a  2802              CMP      r0,#2
00014c  d108              BNE      |L3.352|
;;;559        {
;;;560            // Enable PLL
;;;561            CSC->CR0.MBIT.PLL_EN = 1;
00014e  4610              MOV      r0,r2
000150  7c00              LDRB     r0,[r0,#0x10]
000152  2120              MOVS     r1,#0x20
000154  4388              BICS     r0,r0,r1
000156  3020              ADDS     r0,r0,#0x20
000158  4611              MOV      r1,r2
00015a  7408              STRB     r0,[r1,#0x10]
;;;562    #if defined(CONF_CSC_PLL_LDEN)
;;;563            // Wait PLL stable, when PLL signal lock detects function is enabled
;;;564            if(CONF_CSC_PLL_LDEN == CSC_PLL_PLL_LDEN_enable_w)
;;;565            {
;;;566                CSC->PLL.W |= CSC_PLL_PLL_LDEN_enable_w;
;;;567                while(CSC->STA.MBIT.PLL_LOCKF==0);
;;;568            }
;;;569    #endif
;;;570            
;;;571    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;572            // Wait PLL ready
;;;573            while(CSC->STA.MBIT.PLL_STA == 0);
;;;574    #endif
;;;575        
;;;576            // Clear PLLF
;;;577            CSC->STA.B[0] = CSC_STA_PLLF_mask_b0;
00015c  2040              MOVS     r0,#0x40
00015e  7008              STRB     r0,[r1,#0]
                  |L3.352|
;;;578        }
;;;579        
;;;580    // USB device check, if USB APB0 enable will enable PLL function.
;;;581    #if USB_DEVICE
;;;582        if((CONF_CSC_APB0&CSC_APB0_USB_EN_enable_w)==CSC_APB0_USB_EN_enable_w)
;;;583        {
;;;584            // Enable PLL function
;;;585            CSC->CR0.MBIT.PLL_EN = 1;
;;;586            #if defined(CONF_CSC_PLL_LDEN)
;;;587                #ifdef CSC_STA_Ver_2 
;;;588                    // Wait PLL stable, when PLL signal lock detects function is enabled
;;;589                    if(CONF_CSC_PLL_LDEN == CSC_PLL_PLL_LDEN_enable_w)
;;;590                    {
;;;591                        CSC->PLL.W |= CSC_PLL_PLL_LDEN_enable_w;
;;;592                        while(CSC->STA.MBIT.PLL_LOCKF==0);
;;;593                    }
;;;594                #endif
;;;595            #endif
;;;596            
;;;597    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;598            // Wait PLL ready
;;;599            while(CSC->STA.MBIT.PLL_STA == 0);
;;;600    #endif
;;;601            
;;;602            // Clear PLLF
;;;603            CSC->STA.B[0] = CSC_STA_PLLF_mask_b0;
;;;604    
;;;605        }
;;;606    #endif          // USB clock checks at ON MODE.
;;;607        
;;;608        CSC->CR0.MBIT.MAIN_SEL = CSC_SET.CR0.MBIT.MAIN_SEL;     // Main clock select.
000160  4669              MOV      r1,sp
000162  7c49              LDRB     r1,[r1,#0x11]
000164  0609              LSLS     r1,r1,#24
000166  0f89              LSRS     r1,r1,#30
000168  0189              LSLS     r1,r1,#6
00016a  22c0              MOVS     r2,#0xc0
00016c  4011              ANDS     r1,r1,r2
00016e  4608              MOV      r0,r1
000170  4932              LDR      r1,|L3.572|
000172  7c49              LDRB     r1,[r1,#0x11]
000174  4391              BICS     r1,r1,r2
000176  4301              ORRS     r1,r1,r0
000178  4a30              LDR      r2,|L3.572|
00017a  7451              STRB     r1,[r2,#0x11]
;;;609        
;;;610        CSC->CR0.MBIT.ST_SEL= CSC_SET.CR0.MBIT.ST_SEL;          // System tick external clock select.
00017c  4669              MOV      r1,sp
00017e  7c89              LDRB     r1,[r1,#0x12]
000180  07c8              LSLS     r0,r1,#31
000182  0fc0              LSRS     r0,r0,#31
000184  4611              MOV      r1,r2
000186  7c89              LDRB     r1,[r1,#0x12]
000188  0849              LSRS     r1,r1,#1
00018a  0049              LSLS     r1,r1,#1
00018c  4301              ORRS     r1,r1,r0
00018e  7491              STRB     r1,[r2,#0x12]
;;;611        CSC->DIV.W = CSC_SET.DIV.W;                             // Clock divider set.
000190  9805              LDR      r0,[sp,#0x14]
000192  4611              MOV      r1,r2
000194  6148              STR      r0,[r1,#0x14]
;;;612        
;;;613        /*===== FPGA mask CK_HS =====*/
;;;614        // Check CK_HS success
;;;615    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;616        REG = 0x01 << CSC_SET.CR0.MBIT.MAIN_SEL;
;;;617        while(CSC->STA.MBIT.MAIN_STA != REG);
;;;618    #endif
;;;619        
;;;620        // Configure ICKO function
;;;621        CSC->INT.W = CSC_CFG[1];
000196  6860              LDR      r0,[r4,#4]
000198  6048              STR      r0,[r1,#4]
;;;622        CSC->CKO.W = CSC_CFG[6];
00019a  69a0              LDR      r0,[r4,#0x18]
00019c  6188              STR      r0,[r1,#0x18]
;;;623        
;;;624        // Configure peripheral clock 
;;;625        CSC->AHB.W = CSC_CFG[7];
00019e  69e0              LDR      r0,[r4,#0x1c]
0001a0  61c8              STR      r0,[r1,#0x1c]
;;;626        CSC->APB0.W = CSC_CFG[8];
0001a2  6a20              LDR      r0,[r4,#0x20]
0001a4  6208              STR      r0,[r1,#0x20]
;;;627        CSC->APB1.W = CSC_CFG[9];
0001a6  6a60              LDR      r0,[r4,#0x24]
0001a8  6248              STR      r0,[r1,#0x24]
;;;628        CSC->SLP0.W = CSC_CFG[10];
0001aa  6aa0              LDR      r0,[r4,#0x28]
0001ac  6308              STR      r0,[r1,#0x30]
;;;629        CSC->SLP1.W = CSC_CFG[11];
0001ae  6ae0              LDR      r0,[r4,#0x2c]
0001b0  6348              STR      r0,[r1,#0x34]
;;;630        CSC->STP0.W = CSC_CFG[12];
0001b2  6b20              LDR      r0,[r4,#0x30]
0001b4  6388              STR      r0,[r1,#0x38]
;;;631        CSC->CKS0.W = CSC_CFG[14];
0001b6  4921              LDR      r1,|L3.572|
0001b8  3140              ADDS     r1,r1,#0x40
0001ba  6ba0              LDR      r0,[r4,#0x38]
0001bc  6008              STR      r0,[r1,#0]
;;;632        CSC->CKS1.W = CSC_CFG[15];
0001be  6be0              LDR      r0,[r4,#0x3c]
0001c0  6048              STR      r0,[r1,#4]
;;;633        CSC->CKS2.W = CSC_CFG[16];
0001c2  6c20              LDR      r0,[r4,#0x40]
0001c4  6088              STR      r0,[r1,#8]
;;;634        
;;;635        
;;;636        /*===== Disable Not Used Clock Source =====*/
;;;637        // When CK_HS and CK_HS2 not select CK_IHRCO
;;;638    #if defined(HS2_SEL_Ver_0)
;;;639        if((CSC->CR0.MBIT.HS_SEL != 0)&&(CSC->CR0.MBIT.HS2_SEL != 0))
;;;640            CSC->CR0.MBIT.IHRCO_EN = 0;
;;;641    #else
;;;642        if(CSC->CR0.MBIT.HS_SEL != 0)
0001c6  4610              MOV      r0,r2
0001c8  7c40              LDRB     r0,[r0,#0x11]
0001ca  0700              LSLS     r0,r0,#28
0001cc  0f80              LSRS     r0,r0,#30
0001ce  2800              CMP      r0,#0
0001d0  d005              BEQ      |L3.478|
;;;643            CSC->CR0.MBIT.IHRCO_EN = 0;
0001d2  4610              MOV      r0,r2
0001d4  7c00              LDRB     r0,[r0,#0x10]
0001d6  2108              MOVS     r1,#8
0001d8  4388              BICS     r0,r0,r1
0001da  4611              MOV      r1,r2
0001dc  7408              STRB     r0,[r1,#0x10]
                  |L3.478|
;;;644    #endif
;;;645        // When CK_HS, CK_HS2 and CK_LS not select CK_XOSC
;;;646    #if defined(HS2_SEL_Ver_0)
;;;647        if((CSC_SET.CR0.MBIT.HS_SEL!= 1) && (CSC_SET.CR0.MBIT.LS_SEL != 1)&&(CSC_SET.CR0.MBIT.HS2_SEL  != 1))
;;;648        {
;;;649            // Set PC13 and PC14 AFS is GPIO
;;;650            IOMC->CR14.H[0] &= 0x0FFF;
;;;651            // When EXTCK and XOSC are non used, change PC14 AFS to GPIO
;;;652            if((CSC_SET.CR0.MBIT.HS_SEL != 0x03) && (CSC_SET.CR0.MBIT.LS_SEL != 0x03))
;;;653                IOMC->CR13.H[0] &= 0x0FFF;
;;;654        }
;;;655    #else
;;;656        if((CSC_SET.CR0.MBIT.HS_SEL!= 1) && (CSC_SET.CR0.MBIT.LS_SEL != 1))
0001de  4668              MOV      r0,sp
0001e0  7c40              LDRB     r0,[r0,#0x11]
0001e2  0700              LSLS     r0,r0,#28
0001e4  0f80              LSRS     r0,r0,#30
0001e6  2801              CMP      r0,#1
0001e8  d01c              BEQ      |L3.548|
0001ea  4668              MOV      r0,sp
0001ec  7c40              LDRB     r0,[r0,#0x11]
0001ee  0780              LSLS     r0,r0,#30
0001f0  0f80              LSRS     r0,r0,#30
0001f2  2801              CMP      r0,#1
0001f4  d016              BEQ      |L3.548|
;;;657        {
;;;658            // Set PC13 and PC14 AFS is GPIO
;;;659            IOMC->CR14.H[0] &= 0x0FFF;
0001f6  4813              LDR      r0,|L3.580|
0001f8  8b00              LDRH     r0,[r0,#0x18]
0001fa  0500              LSLS     r0,r0,#20
0001fc  0d00              LSRS     r0,r0,#20
0001fe  4911              LDR      r1,|L3.580|
000200  8308              STRH     r0,[r1,#0x18]
;;;660            // When EXTCK and XOSC are non used, change PC14 AFS to GPIO
;;;661            if((CSC_SET.CR0.MBIT.HS_SEL != 0x03) && (CSC_SET.CR0.MBIT.LS_SEL != 0x03))
000202  4668              MOV      r0,sp
000204  7c40              LDRB     r0,[r0,#0x11]
000206  0700              LSLS     r0,r0,#28
000208  0f80              LSRS     r0,r0,#30
00020a  2803              CMP      r0,#3
00020c  d00a              BEQ      |L3.548|
00020e  4668              MOV      r0,sp
000210  7c40              LDRB     r0,[r0,#0x11]
000212  0780              LSLS     r0,r0,#30
000214  0f80              LSRS     r0,r0,#30
000216  2803              CMP      r0,#3
000218  d004              BEQ      |L3.548|
;;;662                IOMC->CR13.H[0] &= 0x0FFF;
00021a  4608              MOV      r0,r1
00021c  8a80              LDRH     r0,[r0,#0x14]
00021e  0500              LSLS     r0,r0,#20
000220  0d00              LSRS     r0,r0,#20
000222  8288              STRH     r0,[r1,#0x14]
                  |L3.548|
;;;663        }
;;;664    #endif
;;;665        
;;;666        // Protect CSC module
;;;667        CSC->KEY.MBIT.KEY = 0x0000;
000224  4805              LDR      r0,|L3.572|
000226  8980              LDRH     r0,[r0,#0xc]
000228  2000              MOVS     r0,#0
00022a  4904              LDR      r1,|L3.572|
00022c  8188              STRH     r0,[r1,#0xc]
;;;668        
;;;669        SystemCoreClock = CONF_CK_AHB_FREQ;
00022e  4806              LDR      r0,|L3.584|
000230  4906              LDR      r1,|L3.588|
000232  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;670        
;;;671    }
000234  b013              ADD      sp,sp,#0x4c
000236  bd30              POP      {r4,r5,pc}
;;;672    
                          ENDP

                  |L3.568|
                          DCD      0x0000a217
                  |L3.572|
                          DCD      0x4c010000
                  |L3.576|
                          DCD      CSC_InitConfig
                  |L3.580|
                          DCD      0x44020020
                  |L3.584|
                          DCD      0x00b71b00
                  |L3.588|
                          DCD      SystemCoreClock

                          AREA ||i.CSC_XOSC_Enable||, CODE, READONLY, ALIGN=2

                  CSC_XOSC_Enable PROC
;;;295     */
;;;296    void CSC_XOSC_Enable(uint32_t *CSC_CFG)
000000  b510              PUSH     {r4,lr}
;;;297    {
000002  b094              SUB      sp,sp,#0x50
000004  4604              MOV      r4,r0
;;;298        CSC_Struct CSC_SET = {0};
000006  214c              MOVS     r1,#0x4c
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;299        
;;;300        // Reload CSC CR0 Configure data.
;;;301        CSC_SET.CR0.W = CSC_CFG[4];
00000e  6920              LDR      r0,[r4,#0x10]
000010  9005              STR      r0,[sp,#0x14]
;;;302        // Enable PC clock
;;;303        CSC->AHB.MBIT.IOPC_EN = 1;
000012  481f              LDR      r0,|L4.144|
000014  7f00              LDRB     r0,[r0,#0x1c]
000016  2104              MOVS     r1,#4
000018  4388              BICS     r0,r0,r1
00001a  1d00              ADDS     r0,r0,#4
00001c  491c              LDR      r1,|L4.144|
00001e  7708              STRB     r0,[r1,#0x1c]
;;;304        if((IOMC->CR13.H[0] != 0x1000)||(IOMC->CR14.H[0] != 0x1000))
000020  481c              LDR      r0,|L4.148|
000022  8a80              LDRH     r0,[r0,#0x14]
000024  2101              MOVS     r1,#1
000026  0309              LSLS     r1,r1,#12
000028  4288              CMP      r0,r1
00002a  d103              BNE      |L4.52|
00002c  4819              LDR      r0,|L4.148|
00002e  8b00              LDRH     r0,[r0,#0x18]
000030  4288              CMP      r0,r1
000032  d004              BEQ      |L4.62|
                  |L4.52|
;;;305        {
;;;306            // Set PC13 and PC14 analog IO and AFS is XOSC pin
;;;307            IOMC->CR13.H[0] = 0x1000;
000034  2001              MOVS     r0,#1
000036  0300              LSLS     r0,r0,#12
000038  4916              LDR      r1,|L4.148|
00003a  8288              STRH     r0,[r1,#0x14]
;;;308            IOMC->CR14.H[0] = 0x1000;
00003c  8308              STRH     r0,[r1,#0x18]
                  |L4.62|
;;;309        }
;;;310        
;;;311    #if defined(CSC_STA_Ver_0)
;;;312            // Wait XOSC ready
;;;313            while(CSC->STA.MBIT.XOSCF == 0);
00003e  bf00              NOP      
                  |L4.64|
000040  4813              LDR      r0,|L4.144|
000042  7800              LDRB     r0,[r0,#0]
000044  0780              LSLS     r0,r0,#30
000046  0fc0              LSRS     r0,r0,#31
000048  2800              CMP      r0,#0
00004a  d0f9              BEQ      |L4.64|
;;;314    #endif
;;;315    
;;;316    #if defined(CSC_STA_Ver_1) || defined(CSC_STA_Ver_2)
;;;317        // Wait XOSC ready
;;;318        while(CSC->STA.MBIT.XOSC_STA == 0);
;;;319    #endif
;;;320        
;;;321        // Clear XOSCF
;;;322        CSC->STA.B[0] = CSC_STA_XOSCF_mask_b0;
00004c  2002              MOVS     r0,#2
00004e  4910              LDR      r1,|L4.144|
000050  7008              STRB     r0,[r1,#0]
;;;323    
;;;324        // Missing Clock Detect configure
;;;325        CSC->CR0.MBIT.MCD_SEL = CSC_SET.CR0.MBIT.MCD_SEL;
000052  a901              ADD      r1,sp,#4
000054  7c89              LDRB     r1,[r1,#0x12]
000056  0609              LSLS     r1,r1,#24
000058  0f89              LSRS     r1,r1,#30
00005a  0189              LSLS     r1,r1,#6
00005c  22c0              MOVS     r2,#0xc0
00005e  4011              ANDS     r1,r1,r2
000060  4608              MOV      r0,r1
000062  490b              LDR      r1,|L4.144|
000064  7c89              LDRB     r1,[r1,#0x12]
000066  4391              BICS     r1,r1,r2
000068  4301              ORRS     r1,r1,r0
00006a  4a09              LDR      r2,|L4.144|
00006c  7491              STRB     r1,[r2,#0x12]
;;;326        // Setting MCD function
;;;327        CSC->CR0.MBIT.MCD_DIS = CSC_SET.CR0.MBIT.MCD_DIS;
00006e  4669              MOV      r1,sp
000070  7d09              LDRB     r1,[r1,#0x14]
000072  06c9              LSLS     r1,r1,#27
000074  0fc9              LSRS     r1,r1,#31
000076  0109              LSLS     r1,r1,#4
000078  2210              MOVS     r2,#0x10
00007a  4011              ANDS     r1,r1,r2
00007c  4608              MOV      r0,r1
00007e  4904              LDR      r1,|L4.144|
000080  7c09              LDRB     r1,[r1,#0x10]
000082  4391              BICS     r1,r1,r2
000084  4301              ORRS     r1,r1,r0
000086  4a02              LDR      r2,|L4.144|
000088  7411              STRB     r1,[r2,#0x10]
;;;328        
;;;329    }
00008a  b014              ADD      sp,sp,#0x50
00008c  bd10              POP      {r4,pc}
;;;330    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x4c010000
                  |L4.148|
                          DCD      0x44020020

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  CSC_InitConfig
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00010000
                          DCD      0x00000000
                          DCD      0x00000210
                          DCD      0x00000001
                          DCD      0x00000008
                          DCD      0x0000911f
                          DCD      0x000f13ed
                          DCD      0x00008993
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "RTE\\MG32x02z_ChipInit_Wizard\\MG32F02A132\\MG32x02z_CSC_Init.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_MG32x02z_CSC_Init_c_9c9a8ebc____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_MG32x02z_CSC_Init_c_9c9a8ebc____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_MG32x02z_CSC_Init_c_9c9a8ebc____REVSH|
#line 496
|__asm___19_MG32x02z_CSC_Init_c_9c9a8ebc____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
