; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_adc_drv.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_adc_drv.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_adc_drv.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Source\MG32x02z_ADC_DRV.c]
                          THUMB

                          AREA ||i.ADC_AutoOff_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoOff_Cmd PROC
;;;1152    */
;;;1153   void ADC_AutoOff_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1154   {
;;;1155       ADCx->CR0.MBIT.AUTOFF_EN = NewState;
000002  7c02              LDRB     r2,[r0,#0x10]
000004  2302              MOVS     r3,#2
000006  439a              BICS     r2,r2,r3
000008  004b              LSLS     r3,r1,#1
00000a  2402              MOVS     r4,#2
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7402              STRB     r2,[r0,#0x10]
;;;1156   }
000012  bd10              POP      {r4,pc}
;;;1157   #endif
                          ENDP


                          AREA ||i.ADC_BaseStructure_Init||, CODE, READONLY, ALIGN=1

                  ADC_BaseStructure_Init PROC
;;;114     */
;;;115     void ADC_BaseStructure_Init(ADC_InitTypeDef* ADC_BaseInitStruct)
000000  2100              MOVS     r1,#0
;;;116    {
;;;117        // config ADC clock 
;;;118        ADC_BaseInitStruct->ADCMainClockSelect = ADC_CKADC;
000002  7001              STRB     r1,[r0,#0]
;;;119            ADC_BaseInitStruct->ADC_IntCK_Div = ADC_IntDIV16;   // for internal clock divider
000004  2103              MOVS     r1,#3
000006  7041              STRB     r1,[r0,#1]
;;;120            ADC_BaseInitStruct->ADC_CKPLL_Div = ADC_PLLDIV6;    // only for clock select PLL     
000008  7081              STRB     r1,[r0,#2]
;;;121        
;;;122        // ADC data alignment mode (Right or Left)
;;;123        ADC_BaseInitStruct->ADC_DataAlign = ADC_RightJustified;
00000a  2100              MOVS     r1,#0
00000c  70c1              STRB     r1,[r0,#3]
;;;124        
;;;125        // ADC conversion resolution 10 or 12 bit
;;;126        ADC_BaseInitStruct->ADC_ResolutionSel = ADC_12BitData;
00000e  7101              STRB     r1,[r0,#4]
;;;127        
;;;128        // ADC overwritten data or keep data
;;;129        ADC_BaseInitStruct->ADC_DataOverrunEvent = ADC_DataOverWritten;
000010  7141              STRB     r1,[r0,#5]
;;;130        
;;;131    }
000012  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||i.ADC_Base_Init||, CODE, READONLY, ALIGN=1

                  ADC_Base_Init PROC
;;;150     */
;;;151    void ADC_Base_Init(ADC_Struct* ADCx, ADC_InitTypeDef* ADC_BaseInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;152    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;153        // config clock
;;;154        ADC_ClockSource_Select(ADCx, ADC_BaseInitStruct->ADCMainClockSelect);
000006  7821              LDRB     r1,[r4,#0]
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       ADC_ClockSource_Select
;;;155            ADC_SetInternalClockDivider(ADCx, ADC_BaseInitStruct->ADC_IntCK_Div);
00000e  7861              LDRB     r1,[r4,#1]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       ADC_SetInternalClockDivider
;;;156            ADC_SetPLLClockDivider(ADCx, ADC_BaseInitStruct->ADC_CKPLL_Div);
000016  78a1              LDRB     r1,[r4,#2]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       ADC_SetPLLClockDivider
;;;157        
;;;158        // ADC data alignment
;;;159        ADC_DataAlignment_Select(ADCx, ADC_BaseInitStruct->ADC_DataAlign);
00001e  78e1              LDRB     r1,[r4,#3]
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       ADC_DataAlignment_Select
;;;160        
;;;161        // ADC conversion resolution
;;;162        ADC_DataResolution_Select(ADCx, ADC_BaseInitStruct->ADC_ResolutionSel);
000026  7921              LDRB     r1,[r4,#4]
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       ADC_DataResolution_Select
;;;163        
;;;164        // ADC data overwritten or keep mode
;;;165        ADC_DataOverrunMode_Select(ADCx, ADC_BaseInitStruct->ADC_DataOverrunEvent);
00002e  7961              LDRB     r1,[r4,#5]
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       ADC_DataOverrunMode_Select
;;;166        
;;;167        #if defined(MG32_2ND)
;;;168            ADCx->ANA.W |= 0x00000300;
;;;169        #endif
;;;170        #if defined(MG32_3RD)
;;;171            ADCx->ANA.W = (ADCx->ANA.W & ADC_ANA_CONV_TIME_mask_w) | 0x00000200;
;;;172        #endif
;;;173    }
000036  bd30              POP      {r4,r5,pc}
;;;174    ///@}
                          ENDP


                          AREA ||i.ADC_ChannelMUX_Select||, CODE, READONLY, ALIGN=1

                  ADC_ChannelMUX_Select PROC
;;;1446    */
;;;1447   void ADC_ChannelMUX_Select(ADC_Struct* ADCx, ADC_ChannelMUX_Def ChannelSel)
000000  b510              PUSH     {r4,lr}
;;;1448   {
;;;1449       ADCx->START.MBIT.CH_SEL = ChannelSel;
000002  2221              MOVS     r2,#0x21
000004  5c12              LDRB     r2,[r2,r0]
000006  2310              MOVS     r3,#0x10
000008  439a              BICS     r2,r2,r3
00000a  010b              LSLS     r3,r1,#4
00000c  2410              MOVS     r4,#0x10
00000e  4023              ANDS     r3,r3,r4
000010  431a              ORRS     r2,r2,r3
000012  2321              MOVS     r3,#0x21
000014  541a              STRB     r2,[r3,r0]
;;;1450   }
000016  bd10              POP      {r4,pc}
;;;1451   
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;2355    */
;;;2356   void ADC_ClearFlag(ADC_Struct* ADCx, uint32_t ADC_ITSTAFlag)
000000  6001              STR      r1,[r0,#0]
;;;2357   {
;;;2358       ADCx->STA.W = ADC_ITSTAFlag;
;;;2359   }
000002  4770              BX       lr
;;;2360   ///@}
                          ENDP


                          AREA ||i.ADC_ClearSum0Flags||, CODE, READONLY, ALIGN=1

                  ADC_ClearSum0Flags PROC
;;;1794    */
;;;1795   void ADC_ClearSum0Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag)
000000  8641              STRH     r1,[r0,#0x32]
;;;1796   {
;;;1797       ADCx->SUM0.H[1] = ADC_SUMxFlag;
;;;1798   }
000002  4770              BX       lr
;;;1799   /**
                          ENDP


                          AREA ||i.ADC_ClearSum1Flags||, CODE, READONLY, ALIGN=1

                  ADC_ClearSum1Flags PROC
;;;1815    */
;;;1816   void ADC_ClearSum1Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag)
000000  86c1              STRH     r1,[r0,#0x36]
;;;1817   {
;;;1818       ADCx->SUM1.H[1] = ADC_SUMxFlag;
;;;1819   }
000002  4770              BX       lr
;;;1820   /**
                          ENDP


                          AREA ||i.ADC_ClearSum2Flags||, CODE, READONLY, ALIGN=1

                  ADC_ClearSum2Flags PROC
;;;1836    */
;;;1837   void ADC_ClearSum2Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag)
000000  8741              STRH     r1,[r0,#0x3a]
;;;1838   {
;;;1839       ADCx->SUM2.H[1] = ADC_SUMxFlag;
;;;1840   }
000002  4770              BX       lr
;;;1841   /**
                          ENDP


                          AREA ||i.ADC_ClockSource_Select||, CODE, READONLY, ALIGN=1

                  ADC_ClockSource_Select PROC
;;;221     */
;;;222    void ADC_ClockSource_Select(ADC_Struct* ADCx, ADC_ClockSourceDef ADCClockSrc)
000000  7a42              LDRB     r2,[r0,#9]
;;;223    {
;;;224    	ADCx->CLK.MBIT.CK_SEL2 = ADCClockSrc;
000002  0892              LSRS     r2,r2,#2
000004  0092              LSLS     r2,r2,#2
000006  078b              LSLS     r3,r1,#30
000008  0f9b              LSRS     r3,r3,#30
00000a  431a              ORRS     r2,r2,r3
00000c  7242              STRB     r2,[r0,#9]
;;;225    }
00000e  4770              BX       lr
;;;226    /**
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;1050    */
;;;1051   void ADC_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  7c02              LDRB     r2,[r0,#0x10]
;;;1052   {
;;;1053       ADCx->CR0.MBIT.EN = NewState;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  07cb              LSLS     r3,r1,#31
000008  0fdb              LSRS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  7402              STRB     r2,[r0,#0x10]
;;;1054   }
00000e  4770              BX       lr
;;;1055   
                          ENDP


                          AREA ||i.ADC_ContinueMode_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_ContinueMode_Cmd PROC
;;;1309    */
;;;1310   void ADC_ContinueMode_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1311   {
;;;1312       ADCx->START.MBIT.TRG_CONT = NewState;
000002  2222              MOVS     r2,#0x22
000004  5c12              LDRB     r2,[r2,r0]
000006  2308              MOVS     r3,#8
000008  439a              BICS     r2,r2,r3
00000a  00cb              LSLS     r3,r1,#3
00000c  2408              MOVS     r4,#8
00000e  4023              ANDS     r3,r3,r4
000010  431a              ORRS     r2,r2,r3
000012  2322              MOVS     r3,#0x22
000014  541a              STRB     r2,[r3,r0]
;;;1313   }
000016  bd10              POP      {r4,pc}
;;;1314   /**
                          ENDP


                          AREA ||i.ADC_ConversionMode_Select||, CODE, READONLY, ALIGN=1

                  ADC_ConversionMode_Select PROC
;;;1265    */
;;;1266   void ADC_ConversionMode_Select(ADC_Struct* ADCx, ADC_ConversionModeDef ADCConvMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1267   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1268       switch(ADCConvMode)
000006  0023              MOVS     r3,r4
000008  f7fffffe          BL       __ARM_common_switch8
00000c  05040f1a          DCB      0x05,0x04,0x0f,0x1a
000010  25303b00          DCB      0x25,0x30,0x3b,0x00
;;;1269       {
;;;1270           case ADCMode:
;;;1271               ADC_MainConversionMode_Select(ADC0, ADC_OneShot);
000014  2100              MOVS     r1,#0
000016  205b              MOVS     r0,#0x5b
000018  0600              LSLS     r0,r0,#24
00001a  f7fffffe          BL       ADC_MainConversionMode_Select
;;;1272               ADC_ContinueMode_Cmd(ADC0, DISABLE);
00001e  2100              MOVS     r1,#0
000020  205b              MOVS     r0,#0x5b
000022  0600              LSLS     r0,r0,#24
000024  f7fffffe          BL       ADC_ContinueMode_Cmd
;;;1273               break;
000028  e02c              B        |L12.132|
;;;1274           
;;;1275           case ADCContinueMode:
;;;1276               ADC_MainConversionMode_Select(ADC0, ADC_OneShot);
00002a  2100              MOVS     r1,#0
00002c  205b              MOVS     r0,#0x5b
00002e  0600              LSLS     r0,r0,#24
000030  f7fffffe          BL       ADC_MainConversionMode_Select
;;;1277               ADC_ContinueMode_Cmd(ADC0, ENABLE);
000034  2101              MOVS     r1,#1
000036  205b              MOVS     r0,#0x5b
000038  0600              LSLS     r0,r0,#24
00003a  f7fffffe          BL       ADC_ContinueMode_Cmd
;;;1278               break;
00003e  e021              B        |L12.132|
;;;1279   
;;;1280           case ScanMode:
;;;1281               ADC_MainConversionMode_Select(ADC0, ADC_Scan);
000040  2101              MOVS     r1,#1
000042  205b              MOVS     r0,#0x5b
000044  0600              LSLS     r0,r0,#24
000046  f7fffffe          BL       ADC_MainConversionMode_Select
;;;1282               ADC_ContinueMode_Cmd(ADC0, DISABLE);
00004a  2100              MOVS     r1,#0
00004c  205b              MOVS     r0,#0x5b
00004e  0600              LSLS     r0,r0,#24
000050  f7fffffe          BL       ADC_ContinueMode_Cmd
;;;1283               break;
000054  e016              B        |L12.132|
;;;1284   
;;;1285           case ScanContinueMode:
;;;1286               ADC_MainConversionMode_Select(ADC0, ADC_Scan);
000056  2101              MOVS     r1,#1
000058  205b              MOVS     r0,#0x5b
00005a  0600              LSLS     r0,r0,#24
00005c  f7fffffe          BL       ADC_MainConversionMode_Select
;;;1287               ADC_ContinueMode_Cmd(ADC0, ENABLE);
000060  2101              MOVS     r1,#1
000062  205b              MOVS     r0,#0x5b
000064  0600              LSLS     r0,r0,#24
000066  f7fffffe          BL       ADC_ContinueMode_Cmd
;;;1288               break;
00006a  e00b              B        |L12.132|
;;;1289   
;;;1290           case LoopMode:
;;;1291               ADC_MainConversionMode_Select(ADC0, ADC_Loop);
00006c  2102              MOVS     r1,#2
00006e  205b              MOVS     r0,#0x5b
000070  0600              LSLS     r0,r0,#24
000072  f7fffffe          BL       ADC_MainConversionMode_Select
;;;1292               ADC_ContinueMode_Cmd(ADC0, DISABLE);
000076  2100              MOVS     r1,#0
000078  205b              MOVS     r0,#0x5b
00007a  0600              LSLS     r0,r0,#24
00007c  f7fffffe          BL       ADC_ContinueMode_Cmd
;;;1293               break;
000080  e000              B        |L12.132|
;;;1294   
;;;1295           default:
;;;1296               break;
000082  bf00              NOP      
                  |L12.132|
000084  bf00              NOP                            ;1273
;;;1297       }
;;;1298               
;;;1299   }
000086  bd30              POP      {r4,r5,pc}
;;;1300   /**
                          ENDP


                          AREA ||i.ADC_DMA_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_DMA_Cmd PROC
;;;1069    */
;;;1070   void ADC_DMA_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1071   {
;;;1072       ADCx->CR0.MBIT.DMA_EN = NewState;
000002  7cc2              LDRB     r2,[r0,#0x13]
000004  2380              MOVS     r3,#0x80
000006  439a              BICS     r2,r2,r3
000008  01cb              LSLS     r3,r1,#7
00000a  2480              MOVS     r4,#0x80
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  74c2              STRB     r2,[r0,#0x13]
;;;1073   }
000012  bd10              POP      {r4,pc}
;;;1074   
                          ENDP


                          AREA ||i.ADC_DataAlignment_Select||, CODE, READONLY, ALIGN=1

                  ADC_DataAlignment_Select PROC
;;;1965    */
;;;1966   void ADC_DataAlignment_Select(ADC_Struct* ADCx, ADC_DataAlignModeDef AlignMode)
000000  b510              PUSH     {r4,lr}
;;;1967   {
;;;1968       ADCx->CR1.MBIT.ALIGN_SEL = AlignMode;
000002  7d02              LDRB     r2,[r0,#0x14]
000004  2308              MOVS     r3,#8
000006  439a              BICS     r2,r2,r3
000008  00cb              LSLS     r3,r1,#3
00000a  2408              MOVS     r4,#8
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7502              STRB     r2,[r0,#0x14]
;;;1969   }
000012  bd10              POP      {r4,pc}
;;;1970   
                          ENDP


                          AREA ||i.ADC_DataOverrunMode_Select||, CODE, READONLY, ALIGN=1

                  ADC_DataOverrunMode_Select PROC
;;;2006    */
;;;2007   void ADC_DataOverrunMode_Select(ADC_Struct* ADCx, ADC_DataOWDef DataOW)
000000  7d42              LDRB     r2,[r0,#0x15]
;;;2008   {
;;;2009       ADCx->CR1.MBIT.OVR_MDS = DataOW;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  07cb              LSLS     r3,r1,#31
000008  0fdb              LSRS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  7542              STRB     r2,[r0,#0x15]
;;;2010   }
00000e  4770              BX       lr
;;;2011   
                          ENDP


                          AREA ||i.ADC_DataResolution_Select||, CODE, READONLY, ALIGN=1

                  ADC_DataResolution_Select PROC
;;;1986    */
;;;1987   void ADC_DataResolution_Select(ADC_Struct* ADCx, ADC_ResolutionDef ResolutionData)
000000  b510              PUSH     {r4,lr}
;;;1988   {
;;;1989       ADCx->CR0.MBIT.RES_SEL = ResolutionData;
000002  7c02              LDRB     r2,[r0,#0x10]
000004  23c0              MOVS     r3,#0xc0
000006  439a              BICS     r2,r2,r3
000008  018b              LSLS     r3,r1,#6
00000a  24c0              MOVS     r4,#0xc0
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7402              STRB     r2,[r0,#0x10]
;;;1990   }
000012  bd10              POP      {r4,pc}
;;;1991   
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;59      */
;;;60     void ADC_DeInit(ADC_Struct *ADCx)
000000  2100              MOVS     r1,#0
;;;61     {
;;;62         ADCx->INT.W = 0x00000000;
000002  6041              STR      r1,[r0,#4]
;;;63         ADCx->CLK.W = 0x00000000;
000004  6081              STR      r1,[r0,#8]
;;;64         ADCx->CR0.W = 0x00000000;
000006  6101              STR      r1,[r0,#0x10]
;;;65         ADCx->CR1.W = 0x00000000;
000008  6141              STR      r1,[r0,#0x14]
;;;66         ADCx->MSK.W = 0x00000000;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;67         ADCx->START.W = 0x00001000;
00000c  2101              MOVS     r1,#1
00000e  0309              LSLS     r1,r1,#12
000010  6201              STR      r1,[r0,#0x20]
;;;68     #if defined(MG32_1ST)	
;;;69         ADCx->ANA.W = 0x00008000;
000012  00c9              LSLS     r1,r1,#3
000014  6241              STR      r1,[r0,#0x24]
;;;70     #endif
;;;71     #if defined(MG32_2ND)
;;;72         ADCx->ANA.W = 0x00000300;
;;;73     #endif
;;;74     #if defined(MG32_3RD)
;;;75         ADCx->ANA.W = 0x00000200;
;;;76     #endif
;;;77         // CAL
;;;78     #if defined(MG32_3RD)
;;;79         ADCx->GAIN.W = (0x00000000 | (ADCx->GAIN.W & 0x1F000000));
;;;80     #else
;;;81         ADCx->GAIN.W = 0x00000000;
000016  2100              MOVS     r1,#0
000018  62c1              STR      r1,[r0,#0x2c]
;;;82     #endif
;;;83         ADCx->SUM0.W = 0x00E00000;
00001a  2107              MOVS     r1,#7
00001c  0549              LSLS     r1,r1,#21
00001e  6301              STR      r1,[r0,#0x30]
;;;84         ADCx->SUM1.W = 0x00E00000;
000020  6341              STR      r1,[r0,#0x34]
;;;85         ADCx->SUM2.W = 0x00E00000;
000022  6381              STR      r1,[r0,#0x38]
;;;86         // TCAL
;;;87         ADCx->DAT0.B[2] = 0xC0;
000024  22c0              MOVS     r2,#0xc0
000026  2142              MOVS     r1,#0x42
000028  540a              STRB     r2,[r1,r0]
;;;88         
;;;89         ADCx->STA.W = 0xFFFFFFFF;
00002a  2100              MOVS     r1,#0
00002c  43c9              MVNS     r1,r1
00002e  6001              STR      r1,[r0,#0]
;;;90     }
000030  4770              BX       lr
;;;91     ///@}
                          ENDP


                          AREA ||i.ADC_ExternalChannel_Select||, CODE, READONLY, ALIGN=1

                  ADC_ExternalChannel_Select PROC
;;;1480    */
;;;1481   void ADC_ExternalChannel_Select(ADC_Struct* ADCx, ADC_ExtChannelDef ExtCHSel)
000000  2221              MOVS     r2,#0x21
;;;1482   {
;;;1483       ADCx->START.B[1] = ExtCHSel;
000002  5411              STRB     r1,[r2,r0]
;;;1484   }
000004  4770              BX       lr
;;;1485   
                          ENDP


                          AREA ||i.ADC_GetAllFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetAllFlagStatus PROC
;;;2327    */
;;;2328   uint32_t ADC_GetAllFlagStatus(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;2329   {
;;;2330       return ADCx->STA.W;
000002  6808              LDR      r0,[r1,#0]
;;;2331   }
000004  4770              BX       lr
;;;2332   
                          ENDP


                          AREA ||i.ADC_GetDAT0Channel||, CODE, READONLY, ALIGN=1

                  ADC_GetDAT0Channel PROC
;;;2047    */
;;;2048   uint8_t ADC_GetDAT0Channel(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;2049   {
;;;2050       return ADCx->DAT0.MBIT.DAT0_CH;
000002  2043              MOVS     r0,#0x43
000004  5c40              LDRB     r0,[r0,r1]
000006  0900              LSRS     r0,r0,#4
;;;2051   }
000008  4770              BX       lr
;;;2052   
                          ENDP


                          AREA ||i.ADC_GetDAT0Data||, CODE, READONLY, ALIGN=1

                  ADC_GetDAT0Data PROC
;;;2064    */
;;;2065   int16_t ADC_GetDAT0Data(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;2066   {
;;;2067       return ADCx->DAT0.H[0];
000002  2040              MOVS     r0,#0x40
000004  5a40              LDRH     r0,[r0,r1]
000006  b200              SXTH     r0,r0
;;;2068   }
000008  4770              BX       lr
;;;2069   /**
                          ENDP


                          AREA ||i.ADC_GetDAT0Flags||, CODE, READONLY, ALIGN=1

                  ADC_GetDAT0Flags PROC
;;;2030    */
;;;2031   uint8_t ADC_GetDAT0Flags(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;2032   {
;;;2033       return ADCx->DAT0.B[2];
000002  2042              MOVS     r0,#0x42
000004  5c40              LDRB     r0,[r0,r1]
;;;2034   }
000006  4770              BX       lr
;;;2035   
                          ENDP


                          AREA ||i.ADC_GetSingleFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSingleFlagStatus PROC
;;;2305    */
;;;2306   DRV_Return ADC_GetSingleFlagStatus(ADC_Struct* ADCx, uint32_t ADC_ITSTAFlag)
000000  4602              MOV      r2,r0
;;;2307   {   
;;;2308       if (ADCx->STA.W & ADC_ITSTAFlag)
000002  6810              LDR      r0,[r2,#0]
000004  4008              ANDS     r0,r0,r1
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L23.14|
;;;2309           return DRV_Happened;
00000a  2001              MOVS     r0,#1
                  |L23.12|
;;;2310       else
;;;2311           return DRV_UnHappened;
;;;2312       
;;;2313       
;;;2314   }
00000c  4770              BX       lr
                  |L23.14|
00000e  2000              MOVS     r0,#0                 ;2311
000010  e7fc              B        |L23.12|
;;;2315   
                          ENDP


                          AREA ||i.ADC_GetSum0Data||, CODE, READONLY, ALIGN=1

                  ADC_GetSum0Data PROC
;;;1852    */
;;;1853   int16_t ADC_GetSum0Data(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;1854   {
;;;1855       return ADCx->SUM0.H[0];
000002  8e08              LDRH     r0,[r1,#0x30]
000004  b200              SXTH     r0,r0
;;;1856   }
000006  4770              BX       lr
;;;1857   /**
                          ENDP


                          AREA ||i.ADC_GetSum0Flags||, CODE, READONLY, ALIGN=1

                  ADC_GetSum0Flags PROC
;;;1741    */
;;;1742   uint16_t ADC_GetSum0Flags(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;1743   {
;;;1744       return ADCx->SUM0.H[1];
000002  8e48              LDRH     r0,[r1,#0x32]
;;;1745   }
000004  4770              BX       lr
;;;1746   /**
                          ENDP


                          AREA ||i.ADC_GetSum1Data||, CODE, READONLY, ALIGN=1

                  ADC_GetSum1Data PROC
;;;1868    */
;;;1869   int16_t ADC_GetSum1Data(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;1870   {
;;;1871       return ADCx->SUM1.H[0];
000002  8e88              LDRH     r0,[r1,#0x34]
000004  b200              SXTH     r0,r0
;;;1872   }
000006  4770              BX       lr
;;;1873   /**
                          ENDP


                          AREA ||i.ADC_GetSum1Flags||, CODE, READONLY, ALIGN=1

                  ADC_GetSum1Flags PROC
;;;1757    */
;;;1758   uint16_t ADC_GetSum1Flags(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;1759   {
;;;1760       return ADCx->SUM1.H[1];
000002  8ec8              LDRH     r0,[r1,#0x36]
;;;1761   }
000004  4770              BX       lr
;;;1762   /**
                          ENDP


                          AREA ||i.ADC_GetSum2Data||, CODE, READONLY, ALIGN=1

                  ADC_GetSum2Data PROC
;;;1884    */
;;;1885   int16_t ADC_GetSum2Data(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;1886   {
;;;1887       return ADCx->SUM2.H[0];
000002  8f08              LDRH     r0,[r1,#0x38]
000004  b200              SXTH     r0,r0
;;;1888   }
000006  4770              BX       lr
;;;1889   /**
                          ENDP


                          AREA ||i.ADC_GetSum2Flags||, CODE, READONLY, ALIGN=1

                  ADC_GetSum2Flags PROC
;;;1773    */
;;;1774   uint16_t ADC_GetSum2Flags(ADC_Struct* ADCx)
000000  4601              MOV      r1,r0
;;;1775   {
;;;1776       return ADCx->SUM2.H[1];
000002  8f48              LDRH     r0,[r1,#0x3a]
;;;1777   }
000004  4770              BX       lr
;;;1778   /**
                          ENDP


                          AREA ||i.ADC_HoldConversion_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_HoldConversion_Cmd PROC
;;;1323    */
;;;1324   void ADC_HoldConversion_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1325   {
;;;1326       ADCx->START.MBIT.HOLD = NewState;
000002  2220              MOVS     r2,#0x20
000004  5c12              LDRB     r2,[r2,r0]
000006  2302              MOVS     r3,#2
000008  439a              BICS     r2,r2,r3
00000a  004b              LSLS     r3,r1,#1
00000c  2402              MOVS     r4,#2
00000e  4023              ANDS     r3,r3,r4
000010  431a              ORRS     r2,r2,r3
000012  2320              MOVS     r3,#0x20
000014  541a              STRB     r2,[r3,r0]
;;;1327   }
000016  bd10              POP      {r4,pc}
;;;1328   
                          ENDP


                          AREA ||i.ADC_ITEA_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_ITEA_Cmd PROC
;;;2272    */
;;;2273   void ADC_ITEA_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  7902              LDRB     r2,[r0,#4]
;;;2274   {
;;;2275       ADCx->INT.MBIT.IEA = NewState;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  07cb              LSLS     r3,r1,#31
000008  0fdb              LSRS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  7102              STRB     r2,[r0,#4]
;;;2276   }
00000e  4770              BX       lr
;;;2277   
                          ENDP


                          AREA ||i.ADC_IT_Config||, CODE, READONLY, ALIGN=1

                  ADC_IT_Config PROC
;;;2250    */
;;;2251   void ADC_IT_Config(ADC_Struct* ADCx, uint32_t ADC_ITSrc, FunctionalState NewState)
000000  2a01              CMP      r2,#1
;;;2252   {
;;;2253       if (NewState == ENABLE)
000002  d103              BNE      |L32.12|
;;;2254           ADCx->INT.W |= ADC_ITSrc;
000004  6843              LDR      r3,[r0,#4]
000006  430b              ORRS     r3,r3,r1
000008  6043              STR      r3,[r0,#4]
00000a  e002              B        |L32.18|
                  |L32.12|
;;;2255       else
;;;2256           ADCx->INT.W &= ~ADC_ITSrc;
00000c  6843              LDR      r3,[r0,#4]
00000e  438b              BICS     r3,r3,r1
000010  6043              STR      r3,[r0,#4]
                  |L32.18|
;;;2257   }
000012  4770              BX       lr
;;;2258   
                          ENDP


                          AREA ||i.ADC_InternalChannel_Select||, CODE, READONLY, ALIGN=1

                  ADC_InternalChannel_Select PROC
;;;1502    */
;;;1503   void ADC_InternalChannel_Select(ADC_Struct* ADCx, ADC_IntChannelDef IntCHSel)
000000  2221              MOVS     r2,#0x21
;;;1504   {
;;;1505       ADCx->START.B[1] = IntCHSel;
000002  5411              STRB     r1,[r2,r0]
;;;1506   }
000004  4770              BX       lr
;;;1507   
                          ENDP


                          AREA ||i.ADC_MainConversionMode_Select||, CODE, READONLY, ALIGN=1

                  ADC_MainConversionMode_Select PROC
;;;1340    */
;;;1341   void ADC_MainConversionMode_Select(ADC_Struct* ADCx, ADC_MainConversionModeDef MainCM)
000000  2223              MOVS     r2,#0x23
;;;1342   {
;;;1343       ADCx->START.MBIT.CONV_MDS = MainCM;
000002  5c12              LDRB     r2,[r2,r0]
000004  0892              LSRS     r2,r2,#2
000006  0092              LSLS     r2,r2,#2
000008  078b              LSLS     r3,r1,#30
00000a  0f9b              LSRS     r3,r3,#30
00000c  431a              ORRS     r2,r2,r3
00000e  2323              MOVS     r3,#0x23
000010  541a              STRB     r2,[r3,r0]
;;;1344   }
000012  4770              BX       lr
;;;1345   ///@}
                          ENDP


                          AREA ||i.ADC_Output_Select||, CODE, READONLY, ALIGN=1

                  ADC_Output_Select PROC
;;;364     */
;;;365    void ADC_Output_Select(ADC_Struct* ADCx,ADC_OutputDef ADCOutSel)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367        ADCx->CR1.MBIT.OUT_SEL = ADCOutSel;
000002  7d02              LDRB     r2,[r0,#0x14]
000004  2330              MOVS     r3,#0x30
000006  439a              BICS     r2,r2,r3
000008  010b              LSLS     r3,r1,#4
00000a  2430              MOVS     r4,#0x30
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7502              STRB     r2,[r0,#0x14]
;;;368    }
000012  bd10              POP      {r4,pc}
;;;369    ///@}
                          ENDP


                          AREA ||i.ADC_PGAOffsetCalibration_Cmd||, CODE, READONLY, ALIGN=2

                  ADC_PGAOffsetCalibration_Cmd PROC
;;;440     */
;;;441    void ADC_PGAOffsetCalibration_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;442    {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
;;;443    #if defined(MG32_1ST) || defined(MG32_2ND)
;;;444        uint8_t VOD_x, VOD_0, VOD_63;
;;;445        uint8_t PGAOFFT;
;;;446        
;;;447        if (NewState == DISABLE)
000006  9802              LDR      r0,[sp,#8]
000008  2800              CMP      r0,#0
00000a  d100              BNE      |L36.14|
                  |L36.12|
;;;448            return;
;;;449        
;;;450        // enable PGA calibration state
;;;451        ADCx->CAL.MBIT.CAL_POFFT = 1;
;;;452        
;;;453        //
;;;454        PGAOFFT = 32;
;;;455        ADC_SetPGAOffset(ADC0, PGAOFFT);
;;;456        ADC_PGA_Cmd(ADC0, ENABLE);
;;;457        
;;;458        // read VOD
;;;459        VOD_x = ADC0->STA.MBIT.POF;
;;;460        
;;;461        ADC_SetPGAOffset(ADC0, 0);
;;;462        VOD_0 = ADC0->STA.MBIT.POF;
;;;463        
;;;464        ADC_SetPGAOffset(ADC0, 63);
;;;465        VOD_63 = ADC0->STA.MBIT.POF;
;;;466        
;;;467        if((VOD_0 == VOD_x) && (VOD_63 == VOD_x))
;;;468        {
;;;469            ADC_SetPGAOffset(ADC0, PGAOFFT);
;;;470            ADC0->CAL.MBIT.CAL_POFFT = 0;
;;;471            return;
;;;472        }
;;;473        
;;;474        // read VOD 
;;;475        if (ADC0->STA.MBIT.POF != VOD_x)
;;;476        {
;;;477            PGAOFFT  = 33;
;;;478            ADC_SetPGAOffset(ADC0, PGAOFFT);
;;;479            
;;;480            while (1)
;;;481            {
;;;482                if (ADC0->STA.MBIT.POF != VOD_x) break;
;;;483                PGAOFFT ++;
;;;484                ADC_SetPGAOffset(ADC0, PGAOFFT);
;;;485            }
;;;486        } else 
;;;487        {
;;;488            PGAOFFT  = 31;
;;;489            ADC_SetPGAOffset(ADC0, PGAOFFT);
;;;490            
;;;491            while (1)
;;;492            {
;;;493                if (ADC0->STA.MBIT.POF != VOD_x) break;
;;;494                PGAOFFT --;
;;;495                ADC_SetPGAOffset(ADC0, PGAOFFT);
;;;496            }
;;;497            
;;;498        }
;;;499            
;;;500        // Disable calibration 
;;;501        ADC0->CAL.MBIT.CAL_POFFT = 0;
;;;502    #elif defined(MG32_3RD)
;;;503        uint8_t OFFT_PGA_MaxIDX, OFFT_PGA_MinIDX, OFFT_PGA_ActIDX, old_PGA_Gain, TargetIDX;
;;;504        uint8_t COMPCNT;
;;;505        uint32_t i, j;
;;;506        uint16_t ResultADC;
;;;507        float Disable_PGA_Value, MinCompareValue; 
;;;508        uint32_t rADC_MSK, rADC_START, rADC_CR0, rADC_CR1;
;;;509        uint32_t rSUM0, rSUM1, rSUM2;
;;;510        
;;;511        float PGA_Gain_V[] = {
;;;512            1.000, 1.012, 1.024, 1.037, 1.050, 1.063, 1.077, 1.091, 1.105, 1.120, 
;;;513            1.135, 1.151, 1.167, 1.183, 1.200, 1.217, 1.235, 1.254, 1.273, 1.292,
;;;514            1.313, 1.333, 1.355, 1.377, 1.400, 1.424, 1.448, 1.474, 1.500, 1.527,
;;;515            1.556, 1.585, 1.615, 1.647, 1.680, 1.714, 1.750, 1.787, 1.826, 1.867,
;;;516            1.909, 1.953, 2.000, 2.049, 2.100, 2.154, 2.211, 2.270, 2.333, 2.400,
;;;517            2.471, 2.545, 2.625, 2.710, 2.800, 2.897, 3.000, 3.111, 3.231, 3.360,
;;;518            3.500, 3.652, 3.818, 4.000 
;;;519        };
;;;520    
;;;521        // RESAVE
;;;522        rADC_MSK = ADC0->MSK.W;
;;;523        rADC_START = ADC0->START.W;
;;;524        rADC_CR0 = ADC0->CR0.W;    
;;;525        rADC_CR1 = ADC0->CR1.W;    
;;;526        rSUM0 = ADC0->SUM0.W;
;;;527        rSUM1 = ADC0->SUM1.W;
;;;528        rSUM2 = ADC0->SUM2.W;
;;;529         
;;;530        // ------------------------------------------------------------------------
;;;531        // check VBUF state
;;;532        if (PW->CR0.MBIT.IVR_EN == CLR)
;;;533        {
;;;534            // Enable VBUF + select (0)
;;;535            UnProtectModuleReg(PWprotect);
;;;536            PW_VoltageBuffer(ENABLE);
;;;537            ProtectModuleReg(PWprotect);
;;;538            
;;;539            // delay a time (2020.02.17) - VBUF settling time
;;;540            for(i=0;i<65536;i++);
;;;541        }
;;;542            
;;;543        // config ADC mode for PGA calibration 
;;;544        ADC_SetSumNumber(ADC0, 0);                  // Disable ADC accumulation function
;;;545        ADC_WindowDetect_Cmd(ADC0, DISABLE);        // Disable Window detect function
;;;546        ADC_ConversionMode_Select(ADC0, ADCMode);   // Change ADC to One-Shot mode
;;;547        ADC_TriggerSource_Select(ADC0, ADC_START);  // Trigger mode 
;;;548        ADC_SetOutputCodeFormat(ADC0, ADC_UnsignedFormat);
;;;549        ADC_DataResolution_Select(ADC0, ADC_12BitData);
;;;550        
;;;551        // ------------------------------------------------------------------------
;;;552        // Dsiable PGA & disable PGAOUT
;;;553        ADC_PGA_Cmd(ADC0, DISABLE);
;;;554        
;;;555        // Sample ADC conversion without PGA
;;;556        old_PGA_Gain = ADC0->GAIN.MBIT.GAIN_PGA;
;;;557        ADC_InternalChannel_Select(ADC0, ADC_INT_VPG);
;;;558        ADC_SetExtendSampling(ADC0, 255);
;;;559        //
;;;560        {
;;;561            // abandon 10 conversion data
;;;562            for (j=0;j<10;j++)
;;;563            {
;;;564                ADC_SoftwareConversion_Cmd(ADC0, ENABLE);        
;;;565                while (ADC_GetSingleFlagStatus (ADC0, ADC_E1CNVF) == DRV_UnHappened);
;;;566                ADC_ClearFlag(ADC0,ADC_E1CNVF);
;;;567            }
;;;568            
;;;569            // Average
;;;570            for (j=0,ResultADC=0;j<10;j++)
;;;571            {
;;;572                ADC_SoftwareConversion_Cmd(ADC0, ENABLE);        
;;;573                while (ADC_GetSingleFlagStatus (ADC0, ADC_E1CNVF) == DRV_UnHappened);
;;;574                ADC_ClearFlag(ADC0,ADC_E1CNVF);
;;;575                ResultADC += ADC_GetDAT0Data(ADC0);
;;;576            }
;;;577            ResultADC = ResultADC / 10;
;;;578            
;;;579            // Disable_PGA_Value = Average * PGA gain
;;;580            Disable_PGA_Value = ((float) ResultADC) * PGA_Gain_V[old_PGA_Gain];
;;;581        }
;;;582        
;;;583        // ------------------------------------------------------------------------
;;;584        // Enable PGA
;;;585        ADC_PGA_Cmd(ADC0, ENABLE);
;;;586        
;;;587        // Initial OFFT of PGA
;;;588        COMPCNT = 0;
;;;589        OFFT_PGA_MinIDX = 0;
;;;590        OFFT_PGA_MaxIDX = 31;
;;;591        TargetIDX = OFFT_PGA_ActIDX = OFFT_PGA_MaxIDX >> 1;
;;;592        MinCompareValue = 65535;
;;;593        
;;;594        // ------------------------------------------------------------------------
;;;595        // Compare ADC x PGA 
;;;596        while(COMPCNT < 6 )
;;;597        {
;;;598            // set ADC_GAIN_OFFT
;;;599            ADC_SetPGAOffset(ADC0, OFFT_PGA_ActIDX);
;;;600            
;;;601            // Average ADC conversion
;;;602            for (i=0, ResultADC=0 ; i<10; i++)
;;;603            {
;;;604                ADC_SoftwareConversion_Cmd(ADC0, ENABLE);
;;;605                while (ADC_GetSingleFlagStatus (ADC0,ADC_E1CNVF) == DRV_UnHappened);
;;;606                ADC_ClearFlag(ADC0, (ADC_E1CNVF | ADC_ESMPF));
;;;607                ResultADC += ADC_GetDAT0Data(ADC0);
;;;608            }
;;;609            ResultADC = ResultADC / 10;
;;;610                    
;;;611            // --------------------------------------------------------------------
;;;612            // exit condition
;;;613            if (ResultADC == Disable_PGA_Value)
;;;614            {
;;;615                TargetIDX = OFFT_PGA_ActIDX;
;;;616                break;
;;;617            }
;;;618            
;;;619            // --------------------------------------------------------------------
;;;620            // compare minimum MinCompareValue then get target index
;;;621            if (ResultADC >= Disable_PGA_Value)
;;;622            {
;;;623                if ((ResultADC - Disable_PGA_Value) < MinCompareValue)
;;;624                {
;;;625                    TargetIDX = OFFT_PGA_ActIDX;
;;;626                    MinCompareValue = (Disable_PGA_Value - ResultADC);
;;;627                }
;;;628            }
;;;629            else if ((Disable_PGA_Value - ResultADC) < MinCompareValue)
;;;630            {
;;;631                TargetIDX = OFFT_PGA_ActIDX;
;;;632                MinCompareValue = (Disable_PGA_Value - ResultADC);
;;;633            }
;;;634            
;;;635            // --------------------------------------------------------------------
;;;636            // check ADC_CONV data - Update OFFT_PGA_MaxIDX, OFFT_PGA_MinIDX & OFFT_PGA_ActIDX
;;;637            if (ResultADC >= Disable_PGA_Value)
;;;638            {
;;;639                OFFT_PGA_MaxIDX = OFFT_PGA_ActIDX;
;;;640                OFFT_PGA_ActIDX = (OFFT_PGA_MinIDX + OFFT_PGA_MaxIDX) >> 1;
;;;641            }
;;;642            else 
;;;643            {
;;;644                OFFT_PGA_MinIDX = OFFT_PGA_ActIDX;
;;;645                OFFT_PGA_ActIDX = (OFFT_PGA_MinIDX + OFFT_PGA_MaxIDX) >> 1;
;;;646            }
;;;647            
;;;648            COMPCNT ++;
;;;649        }
;;;650        
;;;651        // ------------------------------------------------------------------------
;;;652        // set ADC_GAIN_OFFT by TargetIDX
;;;653        ADC_SetPGAOffset(ADC0, TargetIDX);
;;;654        // restore
;;;655        ADC0->MSK.W = rADC_MSK;
;;;656        ADC0->START.W = rADC_START;
;;;657        ADC0->CR0.W = rADC_CR0;    
;;;658        ADC0->CR1.W = rADC_CR1;    
;;;659        ADC0->SUM0.W = rSUM0;
;;;660        ADC0->SUM1.W = rSUM1;
;;;661        ADC0->SUM2.W = rSUM2;
;;;662                
;;;663    #endif
;;;664    }
00000c  bdfe              POP      {r1-r7,pc}
                  |L36.14|
00000e  2028              MOVS     r0,#0x28              ;451
000010  5d80              LDRB     r0,[r0,r6]            ;451
000012  2108              MOVS     r1,#8                 ;451
000014  4388              BICS     r0,r0,r1              ;451
000016  3008              ADDS     r0,r0,#8              ;451
000018  2128              MOVS     r1,#0x28              ;451
00001a  5588              STRB     r0,[r1,r6]            ;451
00001c  2520              MOVS     r5,#0x20              ;454
00001e  4629              MOV      r1,r5                 ;455
000020  205b              MOVS     r0,#0x5b              ;455
000022  0600              LSLS     r0,r0,#24             ;455
000024  f7fffffe          BL       ADC_SetPGAOffset
000028  2101              MOVS     r1,#1                 ;456
00002a  205b              MOVS     r0,#0x5b              ;456
00002c  0600              LSLS     r0,r0,#24             ;456
00002e  f7fffffe          BL       ADC_PGA_Cmd
000032  205b              MOVS     r0,#0x5b              ;459
000034  0600              LSLS     r0,r0,#24             ;459
000036  78c0              LDRB     r0,[r0,#3]            ;459
000038  07c4              LSLS     r4,r0,#31             ;459
00003a  0fe4              LSRS     r4,r4,#31             ;459
00003c  2100              MOVS     r1,#0                 ;461
00003e  205b              MOVS     r0,#0x5b              ;461
000040  0600              LSLS     r0,r0,#24             ;461
000042  f7fffffe          BL       ADC_SetPGAOffset
000046  205b              MOVS     r0,#0x5b              ;462
000048  0600              LSLS     r0,r0,#24             ;462
00004a  78c0              LDRB     r0,[r0,#3]            ;462
00004c  07c7              LSLS     r7,r0,#31             ;462
00004e  0fff              LSRS     r7,r7,#31             ;462
000050  213f              MOVS     r1,#0x3f              ;464
000052  205b              MOVS     r0,#0x5b              ;464
000054  0600              LSLS     r0,r0,#24             ;464
000056  f7fffffe          BL       ADC_SetPGAOffset
00005a  205b              MOVS     r0,#0x5b              ;465
00005c  0600              LSLS     r0,r0,#24             ;465
00005e  78c0              LDRB     r0,[r0,#3]            ;465
000060  07c0              LSLS     r0,r0,#31             ;465
000062  0fc0              LSRS     r0,r0,#31             ;465
000064  9000              STR      r0,[sp,#0]            ;465
000066  42a7              CMP      r7,r4                 ;467
000068  d10e              BNE      |L36.136|
00006a  9800              LDR      r0,[sp,#0]            ;467
00006c  42a0              CMP      r0,r4                 ;467
00006e  d10b              BNE      |L36.136|
000070  4629              MOV      r1,r5                 ;469
000072  205b              MOVS     r0,#0x5b              ;469
000074  0600              LSLS     r0,r0,#24             ;469
000076  f7fffffe          BL       ADC_SetPGAOffset
00007a  4823              LDR      r0,|L36.264|
00007c  7a00              LDRB     r0,[r0,#8]            ;470
00007e  2108              MOVS     r1,#8                 ;470
000080  4388              BICS     r0,r0,r1              ;470
000082  4921              LDR      r1,|L36.264|
000084  7208              STRB     r0,[r1,#8]            ;470
000086  e7c1              B        |L36.12|
                  |L36.136|
000088  205b              MOVS     r0,#0x5b              ;475
00008a  0600              LSLS     r0,r0,#24             ;475
00008c  78c0              LDRB     r0,[r0,#3]            ;475
00008e  07c0              LSLS     r0,r0,#31             ;475
000090  0fc0              LSRS     r0,r0,#31             ;475
000092  42a0              CMP      r0,r4                 ;475
000094  d017              BEQ      |L36.198|
000096  2521              MOVS     r5,#0x21              ;477
000098  4629              MOV      r1,r5                 ;478
00009a  205b              MOVS     r0,#0x5b              ;478
00009c  0600              LSLS     r0,r0,#24             ;478
00009e  f7fffffe          BL       ADC_SetPGAOffset
0000a2  e00e              B        |L36.194|
                  |L36.164|
0000a4  205b              MOVS     r0,#0x5b              ;482
0000a6  0600              LSLS     r0,r0,#24             ;482
0000a8  78c0              LDRB     r0,[r0,#3]            ;482
0000aa  07c0              LSLS     r0,r0,#31             ;482
0000ac  0fc0              LSRS     r0,r0,#31             ;482
0000ae  42a0              CMP      r0,r4                 ;482
0000b0  d000              BEQ      |L36.180|
0000b2  e007              B        |L36.196|
                  |L36.180|
0000b4  1c68              ADDS     r0,r5,#1              ;483
0000b6  b2c5              UXTB     r5,r0                 ;483
0000b8  4629              MOV      r1,r5                 ;484
0000ba  205b              MOVS     r0,#0x5b              ;484
0000bc  0600              LSLS     r0,r0,#24             ;484
0000be  f7fffffe          BL       ADC_SetPGAOffset
                  |L36.194|
0000c2  e7ef              B        |L36.164|
                  |L36.196|
0000c4  e017              B        |L36.246|
                  |L36.198|
0000c6  251f              MOVS     r5,#0x1f              ;488
0000c8  4629              MOV      r1,r5                 ;489
0000ca  205b              MOVS     r0,#0x5b              ;489
0000cc  0600              LSLS     r0,r0,#24             ;489
0000ce  f7fffffe          BL       ADC_SetPGAOffset
0000d2  e00e              B        |L36.242|
                  |L36.212|
0000d4  205b              MOVS     r0,#0x5b              ;493
0000d6  0600              LSLS     r0,r0,#24             ;493
0000d8  78c0              LDRB     r0,[r0,#3]            ;493
0000da  07c0              LSLS     r0,r0,#31             ;493
0000dc  0fc0              LSRS     r0,r0,#31             ;493
0000de  42a0              CMP      r0,r4                 ;493
0000e0  d000              BEQ      |L36.228|
0000e2  e007              B        |L36.244|
                  |L36.228|
0000e4  1e68              SUBS     r0,r5,#1              ;494
0000e6  b2c5              UXTB     r5,r0                 ;494
0000e8  4629              MOV      r1,r5                 ;495
0000ea  205b              MOVS     r0,#0x5b              ;495
0000ec  0600              LSLS     r0,r0,#24             ;495
0000ee  f7fffffe          BL       ADC_SetPGAOffset
                  |L36.242|
0000f2  e7ef              B        |L36.212|
                  |L36.244|
0000f4  bf00              NOP                            ;493
                  |L36.246|
0000f6  4804              LDR      r0,|L36.264|
0000f8  7a00              LDRB     r0,[r0,#8]            ;501
0000fa  2108              MOVS     r1,#8                 ;501
0000fc  4388              BICS     r0,r0,r1              ;501
0000fe  4902              LDR      r1,|L36.264|
000100  7208              STRB     r0,[r1,#8]            ;501
000102  bf00              NOP      
000104  e782              B        |L36.12|
;;;665    ///@}
                          ENDP

000106  0000              DCW      0x0000
                  |L36.264|
                          DCD      0x5b000020

                          AREA ||i.ADC_PGA_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_PGA_Cmd PROC
;;;392     */
;;;393    void ADC_PGA_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;394    {
;;;395        ADCx->ANA.MBIT.PGA_EN = NewState;
000002  2224              MOVS     r2,#0x24
000004  5c12              LDRB     r2,[r2,r0]
000006  2304              MOVS     r3,#4
000008  439a              BICS     r2,r2,r3
00000a  008b              LSLS     r3,r1,#2
00000c  2404              MOVS     r4,#4
00000e  4023              ANDS     r3,r3,r4
000010  431a              ORRS     r2,r2,r3
000012  2324              MOVS     r3,#0x24
000014  541a              STRB     r2,[r3,r0]
;;;396    }
000016  bd10              POP      {r4,pc}
;;;397    /**
                          ENDP


                          AREA ||i.ADC_ScanLoopChannel_Enable||, CODE, READONLY, ALIGN=1

                  ADC_ScanLoopChannel_Enable PROC
;;;1522    */
;;;1523   void ADC_ScanLoopChannel_Enable(ADC_Struct* ADCx, uint16_t MSKChannelSel, FunctionalState NewState)
000000  2a01              CMP      r2,#1
;;;1524   {
;;;1525       if (NewState == ENABLE)
000002  d103              BNE      |L38.12|
;;;1526       {
;;;1527           #if defined(MG32_2ND)
;;;1528               ADCx->MSK.H[0] |= MSKChannelSel & 0xFF0F;
;;;1529           #endif
;;;1530           #if defined(MG32_1ST) || defined(MG32_3RD)
;;;1531               ADCx->MSK.H[0] |= MSKChannelSel;
000004  8b83              LDRH     r3,[r0,#0x1c]
000006  430b              ORRS     r3,r3,r1
000008  8383              STRH     r3,[r0,#0x1c]
00000a  e002              B        |L38.18|
                  |L38.12|
;;;1532           #endif
;;;1533       }
;;;1534       else
;;;1535           ADCx->MSK.H[0] &= ~MSKChannelSel;
00000c  8b83              LDRH     r3,[r0,#0x1c]
00000e  438b              BICS     r3,r3,r1
000010  8383              STRH     r3,[r0,#0x1c]
                  |L38.18|
;;;1536   }
000012  4770              BX       lr
;;;1537   
                          ENDP


                          AREA ||i.ADC_SetDigitalOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetDigitalOffset PROC
;;;2082    */
;;;2083   void ADC_SetDigitalOffset(ADC_Struct* ADCx, int8_t sDigiOffset)
000000  7dc2              LDRB     r2,[r0,#0x17]
;;;2084   {
;;;2085       ADCx->CR1.MBIT.DOS_VAL = sDigiOffset;
000002  0952              LSRS     r2,r2,#5
000004  0152              LSLS     r2,r2,#5
000006  06cb              LSLS     r3,r1,#27
000008  0edb              LSRS     r3,r3,#27
00000a  431a              ORRS     r2,r2,r3
00000c  75c2              STRB     r2,[r0,#0x17]
;;;2086   }
00000e  4770              BX       lr
;;;2087   
                          ENDP


                          AREA ||i.ADC_SetExtendSampling||, CODE, READONLY, ALIGN=1

                  ADC_SetExtendSampling PROC
;;;1233    */
;;;1234   void ADC_SetExtendSampling(ADC_Struct* ADCx, uint8_t ADCSampleTime)
000000  7c82              LDRB     r2,[r0,#0x12]
;;;1235   {
;;;1236       ADCx->CR0.MBIT.SMP_SEL = ADCSampleTime;
000002  b2cb              UXTB     r3,r1
000004  7483              STRB     r3,[r0,#0x12]
;;;1237   }
000006  4770              BX       lr
;;;1238   ///@}
                          ENDP


                          AREA ||i.ADC_SetHigherThreshold||, CODE, READONLY, ALIGN=1

                  ADC_SetHigherThreshold PROC
;;;307     */
;;;308    void ADC_SetHigherThreshold(ADC_Struct* ADCx, int16_t HThreshold)
000000  81c1              STRH     r1,[r0,#0xe]
;;;309    {
;;;310        ADCx->WINDTH.H[1] = HThreshold;
;;;311    }
000002  4770              BX       lr
;;;312    /**
                          ENDP


                          AREA ||i.ADC_SetInternalClockDivider||, CODE, READONLY, ALIGN=1

                  ADC_SetInternalClockDivider PROC
;;;242     */
;;;243    void ADC_SetInternalClockDivider(ADC_Struct* ADCx, ADC_INTClockDivDef INTClockSrc)
000000  b510              PUSH     {r4,lr}
;;;244    {
;;;245    	ADCx->CLK.MBIT.CK_DIV = INTClockSrc;
000002  7a02              LDRB     r2,[r0,#8]
000004  2330              MOVS     r3,#0x30
000006  439a              BICS     r2,r2,r3
000008  010b              LSLS     r3,r1,#4
00000a  2430              MOVS     r4,#0x30
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7202              STRB     r2,[r0,#8]
;;;246    }
000012  bd10              POP      {r4,pc}
;;;247    #if defined(MG32_3RD)
                          ENDP


                          AREA ||i.ADC_SetLimitFunction||, CODE, READONLY, ALIGN=1

                  ADC_SetLimitFunction PROC
;;;1614    */
;;;1615   void ADC_SetLimitFunction(ADC_Struct* ADCx, ADC_LimitModeDef ADCLimitMode)
000000  b510              PUSH     {r4,lr}
;;;1616   {
;;;1617       ADCx->CR0.MBIT.LIM_MDS = ADCLimitMode;
000002  7c42              LDRB     r2,[r0,#0x11]
000004  23c0              MOVS     r3,#0xc0
000006  439a              BICS     r2,r2,r3
000008  018b              LSLS     r3,r1,#6
00000a  24c0              MOVS     r4,#0xc0
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7442              STRB     r2,[r0,#0x11]
;;;1618   }
000012  bd10              POP      {r4,pc}
;;;1619   
                          ENDP


                          AREA ||i.ADC_SetLowerThreshold||, CODE, READONLY, ALIGN=1

                  ADC_SetLowerThreshold PROC
;;;290     */
;;;291    void ADC_SetLowerThreshold(ADC_Struct* ADCx, int16_t LThreshold)
000000  8181              STRH     r1,[r0,#0xc]
;;;292    {
;;;293        ADCx->WINDTH.H[0] = LThreshold;
;;;294    }
000002  4770              BX       lr
;;;295    /**
                          ENDP


                          AREA ||i.ADC_SetOutputCodeFormat||, CODE, READONLY, ALIGN=1

                  ADC_SetOutputCodeFormat PROC
;;;2103    */
;;;2104   void ADC_SetOutputCodeFormat(ADC_Struct* ADCx, ADC_OutputCodeFormatDef DatFormat)
000000  7c42              LDRB     r2,[r0,#0x11]
;;;2105   {
;;;2106   #if defined(MG32_1ST)
;;;2107       ADCx->CR0.MBIT.CODE_FMT = DatFormat;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  07cb              LSLS     r3,r1,#31
000008  0fdb              LSRS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  7442              STRB     r2,[r0,#0x11]
;;;2108   #endif
;;;2109   }
00000e  4770              BX       lr
;;;2110   ///@}
                          ENDP


                          AREA ||i.ADC_SetPGAGain||, CODE, READONLY, ALIGN=1

                  ADC_SetPGAGain PROC
;;;409     */
;;;410    void ADC_SetPGAGain(ADC_Struct* ADCx, uint8_t PGAGain)
000000  222c              MOVS     r2,#0x2c
;;;411    {
;;;412        ADCx->GAIN.MBIT.GAIN_PGA = PGAGain;
000002  5c12              LDRB     r2,[r2,r0]
000004  0992              LSRS     r2,r2,#6
000006  0192              LSLS     r2,r2,#6
000008  068b              LSLS     r3,r1,#26
00000a  0e9b              LSRS     r3,r3,#26
00000c  431a              ORRS     r2,r2,r3
00000e  232c              MOVS     r3,#0x2c
000010  541a              STRB     r2,[r3,r0]
;;;413    }
000012  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.ADC_SetPGAOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetPGAOffset PROC
;;;422     */
;;;423    void ADC_SetPGAOffset(ADC_Struct* ADCx, uint8_t PGAOFFT)
000000  222e              MOVS     r2,#0x2e
;;;424    {
;;;425        ADCx->GAIN.MBIT.OFFT_PGA = PGAOFFT;
000002  5c12              LDRB     r2,[r2,r0]
000004  0992              LSRS     r2,r2,#6
000006  0192              LSLS     r2,r2,#6
000008  068b              LSLS     r3,r1,#26
00000a  0e9b              LSRS     r3,r3,#26
00000c  431a              ORRS     r2,r2,r3
00000e  232e              MOVS     r3,#0x2e
000010  541a              STRB     r2,[r3,r0]
;;;426    }
000012  4770              BX       lr
;;;427    /**
                          ENDP


                          AREA ||i.ADC_SetPLLClockDivider||, CODE, READONLY, ALIGN=1

                  ADC_SetPLLClockDivider PROC
;;;199     */
;;;200    void ADC_SetPLLClockDivider(ADC_Struct* ADCx, ADC_PLLClockDivDef PLLClockDIV)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202    	ADCx->CLK.MBIT.CK_DIV2 = PLLClockDIV;
000002  7a42              LDRB     r2,[r0,#9]
000004  230c              MOVS     r3,#0xc
000006  439a              BICS     r2,r2,r3
000008  008b              LSLS     r3,r1,#2
00000a  240c              MOVS     r4,#0xc
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7242              STRB     r2,[r0,#9]
;;;203    }
000012  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.ADC_SetSum0Channel||, CODE, READONLY, ALIGN=1

                  ADC_SetSum0Channel PROC
;;;1632    */
;;;1633   void ADC_SetSum0Channel(ADC_Struct* ADCx,uint8_t Sum0ChannelSel)
000000  7f82              LDRB     r2,[r0,#0x1e]
;;;1634   {
;;;1635       ADCx->MSK.MBIT.SUM0_MUX = Sum0ChannelSel;
000002  0912              LSRS     r2,r2,#4
000004  0112              LSLS     r2,r2,#4
000006  070b              LSLS     r3,r1,#28
000008  0f1b              LSRS     r3,r3,#28
00000a  431a              ORRS     r2,r2,r3
00000c  7782              STRB     r2,[r0,#0x1e]
;;;1636   }
00000e  4770              BX       lr
;;;1637   /**
                          ENDP


                          AREA ||i.ADC_SetSum0Data||, CODE, READONLY, ALIGN=1

                  ADC_SetSum0Data PROC
;;;1901    */
;;;1902   void ADC_SetSum0Data(ADC_Struct* ADCx, int16_t ADCSum0Initial)
000000  8601              STRH     r1,[r0,#0x30]
;;;1903   {
;;;1904       ADCx->SUM0.H[0] = ADCSum0Initial;
;;;1905   }
000002  4770              BX       lr
;;;1906   /**
                          ENDP


                          AREA ||i.ADC_SetSum1Channel||, CODE, READONLY, ALIGN=1

                  ADC_SetSum1Channel PROC
;;;1649    */
;;;1650   void ADC_SetSum1Channel(ADC_Struct* ADCx,uint8_t Sum1ChannelSel)
000000  b510              PUSH     {r4,lr}
;;;1651   {
;;;1652       ADCx->MSK.MBIT.SUM1_MUX = Sum1ChannelSel;
000002  7f82              LDRB     r2,[r0,#0x1e]
000004  23f0              MOVS     r3,#0xf0
000006  439a              BICS     r2,r2,r3
000008  010b              LSLS     r3,r1,#4
00000a  24f0              MOVS     r4,#0xf0
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7782              STRB     r2,[r0,#0x1e]
;;;1653   }
000012  bd10              POP      {r4,pc}
;;;1654   /**
                          ENDP


                          AREA ||i.ADC_SetSum1Data||, CODE, READONLY, ALIGN=1

                  ADC_SetSum1Data PROC
;;;1918    */
;;;1919   void ADC_SetSum1Data(ADC_Struct* ADCx, int16_t ADCSum1Initial)
000000  8681              STRH     r1,[r0,#0x34]
;;;1920   {
;;;1921       ADCx->SUM1.H[0] = ADCSum1Initial;
;;;1922   }
000002  4770              BX       lr
;;;1923   /**
                          ENDP


                          AREA ||i.ADC_SetSum2Channel||, CODE, READONLY, ALIGN=1

                  ADC_SetSum2Channel PROC
;;;1666    */
;;;1667   void ADC_SetSum2Channel(ADC_Struct* ADCx,uint8_t Sum2ChannelSel)
000000  7fc2              LDRB     r2,[r0,#0x1f]
;;;1668   {
;;;1669       ADCx->MSK.MBIT.SUM2_MUX = Sum2ChannelSel;
000002  0912              LSRS     r2,r2,#4
000004  0112              LSLS     r2,r2,#4
000006  070b              LSLS     r3,r1,#28
000008  0f1b              LSRS     r3,r3,#28
00000a  431a              ORRS     r2,r2,r3
00000c  77c2              STRB     r2,[r0,#0x1f]
;;;1670   }
00000e  4770              BX       lr
;;;1671   
                          ENDP


                          AREA ||i.ADC_SetSum2Data||, CODE, READONLY, ALIGN=1

                  ADC_SetSum2Data PROC
;;;1935    */
;;;1936   void ADC_SetSum2Data(ADC_Struct* ADCx, int16_t ADCSum2Initial)
000000  8701              STRH     r1,[r0,#0x38]
;;;1937   {
;;;1938       ADCx->SUM2.H[0] = ADCSum2Initial;
;;;1939   }
000002  4770              BX       lr
;;;1940   ///@}
                          ENDP


                          AREA ||i.ADC_SetSumNumber||, CODE, READONLY, ALIGN=1

                  ADC_SetSumNumber PROC
;;;1704    */
;;;1705   void ADC_SetSumNumber(ADC_Struct* ADCx, uint8_t ADCSumNumbers)
000000  7d82              LDRB     r2,[r0,#0x16]
;;;1706   {
;;;1707       ADCx->CR1.MBIT.SUM_NUM = ADCSumNumbers;
000002  09d2              LSRS     r2,r2,#7
000004  01d2              LSLS     r2,r2,#7
000006  064b              LSLS     r3,r1,#25
000008  0e5b              LSRS     r3,r3,#25
00000a  431a              ORRS     r2,r2,r3
00000c  7582              STRB     r2,[r0,#0x16]
;;;1708   }
00000e  4770              BX       lr
;;;1709   
                          ENDP


                          AREA ||i.ADC_SingleDifferentMode_Select||, CODE, READONLY, ALIGN=1

                  ADC_SingleDifferentMode_Select PROC
;;;1582    */
;;;1583   void ADC_SingleDifferentMode_Select(ADC_Struct* ADCx, ADC_ConversionTypeDef ADC_ConversionType)
000000  b510              PUSH     {r4,lr}
;;;1584   {
;;;1585   #if defined(MG32_1ST)
;;;1586       ADCx->CR0.MBIT.MDS = ADC_ConversionType;
000002  7c02              LDRB     r2,[r0,#0x10]
000004  2308              MOVS     r3,#8
000006  439a              BICS     r2,r2,r3
000008  00cb              LSLS     r3,r1,#3
00000a  2408              MOVS     r4,#8
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7402              STRB     r2,[r0,#0x10]
;;;1587   #endif
;;;1588   }
000012  bd10              POP      {r4,pc}
;;;1589   
                          ENDP


                          AREA ||i.ADC_SoftwareConversion_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareConversion_Cmd PROC
;;;1395    */
;;;1396   void ADC_SoftwareConversion_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  2220              MOVS     r2,#0x20
;;;1397   {
;;;1398       ADCx->START.MBIT.START = NewState;
000002  5c12              LDRB     r2,[r2,r0]
000004  0852              LSRS     r2,r2,#1
000006  0052              LSLS     r2,r2,#1
000008  07cb              LSLS     r3,r1,#31
00000a  0fdb              LSRS     r3,r3,#31
00000c  431a              ORRS     r2,r2,r3
00000e  2320              MOVS     r3,#0x20
000010  541a              STRB     r2,[r3,r0]
;;;1399   }
000012  4770              BX       lr
;;;1400   
                          ENDP


                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=2

                  ADC_StartCalibration PROC
;;;762     */
;;;763    void ADC_StartCalibration(ADC_Struct* ADCx, FunctionalState NewState)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;764    {
000002  b08d              SUB      sp,sp,#0x34
000004  4604              MOV      r4,r0
;;;765    #if defined(MG32_1ST)
;;;766        int16_t VRP, VRN, VRM;
;;;767        int32_t VRPV, VRNV;
;;;768        uint8_t i;
;;;769        uint32_t rADC_MSK, rADC_START, rADC_CR0, rADC_CR1;
;;;770        uint32_t rSUM0, rSUM1, rSUM2;
;;;771        
;;;772        //
;;;773        if (NewState == DISABLE)
000006  980e              LDR      r0,[sp,#0x38]
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L58.16|
                  |L58.12|
;;;774            return;
;;;775       
;;;776        // RESAVE
;;;777        rADC_MSK = ADCx->MSK.W;
;;;778        rADC_START = ADCx->START.W;
;;;779        rADC_CR0 = ADCx->CR0.W;   
;;;780        rADC_CR1 = ADCx->CR1.W;   
;;;781        rSUM0 = ADCx->SUM0.W;
;;;782        rSUM1 = ADCx->SUM1.W;
;;;783        rSUM2 = ADCx->SUM2.W;
;;;784        
;;;785        // reset SUM_NUM & window detect
;;;786        ADCx->CR1.W &= ~(ADC_CR1_SUM_NUM_mask_w | ADC_CR1_WIND_EN_enable_w);
;;;787    
;;;788        // config ADC mode for calibration 
;;;789        ADC_ConversionMode_Select(ADCx, ADCMode);
;;;790        ADC_TriggerSource_Select(ADCx, ADC_START);
;;;791        ADC_SingleDifferentMode_Select(ADC0, ADC_SingleMode);
;;;792        ADC_SetOutputCodeFormat(ADC0, ADC_UnsignedFormat);
;;;793        ADC_DataResolution_Select(ADC0, ADC_12BitData);
;;;794        
;;;795        // start calibration
;;;796        UnProtectModuleReg(CFGprotect); 
;;;797        
;;;798        VRP = 32;
;;;799        VRN = 32;
;;;800        VRM = 32;
;;;801        CFG_SetADC0RefTop(VRP);
;;;802        CFG_SetADC0RefMiddle(VRM);
;;;803        CFG_SetADC0RefBottom(VRN);
;;;804        
;;;805        
;;;806        VRN = 0;
;;;807        while(1)
;;;808        {
;;;809            CFG_SetADC0RefBottom(VRN);
;;;810            ADC_ChannelMUX_Select(ADC0, ADC_InternalChannel);
;;;811            ADC_InternalChannel_Select(ADCx, ADC_INT_VSSA);
;;;812            for (i=0, VRNV=0 ; i<10; i++)
;;;813            {
;;;814                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
;;;815                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
;;;816                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
;;;817            }
;;;818            for (i=0, VRNV=0 ; i<10; i++)
;;;819            {
;;;820                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
;;;821                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
;;;822                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
;;;823                if( ADC_GetDAT0Data(ADCx) == 0x0000) break;
;;;824                VRNV += ADC_GetDAT0Data(ADCx);
;;;825            }
;;;826            VRNV = VRNV / 10;
;;;827            
;;;828            if (VRNV > 0) VRN ++;
;;;829            if (VRNV == 0) 
;;;830            {
;;;831                VRN -= 1; 
;;;832                break;
;;;833            }
;;;834            if (VRN == 64) 
;;;835            {
;;;836                VRN = 32;
;;;837                break;
;;;838            }
;;;839        }
;;;840        
;;;841        CFG_SetADC0RefMiddle(32);
;;;842        CFG_SetADC0RefBottom(32);
;;;843        VRP = 0;
;;;844        while(1)
;;;845        {
;;;846            CFG_SetADC0RefTop(VRP);
;;;847            
;;;848            ADC_InternalChannel_Select(ADCx, ADC_INT_IVREF);
;;;849            for (i=0, VRPV=0 ; i<10; i++)
;;;850            {
;;;851                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
;;;852                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
;;;853                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
;;;854            }
;;;855            for (i=0, VRPV=0 ; i<10; i++)
;;;856            {
;;;857                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
;;;858                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
;;;859                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
;;;860                if( ADC_GetDAT0Data(ADCx) < 4095) break;
;;;861                VRPV += ADC_GetDAT0Data(ADCx);
;;;862            }
;;;863            VRPV = VRPV / 10;
;;;864            
;;;865            if (VRPV > 4094) 
;;;866                VRP ++;
;;;867            else 
;;;868            {
;;;869                VRP --;
;;;870                break;
;;;871            }
;;;872            
;;;873            if (VRP == 64) 
;;;874            {
;;;875                VRP = 32;
;;;876                break;
;;;877            }
;;;878            
;;;879        }
;;;880        
;;;881        CFG_SetADC0RefTop(VRP);
;;;882        CFG_SetADC0RefMiddle(VRM);
;;;883        CFG_SetADC0RefBottom(VRN);
;;;884        
;;;885        
;;;886        VRM = (CFG_GetADC0RefTop() + CFG_GetADC0RefBottom()) / 2;
;;;887        CFG_SetADC0RefMiddle(VRM);
;;;888        
;;;889    //    // middle trim
;;;890        ADC_VRMCalibration(ADCx, VRM);
;;;891                
;;;892        ProtectModuleReg(CFGprotect);   
;;;893        
;;;894        ADCx->MSK.W = rADC_MSK;
;;;895        ADCx->START.W = rADC_START;
;;;896        ADCx->CR0.W = rADC_CR0;    
;;;897        ADCx->CR1.W = rADC_CR1;    
;;;898        ADCx->SUM0.W = rSUM0;
;;;899        ADCx->SUM1.W = rSUM1;
;;;900        ADCx->SUM2.W = rSUM2;
;;;901    #elif defined(MG32_3RD)
;;;902        int16_t ADC_CONV;
;;;903        uint8_t i, OFFT_ADC_MinIDX;
;;;904        uint32_t rADC_MSK, rADC_START, rADC_CR0, rADC_CR1;
;;;905        uint32_t rSUM0, rSUM1, rSUM2;
;;;906       
;;;907        //
;;;908        if (NewState == DISABLE)
;;;909            return;
;;;910       
;;;911        // RESAVE
;;;912        rADC_MSK = ADCx->MSK.W;
;;;913        rADC_START = ADCx->START.W;
;;;914        rADC_CR0 = ADCx->CR0.W;  
;;;915        rADC_CR1 = ADCx->CR1.W;  
;;;916        rSUM0 = ADCx->SUM0.W;
;;;917        rSUM1 = ADCx->SUM1.W;
;;;918        rSUM2 = ADCx->SUM2.W;
;;;919       
;;;920        // reset SUM_NUM & window detect
;;;921        ADCx->CR1.W &= ~(ADC_CR1_SUM_NUM_mask_w | ADC_CR1_WIND_EN_enable_w);
;;;922    
;;;923        // config ADC mode for calibration
;;;924        ADC_ConversionMode_Select(ADCx, ADCMode);
;;;925        ADC_TriggerSource_Select(ADCx, ADC_START);
;;;926        ADC_SingleDifferentMode_Select(ADC0, ADC_SingleMode);
;;;927        ADC_SetOutputCodeFormat(ADC0, ADC_UnsignedFormat);
;;;928        ADC_DataResolution_Select(ADC0, ADC_12BitData);
;;;929       
;;;930        // ------------------------------------------------------------------------
;;;931        // start calibration - Offset issue
;;;932        // ------------------------------------------------------------------------
;;;933        ADC_InternalChannel_Select(ADCx, ADC_INT_VSSA); // select internal channel VSSA
;;;934       
;;;935        OFFT_ADC_MinIDX = 0;
;;;936    
;;;937        // ------------------------------------------------------------------------
;;;938        // 1. Scan minimum index when ADC sample not equal '0'
;;;939        // ------------------------------------------------------------------------
;;;940        while(1)
;;;941        {
;;;942            // set ADC_GAIN_OFFT
;;;943            ADC0->GAIN.MBIT.OFFT_ADC = OFFT_ADC_MinIDX;
;;;944    
;;;945            // sample internal VSS
;;;946            ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
;;;947            while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
;;;948            ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
;;;949            ADC_CONV = ADC_GetDAT0Data(ADCx);
;;;950            
;;;951           
;;;952            // check ADC_CONV data (search ADC_CONV==1 or 2)  
;;;953            if (ADC_CONV == 0)
;;;954            {
;;;955                OFFT_ADC_MinIDX ++;
;;;956            }
;;;957            else 
;;;958            {
;;;959                if(OFFT_ADC_MinIDX < 2)     // No trimming range in this issue
;;;960                {
;;;961                    OFFT_ADC_MinIDX = 0;
;;;962                    break;         
;;;963                }
;;;964                OFFT_ADC_MinIDX -= 2;
;;;965                break;
;;;966            }
;;;967           
;;;968            //
;;;969            if (OFFT_ADC_MinIDX == 31) break;
;;;970           
;;;971        }
;;;972       
;;;973        // ------------------------------------------------------------------------
;;;974        // 2. average ADC conversion data -> decide the optimum
;;;975        // ------------------------------------------------------------------------
;;;976        while(1)
;;;977        {
;;;978            // set ADC_GAIN_OFFT
;;;979            ADC0->GAIN.MBIT.OFFT_ADC = OFFT_ADC_MinIDX;
;;;980                   
;;;981            // Average ADC conversion
;;;982            
;;;983            
;;;984            for (i=0, ADC_CONV=0 ; i<8; i++)
;;;985            {
;;;986                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
;;;987                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
;;;988                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
;;;989                ADC_CONV += ADC_GetDAT0Data(ADCx);
;;;990            
;;;991           
;;;992            }        
;;;993           
;;;994            // check ADC_CONV data (search ADC_CONV==1 or 2)  
;;;995            if (ADC_CONV == 0)
;;;996            {
;;;997                OFFT_ADC_MinIDX ++;
;;;998            }
;;;999            else if (ADC_CONV < 8)
;;;1000           {
;;;1001               break;
;;;1002           }
;;;1003           else
;;;1004           {
;;;1005               if(OFFT_ADC_MinIDX == 0) break;         // No trimming range in this issue
;;;1006               OFFT_ADC_MinIDX --;         // make sure -> ADC can convert '0'
;;;1007               break;
;;;1008           }
;;;1009           //
;;;1010           if (OFFT_ADC_MinIDX > 31) break;
;;;1011          
;;;1012       }
;;;1013      
;;;1014       // desire ADC_GAIN_OFFT
;;;1015       ADC0->GAIN.MBIT.OFFT_ADC = OFFT_ADC_MinIDX;
;;;1016       
;;;1017   
;;;1018       // restore
;;;1019       ADCx->MSK.W = rADC_MSK;
;;;1020       ADCx->START.W = rADC_START;
;;;1021       ADCx->CR0.W = rADC_CR0;    
;;;1022       ADCx->CR1.W = rADC_CR1;    
;;;1023       ADCx->SUM0.W = rSUM0;
;;;1024       ADCx->SUM1.W = rSUM1;
;;;1025       ADCx->SUM2.W = rSUM2;
;;;1026   #endif   
;;;1027   }
00000c  b00f              ADD      sp,sp,#0x3c
00000e  bdf0              POP      {r4-r7,pc}
                  |L58.16|
000010  69e0              LDR      r0,[r4,#0x1c]         ;777
000012  9008              STR      r0,[sp,#0x20]         ;777
000014  6a20              LDR      r0,[r4,#0x20]         ;778
000016  9007              STR      r0,[sp,#0x1c]         ;778
000018  6920              LDR      r0,[r4,#0x10]         ;779
00001a  9006              STR      r0,[sp,#0x18]         ;779
00001c  6960              LDR      r0,[r4,#0x14]         ;780
00001e  9005              STR      r0,[sp,#0x14]         ;780
000020  6b20              LDR      r0,[r4,#0x30]         ;781
000022  9004              STR      r0,[sp,#0x10]         ;781
000024  6b60              LDR      r0,[r4,#0x34]         ;782
000026  9003              STR      r0,[sp,#0xc]          ;782
000028  6ba0              LDR      r0,[r4,#0x38]         ;783
00002a  9002              STR      r0,[sp,#8]            ;783
00002c  6960              LDR      r0,[r4,#0x14]         ;786
00002e  4992              LDR      r1,|L58.632|
000030  4008              ANDS     r0,r0,r1              ;786
000032  6160              STR      r0,[r4,#0x14]         ;786
000034  2100              MOVS     r1,#0                 ;789
000036  4620              MOV      r0,r4                 ;789
000038  f7fffffe          BL       ADC_ConversionMode_Select
00003c  2100              MOVS     r1,#0                 ;790
00003e  4620              MOV      r0,r4                 ;790
000040  f7fffffe          BL       ADC_TriggerSource_Select
000044  2100              MOVS     r1,#0                 ;791
000046  205b              MOVS     r0,#0x5b              ;791
000048  0600              LSLS     r0,r0,#24             ;791
00004a  f7fffffe          BL       ADC_SingleDifferentMode_Select
00004e  2100              MOVS     r1,#0                 ;792
000050  205b              MOVS     r0,#0x5b              ;792
000052  0600              LSLS     r0,r0,#24             ;792
000054  f7fffffe          BL       ADC_SetOutputCodeFormat
000058  2100              MOVS     r1,#0                 ;793
00005a  205b              MOVS     r0,#0x5b              ;793
00005c  0600              LSLS     r0,r0,#24             ;793
00005e  f7fffffe          BL       ADC_DataResolution_Select
000062  4886              LDR      r0,|L58.636|
000064  f7fffffe          BL       UnProtectModuleReg
000068  2520              MOVS     r5,#0x20              ;798
00006a  2020              MOVS     r0,#0x20              ;799
00006c  900c              STR      r0,[sp,#0x30]         ;799
00006e  2120              MOVS     r1,#0x20              ;800
000070  910b              STR      r1,[sp,#0x2c]         ;800
000072  4628              MOV      r0,r5                 ;801
000074  f7fffffe          BL       CFG_SetADC0RefTop
000078  980b              LDR      r0,[sp,#0x2c]         ;802
00007a  f7fffffe          BL       CFG_SetADC0RefMiddle
00007e  980c              LDR      r0,[sp,#0x30]         ;803
000080  f7fffffe          BL       CFG_SetADC0RefBottom
000084  2000              MOVS     r0,#0                 ;806
000086  900c              STR      r0,[sp,#0x30]         ;806
000088  e061              B        |L58.334|
                  |L58.138|
00008a  990c              LDR      r1,[sp,#0x30]         ;809
00008c  b2c8              UXTB     r0,r1                 ;809
00008e  f7fffffe          BL       CFG_SetADC0RefBottom
000092  2101              MOVS     r1,#1                 ;810
000094  205b              MOVS     r0,#0x5b              ;810
000096  0600              LSLS     r0,r0,#24             ;810
000098  f7fffffe          BL       ADC_ChannelMUX_Select
00009c  2110              MOVS     r1,#0x10              ;811
00009e  4620              MOV      r0,r4                 ;811
0000a0  f7fffffe          BL       ADC_InternalChannel_Select
0000a4  2600              MOVS     r6,#0                 ;812
0000a6  2000              MOVS     r0,#0                 ;812
0000a8  9009              STR      r0,[sp,#0x24]         ;812
0000aa  e010              B        |L58.206|
                  |L58.172|
0000ac  2101              MOVS     r1,#1                 ;814
0000ae  4620              MOV      r0,r4                 ;814
0000b0  f7fffffe          BL       ADC_SoftwareConversion_Cmd
0000b4  bf00              NOP                            ;815
                  |L58.182|
0000b6  2108              MOVS     r1,#8                 ;815
0000b8  4620              MOV      r0,r4                 ;815
0000ba  f7fffffe          BL       ADC_GetSingleFlagStatus
0000be  2800              CMP      r0,#0                 ;815
0000c0  d0f9              BEQ      |L58.182|
0000c2  210c              MOVS     r1,#0xc               ;816
0000c4  4620              MOV      r0,r4                 ;816
0000c6  f7fffffe          BL       ADC_ClearFlag
0000ca  1c70              ADDS     r0,r6,#1              ;812
0000cc  b2c6              UXTB     r6,r0                 ;812
                  |L58.206|
0000ce  2e0a              CMP      r6,#0xa               ;812
0000d0  dbec              BLT      |L58.172|
0000d2  2600              MOVS     r6,#0                 ;818
0000d4  2000              MOVS     r0,#0                 ;818
0000d6  9009              STR      r0,[sp,#0x24]         ;818
0000d8  e01c              B        |L58.276|
                  |L58.218|
0000da  2101              MOVS     r1,#1                 ;820
0000dc  4620              MOV      r0,r4                 ;820
0000de  f7fffffe          BL       ADC_SoftwareConversion_Cmd
0000e2  bf00              NOP                            ;821
                  |L58.228|
0000e4  2108              MOVS     r1,#8                 ;821
0000e6  4620              MOV      r0,r4                 ;821
0000e8  f7fffffe          BL       ADC_GetSingleFlagStatus
0000ec  2800              CMP      r0,#0                 ;821
0000ee  d0f9              BEQ      |L58.228|
0000f0  210c              MOVS     r1,#0xc               ;822
0000f2  4620              MOV      r0,r4                 ;822
0000f4  f7fffffe          BL       ADC_ClearFlag
0000f8  4620              MOV      r0,r4                 ;823
0000fa  f7fffffe          BL       ADC_GetDAT0Data
0000fe  2800              CMP      r0,#0                 ;823
000100  d100              BNE      |L58.260|
000102  e009              B        |L58.280|
                  |L58.260|
000104  4620              MOV      r0,r4                 ;824
000106  f7fffffe          BL       ADC_GetDAT0Data
00010a  9909              LDR      r1,[sp,#0x24]         ;824
00010c  1840              ADDS     r0,r0,r1              ;824
00010e  9009              STR      r0,[sp,#0x24]         ;824
000110  1c70              ADDS     r0,r6,#1              ;818
000112  b2c6              UXTB     r6,r0                 ;818
                  |L58.276|
000114  2e0a              CMP      r6,#0xa               ;818
000116  dbe0              BLT      |L58.218|
                  |L58.280|
000118  bf00              NOP                            ;823
00011a  210a              MOVS     r1,#0xa               ;826
00011c  9809              LDR      r0,[sp,#0x24]         ;826
00011e  f7fffffe          BL       __aeabi_idivmod
000122  9009              STR      r0,[sp,#0x24]         ;826
000124  9809              LDR      r0,[sp,#0x24]         ;828
000126  2800              CMP      r0,#0                 ;828
000128  dd03              BLE      |L58.306|
00012a  980c              LDR      r0,[sp,#0x30]         ;828
00012c  1c40              ADDS     r0,r0,#1              ;828
00012e  b200              SXTH     r0,r0                 ;828
000130  900c              STR      r0,[sp,#0x30]         ;828
                  |L58.306|
000132  9809              LDR      r0,[sp,#0x24]         ;829
000134  2800              CMP      r0,#0                 ;829
000136  d104              BNE      |L58.322|
000138  980c              LDR      r0,[sp,#0x30]         ;831
00013a  1e40              SUBS     r0,r0,#1              ;831
00013c  b200              SXTH     r0,r0                 ;831
00013e  900c              STR      r0,[sp,#0x30]         ;831
000140  e006              B        |L58.336|
                  |L58.322|
000142  980c              LDR      r0,[sp,#0x30]         ;834
000144  2840              CMP      r0,#0x40              ;834
000146  d102              BNE      |L58.334|
000148  2020              MOVS     r0,#0x20              ;836
00014a  900c              STR      r0,[sp,#0x30]         ;836
00014c  e000              B        |L58.336|
                  |L58.334|
00014e  e79c              B        |L58.138|
                  |L58.336|
000150  bf00              NOP                            ;832
000152  2020              MOVS     r0,#0x20              ;841
000154  f7fffffe          BL       CFG_SetADC0RefMiddle
000158  2020              MOVS     r0,#0x20              ;842
00015a  f7fffffe          BL       CFG_SetADC0RefBottom
00015e  2500              MOVS     r5,#0                 ;843
000160  e056              B        |L58.528|
                  |L58.354|
000162  b2e8              UXTB     r0,r5                 ;846
000164  f7fffffe          BL       CFG_SetADC0RefTop
000168  2111              MOVS     r1,#0x11              ;848
00016a  4620              MOV      r0,r4                 ;848
00016c  f7fffffe          BL       ADC_InternalChannel_Select
000170  2600              MOVS     r6,#0                 ;849
000172  2000              MOVS     r0,#0                 ;849
000174  900a              STR      r0,[sp,#0x28]         ;849
000176  e010              B        |L58.410|
                  |L58.376|
000178  2101              MOVS     r1,#1                 ;851
00017a  4620              MOV      r0,r4                 ;851
00017c  f7fffffe          BL       ADC_SoftwareConversion_Cmd
000180  bf00              NOP                            ;852
                  |L58.386|
000182  2108              MOVS     r1,#8                 ;852
000184  4620              MOV      r0,r4                 ;852
000186  f7fffffe          BL       ADC_GetSingleFlagStatus
00018a  2800              CMP      r0,#0                 ;852
00018c  d0f9              BEQ      |L58.386|
00018e  210c              MOVS     r1,#0xc               ;853
000190  4620              MOV      r0,r4                 ;853
000192  f7fffffe          BL       ADC_ClearFlag
000196  1c70              ADDS     r0,r6,#1              ;849
000198  b2c6              UXTB     r6,r0                 ;849
                  |L58.410|
00019a  2e0a              CMP      r6,#0xa               ;849
00019c  dbec              BLT      |L58.376|
00019e  2600              MOVS     r6,#0                 ;855
0001a0  2000              MOVS     r0,#0                 ;855
0001a2  900a              STR      r0,[sp,#0x28]         ;855
0001a4  e01d              B        |L58.482|
                  |L58.422|
0001a6  2101              MOVS     r1,#1                 ;857
0001a8  4620              MOV      r0,r4                 ;857
0001aa  f7fffffe          BL       ADC_SoftwareConversion_Cmd
0001ae  bf00              NOP                            ;858
                  |L58.432|
0001b0  2108              MOVS     r1,#8                 ;858
0001b2  4620              MOV      r0,r4                 ;858
0001b4  f7fffffe          BL       ADC_GetSingleFlagStatus
0001b8  2800              CMP      r0,#0                 ;858
0001ba  d0f9              BEQ      |L58.432|
0001bc  210c              MOVS     r1,#0xc               ;859
0001be  4620              MOV      r0,r4                 ;859
0001c0  f7fffffe          BL       ADC_ClearFlag
0001c4  4620              MOV      r0,r4                 ;860
0001c6  f7fffffe          BL       ADC_GetDAT0Data
0001ca  492d              LDR      r1,|L58.640|
0001cc  4288              CMP      r0,r1                 ;860
0001ce  da00              BGE      |L58.466|
0001d0  e009              B        |L58.486|
                  |L58.466|
0001d2  4620              MOV      r0,r4                 ;861
0001d4  f7fffffe          BL       ADC_GetDAT0Data
0001d8  990a              LDR      r1,[sp,#0x28]         ;861
0001da  1840              ADDS     r0,r0,r1              ;861
0001dc  900a              STR      r0,[sp,#0x28]         ;861
0001de  1c70              ADDS     r0,r6,#1              ;855
0001e0  b2c6              UXTB     r6,r0                 ;855
                  |L58.482|
0001e2  2e0a              CMP      r6,#0xa               ;855
0001e4  dbdf              BLT      |L58.422|
                  |L58.486|
0001e6  bf00              NOP                            ;860
0001e8  210a              MOVS     r1,#0xa               ;863
0001ea  980a              LDR      r0,[sp,#0x28]         ;863
0001ec  f7fffffe          BL       __aeabi_idivmod
0001f0  900a              STR      r0,[sp,#0x28]         ;863
0001f2  4923              LDR      r1,|L58.640|
0001f4  1e49              SUBS     r1,r1,#1              ;865
0001f6  980a              LDR      r0,[sp,#0x28]         ;865
0001f8  4288              CMP      r0,r1                 ;865
0001fa  dd02              BLE      |L58.514|
0001fc  1c68              ADDS     r0,r5,#1              ;866
0001fe  b205              SXTH     r5,r0                 ;866
000200  e002              B        |L58.520|
                  |L58.514|
000202  1e68              SUBS     r0,r5,#1              ;869
000204  b205              SXTH     r5,r0                 ;869
000206  e004              B        |L58.530|
                  |L58.520|
000208  2d40              CMP      r5,#0x40              ;873
00020a  d101              BNE      |L58.528|
00020c  2520              MOVS     r5,#0x20              ;875
00020e  e000              B        |L58.530|
                  |L58.528|
000210  e7a7              B        |L58.354|
                  |L58.530|
000212  bf00              NOP                            ;870
000214  b2e8              UXTB     r0,r5                 ;881
000216  f7fffffe          BL       CFG_SetADC0RefTop
00021a  990b              LDR      r1,[sp,#0x2c]         ;882
00021c  b2c8              UXTB     r0,r1                 ;882
00021e  f7fffffe          BL       CFG_SetADC0RefMiddle
000222  990c              LDR      r1,[sp,#0x30]         ;883
000224  b2c8              UXTB     r0,r1                 ;883
000226  f7fffffe          BL       CFG_SetADC0RefBottom
00022a  f7fffffe          BL       CFG_GetADC0RefTop
00022e  4607              MOV      r7,r0                 ;886
000230  f7fffffe          BL       CFG_GetADC0RefBottom
000234  1838              ADDS     r0,r7,r0              ;886
000236  0fc1              LSRS     r1,r0,#31             ;886
000238  9001              STR      r0,[sp,#4]            ;886
00023a  1808              ADDS     r0,r1,r0              ;886
00023c  1040              ASRS     r0,r0,#1              ;886
00023e  900b              STR      r0,[sp,#0x2c]         ;886
000240  990b              LDR      r1,[sp,#0x2c]         ;887
000242  b2c8              UXTB     r0,r1                 ;887
000244  f7fffffe          BL       CFG_SetADC0RefMiddle
000248  980b              LDR      r0,[sp,#0x2c]         ;890
00024a  b2c1              UXTB     r1,r0                 ;890
00024c  4620              MOV      r0,r4                 ;890
00024e  f7fffffe          BL       ADC_VRMCalibration
000252  480a              LDR      r0,|L58.636|
000254  f7fffffe          BL       ProtectModuleReg
000258  9808              LDR      r0,[sp,#0x20]         ;894
00025a  61e0              STR      r0,[r4,#0x1c]         ;894
00025c  9807              LDR      r0,[sp,#0x1c]         ;895
00025e  6220              STR      r0,[r4,#0x20]         ;895
000260  9806              LDR      r0,[sp,#0x18]         ;896
000262  6120              STR      r0,[r4,#0x10]         ;896
000264  9805              LDR      r0,[sp,#0x14]         ;897
000266  6160              STR      r0,[r4,#0x14]         ;897
000268  9804              LDR      r0,[sp,#0x10]         ;898
00026a  6320              STR      r0,[r4,#0x30]         ;898
00026c  9803              LDR      r0,[sp,#0xc]          ;899
00026e  6360              STR      r0,[r4,#0x34]         ;899
000270  9802              LDR      r0,[sp,#8]            ;900
000272  63a0              STR      r0,[r4,#0x38]         ;900
000274  bf00              NOP      
000276  e6c9              B        |L58.12|
;;;1028   ///@}
                          ENDP

                  |L58.632|
                          DCD      0xff80fffe
                  |L58.636|
                          DCD      0x4ff0000c
                  |L58.640|
                          DCD      0x00000fff

                          AREA ||i.ADC_SumChannelMode_Select||, CODE, READONLY, ALIGN=1

                  ADC_SumChannelMode_Select PROC
;;;1686    */
;;;1687   void ADC_SumChannelMode_Select(ADC_Struct* ADCx,ADC_SumChannelXDef ADCSumChXDef)
000000  b510              PUSH     {r4,lr}
;;;1688   {
;;;1689       ADCx->CR1.MBIT.SUM_MDS = ADCSumChXDef;
000002  7d42              LDRB     r2,[r0,#0x15]
000004  2304              MOVS     r3,#4
000006  439a              BICS     r2,r2,r3
000008  008b              LSLS     r3,r1,#2
00000a  2404              MOVS     r4,#4
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7542              STRB     r2,[r0,#0x15]
;;;1690   }
000012  bd10              POP      {r4,pc}
;;;1691   
                          ENDP


                          AREA ||i.ADC_SumOverrunMode_Select||, CODE, READONLY, ALIGN=1

                  ADC_SumOverrunMode_Select PROC
;;;1724    */
;;;1725   void ADC_SumOverrunMode_Select(ADC_Struct* ADCx, ADC_SumDataOWDef ADCSumOW)
000000  b510              PUSH     {r4,lr}
;;;1726   {
;;;1727       ADCx->CR1.MBIT.SOVR_MDS = ADCSumOW;
000002  7d42              LDRB     r2,[r0,#0x15]
000004  2302              MOVS     r3,#2
000006  439a              BICS     r2,r2,r3
000008  004b              LSLS     r3,r1,#1
00000a  2402              MOVS     r4,#2
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7542              STRB     r2,[r0,#0x15]
;;;1728   }
000012  bd10              POP      {r4,pc}
;;;1729   
                          ENDP


                          AREA ||i.ADC_TriggerEdge_Select||, CODE, READONLY, ALIGN=1

                  ADC_TriggerEdge_Select PROC
;;;1417    */
;;;1418   void ADC_TriggerEdge_Select(ADC_Struct* ADCx, ADC_TriggerEdgeDef ADCExtEdgeSel)
000000  b510              PUSH     {r4,lr}
;;;1419   {
;;;1420       ADCx->START.MBIT.TRG_SEL = ADCExtEdgeSel;
000002  2222              MOVS     r2,#0x22
000004  5c12              LDRB     r2,[r2,r0]
000006  2330              MOVS     r3,#0x30
000008  439a              BICS     r2,r2,r3
00000a  010b              LSLS     r3,r1,#4
00000c  2430              MOVS     r4,#0x30
00000e  4023              ANDS     r3,r3,r4
000010  431a              ORRS     r2,r2,r3
000012  2322              MOVS     r3,#0x22
000014  541a              STRB     r2,[r3,r0]
;;;1421   }
000016  bd10              POP      {r4,pc}
;;;1422   ///@}
                          ENDP


                          AREA ||i.ADC_TriggerSource_Select||, CODE, READONLY, ALIGN=1

                  ADC_TriggerSource_Select PROC
;;;1376    */
;;;1377   void ADC_TriggerSource_Select(ADC_Struct* ADCx, ADC_TriggerSourceDef ADCTrgSel)
000000  2222              MOVS     r2,#0x22
;;;1378   {
;;;1379       ADCx->START.MBIT.START_SEL = ADCTrgSel;
000002  5c12              LDRB     r2,[r2,r0]
000004  08d2              LSRS     r2,r2,#3
000006  00d2              LSLS     r2,r2,#3
000008  074b              LSLS     r3,r1,#29
00000a  0f5b              LSRS     r3,r3,#29
00000c  431a              ORRS     r2,r2,r3
00000e  2322              MOVS     r3,#0x22
000010  541a              STRB     r2,[r3,r0]
;;;1380   }
000012  4770              BX       lr
;;;1381   
                          ENDP


                          AREA ||i.ADC_VRMCalibration||, CODE, READONLY, ALIGN=2

                  ADC_VRMCalibration PROC
;;;680     *****************************************************************************/
;;;681    void ADC_VRMCalibration(ADC_Struct* ADCx,uint8_t VRMV) 
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;682    {
000002  b081              SUB      sp,sp,#4
;;;683        int32_t VRPV, VRNV, VRM;
;;;684        int32_t CaliV;
;;;685        uint8_t i;
;;;686        
;;;687        UnProtectModuleReg(CFGprotect); 
000004  484d              LDR      r0,|L63.316|
000006  f7fffffe          BL       UnProtectModuleReg
;;;688    
;;;689        VRM = VRMV;
00000a  9e02              LDR      r6,[sp,#8]
;;;690        
;;;691        // middle trim
;;;692        while (1)
00000c  e08e              B        |L63.300|
                  |L63.14|
;;;693        {
;;;694            ADC_InternalChannel_Select(ADCx, ADC_INT_VSSA);
00000e  2110              MOVS     r1,#0x10
000010  9801              LDR      r0,[sp,#4]
000012  f7fffffe          BL       ADC_InternalChannel_Select
;;;695            for (i=0, VRNV=0 ; i<10; i++)
000016  2500              MOVS     r5,#0
000018  2000              MOVS     r0,#0
00001a  9000              STR      r0,[sp,#0]
00001c  e010              B        |L63.64|
                  |L63.30|
;;;696            {
;;;697                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
00001e  2101              MOVS     r1,#1
000020  9801              LDR      r0,[sp,#4]
000022  f7fffffe          BL       ADC_SoftwareConversion_Cmd
;;;698                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
000026  bf00              NOP      
                  |L63.40|
000028  2108              MOVS     r1,#8
00002a  9801              LDR      r0,[sp,#4]
00002c  f7fffffe          BL       ADC_GetSingleFlagStatus
000030  2800              CMP      r0,#0
000032  d0f9              BEQ      |L63.40|
;;;699                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
000034  210c              MOVS     r1,#0xc
000036  9801              LDR      r0,[sp,#4]
000038  f7fffffe          BL       ADC_ClearFlag
00003c  1c68              ADDS     r0,r5,#1              ;695
00003e  b2c5              UXTB     r5,r0                 ;695
                  |L63.64|
000040  2d0a              CMP      r5,#0xa               ;695
000042  dbec              BLT      |L63.30|
;;;700            }
;;;701            for (i=0, VRNV=0 ; i<10; i++)
000044  2500              MOVS     r5,#0
000046  2000              MOVS     r0,#0
000048  9000              STR      r0,[sp,#0]
00004a  e016              B        |L63.122|
                  |L63.76|
;;;702            {
;;;703                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  9801              LDR      r0,[sp,#4]
000050  f7fffffe          BL       ADC_SoftwareConversion_Cmd
;;;704                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
000054  bf00              NOP      
                  |L63.86|
000056  2108              MOVS     r1,#8
000058  9801              LDR      r0,[sp,#4]
00005a  f7fffffe          BL       ADC_GetSingleFlagStatus
00005e  2800              CMP      r0,#0
000060  d0f9              BEQ      |L63.86|
;;;705                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
000062  210c              MOVS     r1,#0xc
000064  9801              LDR      r0,[sp,#4]
000066  f7fffffe          BL       ADC_ClearFlag
;;;706                VRNV += ADC_GetDAT0Data(ADCx);
00006a  9801              LDR      r0,[sp,#4]
00006c  f7fffffe          BL       ADC_GetDAT0Data
000070  9900              LDR      r1,[sp,#0]
000072  1840              ADDS     r0,r0,r1
000074  9000              STR      r0,[sp,#0]
000076  1c68              ADDS     r0,r5,#1              ;701
000078  b2c5              UXTB     r5,r0                 ;701
                  |L63.122|
00007a  2d0a              CMP      r5,#0xa               ;701
00007c  dbe6              BLT      |L63.76|
;;;707            }
;;;708            VRNV = VRNV / 10;
00007e  210a              MOVS     r1,#0xa
000080  9800              LDR      r0,[sp,#0]
000082  f7fffffe          BL       __aeabi_idivmod
000086  9000              STR      r0,[sp,#0]
;;;709            
;;;710            //-------------------------------------------------
;;;711            ADC_InternalChannel_Select(ADCx, ADC_INT_IVREF);
000088  2111              MOVS     r1,#0x11
00008a  9801              LDR      r0,[sp,#4]
00008c  f7fffffe          BL       ADC_InternalChannel_Select
;;;712            for (i=0, VRNV=0 ; i<10; i++)
000090  2500              MOVS     r5,#0
000092  2000              MOVS     r0,#0
000094  9000              STR      r0,[sp,#0]
000096  e010              B        |L63.186|
                  |L63.152|
;;;713            {
;;;714                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
000098  2101              MOVS     r1,#1
00009a  9801              LDR      r0,[sp,#4]
00009c  f7fffffe          BL       ADC_SoftwareConversion_Cmd
;;;715                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
0000a0  bf00              NOP      
                  |L63.162|
0000a2  2108              MOVS     r1,#8
0000a4  9801              LDR      r0,[sp,#4]
0000a6  f7fffffe          BL       ADC_GetSingleFlagStatus
0000aa  2800              CMP      r0,#0
0000ac  d0f9              BEQ      |L63.162|
;;;716                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
0000ae  210c              MOVS     r1,#0xc
0000b0  9801              LDR      r0,[sp,#4]
0000b2  f7fffffe          BL       ADC_ClearFlag
0000b6  1c68              ADDS     r0,r5,#1              ;712
0000b8  b2c5              UXTB     r5,r0                 ;712
                  |L63.186|
0000ba  2d0a              CMP      r5,#0xa               ;712
0000bc  dbec              BLT      |L63.152|
;;;717            }
;;;718            for (i=0, VRPV=0 ; i<10; i++)
0000be  2500              MOVS     r5,#0
0000c0  2700              MOVS     r7,#0
0000c2  e014              B        |L63.238|
                  |L63.196|
;;;719            {
;;;720                ADC_SoftwareConversion_Cmd(ADCx, ENABLE);
0000c4  2101              MOVS     r1,#1
0000c6  9801              LDR      r0,[sp,#4]
0000c8  f7fffffe          BL       ADC_SoftwareConversion_Cmd
;;;721                while (ADC_GetSingleFlagStatus (ADCx,ADC_E1CNVF) == DRV_UnHappened);
0000cc  bf00              NOP      
                  |L63.206|
0000ce  2108              MOVS     r1,#8
0000d0  9801              LDR      r0,[sp,#4]
0000d2  f7fffffe          BL       ADC_GetSingleFlagStatus
0000d6  2800              CMP      r0,#0
0000d8  d0f9              BEQ      |L63.206|
;;;722                ADC_ClearFlag(ADCx, (ADC_E1CNVF | ADC_ESMPF));
0000da  210c              MOVS     r1,#0xc
0000dc  9801              LDR      r0,[sp,#4]
0000de  f7fffffe          BL       ADC_ClearFlag
;;;723                VRPV += ADC_GetDAT0Data(ADCx);
0000e2  9801              LDR      r0,[sp,#4]
0000e4  f7fffffe          BL       ADC_GetDAT0Data
0000e8  19c7              ADDS     r7,r0,r7
0000ea  1c68              ADDS     r0,r5,#1              ;718
0000ec  b2c5              UXTB     r5,r0                 ;718
                  |L63.238|
0000ee  2d0a              CMP      r5,#0xa               ;718
0000f0  dbe8              BLT      |L63.196|
;;;724            }
;;;725            VRPV = VRPV / 10;
0000f2  210a              MOVS     r1,#0xa
0000f4  4638              MOV      r0,r7
0000f6  f7fffffe          BL       __aeabi_idivmod
0000fa  4607              MOV      r7,r0
;;;726            
;;;727            
;;;728            //-------------------------------------------------
;;;729            CaliV = (VRNV + VRPV) >> 1;
0000fc  9800              LDR      r0,[sp,#0]
0000fe  19c0              ADDS     r0,r0,r7
000100  1044              ASRS     r4,r0,#1
;;;730            CaliV = CaliV - 2048;
000102  2001              MOVS     r0,#1
000104  02c0              LSLS     r0,r0,#11
000106  1a24              SUBS     r4,r4,r0
;;;731            CaliV = CaliV / 2;
000108  4620              MOV      r0,r4
00010a  0fe1              LSRS     r1,r4,#31
00010c  1809              ADDS     r1,r1,r0
00010e  104c              ASRS     r4,r1,#1
;;;732            VRM = VRM + CaliV;
000110  1936              ADDS     r6,r6,r4
;;;733            CFG_SetADC0RefMiddle(VRM);
000112  b2f0              UXTB     r0,r6
000114  f7fffffe          BL       CFG_SetADC0RefMiddle
;;;734            
;;;735                    
;;;736            if (CaliV == 1) break;
000118  2c01              CMP      r4,#1
00011a  d100              BNE      |L63.286|
00011c  e007              B        |L63.302|
                  |L63.286|
;;;737            if (CaliV == 0) break;
00011e  2c00              CMP      r4,#0
000120  d100              BNE      |L63.292|
000122  e004              B        |L63.302|
                  |L63.292|
;;;738            if (CaliV == -1) break;
000124  1c60              ADDS     r0,r4,#1
000126  2800              CMP      r0,#0
000128  d100              BNE      |L63.300|
00012a  e000              B        |L63.302|
                  |L63.300|
00012c  e76f              B        |L63.14|
                  |L63.302|
00012e  bf00              NOP                            ;736
;;;739            
;;;740            
;;;741        }
;;;742            
;;;743        // 2018.08.29 test
;;;744        VRM = VRM + 1;
000130  1c76              ADDS     r6,r6,#1
;;;745        CFG_SetADC0RefMiddle(VRM);
000132  b2f0              UXTB     r0,r6
000134  f7fffffe          BL       CFG_SetADC0RefMiddle
;;;746    }
000138  bdfe              POP      {r1-r7,pc}
;;;747    #endif        
                          ENDP

00013a  0000              DCW      0x0000
                  |L63.316|
                          DCD      0x4ff0000c

                          AREA ||i.ADC_WaitDataReadOut||, CODE, READONLY, ALIGN=1

                  ADC_WaitDataReadOut PROC
;;;1216    */
;;;1217   void ADC_WaitDataReadOut(ADC_Struct* ADCx, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1218   {
;;;1219       ADCx->CR0.MBIT.WAIT_EN = NewState;
000002  7c02              LDRB     r2,[r0,#0x10]
000004  2304              MOVS     r3,#4
000006  439a              BICS     r2,r2,r3
000008  008b              LSLS     r3,r1,#2
00000a  2404              MOVS     r4,#4
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7402              STRB     r2,[r0,#0x10]
;;;1220   }
000012  bd10              POP      {r4,pc}
;;;1221   /**
                          ENDP


                          AREA ||i.ADC_WindowDetectRange_Select||, CODE, READONLY, ALIGN=1

                  ADC_WindowDetectRange_Select PROC
;;;326     */
;;;327    void ADC_WindowDetectRange_Select(ADC_Struct* ADCx, ADC_WindowDetectApplyDef WINDApply)
000000  b510              PUSH     {r4,lr}
;;;328    {
;;;329        ADCx->CR1.MBIT.WIND_MDS = WINDApply;
000002  7d02              LDRB     r2,[r0,#0x14]
000004  2302              MOVS     r3,#2
000006  439a              BICS     r2,r2,r3
000008  004b              LSLS     r3,r1,#1
00000a  2402              MOVS     r4,#2
00000c  4023              ANDS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  7502              STRB     r2,[r0,#0x14]
;;;330    }
000012  bd10              POP      {r4,pc}
;;;331    /**
                          ENDP


                          AREA ||i.ADC_WindowDetect_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_WindowDetect_Cmd PROC
;;;344     */
;;;345    void ADC_WindowDetect_Cmd(ADC_Struct* ADCx, FunctionalState NewState)
000000  7d02              LDRB     r2,[r0,#0x14]
;;;346    {
;;;347        ADCx->CR1.MBIT.WIND_EN = NewState;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  07cb              LSLS     r3,r1,#31
000008  0fdb              LSRS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  7502              STRB     r2,[r0,#0x14]
;;;348    }
00000e  4770              BX       lr
;;;349    /**
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L403.24|
                  |L403.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L403.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L403.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Driver\\Source\\MG32x02z_ADC_DRV.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_ADC_DRV_c_e11a2ea2____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_ADC_DRV_c_e11a2ea2____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_ADC_DRV_c_e11a2ea2____REVSH|
#line 496
|__asm___18_MG32x02z_ADC_DRV_c_e11a2ea2____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
