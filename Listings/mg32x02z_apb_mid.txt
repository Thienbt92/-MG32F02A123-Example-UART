; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_apb_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_apb_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_apb_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_APB_MID.c]
                          THUMB

                          AREA ||i.MID_APB_UpdateSwitchState||, CODE, READONLY, ALIGN=1

                  MID_APB_UpdateSwitchState PROC
;;;485     */
;;;486    MID_StatusTypeDef MID_APB_UpdateSwitchState(MID_OBMx_HandleTypeDef *mOBMx, uint32_t InitState)                
000000  b510              PUSH     {r4,lr}
;;;487    {
000002  4602              MOV      r2,r0
;;;488        uint32_t tmpREG;
;;;489            
;;;490        /* Process locked */
;;;491        __MID_LOCK(mOBMx);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5c80              LDRB     r0,[r0,r2]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;492    
;;;493        if(mOBMx->State == MID_APB_STATE_READY)
;;;494        {
;;;495            tmpREG = mOBMx->Instance->OBMx0.W & ~APB_OBM10_OBM1_STA_mask_w;
;;;496            tmpREG |= InitState;
;;;497            mOBMx->Instance->OBMx0.W = tmpREG;
;;;498        }
;;;499        else
;;;500        {
;;;501            __MID_UNLOCK(mOBMx);
;;;502            return MID_FAILURE;
;;;503        }
;;;504        
;;;505        /* Process unlocked */
;;;506        __MID_UNLOCK(mOBMx);
;;;507    
;;;508        /* Return function status */
;;;509        return MID_SUCCESS;
;;;510    }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  2401              MOVS     r4,#1                 ;491
000014  203c              MOVS     r0,#0x3c              ;491
000016  5484              STRB     r4,[r0,r2]            ;491
000018  bf00              NOP                            ;491
00001a  203d              MOVS     r0,#0x3d              ;493
00001c  5c80              LDRB     r0,[r0,r2]            ;493
00001e  2801              CMP      r0,#1                 ;493
000020  d10a              BNE      |L1.56|
000022  6810              LDR      r0,[r2,#0]            ;495
000024  6800              LDR      r0,[r0,#0]            ;495
000026  2410              MOVS     r4,#0x10              ;495
000028  43a0              BICS     r0,r0,r4              ;495
00002a  4603              MOV      r3,r0                 ;495
00002c  4618              MOV      r0,r3                 ;496
00002e  4308              ORRS     r0,r0,r1              ;496
000030  4603              MOV      r3,r0                 ;496
000032  6810              LDR      r0,[r2,#0]            ;497
000034  6003              STR      r3,[r0,#0]            ;497
000036  e006              B        |L1.70|
                  |L1.56|
000038  bf00              NOP                            ;501
00003a  2400              MOVS     r4,#0                 ;501
00003c  203c              MOVS     r0,#0x3c              ;501
00003e  5484              STRB     r4,[r0,r2]            ;501
000040  bf00              NOP                            ;501
000042  2001              MOVS     r0,#1                 ;502
000044  e7e4              B        |L1.16|
                  |L1.70|
000046  bf00              NOP                            ;506
000048  2400              MOVS     r4,#0                 ;506
00004a  203c              MOVS     r0,#0x3c              ;506
00004c  5484              STRB     r4,[r0,r2]            ;506
00004e  bf00              NOP                            ;506
000050  2000              MOVS     r0,#0                 ;509
000052  e7dd              B        |L1.16|
;;;511    
                          ENDP


                          AREA ||i.MID_OBMx_DeInit||, CODE, READONLY, ALIGN=1

                  MID_OBMx_DeInit PROC
;;;136     */
;;;137    MID_StatusTypeDef MID_OBMx_DeInit(MID_OBMx_HandleTypeDef *mOBMx)
000000  b510              PUSH     {r4,lr}
;;;138    {
000002  4604              MOV      r4,r0
;;;139    
;;;140        /* Process locked */
;;;141        __MID_LOCK(mOBMx);
000004  bf00              NOP      
000006  203c              MOVS     r0,#0x3c
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;142    
;;;143        /* Check the APB handle allocation and lock status */
;;;144        if(mOBMx == NULL) 
;;;145        {
;;;146            return MID_FAILURE;
;;;147        }
;;;148        else
;;;149        {
;;;150            /* Reset OBMx register */
;;;151            mOBMx->Instance->OBMx0.W = 0x0U;
;;;152            mOBMx->Instance->OBMx1.W = 0x0U;
;;;153    
;;;154            /* DeInit the low level hardware: GPIO, CLOCK and NVIC */
;;;155            MID_OBMx_MspDeInit(mOBMx);
;;;156    
;;;157            /* Set OBMx state */
;;;158            mOBMx->State = MID_APB_STATE_RESET;
;;;159        }
;;;160    
;;;161        /* Process unlocked */
;;;162        __MID_UNLOCK(mOBMx);
;;;163    
;;;164        /* Return function status */
;;;165        return MID_SUCCESS;
;;;166    }
000010  bd10              POP      {r4,pc}
                  |L2.18|
000012  2101              MOVS     r1,#1                 ;141
000014  203c              MOVS     r0,#0x3c              ;141
000016  5501              STRB     r1,[r0,r4]            ;141
000018  bf00              NOP                            ;141
00001a  2c00              CMP      r4,#0                 ;144
00001c  d101              BNE      |L2.34|
00001e  2001              MOVS     r0,#1                 ;146
000020  e7f6              B        |L2.16|
                  |L2.34|
000022  2000              MOVS     r0,#0                 ;151
000024  6821              LDR      r1,[r4,#0]            ;151
000026  6008              STR      r0,[r1,#0]            ;151
000028  6821              LDR      r1,[r4,#0]            ;152
00002a  6048              STR      r0,[r1,#4]            ;152
00002c  4620              MOV      r0,r4                 ;155
00002e  f7fffffe          BL       MID_OBMx_MspDeInit
000032  2100              MOVS     r1,#0                 ;158
000034  203d              MOVS     r0,#0x3d              ;158
000036  5501              STRB     r1,[r0,r4]            ;158
000038  bf00              NOP                            ;162
00003a  203c              MOVS     r0,#0x3c              ;162
00003c  5501              STRB     r1,[r0,r4]            ;162
00003e  bf00              NOP                            ;162
000040  2000              MOVS     r0,#0                 ;165
000042  e7e5              B        |L2.16|
;;;167    
                          ENDP


                          AREA ||i.MID_OBMx_GetOutputLevel||, CODE, READONLY, ALIGN=2

                  MID_OBMx_GetOutputLevel PROC
;;;395     */
;;;396    uint32_t MID_OBMx_GetOutputLevel(MID_OBMx_HandleTypeDef* mOBMx)
000000  4601              MOV      r1,r0
;;;397    {
;;;398        uint32_t STABITDef=0x00000000U;
000002  2200              MOVS     r2,#0
;;;399        
;;;400        #if !defined(MG32_1ST)
;;;401        if(mOBMx->Instance == OBM0)
;;;402            STABITDef = APB->STA.W & APB_STA_OBM0_OUT_mask_w;
;;;403        #endif
;;;404        if(mOBMx->Instance == OBM1)
000004  4b08              LDR      r3,|L3.40|
000006  6808              LDR      r0,[r1,#0]
000008  4298              CMP      r0,r3
00000a  d106              BNE      |L3.26|
;;;405            STABITDef = APB->STA.W & APB_STA_OBM1_OUT_mask_w;
00000c  205f              MOVS     r0,#0x5f
00000e  0600              LSLS     r0,r0,#24
000010  6800              LDR      r0,[r0,#0]
000012  2301              MOVS     r3,#1
000014  045b              LSLS     r3,r3,#17
000016  4018              ANDS     r0,r0,r3
000018  4602              MOV      r2,r0
                  |L3.26|
;;;406        
;;;407        if(STABITDef != 0U)
00001a  2a00              CMP      r2,#0
00001c  d001              BEQ      |L3.34|
;;;408        {
;;;409            return(OBM_OUTPUTLEVEL_HIGH);
00001e  2001              MOVS     r0,#1
                  |L3.32|
;;;410        }
;;;411        return(OBM_OUTPUTLEVEL_LOW);
;;;412    }
000020  4770              BX       lr
                  |L3.34|
000022  2000              MOVS     r0,#0                 ;411
000024  e7fc              B        |L3.32|
;;;413    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x5f000028

                          AREA ||i.MID_OBMx_GetState||, CODE, READONLY, ALIGN=1

                  MID_OBMx_GetState PROC
;;;518     */
;;;519    uint32_t MID_OBMx_GetState(MID_OBMx_HandleTypeDef *mOBMx)
000000  4601              MOV      r1,r0
;;;520    {
;;;521        /* Check the APB handle allocation */
;;;522        if(mOBMx == NULL)
000002  2900              CMP      r1,#0
000004  d100              BNE      |L4.8|
                  |L4.6|
;;;523        {
;;;524            return MID_APB_STATE_RESET;
;;;525        }
;;;526        
;;;527        return mOBMx->State;
;;;528    }
000006  4770              BX       lr
                  |L4.8|
000008  203d              MOVS     r0,#0x3d              ;527
00000a  5c40              LDRB     r0,[r0,r1]            ;527
00000c  e7fb              B        |L4.6|
;;;529    #endif
                          ENDP


                          AREA ||i.MID_OBMx_GetSwitchState||, CODE, READONLY, ALIGN=2

                  MID_OBMx_GetSwitchState PROC
;;;453     */
;;;454    uint32_t MID_OBMx_GetSwitchState(MID_OBMx_HandleTypeDef *mOBMx)
000000  4601              MOV      r1,r0
;;;455    {
;;;456        uint32_t SwitchStatus;
;;;457        
;;;458        /* Check the APB handle allocation */
;;;459        #if defined(MG32_2ND)
;;;460        if(mOBMx->Instance == OBM0)
;;;461        {
;;;462            SwitchStatus = APB->STA.W & APB_STA_OBM0_SW_mask_w;
;;;463        }
;;;464        #endif
;;;465        if(mOBMx->Instance == OBM1)
000002  4b08              LDR      r3,|L5.36|
000004  6808              LDR      r0,[r1,#0]
000006  4298              CMP      r0,r3
000008  d105              BNE      |L5.22|
;;;466        {
;;;467            SwitchStatus = APB->STA.W & APB_STA_OBM1_SW_mask_w;
00000a  205f              MOVS     r0,#0x5f
00000c  0600              LSLS     r0,r0,#24
00000e  6802              LDR      r2,[r0,#0]
000010  2301              MOVS     r3,#1
000012  065b              LSLS     r3,r3,#25
000014  401a              ANDS     r2,r2,r3
                  |L5.22|
;;;468        }
;;;469    
;;;470        if(SwitchStatus != 0U)
000016  2a00              CMP      r2,#0
000018  d001              BEQ      |L5.30|
;;;471        {
;;;472            return(OBM_SWITCHSTATUS_HIGH);
00001a  2001              MOVS     r0,#1
                  |L5.28|
;;;473        }
;;;474        return(OBM_SWITCHSTATUS_LOW);
;;;475    }
00001c  4770              BX       lr
                  |L5.30|
00001e  2000              MOVS     r0,#0                 ;474
000020  e7fc              B        |L5.28|
;;;476    /**
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x5f000028

                          AREA ||i.MID_OBMx_IRQHandler||, CODE, READONLY, ALIGN=1

                  MID_OBMx_IRQHandler PROC
;;;357     */
;;;358    void MID_OBMx_IRQHandler(MID_OBMx_HandleTypeDef* mOBMx)
000000  b510              PUSH     {r4,lr}
;;;359    {
000002  4604              MOV      r4,r0
;;;360        /* ========== Check APB flag ========== */
;;;361        #if !defined(MG32_1ST)
;;;362        if(__DRV_APB_GET_FLAG(APB_FLAG_OBM0))
;;;363        {
;;;364            /* Clear APB Exti pending bit */
;;;365            __DRV_APB_CLEAR_FLAG(APB_FLAG_OBM0);
;;;366            
;;;367            /* APB trigger user callback */
;;;368            MID_OBMx_TriggerCallbackOBM0(mOBMx);    
;;;369        }
;;;370        #endif
;;;371        if(__DRV_APB_GET_FLAG(APB_FLAG_OBM1))
000004  205f              MOVS     r0,#0x5f
000006  0600              LSLS     r0,r0,#24
000008  6800              LDR      r0,[r0,#0]
00000a  2101              MOVS     r1,#1
00000c  0249              LSLS     r1,r1,#9
00000e  4008              ANDS     r0,r0,r1
000010  4288              CMP      r0,r1
000012  d105              BNE      |L6.32|
;;;372        {
;;;373            /* Clear APB Exti pending bit */
;;;374            __DRV_APB_CLEAR_FLAG(APB_FLAG_OBM1);
000014  215f              MOVS     r1,#0x5f
000016  0609              LSLS     r1,r1,#24
000018  6008              STR      r0,[r1,#0]
;;;375            
;;;376            /* APB trigger user callback */
;;;377            MID_OBMx_TriggerCallbackOBM1(mOBMx);    
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       MID_OBMx_TriggerCallbackOBM1
                  |L6.32|
;;;378        }
;;;379    
;;;380    }
000020  bd10              POP      {r4,pc}
;;;381    
                          ENDP


                          AREA ||i.MID_OBMx_Init||, CODE, READONLY, ALIGN=1

                  MID_OBMx_Init PROC
;;;72      */
;;;73     MID_StatusTypeDef MID_OBMx_Init(MID_OBMx_HandleTypeDef* mOBMx)
000000  b570              PUSH     {r4-r6,lr}
;;;74     {
000002  4604              MOV      r4,r0
;;;75         uint32_t tmpREG;
;;;76         
;;;77         /* Check APB handle */
;;;78         if(mOBMx == NULL) 
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L7.12|
;;;79         {
;;;80             return MID_FAILURE;
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;81         }
;;;82         else
;;;83         {
;;;84             /* Init the another GPIO module or SYCLK  ... */
;;;85             MID_OBMx_MspInit(mOBMx);
;;;86             
;;;87             /* Change APB peripheral state */
;;;88             mOBMx->State = MID_APB_STATE_BUSY;
;;;89         
;;;90             // ------------------------------------------------------------------------
;;;91             /* Config of OBMX parameters:                                             */
;;;92             // ------------------------------------------------------------------------
;;;93             tmpREG = mOBMx->Init.OutChannel0Polarity    | 
;;;94                      mOBMx->Init.OutChannel0Src         | 
;;;95                      mOBMx->Init.OutChannel1Polarity    | 
;;;96                      mOBMx->Init.OutChannel1Src         | 
;;;97                      mOBMx->Init.OBMxOutPolarity        | 
;;;98                      mOBMx->Init.SyncFilter;
;;;99             
;;;100            mOBMx->Instance->OBMx1.W = tmpREG;
;;;101    
;;;102            //
;;;103            tmpREG = mOBMx->Init.BKS0Polarity           | 
;;;104                     mOBMx->Init.BKS0Src                | 
;;;105                     mOBMx->Init.BKS1Polarity           | 
;;;106                     mOBMx->Init.BKS1Src                | 
;;;107                     mOBMx->Init.BKS2Polarity           | 
;;;108                     mOBMx->Init.BKS2Src                | 
;;;109                     mOBMx->Init.InitSTAState           | 
;;;110                     mOBMx->Init.OBMxMode;
;;;111            
;;;112            mOBMx->Instance->OBMx0.W = tmpREG;
;;;113            
;;;114            /* Initialize the APB state*/
;;;115            mOBMx->State = MID_APB_STATE_READY;
;;;116        }
;;;117        
;;;118        /* Return function status */
;;;119        return MID_SUCCESS;
;;;120    }
00000a  bd70              POP      {r4-r6,pc}
                  |L7.12|
00000c  4620              MOV      r0,r4                 ;85
00000e  f7fffffe          BL       MID_OBMx_MspInit
000012  2102              MOVS     r1,#2                 ;88
000014  203d              MOVS     r0,#0x3d              ;88
000016  5501              STRB     r1,[r0,r4]            ;88
000018  6a21              LDR      r1,[r4,#0x20]         ;93
00001a  6a60              LDR      r0,[r4,#0x24]         ;93
00001c  4308              ORRS     r0,r0,r1              ;93
00001e  6ae1              LDR      r1,[r4,#0x2c]         ;93
000020  4308              ORRS     r0,r0,r1              ;93
000022  6aa1              LDR      r1,[r4,#0x28]         ;93
000024  4308              ORRS     r0,r0,r1              ;93
000026  6b21              LDR      r1,[r4,#0x30]         ;93
000028  4308              ORRS     r0,r0,r1              ;93
00002a  6b61              LDR      r1,[r4,#0x34]         ;93
00002c  4308              ORRS     r0,r0,r1              ;93
00002e  4605              MOV      r5,r0                 ;93
000030  6820              LDR      r0,[r4,#0]            ;100
000032  6045              STR      r5,[r0,#4]            ;100
000034  68a1              LDR      r1,[r4,#8]            ;103
000036  68e0              LDR      r0,[r4,#0xc]          ;103
000038  4308              ORRS     r0,r0,r1              ;103
00003a  6961              LDR      r1,[r4,#0x14]         ;103
00003c  4308              ORRS     r0,r0,r1              ;103
00003e  6921              LDR      r1,[r4,#0x10]         ;103
000040  4308              ORRS     r0,r0,r1              ;103
000042  69e1              LDR      r1,[r4,#0x1c]         ;103
000044  4308              ORRS     r0,r0,r1              ;103
000046  69a1              LDR      r1,[r4,#0x18]         ;103
000048  4308              ORRS     r0,r0,r1              ;103
00004a  6ba1              LDR      r1,[r4,#0x38]         ;103
00004c  4308              ORRS     r0,r0,r1              ;103
00004e  6861              LDR      r1,[r4,#4]            ;103
000050  4308              ORRS     r0,r0,r1              ;103
000052  4605              MOV      r5,r0                 ;103
000054  6820              LDR      r0,[r4,#0]            ;112
000056  6005              STR      r5,[r0,#0]            ;112
000058  2101              MOVS     r1,#1                 ;115
00005a  203d              MOVS     r0,#0x3d              ;115
00005c  5501              STRB     r1,[r0,r4]            ;115
00005e  2000              MOVS     r0,#0                 ;119
000060  e7d3              B        |L7.10|
;;;121    
                          ENDP


                          AREA ||i.MID_OBMx_MspDeInit||, CODE, READONLY, ALIGN=1

                  MID_OBMx_MspDeInit PROC
;;;190     */
;;;191    __weak void MID_OBMx_MspDeInit(MID_OBMx_HandleTypeDef* mOBMx)
000000  4770              BX       lr
;;;192    {
;;;193        /* Prevent unused argument(s) compilation warning */
;;;194        UNUSED(mOBMx);
;;;195        /* NOTE : This function Should not be modified, when the callback is needed,
;;;196                    the MID_OBMx_MspDeInit could be implemented in the user file
;;;197        */
;;;198    }
;;;199    ///@} 
                          ENDP


                          AREA ||i.MID_OBMx_MspInit||, CODE, READONLY, ALIGN=1

                  MID_OBMx_MspInit PROC
;;;174     */
;;;175    __weak void MID_OBMx_MspInit(MID_OBMx_HandleTypeDef* mOBMx)
000000  4770              BX       lr
;;;176    {
;;;177        /* Prevent unused argument(s) compilation warning */
;;;178        UNUSED(mOBMx);
;;;179        /* NOTE : This function Should not be modified, when the callback is needed,
;;;180                    the MID_OBMx_MspInit could be implemented in the user file
;;;181        */
;;;182    }
;;;183    
                          ENDP


                          AREA ||i.MID_OBMx_Start||, CODE, READONLY, ALIGN=1

                  MID_OBMx_Start PROC
;;;220     */
;;;221    MID_StatusTypeDef MID_OBMx_Start(MID_OBMx_HandleTypeDef* mOBMx)
000000  b570              PUSH     {r4-r6,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223        MID_StatusTypeDef status;
;;;224        
;;;225        status = MID_OBMx_Init(mOBMx);    
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       MID_OBMx_Init
00000a  4605              MOV      r5,r0
;;;226        return status;
00000c  4628              MOV      r0,r5
;;;227    }
00000e  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP


                          AREA ||i.MID_OBMx_Start_IT||, CODE, READONLY, ALIGN=2

                  MID_OBMx_Start_IT PROC
;;;259     */
;;;260    MID_StatusTypeDef MID_OBMx_Start_IT(MID_OBMx_HandleTypeDef* mOBMx)
000000  b510              PUSH     {r4,lr}
;;;261    {
000002  4604              MOV      r4,r0
;;;262        
;;;263        /* Check the APB handle allocation and lock status */
;;;264        if(mOBMx == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L11.12|
;;;265        {
;;;266            return MID_FAILURE;
000008  2001              MOVS     r0,#1
                  |L11.10|
;;;267        }
;;;268        else
;;;269        {
;;;270            MID_OBMx_Init(mOBMx);
;;;271            
;;;272            if(mOBMx->State == MID_APB_STATE_READY)
;;;273            {
;;;274                #if !defined(MG32_1ST)
;;;275                if(mOBMx->Instance == OBM0)
;;;276                    __DRV_APB_ENABLE_IT(APB_IT_OBM0);
;;;277                #endif
;;;278                if(mOBMx->Instance == OBM1)
;;;279                    __DRV_APB_ENABLE_IT(APB_IT_OBM1);
;;;280                
;;;281                __DRV_APB_ENABLE_ITEA();
;;;282                SYS->INT.MBIT.IEA = 1;
;;;283                
;;;284            }
;;;285            else
;;;286            {
;;;287                return MID_FAILURE;
;;;288            }
;;;289        }
;;;290        
;;;291        return MID_SUCCESS;
;;;292    }
00000a  bd10              POP      {r4,pc}
                  |L11.12|
00000c  4620              MOV      r0,r4                 ;270
00000e  f7fffffe          BL       MID_OBMx_Init
000012  203d              MOVS     r0,#0x3d              ;272
000014  5d00              LDRB     r0,[r0,r4]            ;272
000016  2801              CMP      r0,#1                 ;272
000018  d11c              BNE      |L11.84|
00001a  4910              LDR      r1,|L11.92|
00001c  6820              LDR      r0,[r4,#0]            ;278
00001e  4288              CMP      r0,r1                 ;278
000020  d108              BNE      |L11.52|
000022  205f              MOVS     r0,#0x5f              ;279
000024  0600              LSLS     r0,r0,#24             ;279
000026  6840              LDR      r0,[r0,#4]            ;279
000028  2101              MOVS     r1,#1                 ;279
00002a  0249              LSLS     r1,r1,#9              ;279
00002c  4308              ORRS     r0,r0,r1              ;279
00002e  215f              MOVS     r1,#0x5f              ;279
000030  0609              LSLS     r1,r1,#24             ;279
000032  6048              STR      r0,[r1,#4]            ;279
                  |L11.52|
000034  205f              MOVS     r0,#0x5f              ;281
000036  0600              LSLS     r0,r0,#24             ;281
000038  6840              LDR      r0,[r0,#4]            ;281
00003a  2101              MOVS     r1,#1                 ;281
00003c  4308              ORRS     r0,r0,r1              ;281
00003e  215f              MOVS     r1,#0x5f              ;281
000040  0609              LSLS     r1,r1,#24             ;281
000042  6048              STR      r0,[r1,#4]            ;281
000044  4806              LDR      r0,|L11.96|
000046  7900              LDRB     r0,[r0,#4]            ;282
000048  0840              LSRS     r0,r0,#1              ;282
00004a  0040              LSLS     r0,r0,#1              ;282
00004c  1c40              ADDS     r0,r0,#1              ;282
00004e  4904              LDR      r1,|L11.96|
000050  7108              STRB     r0,[r1,#4]            ;282
000052  e001              B        |L11.88|
                  |L11.84|
000054  2001              MOVS     r0,#1                 ;287
000056  e7d8              B        |L11.10|
                  |L11.88|
000058  2000              MOVS     r0,#0                 ;291
00005a  e7d6              B        |L11.10|
;;;293    
                          ENDP

                  |L11.92|
                          DCD      0x5f000028
                  |L11.96|
                          DCD      0x4c030000

                          AREA ||i.MID_OBMx_Stop||, CODE, READONLY, ALIGN=1

                  MID_OBMx_Stop PROC
;;;241     */
;;;242    MID_StatusTypeDef MID_OBMx_Stop(MID_OBMx_HandleTypeDef* mOBMx)
000000  b510              PUSH     {r4,lr}
;;;243    {
000002  4604              MOV      r4,r0
;;;244        MID_OBMx_DeInit(mOBMx);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       MID_OBMx_DeInit
;;;245        
;;;246        return MID_SUCCESS;
00000a  2000              MOVS     r0,#0
;;;247    }
00000c  bd10              POP      {r4,pc}
;;;248    
                          ENDP


                          AREA ||i.MID_OBMx_Stop_IT||, CODE, READONLY, ALIGN=2

                  MID_OBMx_Stop_IT PROC
;;;307     */
;;;308    MID_StatusTypeDef MID_OBMx_Stop_IT(MID_OBMx_HandleTypeDef* mOBMx)
000000  4601              MOV      r1,r0
;;;309    {
;;;310    
;;;311        /* Process locked */
;;;312        __MID_LOCK(mOBMx);
000002  bf00              NOP      
000004  203c              MOVS     r0,#0x3c
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L13.16|
00000c  2002              MOVS     r0,#2
                  |L13.14|
;;;313    
;;;314        /* 1. Stop potential conversion on going, on regular group */
;;;315        if(mOBMx->State == MID_APB_STATE_READY)
;;;316        {
;;;317            #if !defined(MG32_1ST)
;;;318            if(mOBMx->Instance == OBM0)
;;;319                __DRV_APB_DISABLE_IT(APB_IT_OBM0);
;;;320            #endif
;;;321            if(mOBMx->Instance == OBM1)
;;;322                __DRV_APB_DISABLE_IT(APB_IT_OBM1);
;;;323                
;;;324        }
;;;325        else
;;;326        {
;;;327            return MID_FAILURE;
;;;328        }
;;;329        
;;;330    
;;;331        // disable ITEA
;;;332        if((APB->INT.W & (0xFFFFFFFE)) == 0x00000000U)
;;;333            __DRV_APB_DISABLE_ITEA();
;;;334        
;;;335        /* Process unlocked */
;;;336        __MID_UNLOCK(mOBMx);
;;;337    
;;;338        /* Return function status */
;;;339        return MID_SUCCESS;
;;;340    }
00000e  4770              BX       lr
                  |L13.16|
000010  2201              MOVS     r2,#1                 ;312
000012  203c              MOVS     r0,#0x3c              ;312
000014  5442              STRB     r2,[r0,r1]            ;312
000016  bf00              NOP                            ;312
000018  203d              MOVS     r0,#0x3d              ;315
00001a  5c40              LDRB     r0,[r0,r1]            ;315
00001c  2801              CMP      r0,#1                 ;315
00001e  d10d              BNE      |L13.60|
000020  4a12              LDR      r2,|L13.108|
000022  6808              LDR      r0,[r1,#0]            ;321
000024  4290              CMP      r0,r2                 ;321
000026  d10b              BNE      |L13.64|
000028  205f              MOVS     r0,#0x5f              ;322
00002a  0600              LSLS     r0,r0,#24             ;322
00002c  6840              LDR      r0,[r0,#4]            ;322
00002e  2201              MOVS     r2,#1                 ;322
000030  0252              LSLS     r2,r2,#9              ;322
000032  4390              BICS     r0,r0,r2              ;322
000034  225f              MOVS     r2,#0x5f              ;322
000036  0612              LSLS     r2,r2,#24             ;322
000038  6050              STR      r0,[r2,#4]            ;322
00003a  e001              B        |L13.64|
                  |L13.60|
00003c  2001              MOVS     r0,#1                 ;327
00003e  e7e6              B        |L13.14|
                  |L13.64|
000040  205f              MOVS     r0,#0x5f              ;332
000042  0600              LSLS     r0,r0,#24             ;332
000044  6840              LDR      r0,[r0,#4]            ;332
000046  0840              LSRS     r0,r0,#1              ;332
000048  0040              LSLS     r0,r0,#1              ;332
00004a  2800              CMP      r0,#0                 ;332
00004c  d107              BNE      |L13.94|
00004e  205f              MOVS     r0,#0x5f              ;333
000050  0600              LSLS     r0,r0,#24             ;333
000052  6840              LDR      r0,[r0,#4]            ;333
000054  0840              LSRS     r0,r0,#1              ;333
000056  0040              LSLS     r0,r0,#1              ;333
000058  225f              MOVS     r2,#0x5f              ;333
00005a  0612              LSLS     r2,r2,#24             ;333
00005c  6050              STR      r0,[r2,#4]            ;333
                  |L13.94|
00005e  bf00              NOP                            ;336
000060  2200              MOVS     r2,#0                 ;336
000062  203c              MOVS     r0,#0x3c              ;336
000064  5442              STRB     r2,[r0,r1]            ;336
000066  bf00              NOP                            ;336
000068  2000              MOVS     r0,#0                 ;339
00006a  e7d0              B        |L13.14|
;;;341    ///@} 
                          ENDP

                  |L13.108|
                          DCD      0x5f000028

                          AREA ||i.MID_OBMx_TriggerCallbackOBM0||, CODE, READONLY, ALIGN=1

                  MID_OBMx_TriggerCallbackOBM0 PROC
;;;421     */
;;;422    __weak void MID_OBMx_TriggerCallbackOBM0(MID_OBMx_HandleTypeDef* mOBMx)
000000  4770              BX       lr
;;;423    {
;;;424        /* Prevent unused argument(s) compilation warning */
;;;425        UNUSED(mOBMx);
;;;426        /* NOTE : This function Should not be modified, when the callback is needed,
;;;427                    the MID_OBMx_TriggerCallbackOBM0 could be implemented in the user file
;;;428        */
;;;429    }
;;;430    
                          ENDP


                          AREA ||i.MID_OBMx_TriggerCallbackOBM1||, CODE, READONLY, ALIGN=1

                  MID_OBMx_TriggerCallbackOBM1 PROC
;;;437     */
;;;438    __weak void MID_OBMx_TriggerCallbackOBM1(MID_OBMx_HandleTypeDef* mOBMx)
000000  4770              BX       lr
;;;439    {
;;;440        /* Prevent unused argument(s) compilation warning */
;;;441        UNUSED(mOBMx);
;;;442        /* NOTE : This function Should not be modified, when the callback is needed,
;;;443                    the MID_OBMx_TriggerCallbackOBM1 could be implemented in the user file
;;;444        */
;;;445    }
;;;446    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_APB_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_APB_MID_c_23eed381____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_APB_MID_c_23eed381____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_APB_MID_c_23eed381____REVSH|
#line 496
|__asm___18_MG32x02z_APB_MID_c_23eed381____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
