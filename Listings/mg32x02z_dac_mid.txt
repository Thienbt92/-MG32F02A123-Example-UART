; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_dac_mid.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_dac_mid.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_dac_mid.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Source\MG32x02z_DAC_MID.c]
                          THUMB

                          AREA ||i.DAC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  DAC_DMAConvCplt PROC
;;;743     */
;;;744    static void DAC_DMAConvCplt(DMA_HandleTypeDef *mDMA)   
000000  b570              PUSH     {r4-r6,lr}
;;;745    {
000002  4604              MOV      r4,r0
;;;746        DAC_HandleTypeDef* mDAC = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )mDMA)->Parent;
000004  6aa5              LDR      r5,[r4,#0x28]
;;;747        
;;;748        MID_DAC_ConvCpltCallback(mDAC); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MID_DAC_ConvCpltCallback
;;;749        
;;;750        mDAC->State= MID_DAC_STATE_READY;
00000c  2001              MOVS     r0,#1
00000e  7668              STRB     r0,[r5,#0x19]
;;;751    }
000010  bd70              POP      {r4-r6,pc}
;;;752    
                          ENDP


                          AREA ||i.DAC_DMAError||, CODE, READONLY, ALIGN=1

                  DAC_DMAError PROC
;;;775     */
;;;776    static void DAC_DMAError(DMA_HandleTypeDef *mDMA)   
000000  b570              PUSH     {r4-r6,lr}
;;;777    {
000002  4605              MOV      r5,r0
;;;778        DAC_HandleTypeDef* mDAC = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )mDMA)->Parent;
000004  6aac              LDR      r4,[r5,#0x28]
;;;779        
;;;780        /* Set DAC error code to DMA error */
;;;781        mDAC->ErrorCode |= MID_DAC_ERROR_DMA;
000006  6a20              LDR      r0,[r4,#0x20]
000008  2102              MOVS     r1,#2
00000a  4308              ORRS     r0,r0,r1
00000c  6220              STR      r0,[r4,#0x20]
;;;782        
;;;783        MID_DAC_ErrorCallback(mDAC); 
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       MID_DAC_ErrorCallback
;;;784        
;;;785        mDAC->State= MID_DAC_STATE_READY;
000014  2001              MOVS     r0,#1
000016  7660              STRB     r0,[r4,#0x19]
;;;786    }
000018  bd70              POP      {r4-r6,pc}
;;;787    
                          ENDP


                          AREA ||i.DAC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  DAC_DMAHalfConvCplt PROC
;;;760     */
;;;761    static void DAC_DMAHalfConvCplt(DMA_HandleTypeDef *mDMA)   
000000  b570              PUSH     {r4-r6,lr}
;;;762    {
000002  4604              MOV      r4,r0
;;;763        DAC_HandleTypeDef* mDAC = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )mDMA)->Parent;
000004  6aa5              LDR      r5,[r4,#0x28]
;;;764        /* Conversion complete callback */
;;;765        MID_DAC_ConvHalfCpltCallback(mDAC); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MID_DAC_ConvHalfCpltCallback
;;;766    }
00000c  bd70              POP      {r4-r6,pc}
;;;767    
                          ENDP


                          AREA ||i.MID_DAC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_DAC_ConvCpltCallback PROC
;;;617     */
;;;618    __weak void MID_DAC_ConvCpltCallback(DAC_HandleTypeDef* mDAC)
000000  4770              BX       lr
;;;619    {
;;;620        /* Prevent unused argument(s) compilation warning */
;;;621        UNUSED(mDAC);
;;;622        /* NOTE : This function Should not be modified, when the callback is needed,
;;;623                the MID_DAC_TriggerCallback could be implemented in the user file
;;;624        */
;;;625    }
;;;626    
                          ENDP


                          AREA ||i.MID_DAC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  MID_DAC_ConvHalfCpltCallback PROC
;;;633     */
;;;634    __weak void MID_DAC_ConvHalfCpltCallback(DAC_HandleTypeDef* mDAC)
000000  4770              BX       lr
;;;635    {
;;;636        /* Prevent unused argument(s) compilation warning */
;;;637        UNUSED(mDAC);
;;;638        /* NOTE : This function Should not be modified, when the callback is needed,
;;;639                    the MID_DAC_TriggerCallback could be implemented in the user file
;;;640        */
;;;641    }
;;;642    
                          ENDP


                          AREA ||i.MID_DAC_DMAUnderrunCallback||, CODE, READONLY, ALIGN=1

                  MID_DAC_DMAUnderrunCallback PROC
;;;666     */
;;;667    __weak void MID_DAC_DMAUnderrunCallback(DAC_HandleTypeDef *mDAC)
000000  4770              BX       lr
;;;668    {
;;;669        /* Prevent unused argument(s) compilation warning */
;;;670        UNUSED(mDAC);
;;;671        
;;;672        /* NOTE : This function should not be modified. When the callback is needed,
;;;673                function MID_DAC_ConvCpltCallback must be implemented in the user file.
;;;674        */
;;;675    }
;;;676    ///@} 
                          ENDP


                          AREA ||i.MID_DAC_DeInit||, CODE, READONLY, ALIGN=1

                  MID_DAC_DeInit PROC
;;;127     */
;;;128    MID_StatusTypeDef MID_DAC_DeInit(DAC_HandleTypeDef *mDAC)
000000  b510              PUSH     {r4,lr}
;;;129    {
000002  4604              MOV      r4,r0
;;;130    
;;;131        /* Process locked */
;;;132        __MID_LOCK(mDAC);
000004  bf00              NOP      
000006  7e20              LDRB     r0,[r4,#0x18]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;133    
;;;134        /* Check the DAC handle allocation and lock status */
;;;135        if(mDAC == NULL) 
;;;136        {
;;;137            return MID_FAILURE;
;;;138        }
;;;139        else
;;;140        {
;;;141            /* Change DAC state */
;;;142            mDAC->State = MID_DAC_STATE_BUSY;
;;;143            
;;;144            /* DeInit the low level hardware */
;;;145            MID_DAC_MspDeInit(mDAC);
;;;146            
;;;147            /* Set DAC error code to none */
;;;148            mDAC->ErrorCode = MID_DAC_ERROR_NONE;
;;;149            
;;;150            /* Change DAC state */
;;;151            mDAC->State = MID_DAC_STATE_RESET;
;;;152    
;;;153        }
;;;154    
;;;155        /* Process unlocked */
;;;156        __MID_UNLOCK(mDAC);
;;;157    
;;;158        /* Return function status */
;;;159        return MID_SUCCESS;
;;;160    }
00000e  bd10              POP      {r4,pc}
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;132
000012  7620              STRB     r0,[r4,#0x18]         ;132
000014  bf00              NOP                            ;132
000016  2c00              CMP      r4,#0                 ;135
000018  d100              BNE      |L7.28|
00001a  e7f8              B        |L7.14|
                  |L7.28|
00001c  2011              MOVS     r0,#0x11              ;142
00001e  7660              STRB     r0,[r4,#0x19]         ;142
000020  4620              MOV      r0,r4                 ;145
000022  f7fffffe          BL       MID_DAC_MspDeInit
000026  2000              MOVS     r0,#0                 ;148
000028  6220              STR      r0,[r4,#0x20]         ;148
00002a  7660              STRB     r0,[r4,#0x19]         ;151
00002c  bf00              NOP                            ;156
00002e  7620              STRB     r0,[r4,#0x18]         ;156
000030  bf00              NOP                            ;156
000032  bf00              NOP                            ;159
000034  e7eb              B        |L7.14|
;;;161    
                          ENDP


                          AREA ||i.MID_DAC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  MID_DAC_ErrorCallback PROC
;;;649     */
;;;650    __weak void MID_DAC_ErrorCallback(DAC_HandleTypeDef *mDAC)
000000  4770              BX       lr
;;;651    {
;;;652        /* Prevent unused argument(s) compilation warning */
;;;653        UNUSED(mDAC);
;;;654        
;;;655        /* NOTE : This function should not be modified. When the callback is needed,
;;;656                function MID_DAC_ConvCpltCallback must be implemented in the user file.
;;;657        */
;;;658    }
;;;659    
                          ENDP


                          AREA ||i.MID_DAC_GetError||, CODE, READONLY, ALIGN=1

                  MID_DAC_GetError PROC
;;;722     */
;;;723    uint32_t MID_DAC_GetError(DAC_HandleTypeDef* mDAC)
000000  4601              MOV      r1,r0
;;;724    {
;;;725        /* Return DAC handle state */
;;;726        return mDAC->ErrorCode;
000002  6a08              LDR      r0,[r1,#0x20]
;;;727    }
000004  4770              BX       lr
;;;728    
                          ENDP


                          AREA ||i.MID_DAC_GetState||, CODE, READONLY, ALIGN=1

                  MID_DAC_GetState PROC
;;;707     */
;;;708    MID_DAC_StateTypeDef MID_DAC_GetState(DAC_HandleTypeDef* mDAC)
000000  4601              MOV      r1,r0
;;;709    {
;;;710        /* Return DAC handle state */
;;;711        return mDAC->State;
000002  7e48              LDRB     r0,[r1,#0x19]
;;;712    }
000004  4770              BX       lr
;;;713    
                          ENDP


                          AREA ||i.MID_DAC_GetValue||, CODE, READONLY, ALIGN=1

                  MID_DAC_GetValue PROC
;;;691     */
;;;692    uint32_t MID_DAC_GetValue(DAC_HandleTypeDef *mDAC)
000000  4601              MOV      r1,r0
;;;693    {
;;;694        /* Check the DAC handle allocation */
;;;695        return mDAC->Instance->DOR0.W;
000002  6808              LDR      r0,[r1,#0]
000004  6a80              LDR      r0,[r0,#0x28]
;;;696    }
000006  4770              BX       lr
;;;697    
                          ENDP


                          AREA ||i.MID_DAC_IRQHandler||, CODE, READONLY, ALIGN=1

                  MID_DAC_IRQHandler PROC
;;;497     */
;;;498    void MID_DAC_IRQHandler(DAC_HandleTypeDef* mDAC)
000000  b510              PUSH     {r4,lr}
;;;499    {
000002  4604              MOV      r4,r0
;;;500        if(__DRV_DAC_GET_IT_SOURCE(mDAC, DAC_IT_UNDERRUN))
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2180              MOVS     r1,#0x80
00000a  4008              ANDS     r0,r0,r1
00000c  2880              CMP      r0,#0x80
00000e  d116              BNE      |L12.62|
;;;501        { 
;;;502            /* Check underrun channel 1 flag */
;;;503            if(__DRV_DAC_GET_FLAG(mDAC, DAC_FLAG_UNDERRUN))
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  4008              ANDS     r0,r0,r1
000016  2880              CMP      r0,#0x80
000018  d111              BNE      |L12.62|
;;;504            {
;;;505            /* Change DAC state to error state */
;;;506            mDAC->State = MID_DAC_STATE_ERROR;
00001a  2012              MOVS     r0,#0x12
00001c  7660              STRB     r0,[r4,#0x19]
;;;507            
;;;508            /* Set DAC error code with DMA underrun error */
;;;509            mDAC->ErrorCode |= MID_DAC_ERROR_DMAUNDERRUN;
00001e  6a20              LDR      r0,[r4,#0x20]
000020  2101              MOVS     r1,#1
000022  4308              ORRS     r0,r0,r1
000024  6220              STR      r0,[r4,#0x20]
;;;510            
;;;511            /* Clear the underrun flag */
;;;512            __DRV_DAC_CLEAR_FLAG(mDAC, DAC_FLAG_UNDERRUN);
000026  2080              MOVS     r0,#0x80
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
;;;513            
;;;514            /* Disable the selected DAC with DMA request */
;;;515            __DRV_DAC_DISABLE_DMA(mDAC);
00002c  6820              LDR      r0,[r4,#0]
00002e  6900              LDR      r0,[r0,#0x10]
000030  0040              LSLS     r0,r0,#1
000032  0840              LSRS     r0,r0,#1
000034  6821              LDR      r1,[r4,#0]
000036  6108              STR      r0,[r1,#0x10]
;;;516            
;;;517            /* Error callback */ 
;;;518            MID_DAC_DMAUnderrunCallback(mDAC);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       MID_DAC_DMAUnderrunCallback
                  |L12.62|
;;;519            }
;;;520        }
;;;521        if(__DRV_DAC_GET_IT_SOURCE(mDAC, DAC_IT_READY))
00003e  6820              LDR      r0,[r4,#0]
000040  6840              LDR      r0,[r0,#4]
000042  2102              MOVS     r1,#2
000044  4008              ANDS     r0,r0,r1
000046  2802              CMP      r0,#2
000048  d116              BNE      |L12.120|
;;;522        { 
;;;523            /* Check underrun channel 1 flag */
;;;524            if(__DRV_DAC_GET_FLAG(mDAC, DAC_FLAG_READY))
00004a  6820              LDR      r0,[r4,#0]
00004c  6800              LDR      r0,[r0,#0]
00004e  4008              ANDS     r0,r0,r1
000050  2802              CMP      r0,#2
000052  d111              BNE      |L12.120|
;;;525            {
;;;526            /* Change DAC state to error state */
;;;527            mDAC->State = MID_DAC_STATE_READY;
000054  2001              MOVS     r0,#1
000056  7660              STRB     r0,[r4,#0x19]
;;;528            
;;;529            /* Set DAC error code with DMA underrun error */
;;;530            mDAC->ErrorCode |= MID_DAC_ERROR_DMAUNDERRUN;
000058  6a20              LDR      r0,[r4,#0x20]
00005a  2101              MOVS     r1,#1
00005c  4308              ORRS     r0,r0,r1
00005e  6220              STR      r0,[r4,#0x20]
;;;531            
;;;532            /* Clear the ready flag */
;;;533            __DRV_DAC_CLEAR_FLAG(mDAC, DAC_FLAG_READY);
000060  2002              MOVS     r0,#2
000062  6821              LDR      r1,[r4,#0]
000064  6008              STR      r0,[r1,#0]
;;;534            
;;;535            /* Disable the selected DAC with DMA request */
;;;536            __DRV_DAC_DISABLE_DMA(mDAC);
000066  6820              LDR      r0,[r4,#0]
000068  6900              LDR      r0,[r0,#0x10]
00006a  0040              LSLS     r0,r0,#1
00006c  0840              LSRS     r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6108              STR      r0,[r1,#0x10]
;;;537            
;;;538            /* Error callback */ 
;;;539            MID_DAC_ReadyCallback(mDAC);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       MID_DAC_ReadyCallback
                  |L12.120|
;;;540            }
;;;541        }
;;;542    }
000078  bd10              POP      {r4,pc}
;;;543    
                          ENDP


                          AREA ||i.MID_DAC_Init||, CODE, READONLY, ALIGN=1

                  MID_DAC_Init PROC
;;;64      */
;;;65     MID_StatusTypeDef MID_DAC_Init(DAC_HandleTypeDef* mDAC)
000000  b570              PUSH     {r4-r6,lr}
;;;66     {
000002  4604              MOV      r4,r0
;;;67         uint32_t tmpREG;
;;;68         
;;;69         /* Check DAC handle */
;;;70         if(mDAC == NULL) 
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L13.12|
;;;71         {
;;;72             return MID_FAILURE;
000008  2001              MOVS     r0,#1
                  |L13.10|
;;;73         }
;;;74         
;;;75         if(mDAC->State == MID_DAC_STATE_RESET) 
;;;76         {
;;;77             /* Allocate lock resource and initialize it */
;;;78             mDAC->Lock = MID_UnLocked;
;;;79     
;;;80             /* Init the low level hardware */
;;;81             MID_DAC_MspInit(mDAC);
;;;82         }
;;;83         
;;;84             
;;;85         /* Change DAC peripheral state */
;;;86         mDAC->State = MID_DAC_STATE_BUSY;
;;;87     
;;;88         // ------------------------------------------------------------------------
;;;89         /* Config of DAC parameters:                                              */
;;;90         // ------------------------------------------------------------------------
;;;91         tmpREG = mDAC->Init.TriggerConverionSrc     | 
;;;92                  mDAC->Init.TriggerConverionEdge    | 
;;;93                  mDAC->Init.DataAlign               | 
;;;94                  mDAC->Init.OutputLevel;
;;;95         
;;;96         mDAC->Instance->CR0.W = tmpREG;
;;;97     
;;;98         // for MG32F02A128/U128/A064/U064 - Enable DAC buffer.
;;;99         #if defined(MG32_3RD)
;;;100            mDAC->Instance->CR0.W |= DAC_CR0_BUF0_EN_enable_w;
;;;101        #endif
;;;102        
;;;103        /* Initialize the DAC state*/
;;;104        mDAC->State = MID_DAC_STATE_READY;
;;;105    
;;;106        /* Set DAC error code to none */
;;;107        mDAC->ErrorCode = MID_DAC_ERROR_NONE;
;;;108        
;;;109        /* Return function status */
;;;110        return MID_SUCCESS;
;;;111    }
00000a  bd70              POP      {r4-r6,pc}
                  |L13.12|
00000c  7e60              LDRB     r0,[r4,#0x19]         ;75
00000e  2800              CMP      r0,#0                 ;75
000010  d103              BNE      |L13.26|
000012  7620              STRB     r0,[r4,#0x18]         ;78
000014  4620              MOV      r0,r4                 ;81
000016  f7fffffe          BL       MID_DAC_MspInit
                  |L13.26|
00001a  2011              MOVS     r0,#0x11              ;86
00001c  7660              STRB     r0,[r4,#0x19]         ;86
00001e  68a1              LDR      r1,[r4,#8]            ;91
000020  6860              LDR      r0,[r4,#4]            ;91
000022  4308              ORRS     r0,r0,r1              ;91
000024  68e1              LDR      r1,[r4,#0xc]          ;91
000026  4308              ORRS     r0,r0,r1              ;91
000028  4605              MOV      r5,r0                 ;91
00002a  6921              LDR      r1,[r4,#0x10]         ;91
00002c  430d              ORRS     r5,r5,r1              ;91
00002e  6820              LDR      r0,[r4,#0]            ;96
000030  6105              STR      r5,[r0,#0x10]         ;96
000032  2001              MOVS     r0,#1                 ;104
000034  7660              STRB     r0,[r4,#0x19]         ;104
000036  2000              MOVS     r0,#0                 ;107
000038  6220              STR      r0,[r4,#0x20]         ;107
00003a  bf00              NOP                            ;110
00003c  e7e5              B        |L13.10|
;;;112    
                          ENDP


                          AREA ||i.MID_DAC_MspDeInit||, CODE, READONLY, ALIGN=1

                  MID_DAC_MspDeInit PROC
;;;184     */
;;;185    __weak void MID_DAC_MspDeInit(DAC_HandleTypeDef* mDAC)
000000  4770              BX       lr
;;;186    {
;;;187      /* Prevent unused argument(s) compilation warning */
;;;188      UNUSED(mDAC);
;;;189      /* NOTE : This function Should not be modified, when the callback is needed,
;;;190                the MID_DAC_MspDeInit could be implemented in the user file
;;;191       */
;;;192    }
;;;193    ///@} 
                          ENDP


                          AREA ||i.MID_DAC_MspInit||, CODE, READONLY, ALIGN=1

                  MID_DAC_MspInit PROC
;;;168     */
;;;169    __weak void MID_DAC_MspInit(DAC_HandleTypeDef* mDAC)
000000  4770              BX       lr
;;;170    {
;;;171      /* Prevent unused argument(s) compilation warning */
;;;172      UNUSED(mDAC);
;;;173      /* NOTE : This function Should not be modified, when the callback is needed,
;;;174                the MID_DAC_MspInit could be implemented in the user file
;;;175       */
;;;176    }
;;;177    
                          ENDP


                          AREA ||i.MID_DAC_ReadyCallback||, CODE, READONLY, ALIGN=1

                  MID_DAC_ReadyCallback PROC
;;;600     */
;;;601    __weak void MID_DAC_ReadyCallback(DAC_HandleTypeDef* mDAC)
000000  4770              BX       lr
;;;602    {
;;;603        /* Prevent unused argument(s) compilation warning */
;;;604        UNUSED(mDAC);
;;;605        /* NOTE : This function Should not be modified, when the callback is needed,
;;;606                    the MID_DAC_TriggerCallback could be implemented in the user file
;;;607        */
;;;608    }
;;;609    
                          ENDP


                          AREA ||i.MID_DAC_SetValue||, CODE, READONLY, ALIGN=1

                  MID_DAC_SetValue PROC
;;;557     */
;;;558    MID_StatusTypeDef MID_DAC_SetValue(DAC_HandleTypeDef* mDAC, uint32_t Data)
000000  4602              MOV      r2,r0
;;;559    {
;;;560        switch(mDAC->Init.DataAlign)
000002  68d0              LDR      r0,[r2,#0xc]
000004  2800              CMP      r0,#0
000006  d006              BEQ      |L17.22|
000008  2810              CMP      r0,#0x10
00000a  d007              BEQ      |L17.28|
00000c  2840              CMP      r0,#0x40
00000e  d00a              BEQ      |L17.38|
000010  2850              CMP      r0,#0x50
000012  d111              BNE      |L17.56|
000014  e00b              B        |L17.46|
                  |L17.22|
;;;561        {    
;;;562        #if defined(MG32_3RD)
;;;563        case DAC_ALIGN_12B_R:
;;;564            mDAC->Instance->DAT0.H[0] = Data;
;;;565            break;
;;;566        #endif
;;;567        #if defined(MG32_3RD)
;;;568        case DAC_ALIGN_12B_L:
;;;569            mDAC->Instance->DAT0.H[0] = Data << 4;
;;;570            break;
;;;571        #endif
;;;572        case DAC_ALIGN_10B_R:
;;;573            mDAC->Instance->DAT0.H[0] = Data;
000016  6813              LDR      r3,[r2,#0]
000018  8419              STRH     r1,[r3,#0x20]
;;;574            break;
00001a  e00f              B        |L17.60|
                  |L17.28|
;;;575        case DAC_ALIGN_10B_L:
;;;576            mDAC->Instance->DAT0.H[0] = Data << 6;
00001c  0588              LSLS     r0,r1,#22
00001e  0c00              LSRS     r0,r0,#16
000020  6813              LDR      r3,[r2,#0]
000022  8418              STRH     r0,[r3,#0x20]
;;;577            break;
000024  e00a              B        |L17.60|
                  |L17.38|
;;;578        case DAC_ALIGN_8B_R:
;;;579            mDAC->Instance->DAT0.H[0] = Data & 0x00FF;
000026  b2c8              UXTB     r0,r1
000028  6813              LDR      r3,[r2,#0]
00002a  8418              STRH     r0,[r3,#0x20]
;;;580            break;
00002c  e006              B        |L17.60|
                  |L17.46|
;;;581        case DAC_ALIGN_8B_L:
;;;582            mDAC->Instance->DAT0.H[0] = Data << 8;
00002e  0608              LSLS     r0,r1,#24
000030  0c00              LSRS     r0,r0,#16
000032  6813              LDR      r3,[r2,#0]
000034  8418              STRH     r0,[r3,#0x20]
;;;583            break;
000036  e001              B        |L17.60|
                  |L17.56|
;;;584        default:
;;;585            return MID_FAILURE;
000038  2001              MOVS     r0,#1
                  |L17.58|
;;;586            
;;;587        }
;;;588        
;;;589        /* Return function status */
;;;590        return MID_SUCCESS;
;;;591    }
00003a  4770              BX       lr
                  |L17.60|
00003c  bf00              NOP                            ;574
00003e  2000              MOVS     r0,#0                 ;590
000040  e7fb              B        |L17.58|
;;;592    
                          ENDP


                          AREA ||i.MID_DAC_Start||, CODE, READONLY, ALIGN=1

                  MID_DAC_Start PROC
;;;212     */
;;;213    MID_StatusTypeDef MID_DAC_Start(DAC_HandleTypeDef* mDAC)
000000  4601              MOV      r1,r0
;;;214    {
;;;215        
;;;216        /* Process locked */
;;;217        __MID_LOCK(mDAC);
000002  bf00              NOP      
000004  7e08              LDRB     r0,[r1,#0x18]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L18.14|
00000a  2002              MOVS     r0,#2
                  |L18.12|
;;;218        
;;;219        /* Change DAC state */
;;;220        mDAC->State = MID_DAC_STATE_BUSY;
;;;221        
;;;222        /* Enable the DAC & output DAC */
;;;223        __DRV_DAC_ENABLE(mDAC);
;;;224    
;;;225        /* Change DAC state */
;;;226        mDAC->State = MID_DAC_STATE_READY;
;;;227        
;;;228        /* Process unlocked */
;;;229        __MID_UNLOCK(mDAC);
;;;230        
;;;231        return MID_SUCCESS;
;;;232    }
00000c  4770              BX       lr
                  |L18.14|
00000e  2001              MOVS     r0,#1                 ;217
000010  7608              STRB     r0,[r1,#0x18]         ;217
000012  bf00              NOP                            ;217
000014  2011              MOVS     r0,#0x11              ;220
000016  7648              STRB     r0,[r1,#0x19]         ;220
000018  6808              LDR      r0,[r1,#0]            ;223
00001a  6900              LDR      r0,[r0,#0x10]         ;223
00001c  2201              MOVS     r2,#1                 ;223
00001e  4310              ORRS     r0,r0,r2              ;223
000020  680a              LDR      r2,[r1,#0]            ;223
000022  6110              STR      r0,[r2,#0x10]         ;223
000024  2001              MOVS     r0,#1                 ;226
000026  7648              STRB     r0,[r1,#0x19]         ;226
000028  bf00              NOP                            ;229
00002a  2000              MOVS     r0,#0                 ;229
00002c  7608              STRB     r0,[r1,#0x18]         ;229
00002e  bf00              NOP                            ;229
000030  bf00              NOP                            ;231
000032  e7eb              B        |L18.12|
;;;233    
                          ENDP


                          AREA ||i.MID_DAC_Start_DMA||, CODE, READONLY, ALIGN=2

                  MID_DAC_Start_DMA PROC
;;;388     */
;;;389    MID_StatusTypeDef MID_DAC_Start_DMA(DAC_HandleTypeDef* mDAC, uint32_t* pData, uint32_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;390    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;391        
;;;392        /* Perform DAC enable and conversion start if no conversion is on going */
;;;393    
;;;394        /* Process locked */
;;;395        __MID_LOCK(mDAC);
000008  bf00              NOP      
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L19.20|
000010  2002              MOVS     r0,#2
                  |L19.18|
;;;396    
;;;397        /* Set the DMA Period elapsed callback */
;;;398        mDAC->DMA_Handle->XferCpltCallback  = DAC_DMAConvCplt;
;;;399    
;;;400        /* Set the DMA half transfer complete callback */
;;;401        mDAC->DMA_Handle->XferHalfCpltCallback = DAC_DMAHalfConvCplt;
;;;402    
;;;403        /* Set the DMA error callback */
;;;404        mDAC->DMA_Handle->XferErrorCallback = DAC_DMAError ;
;;;405    
;;;406        /* Clear regular group conversion flag and overrun flag */
;;;407        /* (To ensure of no unknown state from potential previous DAC           */
;;;408        /* operations)                                                          */
;;;409        __DRV_DAC_CLEAR_FLAG(mDAC, (DAC_FLAG_READY | DAC_FLAG_UNDERRUN));
;;;410    
;;;411        /* Enable DAC overrun interrupt */
;;;412        __DRV_DAC_ENABLE_IT(mDAC, DAC_IT_UNDERRUN);
;;;413    
;;;414        /* Enable the DAC Capture/Compare 0 DMA request */
;;;415        __DRV_DAC_ENABLE_DMA(mDAC);
;;;416          
;;;417        /* Start the DMA channel */
;;;418        MID_DMA_Start_IT(mDAC->DMA_Handle, (uint32_t)pData, NULL, Length);  
;;;419    
;;;420        /* Set DAC state                                                        */
;;;421        /* - Clear state bitfield related to regular group conversion results   */
;;;422        /* - Set state bitfield related to regular operation                    */
;;;423        mDAC->State = MID_DAC_STATE_READY;
;;;424    
;;;425        /* Reset DAC all error code fields */
;;;426        mDAC->ErrorCode = MID_DAC_ERROR_NONE;
;;;427        
;;;428        __DRV_DMA_START_REQUEST(mDAC->DMA_Handle->DMAChannelIndex);
;;;429        
;;;430        /* Enable the DAC & output DAC */
;;;431        __DRV_DAC_ENABLE(mDAC);
;;;432        
;;;433        /* Process unlocked */
;;;434        /* Unlock before starting DAC conversions: in case of potential         */
;;;435        /* interruption, to let the process to DAC IRQ Handler.                 */
;;;436        __MID_UNLOCK(mDAC);
;;;437        
;;;438        /* Return function status */
;;;439        return MID_SUCCESS;
;;;440    }
000012  bd70              POP      {r4-r6,pc}
                  |L19.20|
000014  2001              MOVS     r0,#1                 ;395
000016  7620              STRB     r0,[r4,#0x18]         ;395
000018  bf00              NOP                            ;395
00001a  481c              LDR      r0,|L19.140|
00001c  69e1              LDR      r1,[r4,#0x1c]         ;398
00001e  62c8              STR      r0,[r1,#0x2c]         ;398
000020  481b              LDR      r0,|L19.144|
000022  69e1              LDR      r1,[r4,#0x1c]         ;401
000024  6308              STR      r0,[r1,#0x30]         ;401
000026  481b              LDR      r0,|L19.148|
000028  69e1              LDR      r1,[r4,#0x1c]         ;404
00002a  6348              STR      r0,[r1,#0x34]         ;404
00002c  2082              MOVS     r0,#0x82              ;409
00002e  6821              LDR      r1,[r4,#0]            ;409
000030  6008              STR      r0,[r1,#0]            ;409
000032  6820              LDR      r0,[r4,#0]            ;412
000034  6840              LDR      r0,[r0,#4]            ;412
000036  2180              MOVS     r1,#0x80              ;412
000038  4308              ORRS     r0,r0,r1              ;412
00003a  6821              LDR      r1,[r4,#0]            ;412
00003c  6048              STR      r0,[r1,#4]            ;412
00003e  6820              LDR      r0,[r4,#0]            ;415
000040  6900              LDR      r0,[r0,#0x10]         ;415
000042  2101              MOVS     r1,#1                 ;415
000044  07c9              LSLS     r1,r1,#31             ;415
000046  4308              ORRS     r0,r0,r1              ;415
000048  6821              LDR      r1,[r4,#0]            ;415
00004a  6108              STR      r0,[r1,#0x10]         ;415
00004c  462b              MOV      r3,r5                 ;418
00004e  2200              MOVS     r2,#0                 ;418
000050  4631              MOV      r1,r6                 ;418
000052  69e0              LDR      r0,[r4,#0x1c]         ;418
000054  f7fffffe          BL       MID_DMA_Start_IT
000058  2001              MOVS     r0,#1                 ;423
00005a  7660              STRB     r0,[r4,#0x19]         ;423
00005c  2000              MOVS     r0,#0                 ;426
00005e  6220              STR      r0,[r4,#0x20]         ;426
000060  69e0              LDR      r0,[r4,#0x1c]         ;428
000062  6c00              LDR      r0,[r0,#0x40]         ;428
000064  6800              LDR      r0,[r0,#0]            ;428
000066  2101              MOVS     r1,#1                 ;428
000068  03c9              LSLS     r1,r1,#15             ;428
00006a  4308              ORRS     r0,r0,r1              ;428
00006c  69e1              LDR      r1,[r4,#0x1c]         ;428
00006e  6c09              LDR      r1,[r1,#0x40]         ;428
000070  6008              STR      r0,[r1,#0]            ;428
000072  6820              LDR      r0,[r4,#0]            ;431
000074  6900              LDR      r0,[r0,#0x10]         ;431
000076  2101              MOVS     r1,#1                 ;431
000078  4308              ORRS     r0,r0,r1              ;431
00007a  6821              LDR      r1,[r4,#0]            ;431
00007c  6108              STR      r0,[r1,#0x10]         ;431
00007e  bf00              NOP                            ;436
000080  2000              MOVS     r0,#0                 ;436
000082  7620              STRB     r0,[r4,#0x18]         ;436
000084  bf00              NOP                            ;436
000086  bf00              NOP                            ;439
000088  e7c3              B        |L19.18|
;;;441    
                          ENDP

00008a  0000              DCW      0x0000
                  |L19.140|
                          DCD      DAC_DMAConvCplt
                  |L19.144|
                          DCD      DAC_DMAHalfConvCplt
                  |L19.148|
                          DCD      DAC_DMAError

                          AREA ||i.MID_DAC_Start_IT||, CODE, READONLY, ALIGN=2

                  MID_DAC_Start_IT PROC
;;;278     */
;;;279    MID_StatusTypeDef MID_DAC_Start_IT(DAC_HandleTypeDef* mDAC)
000000  4601              MOV      r1,r0
;;;280    {
;;;281        
;;;282        /* Check the DAC handle allocation and lock status */
;;;283        if(mDAC == NULL)
000002  2900              CMP      r1,#0
000004  d101              BNE      |L20.10|
;;;284        {
;;;285            return MID_FAILURE;
000006  2001              MOVS     r0,#1
                  |L20.8|
;;;286        }
;;;287        else
;;;288        {
;;;289            /* Enable DAC interrupt  */
;;;290            mDAC->Instance->INT.W |= mDAC->Init.InteruptMode;
;;;291            __DRV_DAC_ENABLE_ITEA();
;;;292            
;;;293            /* Enable the DAC & output DAC */
;;;294            __DRV_DAC_ENABLE(mDAC);
;;;295        }
;;;296        
;;;297        return MID_SUCCESS;
;;;298    }
000008  4770              BX       lr
                  |L20.10|
00000a  6808              LDR      r0,[r1,#0]            ;290
00000c  6840              LDR      r0,[r0,#4]            ;290
00000e  694a              LDR      r2,[r1,#0x14]         ;290
000010  4310              ORRS     r0,r0,r2              ;290
000012  680a              LDR      r2,[r1,#0]            ;290
000014  6050              STR      r0,[r2,#4]            ;290
000016  4807              LDR      r0,|L20.52|
000018  6840              LDR      r0,[r0,#4]            ;291
00001a  2201              MOVS     r2,#1                 ;291
00001c  4310              ORRS     r0,r0,r2              ;291
00001e  4a05              LDR      r2,|L20.52|
000020  6050              STR      r0,[r2,#4]            ;291
000022  6808              LDR      r0,[r1,#0]            ;294
000024  6900              LDR      r0,[r0,#0x10]         ;294
000026  2201              MOVS     r2,#1                 ;294
000028  4310              ORRS     r0,r0,r2              ;294
00002a  680a              LDR      r2,[r1,#0]            ;294
00002c  6110              STR      r0,[r2,#0x10]         ;294
00002e  2000              MOVS     r0,#0                 ;297
000030  e7ea              B        |L20.8|
;;;299    
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      0x5c080000

                          AREA ||i.MID_DAC_Stop||, CODE, READONLY, ALIGN=1

                  MID_DAC_Stop PROC
;;;246     */
;;;247    MID_StatusTypeDef MID_DAC_Stop(DAC_HandleTypeDef* mDAC)
000000  4601              MOV      r1,r0
;;;248    {
;;;249        
;;;250        /* Process locked */
;;;251        __MID_LOCK(mDAC);
000002  bf00              NOP      
000004  7e08              LDRB     r0,[r1,#0x18]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L21.14|
00000a  2002              MOVS     r0,#2
                  |L21.12|
;;;252        
;;;253        /* Change DAC state */
;;;254        mDAC->State = MID_DAC_STATE_BUSY;
;;;255        
;;;256        /* Enable the DAC & output DAC */
;;;257        __DRV_DAC_DISABLE(mDAC);
;;;258    
;;;259        /* Change DAC state */
;;;260        mDAC->State = MID_DAC_STATE_READY;
;;;261        
;;;262        /* Process unlocked */
;;;263        __MID_UNLOCK(mDAC);
;;;264        
;;;265        return MID_SUCCESS;
;;;266    }
00000c  4770              BX       lr
                  |L21.14|
00000e  2001              MOVS     r0,#1                 ;251
000010  7608              STRB     r0,[r1,#0x18]         ;251
000012  bf00              NOP                            ;251
000014  2011              MOVS     r0,#0x11              ;254
000016  7648              STRB     r0,[r1,#0x19]         ;254
000018  6808              LDR      r0,[r1,#0]            ;257
00001a  6900              LDR      r0,[r0,#0x10]         ;257
00001c  0840              LSRS     r0,r0,#1              ;257
00001e  0040              LSLS     r0,r0,#1              ;257
000020  680a              LDR      r2,[r1,#0]            ;257
000022  6110              STR      r0,[r2,#0x10]         ;257
000024  2001              MOVS     r0,#1                 ;260
000026  7648              STRB     r0,[r1,#0x19]         ;260
000028  bf00              NOP                            ;263
00002a  2000              MOVS     r0,#0                 ;263
00002c  7608              STRB     r0,[r1,#0x18]         ;263
00002e  bf00              NOP                            ;263
000030  bf00              NOP                            ;265
000032  e7eb              B        |L21.12|
;;;267    
                          ENDP


                          AREA ||i.MID_DAC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  MID_DAC_Stop_DMA PROC
;;;455     */
;;;456    MID_StatusTypeDef MID_DAC_Stop_DMA(DAC_HandleTypeDef* mDAC)
000000  b510              PUSH     {r4,lr}
;;;457    {
000002  4604              MOV      r4,r0
;;;458    
;;;459        /* Process locked */
;;;460        __MID_LOCK(mDAC);
000004  bf00              NOP      
000006  7e20              LDRB     r0,[r4,#0x18]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L22.16|
00000c  2002              MOVS     r0,#2
                  |L22.14|
;;;461        
;;;462        /* Disable the selected DAC & DMA request */
;;;463        __DRV_DAC_DISABLE_DMA(mDAC);
;;;464        
;;;465         /* Disable the Peripheral */
;;;466        __DRV_DAC_DISABLE(mDAC);  
;;;467    
;;;468        /* Disable the DMA channel */
;;;469        MID_DMA_Abort(mDAC->DMA_Handle);
;;;470        
;;;471        /* Enable DAC overrun interrupt */
;;;472        __DRV_DAC_DISABLE_IT(mDAC, DAC_IT_UNDERRUN);
;;;473    
;;;474        /* Change DAC state */
;;;475        mDAC->State = MID_DAC_STATE_READY;
;;;476        
;;;477        /* Process unlocked */
;;;478        __MID_UNLOCK(mDAC);
;;;479    
;;;480        /* Return function status */
;;;481        return MID_SUCCESS;
;;;482    }
00000e  bd10              POP      {r4,pc}
                  |L22.16|
000010  2001              MOVS     r0,#1                 ;460
000012  7620              STRB     r0,[r4,#0x18]         ;460
000014  bf00              NOP                            ;460
000016  6820              LDR      r0,[r4,#0]            ;463
000018  6900              LDR      r0,[r0,#0x10]         ;463
00001a  0040              LSLS     r0,r0,#1              ;463
00001c  0840              LSRS     r0,r0,#1              ;463
00001e  6821              LDR      r1,[r4,#0]            ;463
000020  6108              STR      r0,[r1,#0x10]         ;463
000022  6820              LDR      r0,[r4,#0]            ;466
000024  6900              LDR      r0,[r0,#0x10]         ;466
000026  0840              LSRS     r0,r0,#1              ;466
000028  0040              LSLS     r0,r0,#1              ;466
00002a  6821              LDR      r1,[r4,#0]            ;466
00002c  6108              STR      r0,[r1,#0x10]         ;466
00002e  69e0              LDR      r0,[r4,#0x1c]         ;469
000030  f7fffffe          BL       MID_DMA_Abort
000034  6820              LDR      r0,[r4,#0]            ;472
000036  6840              LDR      r0,[r0,#4]            ;472
000038  2180              MOVS     r1,#0x80              ;472
00003a  4388              BICS     r0,r0,r1              ;472
00003c  6821              LDR      r1,[r4,#0]            ;472
00003e  6048              STR      r0,[r1,#4]            ;472
000040  2001              MOVS     r0,#1                 ;475
000042  7660              STRB     r0,[r4,#0x19]         ;475
000044  bf00              NOP                            ;478
000046  2000              MOVS     r0,#0                 ;478
000048  7620              STRB     r0,[r4,#0x18]         ;478
00004a  bf00              NOP                            ;478
00004c  bf00              NOP                            ;481
00004e  e7de              B        |L22.14|
;;;483    ///@} 
                          ENDP


                          AREA ||i.MID_DAC_Stop_IT||, CODE, READONLY, ALIGN=2

                  MID_DAC_Stop_IT PROC
;;;314     */
;;;315    MID_StatusTypeDef MID_DAC_Stop_IT(DAC_HandleTypeDef* mDAC)
000000  4601              MOV      r1,r0
;;;316    {
;;;317    
;;;318        /* Process locked */
;;;319        __MID_LOCK(mDAC);
000002  bf00              NOP      
000004  7e08              LDRB     r0,[r1,#0x18]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L23.14|
00000a  2002              MOVS     r0,#2
                  |L23.12|
;;;320    
;;;321        /* 1. Stop potential conversion on going, on regular group */
;;;322        if(mDAC->State == MID_DAC_STATE_READY)
;;;323        {
;;;324            mDAC->Instance->INT.W &= ~mDAC->Init.InteruptMode;
;;;325        }
;;;326        else
;;;327        {
;;;328            return MID_FAILURE;
;;;329        }
;;;330        
;;;331    
;;;332        // disable ITEA
;;;333        if((mDAC->Instance->INT.W & (0xFFFFFFFE)) == 0x00000000U)
;;;334        {
;;;335            __DRV_DAC_DISABLE_ITEA();
;;;336            /* Enable the DAC & output DAC */
;;;337            __DRV_DAC_DISABLE(mDAC);
;;;338        }
;;;339    
;;;340        /* Process unlocked */
;;;341        __MID_UNLOCK(mDAC);
;;;342    
;;;343        /* Return function status */
;;;344        return MID_SUCCESS;
;;;345    }
00000c  4770              BX       lr
                  |L23.14|
00000e  2001              MOVS     r0,#1                 ;319
000010  7608              STRB     r0,[r1,#0x18]         ;319
000012  bf00              NOP                            ;319
000014  7e48              LDRB     r0,[r1,#0x19]         ;322
000016  2801              CMP      r0,#1                 ;322
000018  d106              BNE      |L23.40|
00001a  6808              LDR      r0,[r1,#0]            ;324
00001c  6840              LDR      r0,[r0,#4]            ;324
00001e  694a              LDR      r2,[r1,#0x14]         ;324
000020  4390              BICS     r0,r0,r2              ;324
000022  680a              LDR      r2,[r1,#0]            ;324
000024  6050              STR      r0,[r2,#4]            ;324
000026  e001              B        |L23.44|
                  |L23.40|
000028  2001              MOVS     r0,#1                 ;328
00002a  e7ef              B        |L23.12|
                  |L23.44|
00002c  6808              LDR      r0,[r1,#0]            ;333
00002e  6840              LDR      r0,[r0,#4]            ;333
000030  0840              LSRS     r0,r0,#1              ;333
000032  0040              LSLS     r0,r0,#1              ;333
000034  2800              CMP      r0,#0                 ;333
000036  d10b              BNE      |L23.80|
000038  4808              LDR      r0,|L23.92|
00003a  6840              LDR      r0,[r0,#4]            ;335
00003c  0840              LSRS     r0,r0,#1              ;335
00003e  0040              LSLS     r0,r0,#1              ;335
000040  4a06              LDR      r2,|L23.92|
000042  6050              STR      r0,[r2,#4]            ;335
000044  6808              LDR      r0,[r1,#0]            ;337
000046  6900              LDR      r0,[r0,#0x10]         ;337
000048  0840              LSRS     r0,r0,#1              ;337
00004a  0040              LSLS     r0,r0,#1              ;337
00004c  680a              LDR      r2,[r1,#0]            ;337
00004e  6110              STR      r0,[r2,#0x10]         ;337
                  |L23.80|
000050  bf00              NOP                            ;341
000052  2000              MOVS     r0,#0                 ;341
000054  7608              STRB     r0,[r1,#0x18]         ;341
000056  bf00              NOP                            ;341
000058  bf00              NOP                            ;344
00005a  e7d7              B        |L23.12|
;;;346    
                          ENDP

                  |L23.92|
                          DCD      0x5c080000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Middleware\\Source\\MG32x02z_DAC_MID.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_DAC_MID_c_79807832____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_DAC_MID_c_79807832____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_DAC_MID_c_79807832____REVSH|
#line 496
|__asm___18_MG32x02z_DAC_MID_c_79807832____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
