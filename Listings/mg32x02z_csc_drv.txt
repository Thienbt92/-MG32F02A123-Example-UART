; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_csc_drv.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_csc_drv.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_csc_drv.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Source\MG32x02z_CSC_DRV.c]
                          THUMB

                          AREA ||i.CSC_CK_AHB_Divider_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_AHB_Divider_Select PROC
;;;520     */
;;;521    void CSC_CK_AHB_Divider_Select (CSC_AHB_DIV_TypeDef CSC_CK_AHB_DIVS)		
000000  4601              MOV      r1,r0
;;;522    {
;;;523        uint8_t   Reg;
;;;524        
;;;525        Reg = CSC->DIV.B[1];
000002  4a05              LDR      r2,|L1.24|
000004  7d50              LDRB     r0,[r2,#0x15]
;;;526        Reg &= ~CSC_DIV_AHB_DIV_mask_b1;
000006  0900              LSRS     r0,r0,#4
000008  0100              LSLS     r0,r0,#4
;;;527        Reg |= CSC_CK_AHB_DIVS;
00000a  4602              MOV      r2,r0
00000c  430a              ORRS     r2,r2,r1
00000e  4610              MOV      r0,r2
;;;528        CSC->DIV.B[1] = Reg;
000010  4a01              LDR      r2,|L1.24|
000012  7550              STRB     r0,[r2,#0x15]
;;;529    }
000014  4770              BX       lr
;;;530    ///@}
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_CK_APB_Divider_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_APB_Divider_Select PROC
;;;460     */
;;;461    void CSC_CK_APB_Divider_Select (CSC_APB_DIV_TypeDef CSC_CK_APB_DIVS)
000000  4601              MOV      r1,r0
;;;462    {   
;;;463        uint8_t   Reg;
;;;464        
;;;465        Reg = CSC->DIV.B[2];
000002  4a05              LDR      r2,|L2.24|
000004  7d90              LDRB     r0,[r2,#0x16]
;;;466        Reg &= ~CSC_DIV_APB_DIV_mask_b2;
000006  08c0              LSRS     r0,r0,#3
000008  00c0              LSLS     r0,r0,#3
;;;467        Reg |= CSC_CK_APB_DIVS;
00000a  4602              MOV      r2,r0
00000c  430a              ORRS     r2,r2,r1
00000e  4610              MOV      r0,r2
;;;468        CSC->DIV.B[2] = Reg;
000010  4a01              LDR      r2,|L2.24|
000012  7590              STRB     r0,[r2,#0x16]
;;;469    }
000014  4770              BX       lr
;;;470    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_CK_HS_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_HS_Select PROC
;;;226     */
;;;227    void CSC_CK_HS_Select (CSC_HS_SEL_TypeDef CSC_CK_HS_SEL)
000000  4601              MOV      r1,r0
;;;228    {
;;;229        uint8_t   Reg;
;;;230        
;;;231        Reg = CSC->CR0.B[1];
000002  4a06              LDR      r2,|L3.28|
000004  7c50              LDRB     r0,[r2,#0x11]
;;;232        Reg &= ~CSC_CR0_HS_SEL_mask_b1;
000006  230c              MOVS     r3,#0xc
000008  4602              MOV      r2,r0
00000a  439a              BICS     r2,r2,r3
00000c  4610              MOV      r0,r2
;;;233        Reg |= CSC_CK_HS_SEL;
00000e  4602              MOV      r2,r0
000010  430a              ORRS     r2,r2,r1
000012  4610              MOV      r0,r2
;;;234        CSC->CR0.B[1] = Reg;
000014  4a01              LDR      r2,|L3.28|
000016  7450              STRB     r0,[r2,#0x11]
;;;235    }
000018  4770              BX       lr
;;;236    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x4c010000

                          AREA ||i.CSC_CK_LS_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_LS_Select PROC
;;;252     */
;;;253    void CSC_CK_LS_Select (CSC_LS_SEL_TypeDef CSC_CK_LS_SEL)
000000  4601              MOV      r1,r0
;;;254    {
;;;255        uint8_t   Reg;
;;;256        
;;;257        Reg = CSC->CR0.B[1];
000002  4a05              LDR      r2,|L4.24|
000004  7c50              LDRB     r0,[r2,#0x11]
;;;258        Reg &= ~CSC_CR0_LS_SEL_mask_b1;
000006  0880              LSRS     r0,r0,#2
000008  0080              LSLS     r0,r0,#2
;;;259        Reg |= CSC_CK_LS_SEL;
00000a  4602              MOV      r2,r0
00000c  430a              ORRS     r2,r2,r1
00000e  4610              MOV      r0,r2
;;;260        CSC->CR0.B[1] = Reg;   
000010  4a01              LDR      r2,|L4.24|
000012  7450              STRB     r0,[r2,#0x11]
;;;261    }   
000014  4770              BX       lr
;;;262    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_CK_MAIN_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_MAIN_Select PROC
;;;199     */
;;;200    void CSC_CK_MAIN_Select (CSC_MAIN_SEL_TypeDef CSC_CK_MAIN_SEL)
000000  4601              MOV      r1,r0
;;;201    {
;;;202        uint8_t   Reg;
;;;203        
;;;204        Reg = CSC->CR0.B[1];
000002  4a06              LDR      r2,|L5.28|
000004  7c50              LDRB     r0,[r2,#0x11]
;;;205        Reg &= ~CSC_CR0_MAIN_SEL_mask_b1;
000006  23c0              MOVS     r3,#0xc0
000008  4602              MOV      r2,r0
00000a  439a              BICS     r2,r2,r3
00000c  4610              MOV      r0,r2
;;;206        Reg |= CSC_CK_MAIN_SEL;
00000e  4602              MOV      r2,r0
000010  430a              ORRS     r2,r2,r1
000012  4610              MOV      r0,r2
;;;207        CSC->CR0.B[1] = Reg;  
000014  4a01              LDR      r2,|L5.28|
000016  7450              STRB     r0,[r2,#0x11]
;;;208    }    
000018  4770              BX       lr
;;;209    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x4c010000

                          AREA ||i.CSC_CK_ST_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_ST_Select PROC
;;;173     */
;;;174    void CSC_CK_ST_Select (CSC_ST_SEL_TypeDef CSC_CK_ST_SEL)
000000  4601              MOV      r1,r0
;;;175    {
;;;176        uint8_t   Reg;
;;;177        
;;;178        Reg = CSC->CR0.B[2];
000002  4a05              LDR      r2,|L6.24|
000004  7c90              LDRB     r0,[r2,#0x12]
;;;179        Reg &= ~CSC_CR0_ST_SEL_mask_b2;
000006  0840              LSRS     r0,r0,#1
000008  0040              LSLS     r0,r0,#1
;;;180        Reg |= CSC_CK_ST_SEL;
00000a  4602              MOV      r2,r0
00000c  430a              ORRS     r2,r2,r1
00000e  4610              MOV      r0,r2
;;;181        CSC->CR0.B[2] = Reg;
000010  4a01              LDR      r2,|L6.24|
000012  7490              STRB     r0,[r2,#0x12]
;;;182    }
000014  4770              BX       lr
;;;183    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_CK_UT_Divider_Select||, CODE, READONLY, ALIGN=2

                  CSC_CK_UT_Divider_Select PROC
;;;487     */
;;;488    void CSC_CK_UT_Divider_Select (CSC_UT_DIV_TypeDef CSC_CK_UT_DIVS)	
000000  4601              MOV      r1,r0
;;;489    {
;;;490        uint8_t   Reg;
;;;491        
;;;492        Reg = CSC->DIV.B[3];
000002  4a06              LDR      r2,|L7.28|
000004  7dd0              LDRB     r0,[r2,#0x17]
;;;493        Reg &= ~CSC_DIV_UT_DIV_mask_b3;
000006  230c              MOVS     r3,#0xc
000008  4602              MOV      r2,r0
00000a  439a              BICS     r2,r2,r3
00000c  4610              MOV      r0,r2
;;;494        Reg |= CSC_CK_UT_DIVS;
00000e  4602              MOV      r2,r0
000010  430a              ORRS     r2,r2,r1
000012  4610              MOV      r0,r2
;;;495        CSC->DIV.B[3] = Reg;
000014  4a01              LDR      r2,|L7.28|
000016  75d0              STRB     r0,[r2,#0x17]
;;;496    }
000018  4770              BX       lr
;;;497    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x4c010000

                          AREA ||i.CSC_ClearFlag||, CODE, READONLY, ALIGN=2

                  CSC_ClearFlag PROC
;;;1240    */
;;;1241   void CSC_ClearFlag (uint32_t CSC_ITSrc)
000000  4901              LDR      r1,|L8.8|
;;;1242   {
;;;1243       CSC->STA.W = CSC_ITSrc;
000002  6008              STR      r0,[r1,#0]
;;;1244   }
000004  4770              BX       lr
;;;1245   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x4c010000

                          AREA ||i.CSC_GetAllFlagStatus||, CODE, READONLY, ALIGN=2

                  CSC_GetAllFlagStatus PROC
;;;1008    */
;;;1009   uint32_t CSC_GetAllFlagStatus (void)
000000  4801              LDR      r0,|L9.8|
;;;1010   {
;;;1011       return CSC->STA.W;
000002  6800              LDR      r0,[r0,#0]
;;;1012   }
000004  4770              BX       lr
;;;1013   
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      0x4c010000

                          AREA ||i.CSC_GetSingleFlagStatus||, CODE, READONLY, ALIGN=2

                  CSC_GetSingleFlagStatus PROC
;;;1206    */
;;;1207   DRV_Return CSC_GetSingleFlagStatus (uint32_t CSC_ITSrc)
000000  4601              MOV      r1,r0
;;;1208   {
;;;1209       DRV_Return bitstatus = DRV_Normal;
000002  2000              MOVS     r0,#0
;;;1210       
;;;1211       if ((CSC->STA.W & CSC_ITSrc) != (uint32_t)DISABLE)
000004  4a04              LDR      r2,|L10.24|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  2a00              CMP      r2,#0
00000c  d001              BEQ      |L10.18|
;;;1212       {
;;;1213           bitstatus = DRV_Happened;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L10.20|
                  |L10.18|
;;;1214       }
;;;1215       else
;;;1216       {
;;;1217           bitstatus = DRV_Normal;
000012  2000              MOVS     r0,#0
                  |L10.20|
;;;1218       }
;;;1219       return  bitstatus;
;;;1220   }
000014  4770              BX       lr
;;;1221   
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_ICKO_ClockSource_Select||, CODE, READONLY, ALIGN=2

                  CSC_ICKO_ClockSource_Select PROC
;;;557     */
;;;558    void CSC_ICKO_ClockSource_Select (CSC_CKO_SEL_TypeDef ICKO_CKS_SEL)
000000  4601              MOV      r1,r0
;;;559    {
;;;560        uint8_t   Reg;
;;;561        
;;;562        Reg = CSC->CKO.B[0];
000002  4a06              LDR      r2,|L11.28|
000004  7e10              LDRB     r0,[r2,#0x18]
;;;563        Reg &= ~CSC_CKO_CKO_SEL_mask_b0;
000006  2370              MOVS     r3,#0x70
000008  4602              MOV      r2,r0
00000a  439a              BICS     r2,r2,r3
00000c  4610              MOV      r0,r2
;;;564        Reg |= ICKO_CKS_SEL;
00000e  4602              MOV      r2,r0
000010  430a              ORRS     r2,r2,r1
000012  4610              MOV      r0,r2
;;;565        CSC->CKO.B[0] = Reg;
000014  4a01              LDR      r2,|L11.28|
000016  7610              STRB     r0,[r2,#0x18]
;;;566    }
000018  4770              BX       lr
;;;567    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x4c010000

                          AREA ||i.CSC_ICKO_Cmd||, CODE, READONLY, ALIGN=2

                  CSC_ICKO_Cmd PROC
;;;609     */
;;;610    void CSC_ICKO_Cmd (FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;611    {
;;;612        if(NewState != DISABLE)
000002  d007              BEQ      |L12.20|
;;;613        {
;;;614            CSC->CKO.MBIT.CKO_EN = SET;
000004  4907              LDR      r1,|L12.36|
000006  7e09              LDRB     r1,[r1,#0x18]
000008  0849              LSRS     r1,r1,#1
00000a  0049              LSLS     r1,r1,#1
00000c  1c49              ADDS     r1,r1,#1
00000e  4a05              LDR      r2,|L12.36|
000010  7611              STRB     r1,[r2,#0x18]
000012  e005              B        |L12.32|
                  |L12.20|
;;;615        }
;;;616        else
;;;617        {
;;;618            CSC->CKO.MBIT.CKO_EN = CLR;
000014  4903              LDR      r1,|L12.36|
000016  7e09              LDRB     r1,[r1,#0x18]
000018  0849              LSRS     r1,r1,#1
00001a  0049              LSLS     r1,r1,#1
00001c  4a01              LDR      r2,|L12.36|
00001e  7611              STRB     r1,[r2,#0x18]
                  |L12.32|
;;;619        }
;;;620    }
000020  4770              BX       lr
;;;621    ///@}
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      0x4c010000

                          AREA ||i.CSC_ICKO_Divider_Select||, CODE, READONLY, ALIGN=2

                  CSC_ICKO_Divider_Select PROC
;;;584     */
;;;585    void CSC_ICKO_Divider_Select (CSC_CKO_DIV_TypeDef CSC_ICKO_DIVS)
000000  4601              MOV      r1,r0
;;;586    {
;;;587        uint8_t   Reg;
;;;588        
;;;589        Reg = CSC->CKO.B[0];
000002  4a06              LDR      r2,|L13.28|
000004  7e10              LDRB     r0,[r2,#0x18]
;;;590        Reg &= ~CSC_CKO_CKO_DIV_mask_b0;
000006  230c              MOVS     r3,#0xc
000008  4602              MOV      r2,r0
00000a  439a              BICS     r2,r2,r3
00000c  4610              MOV      r0,r2
;;;591        Reg |= CSC_ICKO_DIVS;
00000e  4602              MOV      r2,r0
000010  430a              ORRS     r2,r2,r1
000012  4610              MOV      r0,r2
;;;592        CSC->CKO.B[0] = Reg;
000014  4a01              LDR      r2,|L13.28|
000016  7610              STRB     r0,[r2,#0x18]
;;;593    }
000018  4770              BX       lr
;;;594    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x4c010000

                          AREA ||i.CSC_IHRCO_Cmd||, CODE, READONLY, ALIGN=2

                  CSC_IHRCO_Cmd PROC
;;;52      */
;;;53     void CSC_IHRCO_Cmd (FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;54     {
;;;55         uint8_t   Reg;
;;;56         
;;;57         Reg = CSC->CR0.B[0];
000002  4a07              LDR      r2,|L14.32|
000004  7c10              LDRB     r0,[r2,#0x10]
;;;58         
;;;59         if(NewState != DISABLE)
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L14.16|
;;;60         {
;;;61             Reg |= CSC_CR0_IHRCO_EN_mask_b0;
00000a  2208              MOVS     r2,#8
00000c  4310              ORRS     r0,r0,r2
00000e  e003              B        |L14.24|
                  |L14.16|
;;;62         }
;;;63         else
;;;64         {
;;;65             Reg &= ~CSC_CR0_IHRCO_EN_mask_b0;
000010  2308              MOVS     r3,#8
000012  4602              MOV      r2,r0
000014  439a              BICS     r2,r2,r3
000016  4610              MOV      r0,r2
                  |L14.24|
;;;66         }
;;;67         
;;;68         CSC->CR0.B[0] = Reg;
000018  4a01              LDR      r2,|L14.32|
00001a  7410              STRB     r0,[r2,#0x10]
;;;69     }
00001c  4770              BX       lr
;;;70     
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x4c010000

                          AREA ||i.CSC_IHRCO_Select||, CODE, READONLY, ALIGN=2

                  CSC_IHRCO_Select PROC
;;;85      */
;;;86     void CSC_IHRCO_Select (CSC_IHRCO_TypeDef Freq)
000000  4601              MOV      r1,r0
;;;87     {
;;;88         uint8_t   Reg;
;;;89         
;;;90         Reg = CSC->CR0.B[2];
000002  4a07              LDR      r2,|L15.32|
000004  7c90              LDRB     r0,[r2,#0x12]
;;;91         
;;;92         if(Freq != IHRCO_12MHz)
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L15.16|
;;;93         {
;;;94             Reg |= CSC_CR0_IHRCO_SEL_mask_b2;
00000a  2204              MOVS     r2,#4
00000c  4310              ORRS     r0,r0,r2
00000e  e003              B        |L15.24|
                  |L15.16|
;;;95         }
;;;96         else
;;;97         {
;;;98             Reg &= ~CSC_CR0_IHRCO_SEL_mask_b2;
000010  2304              MOVS     r3,#4
000012  4602              MOV      r2,r0
000014  439a              BICS     r2,r2,r3
000016  4610              MOV      r0,r2
                  |L15.24|
;;;99         }
;;;100        
;;;101        CSC->CR0.B[2] = Reg;
000018  4a01              LDR      r2,|L15.32|
00001a  7490              STRB     r0,[r2,#0x12]
;;;102    }	
00001c  4770              BX       lr
;;;103    
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
                          DCD      0x4c010000

                          AREA ||i.CSC_ITEA_Cmd||, CODE, READONLY, ALIGN=2

                  CSC_ITEA_Cmd PROC
;;;1298    */
;;;1299   void CSC_ITEA_Cmd (FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;1300   {
;;;1301       if(NewState != DISABLE)
000002  d007              BEQ      |L16.20|
;;;1302       {
;;;1303           CSC->INT.MBIT.IEA = SET;
000004  4907              LDR      r1,|L16.36|
000006  7909              LDRB     r1,[r1,#4]
000008  0849              LSRS     r1,r1,#1
00000a  0049              LSLS     r1,r1,#1
00000c  1c49              ADDS     r1,r1,#1
00000e  4a05              LDR      r2,|L16.36|
000010  7111              STRB     r1,[r2,#4]
000012  e005              B        |L16.32|
                  |L16.20|
;;;1304       }
;;;1305       else
;;;1306       {
;;;1307           CSC->INT.MBIT.IEA = CLR;
000014  4903              LDR      r1,|L16.36|
000016  7909              LDRB     r1,[r1,#4]
000018  0849              LSRS     r1,r1,#1
00001a  0049              LSLS     r1,r1,#1
00001c  4a01              LDR      r2,|L16.36|
00001e  7111              STRB     r1,[r2,#4]
                  |L16.32|
;;;1308       }
;;;1309   }
000020  4770              BX       lr
;;;1310   ///@}
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      0x4c010000

                          AREA ||i.CSC_IT_Config||, CODE, READONLY, ALIGN=2

                  CSC_IT_Config PROC
;;;1266    */
;;;1267   void CSC_IT_Config (uint32_t CSC_ITSrc, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;1268   {
;;;1269       uint32_t  Reg;
;;;1270       
;;;1271       Reg = CSC->INT.W;
000002  4b07              LDR      r3,|L17.32|
000004  6859              LDR      r1,[r3,#4]
;;;1272       
;;;1273       if(NewState != DISABLE)
000006  2a00              CMP      r2,#0
000008  d003              BEQ      |L17.18|
;;;1274       {
;;;1275           Reg |= CSC_ITSrc;
00000a  460b              MOV      r3,r1
00000c  4303              ORRS     r3,r3,r0
00000e  4619              MOV      r1,r3
000010  e002              B        |L17.24|
                  |L17.18|
;;;1276       }
;;;1277       else
;;;1278       {
;;;1279           Reg &= ~CSC_ITSrc;
000012  460b              MOV      r3,r1
000014  4383              BICS     r3,r3,r0
000016  4619              MOV      r1,r3
                  |L17.24|
;;;1280       }
;;;1281       CSC->INT.W = Reg;
000018  4b01              LDR      r3,|L17.32|
00001a  6059              STR      r1,[r3,#4]
;;;1282   }
00001c  4770              BX       lr
;;;1283   
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      0x4c010000

                          AREA ||i.CSC_MissingClockDetectionDuration_Select||, CODE, READONLY, ALIGN=2

                  CSC_MissingClockDetectionDuration_Select PROC
;;;645     */
;;;646    void CSC_MissingClockDetectionDuration_Select (CSC_MCD_SEL_TypeDef CSC_MCDDuration)
000000  4601              MOV      r1,r0
;;;647    {
;;;648        uint8_t   Reg;
;;;649        
;;;650        Reg = CSC->CR0.B[2];
000002  4a05              LDR      r2,|L18.24|
000004  7c90              LDRB     r0,[r2,#0x12]
;;;651        Reg &= 0x3F;
000006  0680              LSLS     r0,r0,#26
000008  0e80              LSRS     r0,r0,#26
;;;652        Reg |= CSC_MCDDuration;
00000a  4602              MOV      r2,r0
00000c  430a              ORRS     r2,r2,r1
00000e  4610              MOV      r0,r2
;;;653        CSC->CR0.B[2] = Reg;
000010  4a01              LDR      r2,|L18.24|
000012  7490              STRB     r0,[r2,#0x12]
;;;654    }
000014  4770              BX       lr
;;;655    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_MissingClockDetection_Cmd||, CODE, READONLY, ALIGN=2

                  CSC_MissingClockDetection_Cmd PROC
;;;670     */
;;;671    void CSC_MissingClockDetection_Cmd (FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;672    {
;;;673        uint8_t   Reg;
;;;674        
;;;675        Reg = CSC->CR0.B[0];
000002  4a07              LDR      r2,|L19.32|
000004  7c10              LDRB     r0,[r2,#0x10]
;;;676        
;;;677        if(NewState != DISABLE)
000006  2900              CMP      r1,#0
000008  d004              BEQ      |L19.20|
;;;678        {
;;;679            Reg &= ~CSC_CR0_MCD_DIS_mask_b0;
00000a  2310              MOVS     r3,#0x10
00000c  4602              MOV      r2,r0
00000e  439a              BICS     r2,r2,r3
000010  4610              MOV      r0,r2
000012  e001              B        |L19.24|
                  |L19.20|
;;;680        }
;;;681        else
;;;682        {
;;;683            Reg |= CSC_CR0_MCD_DIS_mask_b0;
000014  2210              MOVS     r2,#0x10
000016  4310              ORRS     r0,r0,r2
                  |L19.24|
;;;684        }
;;;685        
;;;686        CSC->CR0.B[0] = Reg;
000018  4a01              LDR      r2,|L19.32|
00001a  7410              STRB     r0,[r2,#0x10]
;;;687    }
00001c  4770              BX       lr
;;;688    ///@}
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      0x4c010000

                          AREA ||i.CSC_PLL_Cmd||, CODE, READONLY, ALIGN=2

                  CSC_PLL_Cmd PROC
;;;423     */
;;;424    void CSC_PLL_Cmd (FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;425    {
;;;426        if(NewState != DISABLE)
000002  d006              BEQ      |L20.18|
;;;427        {
;;;428            CSC->CR0.B[0] |= CSC_CR0_PLL_EN_mask_b0;
000004  4906              LDR      r1,|L20.32|
000006  7c09              LDRB     r1,[r1,#0x10]
000008  2220              MOVS     r2,#0x20
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L20.32|
00000e  7411              STRB     r1,[r2,#0x10]
000010  e005              B        |L20.30|
                  |L20.18|
;;;429        }
;;;430        else
;;;431        {
;;;432            CSC->CR0.B[0] &= ~CSC_CR0_PLL_EN_mask_b0;
000012  4903              LDR      r1,|L20.32|
000014  7c09              LDRB     r1,[r1,#0x10]
000016  2220              MOVS     r2,#0x20
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L20.32|
00001c  7411              STRB     r1,[r2,#0x10]
                  |L20.30|
;;;433        }
;;;434    }
00001e  4770              BX       lr
;;;435    ///@}
                          ENDP

                  |L20.32|
                          DCD      0x4c010000

                          AREA ||i.CSC_PLL_Config||, CODE, READONLY, ALIGN=2

                  CSC_PLL_Config PROC
;;;347     */
;;;348    void CSC_PLL_Config (CSC_PLL_TypeDef* CSC_PLL_CFG)
000000  4601              MOV      r1,r0
;;;349    {
;;;350        uint16_t   Reg;
;;;351    
;;;352    #if defined(MG32_1ST) || defined(MG32_2ND)
;;;353        Reg = CSC->PLL.H[0];                    // PLL MUL config
000002  4a0b              LDR      r2,|L21.48|
000004  8910              LDRH     r0,[r2,#8]
;;;354        Reg &= ~CSC_PLL_PLL_MUL_mask_h0;
000006  23ff              MOVS     r3,#0xff
000008  3301              ADDS     r3,#1
00000a  4602              MOV      r2,r0
00000c  439a              BICS     r2,r2,r3
00000e  4610              MOV      r0,r2
;;;355        Reg |= CSC_PLL_CFG->Multiplication;
000010  884a              LDRH     r2,[r1,#2]
000012  4310              ORRS     r0,r0,r2
;;;356        CSC->PLL.H[0] = Reg;
000014  4a06              LDR      r2,|L21.48|
000016  8110              STRH     r0,[r2,#8]
;;;357        
;;;358        Reg = CSC->DIV.B[0];    // PLL0 DIV and PLL1 DIV config
000018  7d10              LDRB     r0,[r2,#0x14]
;;;359        Reg &= ~(CSC_DIV_PLLO_DIV_mask_b0 | 
00001a  2333              MOVS     r3,#0x33
00001c  4602              MOV      r2,r0
00001e  439a              BICS     r2,r2,r3
000020  4610              MOV      r0,r2
;;;360                 CSC_DIV_PLLI_DIV_mask_b0); 
;;;361        
;;;362        Reg |= (CSC_PLL_CFG->InputDivider | 
000022  780a              LDRB     r2,[r1,#0]
000024  790b              LDRB     r3,[r1,#4]
000026  431a              ORRS     r2,r2,r3
000028  4310              ORRS     r0,r0,r2
;;;363                CSC_PLL_CFG->OutputDivider);
;;;364        
;;;365        CSC->DIV.B[0] = Reg;
00002a  4a01              LDR      r2,|L21.48|
00002c  7510              STRB     r0,[r2,#0x14]
;;;366    #endif
;;;367        
;;;368    #if defined(MG32_3RD)
;;;369        // PLL MUL config
;;;370        Reg = CSC->PLL.H[0];    
;;;371        Reg &= ~(CSC_PLL_PLL_MULX_mask_h0 |
;;;372                 CSC_PLL_PLL_MUL_mask_h0 |
;;;373                 CSC_PLL_PLL_VCOS_mask_h0 |
;;;374                 CSC_PLL_PLL_LDEN_mask_h0 |
;;;375                 CSC_PLL_PLLI_SEL_mask_h0 |
;;;376                 CSC_PLL_PLL_MDS_mask_h0
;;;377                );
;;;378        Reg |= (CSC_PLL_CFG->Multiplication | 
;;;379                CSC_PLL_PLL_VCOS_low_h0 |
;;;380                CSC_PLL_PLL_LDEN_disable_h0 |
;;;381                CSC_PLL_CFG->PLLInputClockSelect | 
;;;382                CSC_PLL_PLL_MDS_mulx_h0
;;;383               );
;;;384        CSC->PLL.H[0] = Reg;
;;;385        
;;;386        // When PLLI select CK_HS
;;;387        if(CSC_PLL_CFG->PLLInputClockSelect == PLLI_SEL_HS)
;;;388        {
;;;389            while((CSC->STA.B[1] & CSC_STA_PLLI_STA_ck_hs_b1) == 0);
;;;390        }
;;;391        // When PLLI select CK_HS2
;;;392        else
;;;393        {
;;;394            while((CSC->STA.B[1] & CSC_STA_PLLI_STA_ck_hs2_b1) == 0);
;;;395        }
;;;396        
;;;397        // PLL0 DIV and PLL1 DIV config
;;;398        Reg = CSC->DIV.B[0];    
;;;399        Reg &= ~(CSC_DIV_PLLO_DIV_mask_b0 | 
;;;400                 CSC_DIV_PLLI_DIV_mask_b0
;;;401                ); 
;;;402        Reg |= (CSC_PLL_CFG->InputDivider | 
;;;403                CSC_PLL_CFG->OutputDivider);
;;;404        CSC->DIV.B[0] = Reg;
;;;405    #endif
;;;406    }
00002e  4770              BX       lr
;;;407    
                          ENDP

                  |L21.48|
                          DCD      0x4c010000

                          AREA ||i.CSC_PeriphONModeClock_Config||, CODE, READONLY, ALIGN=2

                  CSC_PeriphONModeClock_Config PROC
;;;832     */
;;;833    void CSC_PeriphONModeClock_Config (CSC_PeriphOnMode_TypeDef CSC_Periph, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;834    {
000002  460a              MOV      r2,r1
;;;835        uint32_t  Reg;
;;;836    
;;;837        if(CSC_Periph < 32)                         // AHB Periph config
000004  2820              CMP      r0,#0x20
000006  da0e              BGE      |L22.38|
;;;838        {
;;;839            Reg = (0x00000001 <<  CSC_Periph);
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
;;;840            
;;;841            if(NewState != DISABLE)
00000c  2a00              CMP      r2,#0
00000e  d005              BEQ      |L22.28|
;;;842            {
;;;843                CSC->AHB.W |= Reg;
000010  4b24              LDR      r3,|L22.164|
000012  69db              LDR      r3,[r3,#0x1c]
000014  430b              ORRS     r3,r3,r1
000016  4c23              LDR      r4,|L22.164|
000018  61e3              STR      r3,[r4,#0x1c]
00001a  e004              B        |L22.38|
                  |L22.28|
;;;844            }
;;;845            else
;;;846            {
;;;847                CSC->AHB.W &= ~Reg;
00001c  4b21              LDR      r3,|L22.164|
00001e  69db              LDR      r3,[r3,#0x1c]
000020  438b              BICS     r3,r3,r1
000022  4c20              LDR      r4,|L22.164|
000024  61e3              STR      r3,[r4,#0x1c]
                  |L22.38|
;;;848            }
;;;849        }
;;;850        
;;;851        if((32 <= CSC_Periph) & (CSC_Periph < 64))  // APB0 Periph config
000026  2820              CMP      r0,#0x20
000028  db01              BLT      |L22.46|
00002a  2301              MOVS     r3,#1
00002c  e000              B        |L22.48|
                  |L22.46|
00002e  2300              MOVS     r3,#0
                  |L22.48|
000030  2840              CMP      r0,#0x40
000032  da01              BGE      |L22.56|
000034  2401              MOVS     r4,#1
000036  e000              B        |L22.58|
                  |L22.56|
000038  2400              MOVS     r4,#0
                  |L22.58|
00003a  4023              ANDS     r3,r3,r4
00003c  2b00              CMP      r3,#0
00003e  d011              BEQ      |L22.100|
;;;852        {
;;;853            Reg = (0x00000001 << (CSC_Periph - 32));
000040  4603              MOV      r3,r0
000042  3b20              SUBS     r3,r3,#0x20
000044  2401              MOVS     r4,#1
000046  409c              LSLS     r4,r4,r3
000048  4621              MOV      r1,r4
;;;854            if(NewState != DISABLE)
00004a  2a00              CMP      r2,#0
00004c  d005              BEQ      |L22.90|
;;;855            {
;;;856                CSC->APB0.W |= Reg;
00004e  4b15              LDR      r3,|L22.164|
000050  6a1b              LDR      r3,[r3,#0x20]
000052  430b              ORRS     r3,r3,r1
000054  4c13              LDR      r4,|L22.164|
000056  6223              STR      r3,[r4,#0x20]
000058  e004              B        |L22.100|
                  |L22.90|
;;;857            }
;;;858            else
;;;859            {
;;;860                CSC->APB0.W &= ~Reg;
00005a  4b12              LDR      r3,|L22.164|
00005c  6a1b              LDR      r3,[r3,#0x20]
00005e  438b              BICS     r3,r3,r1
000060  4c10              LDR      r4,|L22.164|
000062  6223              STR      r3,[r4,#0x20]
                  |L22.100|
;;;861            }
;;;862        }
;;;863        
;;;864        if((64 <= CSC_Periph) & (CSC_Periph < 96))  // APB1 Periph config
000064  2840              CMP      r0,#0x40
000066  db01              BLT      |L22.108|
000068  2301              MOVS     r3,#1
00006a  e000              B        |L22.110|
                  |L22.108|
00006c  2300              MOVS     r3,#0
                  |L22.110|
00006e  2860              CMP      r0,#0x60
000070  da01              BGE      |L22.118|
000072  2401              MOVS     r4,#1
000074  e000              B        |L22.120|
                  |L22.118|
000076  2400              MOVS     r4,#0
                  |L22.120|
000078  4023              ANDS     r3,r3,r4
00007a  2b00              CMP      r3,#0
00007c  d011              BEQ      |L22.162|
;;;865        {
;;;866            Reg = (0x00000001 << (CSC_Periph - 64));
00007e  4603              MOV      r3,r0
000080  3b40              SUBS     r3,r3,#0x40
000082  2401              MOVS     r4,#1
000084  409c              LSLS     r4,r4,r3
000086  4621              MOV      r1,r4
;;;867            
;;;868            if(NewState != DISABLE)
000088  2a00              CMP      r2,#0
00008a  d005              BEQ      |L22.152|
;;;869            {
;;;870                CSC->APB1.W |= Reg;
00008c  4b05              LDR      r3,|L22.164|
00008e  6a5b              LDR      r3,[r3,#0x24]
000090  430b              ORRS     r3,r3,r1
000092  4c04              LDR      r4,|L22.164|
000094  6263              STR      r3,[r4,#0x24]
000096  e004              B        |L22.162|
                  |L22.152|
;;;871            }
;;;872            else
;;;873            {
;;;874                CSC->APB1.W &= ~Reg;
000098  4b02              LDR      r3,|L22.164|
00009a  6a5b              LDR      r3,[r3,#0x24]
00009c  438b              BICS     r3,r3,r1
00009e  4c01              LDR      r4,|L22.164|
0000a0  6263              STR      r3,[r4,#0x24]
                  |L22.162|
;;;875            }
;;;876        }
;;;877    }		
0000a2  bd10              POP      {r4,pc}
;;;878    
                          ENDP

                  |L22.164|
                          DCD      0x4c010000

                          AREA ||i.CSC_PeriphProcessClockSource_Config||, CODE, READONLY, ALIGN=2

                  CSC_PeriphProcessClockSource_Config PROC
;;;732     */
;;;733    void CSC_PeriphProcessClockSource_Config (CSC_CKS_TypeDef CSC_Periph, CSC_CKSS_TypeDef CSC_CKS)
000000  b510              PUSH     {r4,lr}
;;;734    {
000002  460a              MOV      r2,r1
;;;735        uint32_t  Reg;
;;;736        
;;;737        Reg = 0x00000001;
000004  2101              MOVS     r1,#1
;;;738        
;;;739        if(CSC_Periph < 32)                             // CKS0 Config
000006  2820              CMP      r0,#0x20
000008  da0f              BGE      |L23.42|
;;;740        {
;;;741            Reg = Reg << CSC_Periph;
00000a  460b              MOV      r3,r1
00000c  4083              LSLS     r3,r3,r0
00000e  4619              MOV      r1,r3
;;;742            if(CSC_CKS == CK_APB)
000010  2a00              CMP      r2,#0
000012  d105              BNE      |L23.32|
;;;743            {
;;;744                CSC->CKS0.W &= ~Reg;
000014  4b20              LDR      r3,|L23.152|
000016  681b              LDR      r3,[r3,#0]
000018  438b              BICS     r3,r3,r1
00001a  4c1f              LDR      r4,|L23.152|
00001c  6023              STR      r3,[r4,#0]
00001e  e004              B        |L23.42|
                  |L23.32|
;;;745            }
;;;746            else
;;;747            {
;;;748                CSC->CKS0.W |= Reg;
000020  4b1d              LDR      r3,|L23.152|
000022  681b              LDR      r3,[r3,#0]
000024  430b              ORRS     r3,r3,r1
000026  4c1c              LDR      r4,|L23.152|
000028  6023              STR      r3,[r4,#0]
                  |L23.42|
;;;749            }
;;;750        }
;;;751        
;;;752        if((CSC_Periph >= 32) & (CSC_Periph < 64))      // CKS1 Config
00002a  2820              CMP      r0,#0x20
00002c  db01              BLT      |L23.50|
00002e  2301              MOVS     r3,#1
000030  e000              B        |L23.52|
                  |L23.50|
000032  2300              MOVS     r3,#0
                  |L23.52|
000034  2840              CMP      r0,#0x40
000036  da01              BGE      |L23.60|
000038  2401              MOVS     r4,#1
00003a  e000              B        |L23.62|
                  |L23.60|
00003c  2400              MOVS     r4,#0
                  |L23.62|
00003e  4023              ANDS     r3,r3,r4
000040  2b00              CMP      r3,#0
000042  d012              BEQ      |L23.106|
;;;753        {
;;;754            CSC_Periph -= 32;
000044  4603              MOV      r3,r0
000046  3b20              SUBS     r3,r3,#0x20
000048  b2d8              UXTB     r0,r3
;;;755            Reg = Reg << CSC_Periph;
00004a  460b              MOV      r3,r1
00004c  4083              LSLS     r3,r3,r0
00004e  4619              MOV      r1,r3
;;;756            
;;;757            if(CSC_CKS == CK_APB)
000050  2a00              CMP      r2,#0
000052  d105              BNE      |L23.96|
;;;758            {
;;;759                CSC->CKS1.W &= ~Reg;
000054  4b10              LDR      r3,|L23.152|
000056  685b              LDR      r3,[r3,#4]
000058  438b              BICS     r3,r3,r1
00005a  4c0f              LDR      r4,|L23.152|
00005c  6063              STR      r3,[r4,#4]
00005e  e004              B        |L23.106|
                  |L23.96|
;;;760            }
;;;761            else
;;;762            {
;;;763                CSC->CKS1.W |= Reg;
000060  4b0d              LDR      r3,|L23.152|
000062  685b              LDR      r3,[r3,#4]
000064  430b              ORRS     r3,r3,r1
000066  4c0c              LDR      r4,|L23.152|
000068  6063              STR      r3,[r4,#4]
                  |L23.106|
;;;764            }
;;;765        }
;;;766        
;;;767        if(CSC_Periph >= 64)                            // CKS0 Config
00006a  2840              CMP      r0,#0x40
00006c  db12              BLT      |L23.148|
;;;768        {   
;;;769            CSC_Periph -= 64;
00006e  4603              MOV      r3,r0
000070  3b40              SUBS     r3,r3,#0x40
000072  b2d8              UXTB     r0,r3
;;;770            Reg = Reg << CSC_Periph;
000074  460b              MOV      r3,r1
000076  4083              LSLS     r3,r3,r0
000078  4619              MOV      r1,r3
;;;771            
;;;772            if(CSC_CKS == CK_APB)
00007a  2a00              CMP      r2,#0
00007c  d105              BNE      |L23.138|
;;;773            {
;;;774                CSC->CKS2.W &= ~Reg;
00007e  4b06              LDR      r3,|L23.152|
000080  689b              LDR      r3,[r3,#8]
000082  438b              BICS     r3,r3,r1
000084  4c04              LDR      r4,|L23.152|
000086  60a3              STR      r3,[r4,#8]
000088  e004              B        |L23.148|
                  |L23.138|
;;;775            }
;;;776            else
;;;777            {
;;;778                CSC->CKS2.W |= Reg;
00008a  4b03              LDR      r3,|L23.152|
00008c  689b              LDR      r3,[r3,#8]
00008e  430b              ORRS     r3,r3,r1
000090  4c01              LDR      r4,|L23.152|
000092  60a3              STR      r3,[r4,#8]
                  |L23.148|
;;;779            }
;;;780        }
;;;781    }
000094  bd10              POP      {r4,pc}
;;;782    
                          ENDP

000096  0000              DCW      0x0000
                  |L23.152|
                          DCD      0x4c010040

                          AREA ||i.CSC_PeriphSLEEPModeClock_Config||, CODE, READONLY, ALIGN=2

                  CSC_PeriphSLEEPModeClock_Config PROC
;;;924     */
;;;925    void CSC_PeriphSLEEPModeClock_Config (CSC_PeriphSleepMode_TypeDef CSC_Periph, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;926    {
000002  460a              MOV      r2,r1
;;;927        uint32_t  Reg;
;;;928        
;;;929        if((32 <= CSC_Periph) & (CSC_Periph < 64))  // APB0 Periph config
000004  2820              CMP      r0,#0x20
000006  db01              BLT      |L24.12|
000008  2301              MOVS     r3,#1
00000a  e000              B        |L24.14|
                  |L24.12|
00000c  2300              MOVS     r3,#0
                  |L24.14|
00000e  2840              CMP      r0,#0x40
000010  da01              BGE      |L24.22|
000012  2401              MOVS     r4,#1
000014  e000              B        |L24.24|
                  |L24.22|
000016  2400              MOVS     r4,#0
                  |L24.24|
000018  4023              ANDS     r3,r3,r4
00001a  2b00              CMP      r3,#0
00001c  d010              BEQ      |L24.64|
;;;930        {
;;;931            Reg = (0x00000001 << (CSC_Periph - 32));
00001e  4603              MOV      r3,r0
000020  3b20              SUBS     r3,r3,#0x20
000022  2101              MOVS     r1,#1
000024  4099              LSLS     r1,r1,r3
;;;932            if(NewState != DISABLE)
000026  2a00              CMP      r2,#0
000028  d005              BEQ      |L24.54|
;;;933            {
;;;934                CSC->SLP0.W |= Reg;
00002a  4b15              LDR      r3,|L24.128|
00002c  6b1b              LDR      r3,[r3,#0x30]
00002e  430b              ORRS     r3,r3,r1
000030  4c13              LDR      r4,|L24.128|
000032  6323              STR      r3,[r4,#0x30]
000034  e004              B        |L24.64|
                  |L24.54|
;;;935            }
;;;936            else
;;;937            {
;;;938                CSC->SLP0.W &= ~Reg;
000036  4b12              LDR      r3,|L24.128|
000038  6b1b              LDR      r3,[r3,#0x30]
00003a  438b              BICS     r3,r3,r1
00003c  4c10              LDR      r4,|L24.128|
00003e  6323              STR      r3,[r4,#0x30]
                  |L24.64|
;;;939            }
;;;940        }
;;;941        
;;;942        if((64 <= CSC_Periph) & (CSC_Periph < 96))  // APB1 Periph config
000040  2840              CMP      r0,#0x40
000042  db01              BLT      |L24.72|
000044  2301              MOVS     r3,#1
000046  e000              B        |L24.74|
                  |L24.72|
000048  2300              MOVS     r3,#0
                  |L24.74|
00004a  2860              CMP      r0,#0x60
00004c  da01              BGE      |L24.82|
00004e  2401              MOVS     r4,#1
000050  e000              B        |L24.84|
                  |L24.82|
000052  2400              MOVS     r4,#0
                  |L24.84|
000054  4023              ANDS     r3,r3,r4
000056  2b00              CMP      r3,#0
000058  d011              BEQ      |L24.126|
;;;943        {
;;;944            Reg = (0x00000001 << (CSC_Periph - 64));
00005a  4603              MOV      r3,r0
00005c  3b40              SUBS     r3,r3,#0x40
00005e  2401              MOVS     r4,#1
000060  409c              LSLS     r4,r4,r3
000062  4621              MOV      r1,r4
;;;945            
;;;946            if(NewState != DISABLE)
000064  2a00              CMP      r2,#0
000066  d005              BEQ      |L24.116|
;;;947            {
;;;948                CSC->SLP1.W |= Reg;
000068  4b05              LDR      r3,|L24.128|
00006a  6b5b              LDR      r3,[r3,#0x34]
00006c  430b              ORRS     r3,r3,r1
00006e  4c04              LDR      r4,|L24.128|
000070  6363              STR      r3,[r4,#0x34]
000072  e004              B        |L24.126|
                  |L24.116|
;;;949            }
;;;950            else
;;;951            {
;;;952                CSC->SLP1.W &= ~Reg;
000074  4b02              LDR      r3,|L24.128|
000076  6b5b              LDR      r3,[r3,#0x34]
000078  438b              BICS     r3,r3,r1
00007a  4c01              LDR      r4,|L24.128|
00007c  6363              STR      r3,[r4,#0x34]
                  |L24.126|
;;;953            }
;;;954        }
;;;955    }			
00007e  bd10              POP      {r4,pc}
;;;956    
                          ENDP

                  |L24.128|
                          DCD      0x4c010000

                          AREA ||i.CSC_PeriphSTOPModeClock_Config||, CODE, READONLY, ALIGN=2

                  CSC_PeriphSTOPModeClock_Config PROC
;;;974     */
;;;975    void CSC_PeriphSTOPModeClock_Config (CSC_PeriphStopMode_TypeDef CSC_Periph, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;976    {
;;;977        uint32_t  Reg;
;;;978        
;;;979        Reg = (0x00000001 << (CSC_Periph - 32));
000002  4603              MOV      r3,r0
000004  3b20              SUBS     r3,r3,#0x20
000006  2401              MOVS     r4,#1
000008  409c              LSLS     r4,r4,r3
00000a  4622              MOV      r2,r4
;;;980        if(NewState != DISABLE)
00000c  2900              CMP      r1,#0
00000e  d005              BEQ      |L25.28|
;;;981        {
;;;982            CSC->STP0.W |= Reg;
000010  4b05              LDR      r3,|L25.40|
000012  6b9b              LDR      r3,[r3,#0x38]
000014  4313              ORRS     r3,r3,r2
000016  4c04              LDR      r4,|L25.40|
000018  63a3              STR      r3,[r4,#0x38]
00001a  e004              B        |L25.38|
                  |L25.28|
;;;983        }
;;;984        else
;;;985        {
;;;986            CSC->STP0.W &= ~Reg;
00001c  4b02              LDR      r3,|L25.40|
00001e  6b9b              LDR      r3,[r3,#0x38]
000020  4393              BICS     r3,r3,r2
000022  4c01              LDR      r4,|L25.40|
000024  63a3              STR      r3,[r4,#0x38]
                  |L25.38|
;;;987        }
;;;988    }
000026  bd10              POP      {r4,pc}
;;;989    ///@}
                          ENDP

                  |L25.40|
                          DCD      0x4c010000

                          AREA ||i.CSC_XOSCGain_Select||, CODE, READONLY, ALIGN=2

                  CSC_XOSCGain_Select PROC
;;;148     */
;;;149    void CSC_XOSCGain_Select (CSC_XOSC_GN_TypeDef CSC_XoscGain)
000000  4601              MOV      r1,r0
;;;150    {
;;;151        uint8_t   Reg;
;;;152        
;;;153        Reg = CSC->PLL.B[2];
000002  4a05              LDR      r2,|L26.24|
000004  7a90              LDRB     r0,[r2,#0xa]
;;;154        Reg &= ~CSC_PLL_XOSC_GN_mask_b2;
000006  0880              LSRS     r0,r0,#2
000008  0080              LSLS     r0,r0,#2
;;;155        Reg |= CSC_XoscGain;
00000a  4602              MOV      r2,r0
00000c  430a              ORRS     r2,r2,r1
00000e  4610              MOV      r0,r2
;;;156        CSC->PLL.B[2] = Reg;
000010  4a01              LDR      r2,|L26.24|
000012  7290              STRB     r0,[r2,#0xa]
;;;157    }
000014  4770              BX       lr
;;;158    
                          ENDP

000016  0000              DCW      0x0000
                  |L26.24|
                          DCD      0x4c010000

                          AREA ||i.CSC_XOSC_Cmd||, CODE, READONLY, ALIGN=2

                  CSC_XOSC_Cmd PROC
;;;118     */
;;;119    void CSC_XOSC_Cmd (FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121        if(NewState != DISABLE)
000004  2c00              CMP      r4,#0
000006  d009              BEQ      |L27.28|
;;;122        {
;;;123            GPIO_PinFunction_Select(PINC(13), 1);
000008  2101              MOVS     r1,#1
00000a  4809              LDR      r0,|L27.48|
00000c  f7fffffe          BL       GPIO_PinFunction_Select
;;;124            GPIO_PinFunction_Select(PINC(14), 1);
000010  2101              MOVS     r1,#1
000012  4807              LDR      r0,|L27.48|
000014  1d00              ADDS     r0,r0,#4
000016  f7fffffe          BL       GPIO_PinFunction_Select
00001a  e008              B        |L27.46|
                  |L27.28|
;;;125        }
;;;126        else
;;;127        {
;;;128            GPIO_PinFunction_Select(PINC(13), 0);
00001c  2100              MOVS     r1,#0
00001e  4804              LDR      r0,|L27.48|
000020  f7fffffe          BL       GPIO_PinFunction_Select
;;;129            GPIO_PinFunction_Select(PINC(14), 0);
000024  2100              MOVS     r1,#0
000026  4802              LDR      r0,|L27.48|
000028  1d00              ADDS     r0,r0,#4
00002a  f7fffffe          BL       GPIO_PinFunction_Select
                  |L27.46|
;;;130        }
;;;131    }
00002e  bd10              POP      {r4,pc}
;;;132    
                          ENDP

                  |L27.48|
                          DCD      0x44020034

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Driver\\Source\\MG32x02z_CSC_DRV.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_CSC_DRV_c_57312e36____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_CSC_DRV_c_57312e36____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_CSC_DRV_c_57312e36____REVSH|
#line 496
|__asm___18_MG32x02z_CSC_DRV_c_57312e36____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
