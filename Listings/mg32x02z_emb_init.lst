L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_EMB_Init.c"
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EMB_Init.c
N *
N * @brief       MG32x02z EMB Initial C Code File
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2016/04/11
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N */
N
N/* Includes -----------------------------------------------------------------*/
N
N#include "MG32x02z_ChipInit.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 1
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_ChipInit.H
N *
N * @brief       By the file select you want to function initial.
N *   
N * @par         Project
N *              MG32x02z
N * @version     V1.10
N * @date        2018/01/30
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_ChipInit_H
N 
N#define _MG32x02z_ChipInit_H
N
N#include "RTE_Components.h"
L 1 ".\RTE\_Target_1\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'Example_UART' 
N * Target:  'Target 1' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N
N/*
N * Define the Device Header File: 
N */
N#define CMSIS_device_header "MG32x02z.h"
N
N/* Megawin::MG32x02z_ChipInit_Wizard:ADC:1.0.0 */
N#define MG32x02z_ConfigerWizard_ADC
N/* Megawin::MG32x02z_ChipInit_Wizard:CSC:1.0.4 */
N#define MG32x02z_ConfigerWizard_CSC
N/* Megawin::MG32x02z_ChipInit_Wizard:EMB:1.0.2 */
N#define MG32x02z_ConfigerWizard_EMB
N/* Megawin::MG32x02z_ChipInit_Wizard:EXIC:LQFP80:1.0.2 */
N#define MG32x02z_ConfigerWizard_EXIC
N/* Megawin::MG32x02z_ChipInit_Wizard:GPIO:LQFP80:1.0.2 */
N#define MG32x02z_Package_LQFP80            
N		#define MG32x02z_ConfigerWizard_GPIO
N/* Megawin::MG32x02z_ChipInit_Wizard:GPL:1.0.1 */
N#define MG32x02z_ConfigerWizard_GPL
N/* Megawin::MG32x02z_ChipInit_Wizard:IRQ handler:1.0.5 */
N#define MG32x02z_IRQ_Handler_
N/* Megawin::MG32x02z_ChipInit_Wizard:MEM:1.0.1 */
N#define MG32x02z_ConfigerWizard_MEM
N/* Megawin::MG32x02z_ChipInit_Wizard:PW:1.0.1 */
N#define MG32x02z_ConfigerWizard_PW
N/* Megawin::MG32x02z_ChipInit_Wizard:RST:1.0.1 */
N#define MG32x02z_ConfigerWizard_RST
N/* Megawin::MG32x02z_ChipInit_Wizard:Timer:1.0.0 */
N#define MG32x02z_ConfigerWizard_TM
N/* Megawin::MG32x02z_ChipInit_Wizard:URT:1.0.2 */
N#define MG32x02z_ConfigerWizard_URT  
N		#define URT_Initial_En 1
N/* Megawin::MG32x02z_IRQ_Handler:Systick:1.0.0 */
N#define MG32x02z_SYSTICK_Middleware_Level_IRQ_
N/* Megawin::MG32x02z_Middleware:Middleware-All:1.0.0 */
N#define IRQHandler_Middleware_Level_
N
N
N#endif /* RTE_COMPONENTS_H */
L 35 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N
N#ifdef MG32x02z_ConfigerWizard_PW
N    #include "MG32x02z_PW_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_PW_Init.h" 1
N/**
N *******************************************************************************
N * @file        MG32x02z_PW_Init.h
N *
N * @brief       The PW Init include file.
N *
N * MG32x02z remote controller
N * @version     V1.10
N * @date        2018/01/31
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2018 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N
N
N#ifndef _MG32x02z_PW_INIT_H
N/*!< _MG32x02z_PW_INIT_H */ 
N#define _MG32x02z_PW_INIT_H
N
N
N#include "MG32x02z.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z.h
N *
N * @brief       MG32x02z Device Peripheral Access Layer Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_H
N#define _MG32x02z_H
N#define _MG32x02z_H_VER                             3.9     /*!< File Version */
N
N
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N *************************************************
N *  Chip definitions
N *************************************************
N */
N// Chip Generation
N#if defined(MG32F02A132) || defined(MG32F02A072) || defined(MA862)
X#if 1L || 0L || 0L
N  #define MG32_1ST
N#elif defined(MG32F02A032)
S  #define MG32_2ND
S#elif defined(MG32F02A128) || defined(MG32F02U128) || defined(MG32F02A064) || defined(MG32F02U064)
S  #define MG32_3RD
S#elif defined(MG32F02V032)
S  #define MG32_4TH
N#endif
N
N#if defined(MG32F02U128) || defined(MG32F02U064)
X#if 0L || 0L
S  #define USB_TYPE    1
N#else
N  #define USB_TYPE    0
N#endif
N    
N
N/**
N *************************************************
N *  ARM CPU Configuration Setting
N *************************************************
N */
N#define __CM0_REV                 0 /*!< Core Revision r0p0                             */
N#define __MPU_PRESENT             0 /*!< Chip do not provide MPU                       */
N#define __NVIC_PRIO_BITS          2 /*!< Chip uses 2 Bits for the Priority Levels      */
N#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used   */
N
N/**
N ******************************************************************************
N * @enum        IRQn
N *              Interrupt Number Definition
N ******************************************************************************
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers Definitions *****************************************/
N    NMI_IRQn                    = -14 , /*!<  ;Non Maskable Interrupt                               */
N    HardFault_IRQn              = -13 , /*!<  ;Cortex-M0 Hard Fault Interrupt                       */
N    SVC_IRQn                    = -5 ,  /*!<  ;Cortex-M0 SV Call Interrupt                          */
N    PendSV_IRQn                 = -2 ,  /*!<  ;Cortex-M0 Pend SV Interrupt                          */
N    SysTick_IRQn                = -1 ,  /*!<  ;Cortex-M0 System Tick Interrupt                      */
N/******  Peripheral Interrupt Numbers Definitions ***************************************************/
N    WWDT_IRQn                   =  0 ,  /*!<  ;Window Watchdog                                      */
N    SYS_IRQn                    =  1 ,  /*!<  ;System global Interrupt                              */
N    EXINT0_IRQn                 =  3 ,  /*!<  ;EXIC EXINT0 (PA)                                     */
N    EXINT1_IRQn                 =  4 ,  /*!<  ;EXIC EXINT1 (PB)                                     */
N    EXINT2_IRQn                 =  5 ,  /*!<  ;EXIC EXINT2 (PC)                                     */
N    EXINT3_IRQn                 =  6 ,  /*!<  ;EXIC EXINT3/EXINT4 (PD/PE)                           */
N    COMP_IRQn                   =  7 ,  /*!<  ;Analog Comparators global Interrupt                  */
N    DMA_IRQn                    =  8 ,  /*!<  ;DMA all channel global Interrupt                     */
N    ADC_IRQn                    =  10 , /*!<  ;ADC                                                  */
N    DAC_IRQn                    =  11 , /*!<  ;DAC                                                  */
N    TM0x_IRQn                   =  12 , /*!<  ;Timer TM0x global Interrupt                          */
N    TM10_IRQn                   =  13 , /*!<  ;Timer TM10                                           */
N    TM1x_IRQn                   =  14 , /*!<  ;Timer TM16 ... global Interrupt                      */
N    TM20_IRQn                   =  15 , /*!<  ;Timer TM20                                           */
N    TM2x_IRQn                   =  16 , /*!<  ;Timer TM26 ... global Interrupt                      */
N    TM3x_IRQn                   =  17 , /*!<  ;Timer TM3x global Interrupt                          */
N    URT0_IRQn                   =  20 , /*!<  ;UART URT0                                            */
N    URT123_IRQn                 =  21 , /*!<  ;UART URT1/2/3 global Interrupt                       */
N    URT4x_IRQn                  =  22 , /*!<  ;UART URT4/5/6/7 global Interrupt                     */
N    SPI0_IRQn                   =  24 , /*!<  ;SPI0                                                 */
N    I2C0_IRQn                   =  28 , /*!<  ;I2C0                                                 */
N    I2Cx_IRQn                   =  29 , /*!<  ;I2C1 ... global Interrupt                            */
N    USB_IRQn                    =  30 , /*!<  ;USB                                                  */
N    APX_IRQn                    =  31 , /*!<  ;APX                                                  */
N} IRQn_Type;                    /*!< Interrupt Number Definition */
N
N
N#include "core_cm0.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.8
N * @date     21. August 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.4
N * @date     23. July 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 4U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N 
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_FP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.2.1
N * @date     26. March 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
S#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RESERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  *(vectors + (int32_t)IRQn) = vector;                              /* use pointer arithmetic to access vector */
N  /* ARM Application Note 321 states that the M0 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  return *(vectors + (int32_t)IRQn);                                /* use pointer arithmetic to access vector */
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 107 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z.h" 2
N#include <stdint.h>
N
N/**
N *************************************************
N *  New type definitions
N *************************************************
N */
Ntypedef signed char boolean;		/*!< Boolean	*/
Ntypedef unsigned char byte;			/*!< Byte		*/
N//typedef signed char int8;
N//typedef signed char sint8;
N//typedef unsigned char uint8;
N//typedef signed short int16;
N//typedef signed short sint16;
N//typedef unsigned short uint16;
N//typedef signed int int16;
N//typedef signed int sint16;
N//typedef unsigned int uint16;
N//typedef signed long int32;
N//typedef signed long sint32;
N//typedef unsigned long uint32;
Ntypedef unsigned long long uint64;	/*!< Uint 64-bit	*/
Ntypedef float float32;				/*!< Float 32-bit	*/
Ntypedef double float64;				/*!< Float 64-bit	*/
N
N/**
N *************************************************
N *  @union		ctype
N *				Combined 32/16/8-bit type
N *************************************************
N */
Ntypedef union
N{								
N	__IO uint8_t    B[4];			/*!< Byte 8-bit 		*/
X	volatile uint8_t    B[4];			 
N	__IO uint16_t   H[2];			/*!< Half-Word 16-bit 	*/
X	volatile uint16_t   H[2];			 
N	__IO uint32_t   W;				/*!< Word 32-bit 		*/
X	volatile uint32_t   W;				 
N} ctype;
N
N
N/**
N *************************************************
N *  General definitions
N *************************************************
N */
N//#define     __I     volatile                /*!< defines 'read only' permissions		*/
N//#define     __O     volatile                /*!< defines 'write only' permissions		*/
N//#define     __IO    volatile                /*!< defines 'read / write' permissions	*/
N
N#define TRUE		1				/*!< True	*/
N#define FALSE		0				/*!< False	*/
N
N//#define ENABLE		1
N//#define DISABLE		0
N
N#define MASK8(val)  (((val) < 256) ? (val) : (val) < 65536 ? (val) >> 8 : (val) < 16777216 ?  (val) >> 16 : (val) >> 24)	/*!< Mask 8-bit		*/  
N#define MASK16(val)  (((val) < 65536) ? (val) : (val)>> 16) 																/*!< Mask 16-bit	*/
N
N/**
N ******************************************************************************
N * @enum        FunctionalState
N *              Enable/Disable
N ******************************************************************************
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;										/*!< Enable/Disable	*/
N/**
N ******************************************************************************
N * @enum        FlagStatus
N *              Clear/Se
N ******************************************************************************
N */
Ntypedef enum {CLR = 0, SET = !CLR} FlagStatus ,BitAction;											/*!< Clear/Set	*/
N/**
N ******************************************************************************
N * @enum        ITStatus
N *              None/Happened/Stable/Unstable
N ******************************************************************************
N */
Ntypedef enum {NONE = 0,  HAPPENED = !NONE, UNSTABLE = 0, STABLE = !UNSTABLE} ITStatus, CSCStatus;	/*!< None/Happened/Stable/Unstablee	*/       
N
N
N/**
N *************************************************
N *  Hardware Access
N *************************************************
N */
N 
N///**
N// * @brief  get register value
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// */
N//#define HW_ReadReg(_reg)             (_reg)											/*!< Hardware Read Register */
N
N///**
N// * @brief  set register value
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _value : definitions of register value, like MODULE_REGNAME_xyz
N// */
N//#define HW_WriteReg(_reg, _value)     _reg = (_value)								/*!< Hardware Write Register */
N
N///**
N// * @brief  set register bits value =1
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _mask : definitions of register mask value, like MODULE_REGNAME_mask
N// */
N//#define HW_SetBit(_reg, _mask)		HW_WriteReg(_reg, (HW_ReadReg(_reg) | (_mask))) /*!< Hardware Set Register Bit */
N
N///**
N// * @brief  set register bits value =0
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _mask : definitions of register mask value, like MODULE_REGNAME_mask
N// */
N//#define HW_ClrBit(_reg, _mask)		HW_WriteReg(_reg, (HW_ReadReg(_reg) & ~(_mask)))    /*!< Hardware Clear Register Bit */
N
N/**
N * @brief  get register bit value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N/**
N * @brief  clear register, value = 0
N * @param  REG : definitions of register name, like MODULE_REGNAME
N */
N#define CLEAR_REG(REG)        ((REG) = (0x0))                                       /*!< Hardware Clear Register */
N
N/**
N * @brief  set register value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  VAL : definitions of register value, like MODULE_REGNAME_xyz
N */
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))                                       /*!< Hardware Write Register */
N
N/**
N * @brief  get register value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N */
N#define READ_REG(REG)         ((REG))                                               /*!< Hardware Write Register */
N
N/**
N * @brief  set register bits value =1
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))                                      /*!< Hardware Set Register Bit */
N
N/**
N * @brief  set register bits value =0
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))                                     /*!< Hardware Clear Register Bit */
N
N/**
N * @brief  set register bits value =1
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  CLEARMASK : definitions of register mask value, like MODULE_REGNAME_mask
N * @param  SETMASK : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))  /*!< Hardware Register Modify */
N
N/**
N ******************************************************************************
N *
N *              Header Files Include
N *
N ******************************************************************************
N */
N//#include "MG32x02z__RegPointer.h"
N//#include "MG32x02z__RegAddress.h"
N//#include "MG32x02z_GPIO.h"
N//#include "MG32x02z_GPL.h"
N//#include "MG32x02z_DMA.h"
N//#include "MG32x02z_RST.h"
N//#include "MG32x02z_CSC.h"
N//#include "MG32x02z_PW.h"
N//#include "MG32x02z_SYS.h"
N//#include "MG32x02z_MEM.h"
N//#include "MG32x02z_EMB.h"
N//#include "MG32x02z_CFG.h"
N//#include "MG32x02z_EXIC.h"
N//#include "MG32x02z_I2C.h"
N//#include "MG32x02z_URT.h"
N//#include "MG32x02z_SPI.h"
N//#include "MG32x02z_TM.h"
N//#include "MG32x02z_ADC.h"
N//#include "MG32x02z_CMP.h"
N//#include "MG32x02z_DAC.h"
N//#include "MG32x02z_IWDT.h"
N//#include "MG32x02z_WWDT.h"
N//#include "MG32x02z_RTC.h"
N//#include "MG32x02z_APB.h"
N//#include "MG32x02z_CPU.h"
N
N#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) /* ARM Compiler V6 */
X#if 1L && (5060960 >= 6010050)  
S  #ifndef __weak
S    #define __weak  __attribute__((weak))
S  #endif
S  #ifndef __packed
S    #define __packed  __attribute__((packed))
S  #endif
S#elif defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#elif 0L && !1L  
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__ */
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) /* ARM Compiler V6 */
X#if 1L && (5060960 >= 6010050)  
S  #ifndef __ALIGN_BEGIN
S    #define __ALIGN_BEGIN
S  #endif
S  #ifndef __ALIGN_END
S    #define __ALIGN_END      __attribute__ ((aligned (4)))
S  #endif
S#elif defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#elif 0L && !1L  
S  #ifndef __ALIGN_END
S    #define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler V5*/
X    #if 1L       
N      #define __ALIGN_BEGIN    __align(4)  
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__ */
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)) || defined   (  __GNUC__  )
X#if 1L || (1L && (5060960 >= 6010050)) || 0L
N/* ARM V4/V5 and V6 & GNU Compiler
N   -------------------------------
N*/
N  #define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S  /* ICCARM Compiler
S     ---------------
S  */
S  #define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  // _MG32x02z_H
N
N/*----------------------------------------------------------------------------*/
N/*                           End of file MG32x02z.h                           */
N/*----------------------------------------------------------------------------*/
L 34 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_PW_Init.h" 2
N#include "MG32x02z_PW.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_PW.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_PW.h
N *
N * @brief       MG32x02z PW Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_PW_H
N#define _MG32x02z_PW_H
N#define _MG32x02z_PW_H_VER                          3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_PW_H_VER)
S    #error "MG32x02z_PW_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      PW_Struct
N *              PW  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PORF          :1;     //[1] Power-On reset status flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  PORF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BOD0F         :1;     //[4] BOD0 brown-out detection interrupt flag
X            volatile uint8_t  BOD0F         :1;     
N                                        //0 = Normal : No event occurred and VDD is than high BOD0 threshold
N                                        //1 = Happened : Event happened and VDD is  lower than BOD0 threshold
N            __IO uint8_t  BOD1F         :1;     //[5] BOD1 brown-out detection interrupt flag
X            volatile uint8_t  BOD1F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WKF           :1;     //[7] System received wakeup event flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  WKF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  STATE         :2;     //[17..16] System operation power mode state
X            volatile const  uint8_t  STATE         :2;     
N                                        //0x0 = ON
N                                        //0x1 = SLEEP
N                                        //0x2 = STOP
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  WKMODE        :2;     //[21..20] System wakeup from which power-down mode status.
X            volatile const  uint8_t  WKMODE        :2;     
N                                        //0x0 = NONE : Never wakeup from power-down mode.
N                                        //0x1 = SLEEP
N                                        //0x2 = STOP
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  BOD1_S        :1;     //[25] Brown-Out detect BOD1 status.
X            volatile const  uint8_t  BOD1_S        :1;     
N                                        //0 = High : VDD is high than BOD1 threshold
N                                        //1 = Low : VDD is  lower than BOD1 threshold
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  PW status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] PW interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[3..1] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  BOD0_IE       :1;     //[4] BOD0 brown-out detection interrupt enable.
X            volatile uint8_t  BOD0_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD1_IE       :1;     //[5] BOD1 brown-out detection interrupt enable.
X            volatile uint8_t  BOD1_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WK_IE         :1;     //[7] System received wakeup event interrupt enable bit.
X            volatile uint8_t  WK_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  PW interrupt enable register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] PW key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  PW write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IVR_EN        :1;     //[1] Internal voltage reference source enable
X            volatile uint8_t  IVR_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BOD0_EN       :1;     //[4] BOD0 voltage detect enable.
X            volatile uint8_t  BOD0_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD1_EN       :1;     //[5] BOD1 voltage detect enable.
X            volatile uint8_t  BOD1_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LDO_ON        :1;     //[6] Core voltage LDO mode select when ON or SLEEP mode.
X            volatile uint8_t  LDO_ON        :1;     
N                                        //0 = Normal
N                                        //1 = Low power
N            __IO uint8_t  LDO_STP       :1;     //[7] Core voltage LDO mode select when STOP mode. (default=1)
X            volatile uint8_t  LDO_STP       :1;     
N                                        //0 = Normal
N                                        //1 = Low power
N            __IO uint8_t  BOD1_TRGS     :2;     //[9..8] BOD1 Interrupt trigger selection.
X            volatile uint8_t  BOD1_TRGS     :2;     
N                                        //0x0 = Reserved
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  BOD1_TH       :2;     //[11..10] BOD1 detect voltage threshold select
X            volatile uint8_t  BOD1_TH       :2;     
N                                        //0x0 = 2.0v
N                                        //0x1 = 2.4v
N                                        //0x2 = 3.7v
N                                        //0x3 = 4.2v
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :2;     //[17..16] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  WKSTP_DSEL    :2;     //[21..20] Wakeup delay time selection from STOP mode 
X            volatile uint8_t  WKSTP_DSEL    :2;     
N                                        //0x0 = DT0 (45~60us)
N                                        //0x1 = DT1 (60~75us)
N                                        //0x2 = DT2 (90~105us)
N                                        //0x3 = DT3 (150~165us)
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[25..24] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  PW control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  STP_POR       :1;     //[1] POR power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_POR       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  STP_BOD0      :1;     //[4] BOD0 power-on configuration after enter STOP mode
X            volatile uint8_t  STP_BOD0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  STP_BOD1      :1;     //[5] BOD1 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_BOD1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  SLP_CMP0      :1;     //[16] Analog comparator CMP0 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP0      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  SLP_CMP1      :1;     //[17] Analog comparator CMP1 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP1      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  SLP_CMP2      :1;     //[18] Analog comparator CMP2 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP2      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  SLP_CMP3      :1;     //[19] Analog comparator CMP3 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP3      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP0      :1;     //[20] Analog comparator CMP0 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP0      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP1      :1;     //[21] Analog comparator CMP1 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP1      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP2      :1;     //[22] Analog comparator CMP2 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP2      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP3      :1;     //[23] Analog comparator CMP3 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP3      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  PW control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :4;     //[3..0] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  WKSTP_BOD0    :1;     //[4] BOD0 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_BOD0    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_BOD1    :1;     //[5] BOD1 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_BOD1    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  WKSTP_CMP0    :1;     //[16] Analog comparator CMP0 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP0    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_CMP1    :1;     //[17] Analog comparator CMP1 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP1    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_CMP2    :1;     //[18] Analog comparator CMP2 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP2    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_CMP3    :1;     //[19] Analog comparator CMP3 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP3    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }WKSTP0;                            /*!< WKSTP0     ~ Offset[0x18]  PW STOP mode wakeup control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WKSTP_RTC     :1;     //[5] RTC module events wakeup from STOP mode enable bit
X            volatile uint8_t  WKSTP_RTC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_IWDT    :1;     //[6] IWDT module events wakeup from STOP mode enable bit
X            volatile uint8_t  WKSTP_IWDT    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WKSTP_I2C0    :1;     //[8] I2C0 slave address detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_I2C0    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_I2C1    :1;     //[9] I2C1 slave address detection event wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_I2C1    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :7;     //[30..24] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }WKSTP1;                            /*!< WKSTP1     ~ Offset[0x1C]  PW STOP mode wakeup control register 1 */
N
N} PW_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        PW  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define PW_Base                         ((uint32_t)0x4C020000)              /*!< Power Management Controller */
N#define PW                              ((PW_Struct*) PW_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        PW  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        PW_STA  [register's definitions]
N *              Offset[0x00]  PW status register (0x4C020000)
N ******************************************************************************
N */
N///@{
N#define PW_STA_default                              ((uint32_t)0x00000002)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_STA */
N#define PW_STA_BOD1_S_mask_w                        ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define PW_STA_BOD1_S_mask_h1                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PW_STA_BOD1_S_mask_b3                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_STA_BOD1_S_high_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):High of 32bit */
N#define PW_STA_BOD1_S_high_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):High of 16bit */
N#define PW_STA_BOD1_S_high_b3                       ((uint8_t )0x00)        /*!< Bit Value =(0):High of 8bit */
N#define PW_STA_BOD1_S_low_w                         ((uint32_t)0x02000000)  /*!< Bit Value =(1):Low of 32bit */
N#define PW_STA_BOD1_S_low_h1                        ((uint16_t)0x0200)      /*!< Bit Value =(1):Low of 16bit */
N#define PW_STA_BOD1_S_low_b3                        ((uint8_t )0x02)        /*!< Bit Value =(1):Low of 8bit */
N
N#define PW_STA_WKMODE_mask_w                        ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define PW_STA_WKMODE_mask_h1                       ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define PW_STA_WKMODE_mask_b2                       ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define PW_STA_WKMODE_none_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NONE of 32bit */
N#define PW_STA_WKMODE_none_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NONE of 16bit */
N#define PW_STA_WKMODE_none_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):NONE of 8bit */
N#define PW_STA_WKMODE_sleep_w                       ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):SLEEP of 32bit */
N#define PW_STA_WKMODE_sleep_h1                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):SLEEP of 16bit */
N#define PW_STA_WKMODE_sleep_b2                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):SLEEP of 8bit */
N#define PW_STA_WKMODE_stop_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):STOP of 32bit */
N#define PW_STA_WKMODE_stop_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):STOP of 16bit */
N#define PW_STA_WKMODE_stop_b2                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):STOP of 8bit */
N
N#define PW_STA_STATE_mask_w                         ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define PW_STA_STATE_mask_h1                        ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define PW_STA_STATE_mask_b2                        ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define PW_STA_STATE_on_w                           ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ON of 32bit */
N#define PW_STA_STATE_on_h1                          ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ON of 16bit */
N#define PW_STA_STATE_on_b2                          ((uint8_t )0x00)        /*!< Bit Value =(0x0):ON of 8bit */
N#define PW_STA_STATE_sleep_w                        ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):SLEEP of 32bit */
N#define PW_STA_STATE_sleep_h1                       ((uint16_t)0x0001)      /*!< Bit Value =(0x1):SLEEP of 16bit */
N#define PW_STA_STATE_sleep_b2                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):SLEEP of 8bit */
N#define PW_STA_STATE_stop_w                         ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):STOP of 32bit */
N#define PW_STA_STATE_stop_h1                        ((uint16_t)0x0002)      /*!< Bit Value =(0x2):STOP of 16bit */
N#define PW_STA_STATE_stop_b2                        ((uint8_t )0x02)        /*!< Bit Value =(0x2):STOP of 8bit */
N
N#define PW_STA_WKF_mask_w                           ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PW_STA_WKF_mask_h0                          ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_STA_WKF_mask_b0                          ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_STA_WKF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_WKF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_WKF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_WKF_happened_w                       ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_WKF_happened_h0                      ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_WKF_happened_b0                      ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define PW_STA_BOD1F_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_STA_BOD1F_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_STA_BOD1F_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_STA_BOD1F_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_BOD1F_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_BOD1F_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_BOD1F_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_BOD1F_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_BOD1F_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define PW_STA_BOD0F_mask_w                         ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_STA_BOD0F_mask_h0                        ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_STA_BOD0F_mask_b0                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_STA_BOD0F_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_BOD0F_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_BOD0F_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_BOD0F_happened_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_BOD0F_happened_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_BOD0F_happened_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define PW_STA_PORF_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PW_STA_PORF_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_STA_PORF_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_STA_PORF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_PORF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_PORF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_PORF_happened_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_PORF_happened_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_PORF_happened_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_INT  [register's definitions]
N *              Offset[0x04]  PW interrupt enable register (0x4C020004)
N ******************************************************************************
N */
N///@{
N#define PW_INT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_INT */
N#define PW_INT_WK_IE_mask_w                         ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PW_INT_WK_IE_mask_h0                        ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_INT_WK_IE_mask_b0                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_INT_WK_IE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_WK_IE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_WK_IE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_WK_IE_enable_w                       ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_WK_IE_enable_h0                      ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_WK_IE_enable_b0                      ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_INT_BOD1_IE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_INT_BOD1_IE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_INT_BOD1_IE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_INT_BOD1_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_BOD1_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_BOD1_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_BOD1_IE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_BOD1_IE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_BOD1_IE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_INT_BOD0_IE_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_INT_BOD0_IE_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_INT_BOD0_IE_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_INT_BOD0_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_BOD0_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_BOD0_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_BOD0_IE_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_BOD0_IE_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_BOD0_IE_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_INT_IEA_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PW_INT_IEA_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PW_INT_IEA_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_INT_IEA_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_IEA_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_IEA_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_IEA_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_IEA_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_IEA_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_KEY  [register's definitions]
N *              Offset[0x0C]  PW write protected Key register (0x4C02000C)
N ******************************************************************************
N */
N///@{
N#define PW_KEY_default                              ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_KEY */
N#define PW_KEY_KEY_mask_w                           ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define PW_KEY_KEY_mask_h0                          ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define PW_KEY_KEY_unprotected_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define PW_KEY_KEY_unprotected_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define PW_KEY_KEY_unprotected_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define PW_KEY_KEY_protected_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define PW_KEY_KEY_protected_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define PW_KEY_KEY_protected_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_CR0  [register's definitions]
N *              Offset[0x10]  PW control register 0 (0x4C020010)
N ******************************************************************************
N */
N///@{
N#define PW_CR0_default                              ((uint32_t)0x00000080)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_CR0 */
N#define PW_CR0_WKSTP_DSEL_mask_w                    ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define PW_CR0_WKSTP_DSEL_mask_h1                   ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define PW_CR0_WKSTP_DSEL_mask_b2                   ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt0_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DT0 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt0_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DT0 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt0_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DT0 of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt1_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):DT1 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt1_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DT1 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt1_b2                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DT1 of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt2_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):DT2 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt2_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DT2 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt2_b2                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DT2 of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt3_w                     ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):DT3 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt3_h1                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DT3 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt3_b2                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DT3 of 8bit */
N
N#define PW_CR0_BOD1_TH_mask_w                       ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD1_TH_mask_h0                      ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD1_TH_mask_b1                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD1_TH_2_0v_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):2.0v of 32bit */
N#define PW_CR0_BOD1_TH_2_0v_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):2.0v of 16bit */
N#define PW_CR0_BOD1_TH_2_0v_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):2.0v of 8bit */
N#define PW_CR0_BOD1_TH_2_4v_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):2.4v of 32bit */
N#define PW_CR0_BOD1_TH_2_4v_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x1):2.4v of 16bit */
N#define PW_CR0_BOD1_TH_2_4v_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x1):2.4v of 8bit */
N#define PW_CR0_BOD1_TH_3_7v_w                       ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):3.7v of 32bit */
N#define PW_CR0_BOD1_TH_3_7v_h0                      ((uint16_t)0x0800)      /*!< Bit Value =(0x2):3.7v of 16bit */
N#define PW_CR0_BOD1_TH_3_7v_b1                      ((uint8_t )0x08)        /*!< Bit Value =(0x2):3.7v of 8bit */
N#define PW_CR0_BOD1_TH_4_2v_w                       ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):4.2v of 32bit */
N#define PW_CR0_BOD1_TH_4_2v_h0                      ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):4.2v of 16bit */
N#define PW_CR0_BOD1_TH_4_2v_b1                      ((uint8_t )0x0C)        /*!< Bit Value =(0x3):4.2v of 8bit */
N
N#define PW_CR0_BOD1_TRGS_mask_w                     ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD1_TRGS_mask_h0                    ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD1_TRGS_mask_b1                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD1_TRGS_rising_edge_w              ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define PW_CR0_BOD1_TRGS_rising_edge_h0             ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define PW_CR0_BOD1_TRGS_rising_edge_b1             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define PW_CR0_BOD1_TRGS_falling_edge_w             ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define PW_CR0_BOD1_TRGS_falling_edge_h0            ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define PW_CR0_BOD1_TRGS_falling_edge_b1            ((uint8_t )0x02)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define PW_CR0_BOD1_TRGS_dual_edge_w                ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define PW_CR0_BOD1_TRGS_dual_edge_h0               ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define PW_CR0_BOD1_TRGS_dual_edge_b1               ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define PW_CR0_LDO_STP_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PW_CR0_LDO_STP_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_CR0_LDO_STP_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_CR0_LDO_STP_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_CR0_LDO_STP_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_CR0_LDO_STP_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_CR0_LDO_STP_low_power_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Low power of 32bit */
N#define PW_CR0_LDO_STP_low_power_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Low power of 16bit */
N#define PW_CR0_LDO_STP_low_power_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Low power of 8bit */
N
N#define PW_CR0_LDO_ON_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PW_CR0_LDO_ON_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PW_CR0_LDO_ON_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define PW_CR0_LDO_ON_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_CR0_LDO_ON_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_CR0_LDO_ON_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_CR0_LDO_ON_low_power_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Low power of 32bit */
N#define PW_CR0_LDO_ON_low_power_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Low power of 16bit */
N#define PW_CR0_LDO_ON_low_power_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Low power of 8bit */
N
N#define PW_CR0_BOD1_EN_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD1_EN_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD1_EN_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD1_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR0_BOD1_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR0_BOD1_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR0_BOD1_EN_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR0_BOD1_EN_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR0_BOD1_EN_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR0_BOD0_EN_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD0_EN_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD0_EN_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD0_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR0_BOD0_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR0_BOD0_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR0_BOD0_EN_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR0_BOD0_EN_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR0_BOD0_EN_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR0_IVR_EN_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PW_CR0_IVR_EN_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_CR0_IVR_EN_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_CR0_IVR_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR0_IVR_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR0_IVR_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR0_IVR_EN_enable_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR0_IVR_EN_enable_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR0_IVR_EN_enable_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_CR1  [register's definitions]
N *              Offset[0x14]  PW control register 1 (0x4C020014)
N ******************************************************************************
N */
N///@{
N#define PW_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_CR1 */
N#define PW_CR1_STP_CMP3_mask_w                      ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP3_mask_h1                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP3_mask_b2                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP3_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP3_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP3_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP3_power_on_w                  ((uint32_t)0x00800000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP3_power_on_h1                 ((uint16_t)0x0080)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP3_power_on_b2                 ((uint8_t )0x80)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_CMP2_mask_w                      ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP2_mask_h1                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP2_mask_b2                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP2_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP2_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP2_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP2_power_on_w                  ((uint32_t)0x00400000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP2_power_on_h1                 ((uint16_t)0x0040)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP2_power_on_b2                 ((uint8_t )0x40)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_CMP1_mask_w                      ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP1_mask_h1                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP1_mask_b2                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP1_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP1_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP1_power_on_w                  ((uint32_t)0x00200000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP1_power_on_h1                 ((uint16_t)0x0020)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP1_power_on_b2                 ((uint8_t )0x20)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_CMP0_mask_w                      ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP0_mask_h1                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP0_mask_b2                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP0_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP0_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP0_power_on_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP0_power_on_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP0_power_on_b2                 ((uint8_t )0x10)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP3_mask_w                      ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP3_mask_h1                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP3_mask_b2                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP3_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP3_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP3_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP3_power_on_w                  ((uint32_t)0x00080000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP3_power_on_h1                 ((uint16_t)0x0008)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP3_power_on_b2                 ((uint8_t )0x08)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP2_mask_w                      ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP2_mask_h1                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP2_mask_b2                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP2_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP2_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP2_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP2_power_on_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP2_power_on_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP2_power_on_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP1_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP1_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP1_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP1_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP1_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP1_power_on_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP1_power_on_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP1_power_on_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP0_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP0_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP0_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP0_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP0_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP0_power_on_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP0_power_on_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP0_power_on_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_BOD1_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_BOD1_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_BOD1_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_BOD1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_BOD1_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_BOD1_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_BOD1_enable_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR1_STP_BOD1_enable_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR1_STP_BOD1_enable_b0                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR1_STP_BOD0_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_BOD0_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_BOD0_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_BOD0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_BOD0_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_BOD0_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_BOD0_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR1_STP_BOD0_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR1_STP_BOD0_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR1_STP_POR_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_POR_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_POR_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_POR_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_POR_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_POR_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_POR_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR1_STP_POR_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR1_STP_POR_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_WKSTP0  [register's definitions]
N *              Offset[0x18]  PW STOP mode wakeup control register 0 (0x4C020018)
N ******************************************************************************
N */
N///@{
N#define PW_WKSTP0_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_WKSTP0 */
N#define PW_WKSTP0_WKSTP_CMP3_mask_w                 ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP3_mask_h1                ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP3_mask_b2                ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP3_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP3_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP3_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP3_enable_w               ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP3_enable_h1              ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP3_enable_b2              ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_CMP2_mask_w                 ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP2_mask_h1                ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP2_mask_b2                ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP2_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP2_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP2_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP2_enable_w               ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP2_enable_h1              ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP2_enable_b2              ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_CMP1_mask_w                 ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP1_mask_h1                ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP1_mask_b2                ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP1_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP1_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP1_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP1_enable_w               ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP1_enable_h1              ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP1_enable_b2              ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_CMP0_mask_w                 ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP0_mask_h1                ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP0_mask_b2                ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP0_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP0_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP0_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP0_enable_w               ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP0_enable_h1              ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP0_enable_b2              ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_BOD1_mask_w                 ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_BOD1_mask_h0                ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_BOD1_mask_b0                ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_BOD1_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD1_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD1_disable_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_BOD1_enable_w               ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD1_enable_h0              ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD1_enable_b0              ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_BOD0_mask_w                 ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_BOD0_mask_h0                ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_BOD0_mask_b0                ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_BOD0_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD0_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD0_disable_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_BOD0_enable_w               ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD0_enable_h0              ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD0_enable_b0              ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_WKSTP1  [register's definitions]
N *              Offset[0x1C]  PW STOP mode wakeup control register 1 (0x4C02001C)
N ******************************************************************************
N */
N///@{
N#define PW_WKSTP1_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_WKSTP1 */
N#define PW_WKSTP1_WKSTP_I2C1_mask_w                 ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_I2C1_mask_h0                ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_I2C1_mask_b1                ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_I2C1_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C1_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C1_disable_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_I2C1_enable_w               ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C1_enable_h0              ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C1_enable_b1              ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP1_WKSTP_I2C0_mask_w                 ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_I2C0_mask_h0                ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_I2C0_mask_b1                ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_I2C0_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C0_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C0_disable_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_I2C0_enable_w               ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C0_enable_h0              ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C0_enable_b1              ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP1_WKSTP_IWDT_mask_w                 ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_IWDT_mask_h0                ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_IWDT_mask_b0                ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_IWDT_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_IWDT_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_IWDT_disable_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_IWDT_enable_w               ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_IWDT_enable_h0              ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_IWDT_enable_b0              ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP1_WKSTP_RTC_mask_w                  ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_RTC_mask_h0                 ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_RTC_mask_b0                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_RTC_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_RTC_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_RTC_disable_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_RTC_enable_w                ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_RTC_enable_h0               ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_RTC_enable_b0               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_PW_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_PW.h                          */
N/*----------------------------------------------------------------------------*/
L 35 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_PW_Init.h" 2
N
N
N/**
N ******************************************************************************
N *
N * @struct      PW_InitConfig[]
N *              PW initial configuration array
N *
N ******************************************************************************
N */
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
Nstatic const unsigned int CONF_PW_InitConfig[] =
N{
N//  <h> Configure PW Module
N//      <q3.1>  Enable Internal Voltage Reference 1.4V
N/*      <q3.4>  Enable BOD0 */
N//      <e3.5>  Enable BOD1
N//          <o3.10..11> Select BOD1 Detect Voltage threshold <0=> 2.0V
N//                                                           <1=> 2.4V
N//                                                           <2=> 3.7V
N//                                                           <3=> 4.2V
N//          <o3.8..9> Select Interrupt Trigger <0=> No Interrupt
N//                                             <1=> Rising Edge
N//                                             <2=> Falling Edge
N//                                             <3=> Dual-Edge
N//      </e>
N//      <o3.20..21> Select Wake-Up Delay From Stop Mode <0=> Level0 (0~15us)  
N//                                                      <1=> Level1 (30~45us)  
N//                                                      <2=> Level2 (60~75us)  
N//                                                      <3=> Level3 (120~135us)      
N/*      <o3.16..17> Select Low Power LDO <0=> LV0 (Lowest level)  */
N/*                                       <1=> LV1 (the same LV2)  */
N/*                                       <2=> LV2 (the same LV1)  */
N/*                                       <3=> LV3 (Highest level) */
N//      <o3.7> Select Core Voltage LDO When STOP Mode <0=> Normal
N//                                                    <1=> Low Power
N/*      <o3.6> Select Core Voltage LDO When ON Mode <0=> Normal    */
N/*                                                  <1=> Low Power */
N//      <e1.0> Configure Interrupt (IEA)
N//          <q1.4>  BOD0
N//          <q1.5>  BOD1
N//          <q1.7>  Wakeup
N//      </e>
N    
N//      <h> Configure Analog Module In Sleep Mode 
N//          <q4.16> Comparator CMP0
N//          <q4.17> Comparator CMP1
N//          <q4.18> Comparator CMP2
N//          <q4.19> Comparator CMP3
N//      </h>
N
N//      <h> Configure Analog Module In Stop Mode 
N/*          <q4.1>  Power On  disable */
N/*          <q4.4>  BOD0  disable     */
N//          <q4.5>  BOD1
N//          <q4.20> Comparator CMP0
N//          <q4.21> Comparator CMP1
N//          <q4.22> Comparator CMP2
N//          <q4.23> Comparator CMP3
N//      </h>
N
N//      <h> Configure Wakeup In Stop Mode
N//      <i> GPIO wake-up by EXIC interrupt configured.
N/*          <q5.4>  BOD0  disable*/
N//          <q5.5>  BOD1
N//          <q5.16> Comparator CMP0
N//          <q5.17> Comparator CMP1
N//          <q5.18> Comparator CMP2
N//          <q5.19> Comparator CMP3
N//          <q6.5>  RTC
N//          <q6.6>  IWDT
N//          <q6.8>  I2C0 (Detect Slave Address Only)
N//          <q6.9>  I2C1 (Detect Slave Address Only)
N//      </h>
N
N//  </h>
N
N//*** <<< end of configuration section >>>    ***
N
N0x00000000, // PW_STA 0 not use
N0x00000000, // PW_INT 1 not use
N0x00000000, // PW_KEY 2 not use
N0x00000090, // PW_CR0 3
N0x00000000, // PW_CR1 4
N0x00000010, // PW_WKSTP0 5
N0x00000000, // PW_WKSTP1 6
N};
N
N
N/**
N * @name	Function announce
N *   		
N */
N///@{  
Nvoid PW_Init (void);
N///@}
N
N
N#endif  // _MG32x02z_PW_INIT_H
N
N
L 38 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_RST
N    #include "MG32x02z_RST_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_RST_Init.h" 1
N/**
N *******************************************************************************
N * @file        MG32x02z_RST_Init.h
N *
N * @brief       The RST Init include file.
N *
N * MG32x02z remote controller
N * @version     V1.11
N * @date        2018/08/31
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2018 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N 
N
N#ifndef _MG32x02z_RST_INIT_H
N/*!< _MG32x02z_RST_INIT_H */ 
N#define _MG32x02z_RST_INIT_H
N
N
N#include "stdint.h"
N#include "stdio.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 35 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_RST_Init.h" 2
N#include "string.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 36 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_RST_Init.h" 2
N#include "MG32x02z.h"
N#include "MG32x02z_RST.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_RST.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_RST.h
N *
N * @brief       MG32x02z RST Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_RST_H
N#define _MG32x02z_RST_H
N#define _MG32x02z_RST_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_RST_H_VER)
S    #error "MG32x02z_RST_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      RST_Struct
N *              RST  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PORF          :1;     //[0] Power-on reset flag
X            volatile uint8_t  PORF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  SWF           :1;     //[1] Software forced reset flag
X            volatile uint8_t  SWF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  EXF           :1;     //[2] External input reset flag
X            volatile uint8_t  EXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CPUF          :1;     //[3] CPU SYSRESETREQ bit system reset flag
X            volatile uint8_t  CPUF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  BOD0F         :1;     //[4] BOD0 reset flag
X            volatile uint8_t  BOD0F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  BOD1F         :1;     //[5] BOD1 reset flag
X            volatile uint8_t  BOD1F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  LPMF          :1;     //[6] Low power mode reset flag
X            volatile uint8_t  LPMF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CSCF          :1;     //[8] CSC missing clock detect reset flag
X            volatile uint8_t  CSCF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MEMF          :1;     //[10] Flash memory read/write protect or illegal address error reset flag
X            volatile uint8_t  MEMF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  IWDTF         :1;     //[11] IWDT reset flag
X            volatile uint8_t  IWDTF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  WWDTF         :1;     //[12] WWDT reset flag
X            volatile uint8_t  WWDTF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  ADCF          :1;     //[13] ADC analog voltage watch-dog reset flag
X            volatile uint8_t  ADCF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CMP0F         :1;     //[16] Comparator CMP0 threshold comparison reset flag
X            volatile uint8_t  CMP0F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CMP1F         :1;     //[17] Comparator CMP1 threshold comparison reset flag
X            volatile uint8_t  CMP1F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CMP2F         :1;     //[18] Comparator CMP2 threshold comparison reset flag
X            volatile uint8_t  CMP2F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CMP3F         :1;     //[19] Comparator CMP3 threshold comparison reset flag
X            volatile uint8_t  CMP3F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  WRF           :1;     //[30] Warm reset flag
X            volatile uint8_t  WRF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CRF           :1;     //[31] Cold reset flag
X            volatile uint8_t  CRF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  RST Reset status register */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x04]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] Reset key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __IO uint16_t LOCK          :16;    //[31..16] Reset lock register
X            volatile uint16_t LOCK          :16;    
N                                        //0 = Unlocked
N                                        //1 = Locked
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  RST write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SW_EN         :1;     //[1] System software forced reset enable for whole chip reset
X            volatile uint8_t  SW_EN         :1;     
N                                        //0 = No operation
N                                        //1 = Generate reset
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  PA_DIS0       :1;     //[8] Warm reset disable for PA[3:0] pins
X            volatile uint8_t  PA_DIS0       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PA_DIS1       :1;     //[9] Warm reset disable for PA[11:8] pins
X            volatile uint8_t  PA_DIS1       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PB_DIS0       :1;     //[10] Warm reset disable for PB[3:0] pins
X            volatile uint8_t  PB_DIS0       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PB_DIS1       :1;     //[11] Warm reset disable for PB[11:8] pins
X            volatile uint8_t  PB_DIS1       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PC_DIS0       :1;     //[12] Warm reset disable for PC[3:0] pins
X            volatile uint8_t  PC_DIS0       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PC_DIS1       :1;     //[13] Warm reset disable for PC[11:8] pins
X            volatile uint8_t  PC_DIS1       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PD_DIS0       :1;     //[14] Warm reset disable for PD[3:0] pins
X            volatile uint8_t  PD_DIS0       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PD_DIS1       :1;     //[15] Warm reset disable for PD[11:8] pins
X            volatile uint8_t  PD_DIS1       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PE_DIS0       :1;     //[16] Warm reset disable for PE[3:0] pins
X            volatile uint8_t  PE_DIS0       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PE_DIS1       :1;     //[17] Warm reset disable for PE[9:8] pins
X            volatile uint8_t  PE_DIS1       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  WWDT_WDIS     :1;     //[24] WWDT module Warm reset disable bit
X            volatile uint8_t  WWDT_WDIS     :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  RST control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SW_CE         :1;     //[1] Software forced Cold reset enable. (This bit only reset by POR reset)
X            volatile uint8_t  SW_CE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EX_CE         :1;     //[2] External input Cold reset enable. (This bit only reset by POR reset)
X            volatile uint8_t  EX_CE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CPU_CE        :1;     //[3] CPU SYSRESETREQ bit forced Cold reset enable. (This bit only reset by POR reset)
X            volatile uint8_t  CPU_CE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD0_CE       :1;     //[4] BOD0 Cold reset enable.
X            volatile uint8_t  BOD0_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD1_CE       :1;     //[5] BOD1 Cold reset enable.
X            volatile uint8_t  BOD1_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LPM_CE        :1;     //[6] Low power STOP mode Cold reset enable. (This bit only reset by POR reset) 
X            volatile uint8_t  LPM_CE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CSC_CE        :1;     //[8] CSC missing clock detect Cold reset enable. (This bit only reset by POR reset) 
X            volatile uint8_t  CSC_CE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MEM_CE        :1;     //[10] Flash memory read/write protect or illegal address error Cold reset enable
X            volatile uint8_t  MEM_CE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IWDT_CE       :1;     //[11] IWDT Cold reset enable. (This bit only reset by POR reset) 
X            volatile uint8_t  IWDT_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WWDT_CE       :1;     //[12] WWDT Cold reset enable. (This bit only reset by POR reset) 
X            volatile uint8_t  WWDT_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ADC_CE        :1;     //[13] ADC analog voltage watch-dog Cold reset enable. (This bit only reset by POR reset) 
X            volatile uint8_t  ADC_CE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CMP0_CE       :1;     //[16] Comparator CMP0 threshold comparison Cold reset enable
X            volatile uint8_t  CMP0_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CMP1_CE       :1;     //[17] Comparator CMP1 threshold comparison Cold reset enable
X            volatile uint8_t  CMP1_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CMP2_CE       :1;     //[18] Comparator CMP2 threshold comparison Cold reset enable
X            volatile uint8_t  CMP2_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CMP3_CE       :1;     //[19] Comparator CMP3 threshold comparison Cold reset enable
X            volatile uint8_t  CMP3_CE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CE;                                /*!< CE         ~ Offset[0x14]  RST Cold reset enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SW_WE         :1;     //[1] Software forced Warm reset enable. 
X            volatile uint8_t  SW_WE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EX_WE         :1;     //[2] External input Warm reset enable
X            volatile uint8_t  EX_WE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CPU_WE        :1;     //[3] CPU SYSRESETREQ bit forced Warm reset enable. 
X            volatile uint8_t  CPU_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD0_WE       :1;     //[4] BOD0 Warm reset enable
X            volatile uint8_t  BOD0_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD1_WE       :1;     //[5] BOD1 Warm reset enable
X            volatile uint8_t  BOD1_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LPM_WE        :1;     //[6] Low power STOP mode Warm reset enable.  
X            volatile uint8_t  LPM_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CSC_WE        :1;     //[8] CSC missing clock detect Warm reset enable.  
X            volatile uint8_t  CSC_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MEM_WE        :1;     //[10] Flash memory read/write protect or illegal address error Warm reset enable.  
X            volatile uint8_t  MEM_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IWDT_WE       :1;     //[11] IWDT Warm reset enable
X            volatile uint8_t  IWDT_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WWDT_WE       :1;     //[12] WWDT Warm reset enable.  
X            volatile uint8_t  WWDT_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ADC_WE        :1;     //[13] ADC analog voltage watch-dog Warm reset enable.  
X            volatile uint8_t  ADC_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CMP0_WE       :1;     //[16] Comparator CMP0 threshold comparison Warm reset enable.   
X            volatile uint8_t  CMP0_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CMP1_WE       :1;     //[17] Comparator CMP1 threshold comparison Warm reset enable.  
X            volatile uint8_t  CMP1_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CMP2_WE       :1;     //[18] Comparator CMP2 threshold comparison Warm reset enable.  
X            volatile uint8_t  CMP2_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CMP3_WE       :1;     //[19] Comparator CMP3 threshold comparison Warm reset enable.  
X            volatile uint8_t  CMP3_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }WE;                                /*!< WE         ~ Offset[0x18]  RST Warm reset enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IOPA_EN       :1;     //[0] System software forced reset enable for IO Port-A.
X            volatile uint8_t  IOPA_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  IOPB_EN       :1;     //[1] System software forced reset enable for IO Port-B.
X            volatile uint8_t  IOPB_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  IOPC_EN       :1;     //[2] System software forced reset enable for IO Port-C.
X            volatile uint8_t  IOPC_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  IOPD_EN       :1;     //[3] System software forced reset enable for IO Port-D.
X            volatile uint8_t  IOPD_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  IOPE_EN       :1;     //[4] System software forced reset enable for IO Port-E.
X            volatile uint8_t  IOPE_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  GPL_EN        :1;     //[8] System software forced reset enable for GPL module.
X            volatile uint8_t  GPL_EN        :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :3;     //[11..9] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  EMB_EN        :1;     //[12] System software forced reset enable for EMB module.
X            volatile uint8_t  EMB_EN        :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }AHB;                               /*!< AHB        ~ Offset[0x1C]  RST AHB reset register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ADC0_EN       :1;     //[0] System software forced reset enable for ADC0 module.
X            volatile uint8_t  ADC0_EN       :1;     
N                                        //0 = No operation
N                                        //1 = Generate reset
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CMP_EN        :1;     //[2] System software forced reset enable for CMP module.
X            volatile uint8_t  CMP_EN        :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  DAC_EN        :1;     //[3] System software forced reset enable for DAC module.
X            volatile uint8_t  DAC_EN        :1;     
N                                        //0 = No operation
N                                        //1 = Generate reset
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RTC_EN        :1;     //[5] System software forced reset enable for RTC module.
X            volatile uint8_t  RTC_EN        :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  IWDT_EN       :1;     //[6] System software forced reset enable for IWDT module.
X            volatile uint8_t  IWDT_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  WWDT_EN       :1;     //[7] System software forced reset enable for WWDT module.
X            volatile uint8_t  WWDT_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  I2C0_EN       :1;     //[8] System software forced reset enable for I2C0 module.
X            volatile uint8_t  I2C0_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  I2C1_EN       :1;     //[9] System software forced reset enable for I2C1 module.
X            volatile uint8_t  I2C1_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SPI0_EN       :1;     //[12] System software forced reset enable for SP00 module.
X            volatile uint8_t  SPI0_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  URT0_EN       :1;     //[16] System software forced reset enable for URT0 module.
X            volatile uint8_t  URT0_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  URT1_EN       :1;     //[17] System software forced reset enable for URT1 module.
X            volatile uint8_t  URT1_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  URT2_EN       :1;     //[18] System software forced reset enable for URT2 module.
X            volatile uint8_t  URT2_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  URT3_EN       :1;     //[19] System software forced reset enable for URT3 module.
X            volatile uint8_t  URT3_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }APB0;                              /*!< APB0       ~ Offset[0x20]  RST APB reset register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TM00_EN       :1;     //[0] System software forced reset enable for TM00 module.
X            volatile uint8_t  TM00_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  TM01_EN       :1;     //[1] System software forced reset enable for TM01 module.
X            volatile uint8_t  TM01_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  TM10_EN       :1;     //[4] System software forced reset enable for TM10 module.
X            volatile uint8_t  TM10_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TM16_EN       :1;     //[7] System software forced reset enable for TM16 module.
X            volatile uint8_t  TM16_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __IO uint8_t  TM20_EN       :1;     //[8] System software forced reset enable for TM20 module.
X            volatile uint8_t  TM20_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TM26_EN       :1;     //[11] System software forced reset enable for TM26 module.
X            volatile uint8_t  TM26_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint8_t                :1;     //[12] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[14..13] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  TM36_EN       :1;     //[15] System software forced reset enable for TM36 module.
X            volatile uint8_t  TM36_EN       :1;     
N                                        //0 = No-Reset
N                                        //1 = Reset
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }APB1;                              /*!< APB1       ~ Offset[0x24]  RST APB reset register 1 */
N
N} RST_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        RST  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define RST_Base                        ((uint32_t)0x4C000000)              /*!< Reset Source Controller */
N#define RST                             ((RST_Struct*) RST_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        RST  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        RST_STA  [register's definitions]
N *              Offset[0x00]  RST Reset status register (0x4C000000)
N ******************************************************************************
N */
N///@{
N#define RST_STA_default                             ((uint32_t)0xC0000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_STA */
N#define RST_STA_CRF_mask_w                          ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define RST_STA_CRF_mask_h1                         ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define RST_STA_CRF_mask_b3                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RST_STA_CRF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CRF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CRF_normal_b3                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CRF_happened_w                      ((uint32_t)0x80000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CRF_happened_h1                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CRF_happened_b3                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_WRF_mask_w                          ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define RST_STA_WRF_mask_h1                         ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define RST_STA_WRF_mask_b3                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RST_STA_WRF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_WRF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_WRF_normal_b3                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_WRF_happened_w                      ((uint32_t)0x40000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_WRF_happened_h1                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_WRF_happened_b3                     ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_CMP3F_mask_w                        ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define RST_STA_CMP3F_mask_h1                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_STA_CMP3F_mask_b2                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_STA_CMP3F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CMP3F_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CMP3F_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CMP3F_happened_w                    ((uint32_t)0x00080000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CMP3F_happened_h1                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CMP3F_happened_b2                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_CMP2F_mask_w                        ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define RST_STA_CMP2F_mask_h1                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_STA_CMP2F_mask_b2                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_STA_CMP2F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CMP2F_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CMP2F_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CMP2F_happened_w                    ((uint32_t)0x00040000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CMP2F_happened_h1                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CMP2F_happened_b2                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_CMP1F_mask_w                        ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define RST_STA_CMP1F_mask_h1                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_STA_CMP1F_mask_b2                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_STA_CMP1F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CMP1F_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CMP1F_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CMP1F_happened_w                    ((uint32_t)0x00020000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CMP1F_happened_h1                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CMP1F_happened_b2                   ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_CMP0F_mask_w                        ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define RST_STA_CMP0F_mask_h1                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_STA_CMP0F_mask_b2                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_STA_CMP0F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CMP0F_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CMP0F_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CMP0F_happened_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CMP0F_happened_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CMP0F_happened_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_ADCF_mask_w                         ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define RST_STA_ADCF_mask_h0                        ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define RST_STA_ADCF_mask_b1                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_STA_ADCF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_ADCF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_ADCF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_ADCF_happened_w                     ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_ADCF_happened_h0                    ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_ADCF_happened_b1                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_WWDTF_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define RST_STA_WWDTF_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define RST_STA_WWDTF_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_STA_WWDTF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_WWDTF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_WWDTF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_WWDTF_happened_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_WWDTF_happened_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_WWDTF_happened_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_IWDTF_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define RST_STA_IWDTF_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define RST_STA_IWDTF_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_STA_IWDTF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_IWDTF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_IWDTF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_IWDTF_happened_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_IWDTF_happened_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_IWDTF_happened_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_MEMF_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define RST_STA_MEMF_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define RST_STA_MEMF_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_STA_MEMF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_MEMF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_MEMF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_MEMF_happened_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_MEMF_happened_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_MEMF_happened_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_CSCF_mask_w                         ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_STA_CSCF_mask_h0                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_STA_CSCF_mask_b1                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_STA_CSCF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CSCF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CSCF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CSCF_happened_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CSCF_happened_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CSCF_happened_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_LPMF_mask_w                         ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define RST_STA_LPMF_mask_h0                        ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define RST_STA_LPMF_mask_b0                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RST_STA_LPMF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_LPMF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_LPMF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_LPMF_happened_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_LPMF_happened_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_LPMF_happened_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_BOD1F_mask_w                        ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define RST_STA_BOD1F_mask_h0                       ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define RST_STA_BOD1F_mask_b0                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_STA_BOD1F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_BOD1F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_BOD1F_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_BOD1F_happened_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_BOD1F_happened_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_BOD1F_happened_b0                   ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_BOD0F_mask_w                        ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RST_STA_BOD0F_mask_h0                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RST_STA_BOD0F_mask_b0                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_STA_BOD0F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_BOD0F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_BOD0F_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_BOD0F_happened_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_BOD0F_happened_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_BOD0F_happened_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_CPUF_mask_w                         ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RST_STA_CPUF_mask_h0                        ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_STA_CPUF_mask_b0                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_STA_CPUF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_CPUF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_CPUF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_CPUF_happened_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_CPUF_happened_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_CPUF_happened_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_EXF_mask_w                          ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RST_STA_EXF_mask_h0                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_STA_EXF_mask_b0                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_STA_EXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_EXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_EXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_EXF_happened_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_EXF_happened_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_EXF_happened_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_SWF_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RST_STA_SWF_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_STA_SWF_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_STA_SWF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_SWF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_SWF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_SWF_happened_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_SWF_happened_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_SWF_happened_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RST_STA_PORF_mask_w                         ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RST_STA_PORF_mask_h0                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_STA_PORF_mask_b0                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_STA_PORF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RST_STA_PORF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RST_STA_PORF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RST_STA_PORF_happened_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define RST_STA_PORF_happened_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define RST_STA_PORF_happened_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_KEY  [register's definitions]
N *              Offset[0x0C]  RST write protected Key register (0x4C00000C)
N ******************************************************************************
N */
N///@{
N#define RST_KEY_default                             ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_KEY */
N#define RST_KEY_LOCK_mask_w                         ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define RST_KEY_LOCK_mask_h1                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define RST_KEY_LOCK_unlocked_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unlocked of 32bit */
N#define RST_KEY_LOCK_unlocked_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Unlocked of 16bit */
N#define RST_KEY_LOCK_unlocked_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Unlocked of 8bit */
N#define RST_KEY_LOCK_locked_w                       ((uint32_t)0x00010000)  /*!< Bit Value =(1):Locked of 32bit */
N#define RST_KEY_LOCK_locked_h1                      ((uint16_t)0x0001)      /*!< Bit Value =(1):Locked of 16bit */
N#define RST_KEY_LOCK_locked_b2                      ((uint8_t )0x01)        /*!< Bit Value =(1):Locked of 8bit */
N
N#define RST_KEY_KEY_mask_w                          ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define RST_KEY_KEY_mask_h0                         ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define RST_KEY_KEY_unprotected_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define RST_KEY_KEY_unprotected_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define RST_KEY_KEY_unprotected_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define RST_KEY_KEY_protected_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define RST_KEY_KEY_protected_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define RST_KEY_KEY_protected_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_CR0  [register's definitions]
N *              Offset[0x10]  RST control register 0 (0x4C000010)
N ******************************************************************************
N */
N///@{
N#define RST_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_CR0 */
N#define RST_CR0_WWDT_WDIS_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_WWDT_WDIS_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_CR0_WWDT_WDIS_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_CR0_WWDT_WDIS_enable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_WWDT_WDIS_enable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_WWDT_WDIS_enable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_WWDT_WDIS_disable_w                 ((uint32_t)0x01000000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_WWDT_WDIS_disable_h1                ((uint16_t)0x0100)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_WWDT_WDIS_disable_b3                ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PE_DIS1_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PE_DIS1_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PE_DIS1_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PE_DIS1_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PE_DIS1_enable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PE_DIS1_enable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PE_DIS1_disable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PE_DIS1_disable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PE_DIS1_disable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PE_DIS0_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PE_DIS0_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PE_DIS0_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PE_DIS0_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PE_DIS0_enable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PE_DIS0_enable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PE_DIS0_disable_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PE_DIS0_disable_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PE_DIS0_disable_b2                  ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PD_DIS1_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PD_DIS1_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PD_DIS1_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PD_DIS1_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PD_DIS1_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PD_DIS1_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PD_DIS1_disable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PD_DIS1_disable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PD_DIS1_disable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PD_DIS0_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PD_DIS0_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PD_DIS0_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PD_DIS0_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PD_DIS0_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PD_DIS0_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PD_DIS0_disable_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PD_DIS0_disable_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PD_DIS0_disable_b1                  ((uint8_t )0x40)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PC_DIS1_mask_w                      ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PC_DIS1_mask_h0                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PC_DIS1_mask_b1                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PC_DIS1_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PC_DIS1_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PC_DIS1_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PC_DIS1_disable_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PC_DIS1_disable_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PC_DIS1_disable_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PC_DIS0_mask_w                      ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PC_DIS0_mask_h0                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PC_DIS0_mask_b1                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PC_DIS0_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PC_DIS0_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PC_DIS0_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PC_DIS0_disable_w                   ((uint32_t)0x00001000)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PC_DIS0_disable_h0                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PC_DIS0_disable_b1                  ((uint8_t )0x10)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PB_DIS1_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PB_DIS1_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PB_DIS1_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PB_DIS1_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PB_DIS1_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PB_DIS1_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PB_DIS1_disable_w                   ((uint32_t)0x00000800)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PB_DIS1_disable_h0                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PB_DIS1_disable_b1                  ((uint8_t )0x08)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PB_DIS0_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PB_DIS0_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PB_DIS0_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PB_DIS0_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PB_DIS0_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PB_DIS0_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PB_DIS0_disable_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PB_DIS0_disable_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PB_DIS0_disable_b1                  ((uint8_t )0x04)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PA_DIS1_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PA_DIS1_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PA_DIS1_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PA_DIS1_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PA_DIS1_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PA_DIS1_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PA_DIS1_disable_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PA_DIS1_disable_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PA_DIS1_disable_b1                  ((uint8_t )0x02)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_PA_DIS0_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_CR0_PA_DIS0_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_CR0_PA_DIS0_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_CR0_PA_DIS0_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define RST_CR0_PA_DIS0_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define RST_CR0_PA_DIS0_enable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define RST_CR0_PA_DIS0_disable_w                   ((uint32_t)0x00000100)  /*!< Bit Value =(1):Disable of 32bit */
N#define RST_CR0_PA_DIS0_disable_h0                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Disable of 16bit */
N#define RST_CR0_PA_DIS0_disable_b1                  ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define RST_CR0_SW_EN_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RST_CR0_SW_EN_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_CR0_SW_EN_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_CR0_SW_EN_no_operation_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):No operation of 32bit */
N#define RST_CR0_SW_EN_no_operation_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):No operation of 16bit */
N#define RST_CR0_SW_EN_no_operation_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):No operation of 8bit */
N#define RST_CR0_SW_EN_generate_reset_w              ((uint32_t)0x00000002)  /*!< Bit Value =(1):Generate reset of 32bit */
N#define RST_CR0_SW_EN_generate_reset_h0             ((uint16_t)0x0002)      /*!< Bit Value =(1):Generate reset of 16bit */
N#define RST_CR0_SW_EN_generate_reset_b0             ((uint8_t )0x02)        /*!< Bit Value =(1):Generate reset of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_CE  [register's definitions]
N *              Offset[0x14]  RST Cold reset enable register (0x4C000014)
N ******************************************************************************
N */
N///@{
N#define RST_CE_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_CE */
N#define RST_CE_CMP3_CE_mask_w                       ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define RST_CE_CMP3_CE_mask_h1                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_CE_CMP3_CE_mask_b2                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_CE_CMP3_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_CMP3_CE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_CMP3_CE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_CMP3_CE_enable_w                     ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_CMP3_CE_enable_h1                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_CMP3_CE_enable_b2                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_CMP2_CE_mask_w                       ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define RST_CE_CMP2_CE_mask_h1                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_CE_CMP2_CE_mask_b2                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_CE_CMP2_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_CMP2_CE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_CMP2_CE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_CMP2_CE_enable_w                     ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_CMP2_CE_enable_h1                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_CMP2_CE_enable_b2                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_CMP1_CE_mask_w                       ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define RST_CE_CMP1_CE_mask_h1                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_CE_CMP1_CE_mask_b2                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_CE_CMP1_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_CMP1_CE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_CMP1_CE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_CMP1_CE_enable_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_CMP1_CE_enable_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_CMP1_CE_enable_b2                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_CMP0_CE_mask_w                       ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define RST_CE_CMP0_CE_mask_h1                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_CE_CMP0_CE_mask_b2                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_CE_CMP0_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_CMP0_CE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_CMP0_CE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_CMP0_CE_enable_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_CMP0_CE_enable_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_CMP0_CE_enable_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_ADC_CE_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define RST_CE_ADC_CE_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define RST_CE_ADC_CE_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_CE_ADC_CE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_ADC_CE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_ADC_CE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_ADC_CE_enable_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_ADC_CE_enable_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_ADC_CE_enable_b1                     ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_WWDT_CE_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define RST_CE_WWDT_CE_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define RST_CE_WWDT_CE_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_CE_WWDT_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_WWDT_CE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_WWDT_CE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_WWDT_CE_enable_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_WWDT_CE_enable_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_WWDT_CE_enable_b1                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_IWDT_CE_mask_w                       ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define RST_CE_IWDT_CE_mask_h0                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define RST_CE_IWDT_CE_mask_b1                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_CE_IWDT_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_IWDT_CE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_IWDT_CE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_IWDT_CE_enable_w                     ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_IWDT_CE_enable_h0                    ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_IWDT_CE_enable_b1                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_MEM_CE_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define RST_CE_MEM_CE_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define RST_CE_MEM_CE_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_CE_MEM_CE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_MEM_CE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_MEM_CE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_MEM_CE_enable_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_MEM_CE_enable_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_MEM_CE_enable_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_CSC_CE_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_CE_CSC_CE_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_CE_CSC_CE_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_CE_CSC_CE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_CSC_CE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_CSC_CE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_CSC_CE_enable_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_CSC_CE_enable_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_CSC_CE_enable_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_LPM_CE_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define RST_CE_LPM_CE_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define RST_CE_LPM_CE_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RST_CE_LPM_CE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_LPM_CE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_LPM_CE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_LPM_CE_enable_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_LPM_CE_enable_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_LPM_CE_enable_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_BOD1_CE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define RST_CE_BOD1_CE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define RST_CE_BOD1_CE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_CE_BOD1_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_BOD1_CE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_BOD1_CE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_BOD1_CE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_BOD1_CE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_BOD1_CE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_BOD0_CE_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RST_CE_BOD0_CE_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RST_CE_BOD0_CE_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_CE_BOD0_CE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_BOD0_CE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_BOD0_CE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_BOD0_CE_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_BOD0_CE_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_BOD0_CE_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_CPU_CE_mask_w                        ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RST_CE_CPU_CE_mask_h0                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_CE_CPU_CE_mask_b0                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_CE_CPU_CE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_CPU_CE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_CPU_CE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_CPU_CE_enable_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_CPU_CE_enable_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_CPU_CE_enable_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_EX_CE_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RST_CE_EX_CE_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_CE_EX_CE_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_CE_EX_CE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_EX_CE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_EX_CE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_EX_CE_enable_w                       ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_EX_CE_enable_h0                      ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_EX_CE_enable_b0                      ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_CE_SW_CE_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RST_CE_SW_CE_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_CE_SW_CE_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_CE_SW_CE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_CE_SW_CE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_CE_SW_CE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_CE_SW_CE_enable_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_CE_SW_CE_enable_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_CE_SW_CE_enable_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_WE  [register's definitions]
N *              Offset[0x18]  RST Warm reset enable register (0x4C000018)
N ******************************************************************************
N */
N///@{
N#define RST_WE_default                              ((uint32_t)0x0000000E)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_WE */
N#define RST_WE_CMP3_WE_mask_w                       ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define RST_WE_CMP3_WE_mask_h1                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_WE_CMP3_WE_mask_b2                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_WE_CMP3_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_CMP3_WE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_CMP3_WE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_CMP3_WE_enable_w                     ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_CMP3_WE_enable_h1                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_CMP3_WE_enable_b2                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_CMP2_WE_mask_w                       ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define RST_WE_CMP2_WE_mask_h1                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_WE_CMP2_WE_mask_b2                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_WE_CMP2_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_CMP2_WE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_CMP2_WE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_CMP2_WE_enable_w                     ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_CMP2_WE_enable_h1                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_CMP2_WE_enable_b2                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_CMP1_WE_mask_w                       ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define RST_WE_CMP1_WE_mask_h1                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_WE_CMP1_WE_mask_b2                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_WE_CMP1_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_CMP1_WE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_CMP1_WE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_CMP1_WE_enable_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_CMP1_WE_enable_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_CMP1_WE_enable_b2                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_CMP0_WE_mask_w                       ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define RST_WE_CMP0_WE_mask_h1                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_WE_CMP0_WE_mask_b2                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_WE_CMP0_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_CMP0_WE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_CMP0_WE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_CMP0_WE_enable_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_CMP0_WE_enable_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_CMP0_WE_enable_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_ADC_WE_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define RST_WE_ADC_WE_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define RST_WE_ADC_WE_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_WE_ADC_WE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_ADC_WE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_ADC_WE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_ADC_WE_enable_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_ADC_WE_enable_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_ADC_WE_enable_b1                     ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_WWDT_WE_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define RST_WE_WWDT_WE_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define RST_WE_WWDT_WE_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_WE_WWDT_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_WWDT_WE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_WWDT_WE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_WWDT_WE_enable_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_WWDT_WE_enable_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_WWDT_WE_enable_b1                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_IWDT_WE_mask_w                       ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define RST_WE_IWDT_WE_mask_h0                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define RST_WE_IWDT_WE_mask_b1                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_WE_IWDT_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_IWDT_WE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_IWDT_WE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_IWDT_WE_enable_w                     ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_IWDT_WE_enable_h0                    ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_IWDT_WE_enable_b1                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_MEM_WE_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define RST_WE_MEM_WE_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define RST_WE_MEM_WE_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_WE_MEM_WE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_MEM_WE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_MEM_WE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_MEM_WE_enable_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_MEM_WE_enable_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_MEM_WE_enable_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_CSC_WE_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_WE_CSC_WE_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_WE_CSC_WE_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_WE_CSC_WE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_CSC_WE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_CSC_WE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_CSC_WE_enable_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_CSC_WE_enable_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_CSC_WE_enable_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_LPM_WE_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define RST_WE_LPM_WE_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define RST_WE_LPM_WE_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RST_WE_LPM_WE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_LPM_WE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_LPM_WE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_LPM_WE_enable_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_LPM_WE_enable_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_LPM_WE_enable_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_BOD1_WE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define RST_WE_BOD1_WE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define RST_WE_BOD1_WE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_WE_BOD1_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_BOD1_WE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_BOD1_WE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_BOD1_WE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_BOD1_WE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_BOD1_WE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_BOD0_WE_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RST_WE_BOD0_WE_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RST_WE_BOD0_WE_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_WE_BOD0_WE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_BOD0_WE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_BOD0_WE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_BOD0_WE_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_BOD0_WE_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_BOD0_WE_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_CPU_WE_mask_w                        ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RST_WE_CPU_WE_mask_h0                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_WE_CPU_WE_mask_b0                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_WE_CPU_WE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_CPU_WE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_CPU_WE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_CPU_WE_enable_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_CPU_WE_enable_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_CPU_WE_enable_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_EX_WE_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RST_WE_EX_WE_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_WE_EX_WE_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_WE_EX_WE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_EX_WE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_EX_WE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_EX_WE_enable_w                       ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_EX_WE_enable_h0                      ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_EX_WE_enable_b0                      ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RST_WE_SW_WE_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RST_WE_SW_WE_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_WE_SW_WE_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_WE_SW_WE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RST_WE_SW_WE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RST_WE_SW_WE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RST_WE_SW_WE_enable_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define RST_WE_SW_WE_enable_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RST_WE_SW_WE_enable_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_AHB  [register's definitions]
N *              Offset[0x1C]  RST AHB reset register (0x4C00001C)
N ******************************************************************************
N */
N///@{
N#define RST_AHB_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_AHB */
N#define RST_AHB_EMB_EN_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define RST_AHB_EMB_EN_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define RST_AHB_EMB_EN_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_AHB_EMB_EN_no_reset_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_EMB_EN_no_reset_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_EMB_EN_no_reset_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_EMB_EN_reset_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_EMB_EN_reset_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_EMB_EN_reset_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_AHB_GPL_EN_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_AHB_GPL_EN_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_AHB_GPL_EN_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_AHB_GPL_EN_no_reset_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_GPL_EN_no_reset_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_GPL_EN_no_reset_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_GPL_EN_reset_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_GPL_EN_reset_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_GPL_EN_reset_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_AHB_IOPE_EN_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RST_AHB_IOPE_EN_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RST_AHB_IOPE_EN_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_AHB_IOPE_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_IOPE_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_IOPE_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_IOPE_EN_reset_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_IOPE_EN_reset_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_IOPE_EN_reset_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_AHB_IOPD_EN_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RST_AHB_IOPD_EN_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_AHB_IOPD_EN_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_AHB_IOPD_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_IOPD_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_IOPD_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_IOPD_EN_reset_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_IOPD_EN_reset_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_IOPD_EN_reset_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_AHB_IOPC_EN_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RST_AHB_IOPC_EN_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_AHB_IOPC_EN_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_AHB_IOPC_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_IOPC_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_IOPC_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_IOPC_EN_reset_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_IOPC_EN_reset_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_IOPC_EN_reset_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_AHB_IOPB_EN_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RST_AHB_IOPB_EN_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_AHB_IOPB_EN_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_AHB_IOPB_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_IOPB_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_IOPB_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_IOPB_EN_reset_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_IOPB_EN_reset_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_IOPB_EN_reset_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_AHB_IOPA_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RST_AHB_IOPA_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_AHB_IOPA_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_AHB_IOPA_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_AHB_IOPA_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_AHB_IOPA_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_AHB_IOPA_EN_reset_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_AHB_IOPA_EN_reset_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_AHB_IOPA_EN_reset_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Reset of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_APB0  [register's definitions]
N *              Offset[0x20]  RST APB reset register 0 (0x4C000020)
N ******************************************************************************
N */
N///@{
N#define RST_APB0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_APB0 */
N#define RST_APB0_URT3_EN_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define RST_APB0_URT3_EN_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_APB0_URT3_EN_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_APB0_URT3_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_URT3_EN_no_reset_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_URT3_EN_no_reset_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_URT3_EN_reset_w                    ((uint32_t)0x00080000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_URT3_EN_reset_h1                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_URT3_EN_reset_b2                   ((uint8_t )0x08)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_URT2_EN_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define RST_APB0_URT2_EN_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_APB0_URT2_EN_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_APB0_URT2_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_URT2_EN_no_reset_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_URT2_EN_no_reset_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_URT2_EN_reset_w                    ((uint32_t)0x00040000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_URT2_EN_reset_h1                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_URT2_EN_reset_b2                   ((uint8_t )0x04)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_URT1_EN_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define RST_APB0_URT1_EN_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_APB0_URT1_EN_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_APB0_URT1_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_URT1_EN_no_reset_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_URT1_EN_no_reset_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_URT1_EN_reset_w                    ((uint32_t)0x00020000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_URT1_EN_reset_h1                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_URT1_EN_reset_b2                   ((uint8_t )0x02)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_URT0_EN_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define RST_APB0_URT0_EN_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_APB0_URT0_EN_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_APB0_URT0_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_URT0_EN_no_reset_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_URT0_EN_no_reset_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_URT0_EN_reset_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_URT0_EN_reset_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_URT0_EN_reset_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_SPI0_EN_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define RST_APB0_SPI0_EN_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define RST_APB0_SPI0_EN_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_APB0_SPI0_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_SPI0_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_SPI0_EN_no_reset_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_SPI0_EN_reset_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_SPI0_EN_reset_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_SPI0_EN_reset_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_I2C1_EN_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define RST_APB0_I2C1_EN_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define RST_APB0_I2C1_EN_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_APB0_I2C1_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_I2C1_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_I2C1_EN_no_reset_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_I2C1_EN_reset_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_I2C1_EN_reset_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_I2C1_EN_reset_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_I2C0_EN_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_APB0_I2C0_EN_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_APB0_I2C0_EN_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_APB0_I2C0_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_I2C0_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_I2C0_EN_no_reset_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_I2C0_EN_reset_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_I2C0_EN_reset_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_I2C0_EN_reset_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_WWDT_EN_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define RST_APB0_WWDT_EN_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define RST_APB0_WWDT_EN_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RST_APB0_WWDT_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_WWDT_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_WWDT_EN_no_reset_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_WWDT_EN_reset_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_WWDT_EN_reset_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_WWDT_EN_reset_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_IWDT_EN_mask_w                     ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define RST_APB0_IWDT_EN_mask_h0                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define RST_APB0_IWDT_EN_mask_b0                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RST_APB0_IWDT_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_IWDT_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_IWDT_EN_no_reset_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_IWDT_EN_reset_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_IWDT_EN_reset_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_IWDT_EN_reset_b0                   ((uint8_t )0x40)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_RTC_EN_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define RST_APB0_RTC_EN_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define RST_APB0_RTC_EN_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RST_APB0_RTC_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_RTC_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_RTC_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_RTC_EN_reset_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_RTC_EN_reset_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_RTC_EN_reset_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_DAC_EN_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RST_APB0_DAC_EN_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RST_APB0_DAC_EN_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_APB0_DAC_EN_no_operation_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):No operation of 32bit */
N#define RST_APB0_DAC_EN_no_operation_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):No operation of 16bit */
N#define RST_APB0_DAC_EN_no_operation_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):No operation of 8bit */
N#define RST_APB0_DAC_EN_generate_reset_w            ((uint32_t)0x00000008)  /*!< Bit Value =(1):Generate reset of 32bit */
N#define RST_APB0_DAC_EN_generate_reset_h0           ((uint16_t)0x0008)      /*!< Bit Value =(1):Generate reset of 16bit */
N#define RST_APB0_DAC_EN_generate_reset_b0           ((uint8_t )0x08)        /*!< Bit Value =(1):Generate reset of 8bit */
N
N#define RST_APB0_CMP_EN_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RST_APB0_CMP_EN_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RST_APB0_CMP_EN_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RST_APB0_CMP_EN_no_reset_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB0_CMP_EN_no_reset_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB0_CMP_EN_no_reset_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB0_CMP_EN_reset_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB0_CMP_EN_reset_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB0_CMP_EN_reset_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB0_ADC0_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RST_APB0_ADC0_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_APB0_ADC0_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_APB0_ADC0_EN_no_operation_w             ((uint32_t)0x00000000)  /*!< Bit Value =(0):No operation of 32bit */
N#define RST_APB0_ADC0_EN_no_operation_h0            ((uint16_t)0x0000)      /*!< Bit Value =(0):No operation of 16bit */
N#define RST_APB0_ADC0_EN_no_operation_b0            ((uint8_t )0x00)        /*!< Bit Value =(0):No operation of 8bit */
N#define RST_APB0_ADC0_EN_generate_reset_w           ((uint32_t)0x00000001)  /*!< Bit Value =(1):Generate reset of 32bit */
N#define RST_APB0_ADC0_EN_generate_reset_h0          ((uint16_t)0x0001)      /*!< Bit Value =(1):Generate reset of 16bit */
N#define RST_APB0_ADC0_EN_generate_reset_b0          ((uint8_t )0x01)        /*!< Bit Value =(1):Generate reset of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RST_APB1  [register's definitions]
N *              Offset[0x24]  RST APB reset register 1 (0x4C000024)
N ******************************************************************************
N */
N///@{
N#define RST_APB1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RST_APB1 */
N#define RST_APB1_TM36_EN_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM36_EN_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM36_EN_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM36_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM36_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM36_EN_no_reset_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM36_EN_reset_w                    ((uint32_t)0x00008000)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM36_EN_reset_h0                   ((uint16_t)0x8000)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM36_EN_reset_b1                   ((uint8_t )0x80)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB1_TM26_EN_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM26_EN_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM26_EN_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM26_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM26_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM26_EN_no_reset_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM26_EN_reset_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM26_EN_reset_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM26_EN_reset_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB1_TM20_EN_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM20_EN_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM20_EN_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM20_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM20_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM20_EN_no_reset_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM20_EN_reset_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM20_EN_reset_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM20_EN_reset_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB1_TM16_EN_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM16_EN_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM16_EN_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM16_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM16_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM16_EN_no_reset_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM16_EN_reset_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM16_EN_reset_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM16_EN_reset_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB1_TM10_EN_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM10_EN_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM10_EN_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM10_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM10_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM10_EN_no_reset_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM10_EN_reset_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM10_EN_reset_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM10_EN_reset_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB1_TM01_EN_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM01_EN_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM01_EN_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM01_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM01_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM01_EN_no_reset_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM01_EN_reset_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM01_EN_reset_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM01_EN_reset_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Reset of 8bit */
N
N#define RST_APB1_TM00_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RST_APB1_TM00_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RST_APB1_TM00_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RST_APB1_TM00_EN_no_reset_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Reset of 32bit */
N#define RST_APB1_TM00_EN_no_reset_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Reset of 16bit */
N#define RST_APB1_TM00_EN_no_reset_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Reset of 8bit */
N#define RST_APB1_TM00_EN_reset_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Reset of 32bit */
N#define RST_APB1_TM00_EN_reset_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Reset of 16bit */
N#define RST_APB1_TM00_EN_reset_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Reset of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_RST_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_RST.h                         */
N/*----------------------------------------------------------------------------*/
L 38 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_RST_Init.h" 2
N
N
N/**
N ******************************************************************************
N *
N * @struct      RST_InitConfig[]
N *              RST initial configuration array
N *
N ******************************************************************************
N */
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
Nstatic const unsigned int CONF_RST_InitConfig[] =
N{
N//  <h> Configure RST Module
N    
N//      <h> IO State Kept After Warm Reset
N//          <q3.8>  PA[3:0] pins
N//          <q3.9>  PA[11:8] pins
N//          <q3.10> PB[3:0] pins
N//          <q3.11> PB[11:8] pins
N//          <q3.12> PC[3:0] pins
N//          <q3.13> PC[11:8] pins
N//          <q3.14> PD[3:0] pins
N//          <q3.15> PD[11:8] pins
N//          <q3.16> PE[3:0] pins
N//          <q3.17> PE[9:8] pins
N//      </h>
N    
N//      <h> Cold Reset Source Configuration
N//          <q4.1>  Software Reset
N//          <q4.2>  External Reset Pin
N//          <q4.3>  CPU SYSRESETREQ Bit
N//          <q4.4>  BOD0
N//          <q4.5>  BOD1
N//          <q4.6>  Low Power STOP Mode
N//          <q4.8>  CSC Missing Clock Detect
N//          <q4.10> Flash Memory Read/Write/Erase Error
N//          <q4.11> IWDT
N//          <q4.12> WWDT
N//          <q4.13> ADC Analog Voltage Watch-Dog 
N//          <q4.16> Comparator CMP0
N//          <q4.17> Comparator CMP1
N//          <q4.18> Comparator CMP2
N//          <q4.19> Comparator CMP3
N//      </h>
N
N//      <h> Warm Reset Source Configuration
N//          <q5.1>  Software Reset
N//          <q5.2>  External Reset Pin
N//          <q5.3>  CPU SYSRESETREQ Bit
N//          <q5.4>  BOD0
N//          <q5.5>  BOD1
N//          <q5.6>  Low Power STOP Mode
N//          <q5.8>  CSC Missing Clock Detect
N//          <q5.10> Flash Memory Read/Write/Erase Error
N//          <q5.11> IWDT
N//          <q5.12> WWDT
N//          <q5.13> ADC Analog Voltage Watch-Dog 
N//          <q5.16> Comparator CMP0
N//          <q5.17> Comparator CMP1
N//          <q5.18> Comparator CMP2
N//          <q5.19> Comparator CMP3
N//      </h>
N
N//  </h>
N
N//*** <<< end of configuration section >>>    ***
N
N0x00000000, // RST_STA 0 not use
N0x00000000, // RST_INT 1 not use
N0x00000000, // RST_KEY 2 not use
N0x00000000, // RST_CR0 3
N0x00000000, // RST_CE 4
N0x0000000E, // RST_WE 5
N0x00000000, // RST_AHB 6
N0x00000000, // RST_APB0 7
N0x00000000, // RST_APB1 8
N};
N
N
N/**
N * @name	Function announce
N *   		
N */
N///@{  
Nvoid RST_Init (void);
N///@}
N
N#endif  // _MG32x02z_RST_INIT_H
L 42 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_GPIO
N    #include "MG32x02z_GPIO_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_GPIO_Init.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_GPIO_Init.h
N *
N * @brief       This file is used to configure GPIO setting.
N *              Device : MG32F02A132
N *              Package: LQFP80
N *
N * @par         Project
N *              MG32x02z
N * @version     V0.30
N * @date        2021/04/27 14:40 (H File Generated Date)
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer
N *      The Demo software is provided "AS IS"  without any warranty, either
N *      expressed or implied, including, but not limited to, the implied warranties
N *      of merchantability and fitness for a particular purpose.  The author will
N *      not be liable for any special, incidental, consequential or indirect
N *      damages due to loss of data or any other reason.
N *      These statements agree with the world wide and local dictated laws about
N *      authorship and violence against these laws.
N ******************************************************************************
N @if HIDE
N *Modify History:
N *>>
N *--
N *--
N *>>
N *>>
N *
N @endif
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_GPIO_Init_H
N
N#define _MG32x02z_GPIO_Init_H
N
N#include "MG32x02z.h"
N#include "MG32x02z_GPIO.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_GPIO.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_GPIO.h
N *
N * @brief       MG32x02z GPIO Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_GPIO_H
N#define _MG32x02z_GPIO_H
N#define _MG32x02z_GPIO_H_VER                        3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_GPIO_H_VER)
S    #error "MG32x02z_GPIO_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N *              GPIO  [Module Structure Typedef]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N *
N * @struct      GPIO_Struct
N *              GPIO Input/Output Register Control Definitions  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OUT0          :1;     //[0] IO pin PX0 output data bit.
X            volatile uint8_t  OUT0          :1;     
N            __IO uint8_t  OUT1          :1;     //[1] IO pin PX1 output data bit.
X            volatile uint8_t  OUT1          :1;     
N            __IO uint8_t  OUT2          :1;     //[2] IO pin PX2 output data bit.
X            volatile uint8_t  OUT2          :1;     
N            __IO uint8_t  OUT3          :1;     //[3] IO pin PX3 output data bit.
X            volatile uint8_t  OUT3          :1;     
N            __IO uint8_t  OUT4          :1;     //[4] IO pin PX4 output data bit.
X            volatile uint8_t  OUT4          :1;     
N            __IO uint8_t  OUT5          :1;     //[5] IO pin PX5 output data bit.
X            volatile uint8_t  OUT5          :1;     
N            __IO uint8_t  OUT6          :1;     //[6] IO pin PX6 output data bit.
X            volatile uint8_t  OUT6          :1;     
N            __IO uint8_t  OUT7          :1;     //[7] IO pin PX7 output data bit.
X            volatile uint8_t  OUT7          :1;     
N            __IO uint8_t  OUT8          :1;     //[8] IO pin PX8 output data bit.
X            volatile uint8_t  OUT8          :1;     
N            __IO uint8_t  OUT9          :1;     //[9] IO pin PX9 output data bit.
X            volatile uint8_t  OUT9          :1;     
N            __IO uint8_t  OUT10         :1;     //[10] IO pin PX10 output data bit.
X            volatile uint8_t  OUT10         :1;     
N            __IO uint8_t  OUT11         :1;     //[11] IO pin PX11 output data bit.
X            volatile uint8_t  OUT11         :1;     
N            __IO uint8_t  OUT12         :1;     //[12] IO pin PX12 output data bit.
X            volatile uint8_t  OUT12         :1;     
N            __IO uint8_t  OUT13         :1;     //[13] IO pin PX13 output data bit.
X            volatile uint8_t  OUT13         :1;     
N            __IO uint8_t  OUT14         :1;     //[14] IO pin PX14 output data bit.
X            volatile uint8_t  OUT14         :1;     
N            __IO uint8_t  OUT15         :1;     //[15] IO pin PX15 output data bit.
X            volatile uint8_t  OUT15         :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OUT;                               /*!< OUT        ~ Offset[0x00]  PX output data register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  IN0           :1;     //[0] IO pin PX0 input pin status.
X            volatile const  uint8_t  IN0           :1;     
N            __I  uint8_t  IN1           :1;     //[1] IO pin PX1 input pin status.
X            volatile const  uint8_t  IN1           :1;     
N            __I  uint8_t  IN2           :1;     //[2] IO pin PX2 input pin status.
X            volatile const  uint8_t  IN2           :1;     
N            __I  uint8_t  IN3           :1;     //[3] IO pin PX3 input pin status.
X            volatile const  uint8_t  IN3           :1;     
N            __I  uint8_t  IN4           :1;     //[4] IO pin PX4 input pin status.
X            volatile const  uint8_t  IN4           :1;     
N            __I  uint8_t  IN5           :1;     //[5] IO pin PX5 input pin status.
X            volatile const  uint8_t  IN5           :1;     
N            __I  uint8_t  IN6           :1;     //[6] IO pin PX6 input pin status.
X            volatile const  uint8_t  IN6           :1;     
N            __I  uint8_t  IN7           :1;     //[7] IO pin PX7 input pin status.
X            volatile const  uint8_t  IN7           :1;     
N            __I  uint8_t  IN8           :1;     //[8] IO pin PX8 input pin status.
X            volatile const  uint8_t  IN8           :1;     
N            __I  uint8_t  IN9           :1;     //[9] IO pin PX9 input pin status.
X            volatile const  uint8_t  IN9           :1;     
N            __I  uint8_t  IN10          :1;     //[10] IO pin PX10 input pin status.
X            volatile const  uint8_t  IN10          :1;     
N            __I  uint8_t  IN11          :1;     //[11] IO pin PX11 input pin status.
X            volatile const  uint8_t  IN11          :1;     
N            __I  uint8_t  IN12          :1;     //[12] IO pin PX12 input pin status.
X            volatile const  uint8_t  IN12          :1;     
N            __I  uint8_t  IN13          :1;     //[13] IO pin PX13 input pin status.
X            volatile const  uint8_t  IN13          :1;     
N            __I  uint8_t  IN14          :1;     //[14] IO pin PX14 input pin status.
X            volatile const  uint8_t  IN14          :1;     
N            __I  uint8_t  IN15          :1;     //[15] IO pin PX15 input pin status.
X            volatile const  uint8_t  IN15          :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }IN;                                /*!< IN         ~ Offset[0x04]  PX input data register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __O  uint8_t  SET0          :1;     //[0] IO pin PX0 set data bit
X            volatile  uint8_t  SET0          :1;     
N            __O  uint8_t  SET1          :1;     //[1] IO pin PX1 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET1          :1;     
N            __O  uint8_t  SET2          :1;     //[2] IO pin PX2 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET2          :1;     
N            __O  uint8_t  SET3          :1;     //[3] IO pin PX3 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET3          :1;     
N            __O  uint8_t  SET4          :1;     //[4] IO pin PX4 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET4          :1;     
N            __O  uint8_t  SET5          :1;     //[5] IO pin PX5 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET5          :1;     
N            __O  uint8_t  SET6          :1;     //[6] IO pin PX6 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET6          :1;     
N            __O  uint8_t  SET7          :1;     //[7] IO pin PX7 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET7          :1;     
N            __O  uint8_t  SET8          :1;     //[8] IO pin PX8 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET8          :1;     
N            __O  uint8_t  SET9          :1;     //[9] IO pin PX9 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET9          :1;     
N            __O  uint8_t  SET10         :1;     //[10] IO pin PX10 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET10         :1;     
N            __O  uint8_t  SET11         :1;     //[11] IO pin PX11 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET11         :1;     
N            __O  uint8_t  SET12         :1;     //[12] IO pin PX12 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET12         :1;     
N            __O  uint8_t  SET13         :1;     //[13] IO pin PX13 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET13         :1;     
N            __O  uint8_t  SET14         :1;     //[14] IO pin PX14 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET14         :1;     
N            __O  uint8_t  SET15         :1;     //[15] IO pin PX15 set data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  SET15         :1;     
N            __O  uint8_t  CLR0          :1;     //[16] IO pin PX0 clear data bit
X            volatile  uint8_t  CLR0          :1;     
N            __O  uint8_t  CLR1          :1;     //[17] IO pin PX1 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR1          :1;     
N            __O  uint8_t  CLR2          :1;     //[18] IO pin PX2 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR2          :1;     
N            __O  uint8_t  CLR3          :1;     //[19] IO pin PX3 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR3          :1;     
N            __O  uint8_t  CLR4          :1;     //[20] IO pin PX4 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR4          :1;     
N            __O  uint8_t  CLR5          :1;     //[21] IO pin PX5 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR5          :1;     
N            __O  uint8_t  CLR6          :1;     //[22] IO pin PX6 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR6          :1;     
N            __O  uint8_t  CLR7          :1;     //[23] IO pin PX7 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR7          :1;     
N            __O  uint8_t  CLR8          :1;     //[24] IO pin PX8 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR8          :1;     
N            __O  uint8_t  CLR9          :1;     //[25] IO pin PX9 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR9          :1;     
N            __O  uint8_t  CLR10         :1;     //[26] IO pin PX10 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR10         :1;     
N            __O  uint8_t  CLR11         :1;     //[27] IO pin PX11 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR11         :1;     
N            __O  uint8_t  CLR12         :1;     //[28] IO pin PX12 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR12         :1;     
N            __O  uint8_t  CLR13         :1;     //[29] IO pin PX13 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR13         :1;     
N            __O  uint8_t  CLR14         :1;     //[30] IO pin PX14 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR14         :1;     
N            __O  uint8_t  CLR15         :1;     //[31] IO pin PX15 clear data bit. This bit is no effect for writing 0.
X            volatile  uint8_t  CLR15         :1;     
N        }MBIT;
N    }SC;                                /*!< SC         ~ Offset[0x08]  PX port set / clear register */
N
N    __I uint32_t  RESERVED0;            /*!< Offset[0x0C]       Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SC0           :1;     //[0] GPIO Port set or clear bit for PX0.
X            volatile uint8_t  SC0           :1;     
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC1           :1;     //[8] GPIO Port set or clear bit for PX1.
X            volatile uint8_t  SC1           :1;     
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC2           :1;     //[16] GPIO Port set or clear bit for PX2.
X            volatile uint8_t  SC2           :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC3           :1;     //[24] GPIO Port set or clear bit for PX3.
X            volatile uint8_t  SC3           :1;     
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }SCR0;                              /*!< SCR0       ~ Offset[0x10]  PX port set and clear register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SC4           :1;     //[0] GPIO Port set or clear bit for PX4.
X            volatile uint8_t  SC4           :1;     
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC5           :1;     //[8] GPIO Port set or clear bit for PX5.
X            volatile uint8_t  SC5           :1;     
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC6           :1;     //[16] GPIO Port set or clear bit for PX6.
X            volatile uint8_t  SC6           :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC7           :1;     //[24] GPIO Port set or clear bit for PX7.
X            volatile uint8_t  SC7           :1;     
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }SCR1;                              /*!< SCR1       ~ Offset[0x14]  PX port set and clear register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SC8           :1;     //[0] GPIO Port set or clear bit for PX8.
X            volatile uint8_t  SC8           :1;     
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC9           :1;     //[8] GPIO Port set or clear bit for PX9.
X            volatile uint8_t  SC9           :1;     
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC10          :1;     //[16] GPIO Port set or clear bit for PX10.
X            volatile uint8_t  SC10          :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC11          :1;     //[24] GPIO Port set and clear bit for PX11.
X            volatile uint8_t  SC11          :1;     
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }SCR2;                              /*!< SCR2       ~ Offset[0x18]  PX port set and clear register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SC12          :1;     //[0] GPIO Port set or clear bit for PX12.
X            volatile uint8_t  SC12          :1;     
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC13          :1;     //[8] GPIO Port set or clear bit for PX13.
X            volatile uint8_t  SC13          :1;     
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC14          :1;     //[16] GPIO Port set or clear bit for PX14.
X            volatile uint8_t  SC14          :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  SC15          :1;     //[24] GPIO Port set or clear bit for PX15.
X            volatile uint8_t  SC15          :1;     
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }SCR3;                              /*!< SCR3       ~ Offset[0x1C]  PX port set and clear register 3 */
N
N} GPIO_Struct;
N
N/**
N ******************************************************************************
N *
N * @struct      IOM_Struct
N *              Port IO Mode/AFS Register Control Definitions  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR0;                              /*!< CR0        ~ Offset[0x00]  PX0 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR1;                              /*!< CR1        ~ Offset[0x04]  PX1 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR2;                              /*!< CR2        ~ Offset[0x08]  PX2 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR3;                              /*!< CR3        ~ Offset[0x0C]  PX3 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR4;                              /*!< CR4        ~ Offset[0x10]  PX4 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR5;                              /*!< CR5        ~ Offset[0x14]  PX5 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR6;                              /*!< CR6        ~ Offset[0x18]  PX6 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR7;                              /*!< CR7        ~ Offset[0x1C]  PX7 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR8;                              /*!< CR8        ~ Offset[0x20]  PX8 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR9;                              /*!< CR9        ~ Offset[0x24]  PX9 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR10;                             /*!< CR10       ~ Offset[0x28]  PX10 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR11;                             /*!< CR11       ~ Offset[0x2C]  PX11 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR12;                             /*!< CR12       ~ Offset[0x30]  PX12 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR13;                             /*!< CR13       ~ Offset[0x34]  PX13 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR14;                             /*!< CR14       ~ Offset[0x38]  PX14 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N    } CR15;                             /*!< CR15       ~ Offset[0x3C]  PX15 IO control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  FCKS          :3;     //[2..0] PX port input deglitch filter clock source select for all pins of the port.
X            volatile uint8_t  FCKS          :3;     
N                                        //0x0 = CLK_AHB
N                                        //0x1 = CLK_AHB_Div8 : CLK_AHB divide by 8
N                                        //0x2 = CLK_ILRCO
N                                        //0x3 = TM00_TRGO
N                                        //0x4 = CK_UT
N            __I  uint8_t                :3;     //[5..3] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }FLT;                               /*!< FLT        ~ Offset[0x40]  PX port input filter control register */
N
N} IOM_Struct;
N
N/**
N ******************************************************************************
N *
N * @struct      Pin_Struct
N *              Pin IO Mode/AFS Register Control Definitions  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IOM           :3;     //[2..0] PX0 pin IO mode control bits.
X            volatile uint8_t  IOM           :3;     
N                                        //0x0 = AIO : analog IO
N                                        //0x1 = ODO : open drain output
N                                        //0x2 = PPO : push pull output
N                                        //0x3 = DIN : Digital input
N                                        //0x4 = QB : Quasi-Bidirectional output drive high one CLK
N            __IO uint8_t  HS            :1;     //[3] PX0 pin output high speed mode enable bit.
X            volatile uint8_t  HS            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PU            :1;     //[5] PX0 pin pull-up resister enable bit.
X            volatile uint8_t  PU            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  INV           :1;     //[7] PX0 pin input inverse enable bit.
X            volatile uint8_t  INV           :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  ODC           :2;     //[9..8] PX0 pin output drive strength select.
X            volatile uint8_t  ODC           :2;     
N                                        //0x0 = Level0 : Drive strength-full
N                                        //0x1 = Level1 : Drive strength-1/2 (no function)
N                                        //0x2 = Level2 : Drive strength-1/4
N                                        //0x3 = Level3 : Drive strength-1/8 (no function)
N            __IO uint8_t  FDIV          :2;     //[11..10] PX0 pin input deglitch filter clock divider select.
X            volatile uint8_t  FDIV          :2;     
N                                        //0x0 = Bypass : Bypass filter
N                                        //0x1 = Div1 : Divided by 1
N                                        //0x2 = Div4 : Divided by 4
N                                        //0x3 = Div16 : Divided by 16
N            __IO uint8_t  AFS           :4;     //[15..12] PX0 pin alternate function select. Refer the GPIO AFS table for detail information.
X            volatile uint8_t  AFS           :4;     
N                                        //0x0 = AF0 : GPA0
N                                        //0x1 = AF1 : Reserved
N                                        //0x2 = AF2 : Reserved
N                                        //0x3 = AF3 : Reserved
N                                        //0x4 = AF4 : Reserved
N                                        //0x5 = AF5 : Reserved
N                                        //0x6 = AF6 : Reserved
N                                        //0x7 = AF7 : Reserved
N                                        //0x8 = AF8 : MA0
N                                        //0x9 = AF9 : Reserved
N            __I  uint16_t               :15;    //[30..16] 
X            volatile const  uint16_t               :15;    
N            __IO uint8_t  LCK           :1;     //[31] PX0 pin control register write un-locked control
X            volatile uint8_t  LCK           :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N        }MBIT;
N    }CR;                                /*!< CR         PXn IO control register (X={A,B,C,D,..},n={0~15}) */
N
N} Pin_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        GPIO  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define GPIOA_Base                      ((uint32_t)0x41000000)              /*!< GPIO Input/Output Register Control Definitions */
N#define GPIOB_Base                      ((uint32_t)0x41000020)              /*!< GPIO Input/Output Register Control Definitions */
N#define GPIOC_Base                      ((uint32_t)0x41000040)              /*!< GPIO Input/Output Register Control Definitions */
N#define GPIOD_Base                      ((uint32_t)0x41000060)              /*!< GPIO Input/Output Register Control Definitions */
N#define GPIOE_Base                      ((uint32_t)0x41000080)              /*!< GPIO Input/Output Register Control Definitions */
N#define GPIOA                           ((GPIO_Struct*) GPIOA_Base)
N#define GPIOB                           ((GPIO_Struct*) GPIOB_Base)
N#define GPIOC                           ((GPIO_Struct*) GPIOC_Base)
N#define GPIOD                           ((GPIO_Struct*) GPIOD_Base)
N#define GPIOE                           ((GPIO_Struct*) GPIOE_Base)
N
N#define IOMA_Base                       ((uint32_t)0x44000000)              /*!< Port IO Mode/AFS Register Control Definitions */
N#define IOMB_Base                       ((uint32_t)0x44010000)              /*!< Port IO Mode/AFS Register Control Definitions */
N#define IOMC_Base                       ((uint32_t)0x44020000)              /*!< Port IO Mode/AFS Register Control Definitions */
N#define IOMD_Base                       ((uint32_t)0x44030000)              /*!< Port IO Mode/AFS Register Control Definitions */
N#define IOME_Base                       ((uint32_t)0x44040000)              /*!< Port IO Mode/AFS Register Control Definitions */
N#define IOMA                            ((IOM_Struct*) IOMA_Base)
N#define IOMB                            ((IOM_Struct*) IOMB_Base)
N#define IOMC                            ((IOM_Struct*) IOMC_Base)
N#define IOMD                            ((IOM_Struct*) IOMD_Base)
N#define IOME                            ((IOM_Struct*) IOME_Base)
N#define PINA(PinNum)                    ((Pin_Struct*)((uint32_t) (IOMA_Base + (0x4*PinNum))))
N#define PINB(PinNum)                    ((Pin_Struct*)((uint32_t) (IOMB_Base + (0x4*PinNum))))
N#define PINC(PinNum)                    ((Pin_Struct*)((uint32_t) (IOMC_Base + (0x4*PinNum))))
N#define PIND(PinNum)                    ((Pin_Struct*)((uint32_t) (IOMD_Base + (0x4*PinNum))))
N#define PINE(PinNum)                    ((Pin_Struct*)((uint32_t) (IOME_Base + (0x4*PinNum))))
N///@}
N
N/**
N ******************************************************************************
N *
N * @name          [Register Definitions]
N *
N ******************************************************************************
N */
N
N/*----------------------------------------------------------------------------*/
N/* @module      IOP (GPIO Input/Output Register Control Definitions)          */
N/*----------------------------------------------------------------------------*/
N/**
N ******************************************************************************
N * @name        PX_OUT  [register's definitions]
N *              Offset[0x00]  PX output data register (0x41000000)
N ******************************************************************************
N */
N///@{
N#define PX_OUT_default                              ((uint32_t)0xFFFFFFFF)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_OUT */
N#define PX_OUT_OUT15_mask_w                         ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT15_mask_h0                        ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT15_mask_b1                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT14_mask_w                         ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT14_mask_h0                        ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT14_mask_b1                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT13_mask_w                         ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT13_mask_h0                        ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT13_mask_b1                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT12_mask_w                         ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT12_mask_h0                        ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT12_mask_b1                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT11_mask_w                         ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT11_mask_h0                        ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT11_mask_b1                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT10_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT10_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT10_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT9_mask_w                          ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT9_mask_h0                         ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT9_mask_b1                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT8_mask_w                          ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT8_mask_h0                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT8_mask_b1                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT7_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT7_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT7_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT6_mask_w                          ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT6_mask_h0                         ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT6_mask_b0                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT5_mask_w                          ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT5_mask_h0                         ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT5_mask_b0                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT4_mask_w                          ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT4_mask_h0                         ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT4_mask_b0                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT3_mask_w                          ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT3_mask_h0                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT3_mask_b0                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT2_mask_w                          ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT2_mask_h0                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT2_mask_b0                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT1_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT1_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT1_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_OUT_OUT0_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_OUT_OUT0_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_OUT_OUT0_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_IN  [register's definitions]
N *              Offset[0x04]  PX input data register (0x41000004)
N ******************************************************************************
N */
N///@{
N#define PX_IN_default                               ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_IN */
N#define PX_IN_IN15_mask_w                           ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN15_mask_h0                          ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN15_mask_b1                          ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN14_mask_w                           ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN14_mask_h0                          ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN14_mask_b1                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN13_mask_w                           ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN13_mask_h0                          ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN13_mask_b1                          ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN12_mask_w                           ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN12_mask_h0                          ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN12_mask_b1                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN11_mask_w                           ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN11_mask_h0                          ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN11_mask_b1                          ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN10_mask_w                           ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN10_mask_h0                          ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN10_mask_b1                          ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN9_mask_w                            ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN9_mask_h0                           ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN9_mask_b1                           ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN8_mask_w                            ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN8_mask_h0                           ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN8_mask_b1                           ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN7_mask_w                            ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN7_mask_h0                           ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN7_mask_b0                           ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN6_mask_w                            ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN6_mask_h0                           ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN6_mask_b0                           ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN5_mask_w                            ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN5_mask_h0                           ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN5_mask_b0                           ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN4_mask_w                            ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN4_mask_h0                           ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN4_mask_b0                           ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN3_mask_w                            ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN3_mask_h0                           ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN3_mask_b0                           ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN2_mask_w                            ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN2_mask_h0                           ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN2_mask_b0                           ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN1_mask_w                            ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN1_mask_h0                           ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN1_mask_b0                           ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_IN_IN0_mask_w                            ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_IN_IN0_mask_h0                           ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_IN_IN0_mask_b0                           ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_SC  [register's definitions]
N *              Offset[0x08]  PX port set / clear register (0x41000008)
N ******************************************************************************
N */
N///@{
N#define PX_SC_default                               ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_SC */
N#define PX_SC_CLR15_mask_w                          ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR15_mask_h1                         ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR15_mask_b3                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR14_mask_w                          ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR14_mask_h1                         ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR14_mask_b3                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR13_mask_w                          ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR13_mask_h1                         ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR13_mask_b3                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR12_mask_w                          ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR12_mask_h1                         ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR12_mask_b3                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR11_mask_w                          ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR11_mask_h1                         ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR11_mask_b3                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR10_mask_w                          ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR10_mask_h1                         ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR10_mask_b3                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR9_mask_w                           ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR9_mask_h1                          ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR9_mask_b3                          ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR8_mask_w                           ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR8_mask_h1                          ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR8_mask_b3                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR7_mask_w                           ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR7_mask_h1                          ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR7_mask_b2                          ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR6_mask_w                           ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR6_mask_h1                          ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR6_mask_b2                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR5_mask_w                           ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR5_mask_h1                          ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR5_mask_b2                          ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR4_mask_w                           ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR4_mask_h1                          ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR4_mask_b2                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR3_mask_w                           ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR3_mask_h1                          ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR3_mask_b2                          ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR2_mask_w                           ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR2_mask_h1                          ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR2_mask_b2                          ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR1_mask_w                           ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR1_mask_h1                          ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR1_mask_b2                          ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_CLR0_mask_w                           ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PX_SC_CLR0_mask_h1                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SC_CLR0_mask_b2                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET15_mask_w                          ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET15_mask_h0                         ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET15_mask_b1                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET14_mask_w                          ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET14_mask_h0                         ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET14_mask_b1                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET13_mask_w                          ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET13_mask_h0                         ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET13_mask_b1                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET12_mask_w                          ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET12_mask_h0                         ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET12_mask_b1                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET11_mask_w                          ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET11_mask_h0                         ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET11_mask_b1                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET10_mask_w                          ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET10_mask_h0                         ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET10_mask_b1                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET9_mask_w                           ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET9_mask_h0                          ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET9_mask_b1                          ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET8_mask_w                           ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET8_mask_h0                          ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET8_mask_b1                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET7_mask_w                           ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET7_mask_h0                          ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET7_mask_b0                          ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET6_mask_w                           ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET6_mask_h0                          ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET6_mask_b0                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET5_mask_w                           ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET5_mask_h0                          ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET5_mask_b0                          ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET4_mask_w                           ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET4_mask_h0                          ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET4_mask_b0                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET3_mask_w                           ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET3_mask_h0                          ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET3_mask_b0                          ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET2_mask_w                           ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET2_mask_h0                          ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET2_mask_b0                          ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET1_mask_w                           ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET1_mask_h0                          ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET1_mask_b0                          ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N
N#define PX_SC_SET0_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_SC_SET0_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SC_SET0_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_SCR0  [register's definitions]
N *              Offset[0x10]  PX port set and clear register 0 (0x41000010)
N ******************************************************************************
N */
N///@{
N#define PX_SCR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_SCR0 */
N#define PX_SCR0_SC3_mask_w                          ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define PX_SCR0_SC3_mask_h1                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR0_SC3_mask_b3                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR0_SC2_mask_w                          ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PX_SCR0_SC2_mask_h1                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR0_SC2_mask_b2                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR0_SC1_mask_w                          ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_SCR0_SC1_mask_h0                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR0_SC1_mask_b1                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR0_SC0_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_SCR0_SC0_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR0_SC0_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_SCR1  [register's definitions]
N *              Offset[0x14]  PX port set and clear register 1 (0x41000014)
N ******************************************************************************
N */
N///@{
N#define PX_SCR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_SCR1 */
N#define PX_SCR1_SC7_mask_w                          ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define PX_SCR1_SC7_mask_h1                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR1_SC7_mask_b3                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR1_SC6_mask_w                          ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PX_SCR1_SC6_mask_h1                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR1_SC6_mask_b2                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR1_SC5_mask_w                          ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_SCR1_SC5_mask_h0                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR1_SC5_mask_b1                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR1_SC4_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_SCR1_SC4_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR1_SC4_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_SCR2  [register's definitions]
N *              Offset[0x18]  PX port set and clear register 2 (0x41000018)
N ******************************************************************************
N */
N///@{
N#define PX_SCR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_SCR2 */
N#define PX_SCR2_SC11_mask_w                         ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define PX_SCR2_SC11_mask_h1                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR2_SC11_mask_b3                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR2_SC10_mask_w                         ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PX_SCR2_SC10_mask_h1                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR2_SC10_mask_b2                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR2_SC9_mask_w                          ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_SCR2_SC9_mask_h0                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR2_SC9_mask_b1                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR2_SC8_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_SCR2_SC8_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR2_SC8_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_SCR3  [register's definitions]
N *              Offset[0x1C]  PX port set and clear register 3 (0x4100001C)
N ******************************************************************************
N */
N///@{
N#define PX_SCR3_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PX_SCR3 */
N#define PX_SCR3_SC15_mask_w                         ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define PX_SCR3_SC15_mask_h1                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR3_SC15_mask_b3                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR3_SC14_mask_w                         ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PX_SCR3_SC14_mask_h1                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR3_SC14_mask_b2                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR3_SC13_mask_w                         ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PX_SCR3_SC13_mask_h0                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PX_SCR3_SC13_mask_b1                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define PX_SCR3_SC12_mask_w                         ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PX_SCR3_SC12_mask_h0                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PX_SCR3_SC12_mask_b0                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PX_CR  [register's definitions]
N *              Pin IO Mode/AFS Register Control Definitions
N ******************************************************************************
N */
N///@{
N#define PX_CR_LCK_mask_w                            ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define PX_CR_LCK_mask_h1                           ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define PX_CR_LCK_mask_b3                           ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PX_CR_LCK_locked_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define PX_CR_LCK_locked_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define PX_CR_LCK_locked_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define PX_CR_LCK_un_locked_w                       ((uint32_t)0x80000000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define PX_CR_LCK_un_locked_h1                      ((uint16_t)0x8000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define PX_CR_LCK_un_locked_b3                      ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define PX_CR_AFS_mask_w                            ((uint32_t)0x0000F000)  /*!< Bit Mask of 32bit */
N#define PX_CR_AFS_mask_h0                           ((uint16_t)0xF000)      /*!< Bit Mask of 16bit */
N#define PX_CR_AFS_mask_b1                           ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define PX_CR_AFS_af0_w                             ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):AF0 of 32bit */
N#define PX_CR_AFS_af0_h0                            ((uint16_t)0x0000)      /*!< Bit Value =(0x0):AF0 of 16bit */
N#define PX_CR_AFS_af0_b1                            ((uint8_t )0x00)        /*!< Bit Value =(0x0):AF0 of 8bit */
N#define PX_CR_AFS_af1_w                             ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):AF1 of 32bit */
N#define PX_CR_AFS_af1_h0                            ((uint16_t)0x1000)      /*!< Bit Value =(0x1):AF1 of 16bit */
N#define PX_CR_AFS_af1_b1                            ((uint8_t )0x10)        /*!< Bit Value =(0x1):AF1 of 8bit */
N#define PX_CR_AFS_af2_w                             ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):AF2 of 32bit */
N#define PX_CR_AFS_af2_h0                            ((uint16_t)0x2000)      /*!< Bit Value =(0x2):AF2 of 16bit */
N#define PX_CR_AFS_af2_b1                            ((uint8_t )0x20)        /*!< Bit Value =(0x2):AF2 of 8bit */
N#define PX_CR_AFS_af3_w                             ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):AF3 of 32bit */
N#define PX_CR_AFS_af3_h0                            ((uint16_t)0x3000)      /*!< Bit Value =(0x3):AF3 of 16bit */
N#define PX_CR_AFS_af3_b1                            ((uint8_t )0x30)        /*!< Bit Value =(0x3):AF3 of 8bit */
N#define PX_CR_AFS_af4_w                             ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):AF4 of 32bit */
N#define PX_CR_AFS_af4_h0                            ((uint16_t)0x4000)      /*!< Bit Value =(0x4):AF4 of 16bit */
N#define PX_CR_AFS_af4_b1                            ((uint8_t )0x40)        /*!< Bit Value =(0x4):AF4 of 8bit */
N#define PX_CR_AFS_af5_w                             ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):AF5 of 32bit */
N#define PX_CR_AFS_af5_h0                            ((uint16_t)0x5000)      /*!< Bit Value =(0x5):AF5 of 16bit */
N#define PX_CR_AFS_af5_b1                            ((uint8_t )0x50)        /*!< Bit Value =(0x5):AF5 of 8bit */
N#define PX_CR_AFS_af6_w                             ((uint32_t)0x00006000)  /*!< Bit Value =(0x6):AF6 of 32bit */
N#define PX_CR_AFS_af6_h0                            ((uint16_t)0x6000)      /*!< Bit Value =(0x6):AF6 of 16bit */
N#define PX_CR_AFS_af6_b1                            ((uint8_t )0x60)        /*!< Bit Value =(0x6):AF6 of 8bit */
N#define PX_CR_AFS_af7_w                             ((uint32_t)0x00007000)  /*!< Bit Value =(0x7):AF7 of 32bit */
N#define PX_CR_AFS_af7_h0                            ((uint16_t)0x7000)      /*!< Bit Value =(0x7):AF7 of 16bit */
N#define PX_CR_AFS_af7_b1                            ((uint8_t )0x70)        /*!< Bit Value =(0x7):AF7 of 8bit */
N#define PX_CR_AFS_af8_w                             ((uint32_t)0x00008000)  /*!< Bit Value =(0x8):AF8 of 32bit */
N#define PX_CR_AFS_af8_h0                            ((uint16_t)0x8000)      /*!< Bit Value =(0x8):AF8 of 16bit */
N#define PX_CR_AFS_af8_b1                            ((uint8_t )0x80)        /*!< Bit Value =(0x8):AF8 of 8bit */
N#define PX_CR_AFS_af9_w                             ((uint32_t)0x00009000)  /*!< Bit Value =(0x9):AF9 of 32bit */
N#define PX_CR_AFS_af9_h0                            ((uint16_t)0x9000)      /*!< Bit Value =(0x9):AF9 of 16bit */
N#define PX_CR_AFS_af9_b1                            ((uint8_t )0x90)        /*!< Bit Value =(0x9):AF9 of 8bit */
N
N#define PX_CR_FDIV_mask_w                           ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define PX_CR_FDIV_mask_h0                          ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define PX_CR_FDIV_mask_b1                          ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define PX_CR_FDIV_bypass_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Bypass of 32bit */
N#define PX_CR_FDIV_bypass_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Bypass of 16bit */
N#define PX_CR_FDIV_bypass_b1                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):Bypass of 8bit */
N#define PX_CR_FDIV_div1_w                           ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):Div1 of 32bit */
N#define PX_CR_FDIV_div1_h0                          ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Div1 of 16bit */
N#define PX_CR_FDIV_div1_b1                          ((uint8_t )0x04)        /*!< Bit Value =(0x1):Div1 of 8bit */
N#define PX_CR_FDIV_div4_w                           ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):Div4 of 32bit */
N#define PX_CR_FDIV_div4_h0                          ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Div4 of 16bit */
N#define PX_CR_FDIV_div4_b1                          ((uint8_t )0x08)        /*!< Bit Value =(0x2):Div4 of 8bit */
N#define PX_CR_FDIV_div16_w                          ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):Div16 of 32bit */
N#define PX_CR_FDIV_div16_h0                         ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Div16 of 16bit */
N#define PX_CR_FDIV_div16_b1                         ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Div16 of 8bit */
N
N#define PX_CR_ODC_mask_w                            ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define PX_CR_ODC_mask_h0                           ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define PX_CR_ODC_mask_b1                           ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define PX_CR_ODC_level0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Level0 of 32bit */
N#define PX_CR_ODC_level0_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Level0 of 16bit */
N#define PX_CR_ODC_level0_b1                         ((uint8_t )0x00)        /*!< Bit Value =(0x0):Level0 of 8bit */
N#define PX_CR_ODC_level1_w                          ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Level1 of 32bit */
N#define PX_CR_ODC_level1_h0                         ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level1 of 16bit */
N#define PX_CR_ODC_level1_b1                         ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level1 of 8bit */
N#define PX_CR_ODC_level2_w                          ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Level2 of 32bit */
N#define PX_CR_ODC_level2_h0                         ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Level2 of 16bit */
N#define PX_CR_ODC_level2_b1                         ((uint8_t )0x02)        /*!< Bit Value =(0x2):Level2 of 8bit */
N#define PX_CR_ODC_level3_w                          ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Level3 of 32bit */
N#define PX_CR_ODC_level3_h0                         ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Level3 of 16bit */
N#define PX_CR_ODC_level3_b1                         ((uint8_t )0x03)        /*!< Bit Value =(0x3):Level3 of 8bit */
N
N#define PX_CR_INV_mask_w                            ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PX_CR_INV_mask_h0                           ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PX_CR_INV_mask_b0                           ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PX_CR_INV_disable_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PX_CR_INV_disable_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PX_CR_INV_disable_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PX_CR_INV_enable_w                          ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define PX_CR_INV_enable_h0                         ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define PX_CR_INV_enable_b0                         ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PX_CR_PU_mask_w                             ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PX_CR_PU_mask_h0                            ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PX_CR_PU_mask_b0                            ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PX_CR_PU_disable_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PX_CR_PU_disable_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PX_CR_PU_disable_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PX_CR_PU_enable_w                           ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PX_CR_PU_enable_h0                          ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PX_CR_PU_enable_b0                          ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PX_CR_HS_mask_w                             ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define PX_CR_HS_mask_h0                            ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PX_CR_HS_mask_b0                            ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define PX_CR_HS_disable_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PX_CR_HS_disable_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PX_CR_HS_disable_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PX_CR_HS_enable_w                           ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define PX_CR_HS_enable_h0                          ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define PX_CR_HS_enable_b0                          ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PX_CR_IOM_mask_w                            ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define PX_CR_IOM_mask_h0                           ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define PX_CR_IOM_mask_b0                           ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define PX_CR_IOM_aio_w                             ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):AIO of 32bit */
N#define PX_CR_IOM_aio_h0                            ((uint16_t)0x0000)      /*!< Bit Value =(0x0):AIO of 16bit */
N#define PX_CR_IOM_aio_b0                            ((uint8_t )0x00)        /*!< Bit Value =(0x0):AIO of 8bit */
N#define PX_CR_IOM_odo_w                             ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):ODO of 32bit */
N#define PX_CR_IOM_odo_h0                            ((uint16_t)0x0001)      /*!< Bit Value =(0x1):ODO of 16bit */
N#define PX_CR_IOM_odo_b0                            ((uint8_t )0x01)        /*!< Bit Value =(0x1):ODO of 8bit */
N#define PX_CR_IOM_ppo_w                             ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):PPO of 32bit */
N#define PX_CR_IOM_ppo_h0                            ((uint16_t)0x0002)      /*!< Bit Value =(0x2):PPO of 16bit */
N#define PX_CR_IOM_ppo_b0                            ((uint8_t )0x02)        /*!< Bit Value =(0x2):PPO of 8bit */
N#define PX_CR_IOM_din_w                             ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):DIN of 32bit */
N#define PX_CR_IOM_din_h0                            ((uint16_t)0x0003)      /*!< Bit Value =(0x3):DIN of 16bit */
N#define PX_CR_IOM_din_b0                            ((uint8_t )0x03)        /*!< Bit Value =(0x3):DIN of 8bit */
N#define PX_CR_IOM_qb_w                              ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):QB of 32bit */
N#define PX_CR_IOM_qb_h0                             ((uint16_t)0x0004)      /*!< Bit Value =(0x4):QB of 16bit */
N#define PX_CR_IOM_qb_b0                             ((uint8_t )0x04)        /*!< Bit Value =(0x4):QB of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PA  [register's definitions]
N *              Port IO Mode/AFS Register Control Definitions
N ******************************************************************************
N */
N///@{
N
N/**********************  PA_CR0  [register's definitions]**********************/
N/*!< Offset[0x00]  PA0 IO control register (0x44000000) */
N#define PA_CR0_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR1  [register's definitions]**********************/
N/*!< Offset[0x04]  PA1 IO control register (0x44000004) */
N#define PA_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR2  [register's definitions]**********************/
N/*!< Offset[0x08]  PA2 IO control register (0x44000008) */
N#define PA_CR2_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR3  [register's definitions]**********************/
N/*!< Offset[0x0C]  PA3 IO control register (0x4400000C) */
N#define PA_CR3_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR4  [register's definitions]**********************/
N/*!< Offset[0x10]  PA4 IO control register (0x44000010) */
N#define PA_CR4_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR5  [register's definitions]**********************/
N/*!< Offset[0x14]  PA5 IO control register (0x44000014) */
N#define PA_CR5_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR6  [register's definitions]**********************/
N/*!< Offset[0x18]  PA6 IO control register (0x44000018) */
N#define PA_CR6_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR7  [register's definitions]**********************/
N/*!< Offset[0x1C]  PA7 IO control register (0x4400001C) */
N#define PA_CR7_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR8  [register's definitions]**********************/
N/*!< Offset[0x20]  PA8 IO control register (0x44000020) */
N#define PA_CR8_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_CR9  [register's definitions]**********************/
N/*!< Offset[0x24]  PA9 IO control register (0x44000024) */
N#define PA_CR9_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PA_CR10  [register's definitions]**********************/
N/*!< Offset[0x28]  PA10 IO control register (0x44000028) */
N#define PA_CR10_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PA_CR11  [register's definitions]**********************/
N/*!< Offset[0x2C]  PA11 IO control register (0x4400002C) */
N#define PA_CR11_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PA_CR12  [register's definitions]**********************/
N/*!< Offset[0x30]  PA12 IO control register (0x44000030) */
N#define PA_CR12_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PA_CR13  [register's definitions]**********************/
N/*!< Offset[0x34]  PA13 IO control register (0x44000034) */
N#define PA_CR13_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PA_CR14  [register's definitions]**********************/
N/*!< Offset[0x38]  PA14 IO control register (0x44000038) */
N#define PA_CR14_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PA_CR15  [register's definitions]**********************/
N/*!< Offset[0x3C]  PA15 IO control register (0x4400003C) */
N#define PA_CR15_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PA_FLT  [register's definitions]**********************/
N/*!< Offset[0x40]  PA port input filter control register (0x44000040) */
N#define PA_FLT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N///@}
N/**
N ******************************************************************************
N * @name        PB  [register's definitions]
N *              Port IO Mode/AFS Register Control Definitions
N ******************************************************************************
N */
N///@{
N
N/**********************  PB_CR0  [register's definitions]**********************/
N/*!< Offset[0x00]  PB0 IO control register (0x44010000) */
N#define PB_CR0_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR1  [register's definitions]**********************/
N/*!< Offset[0x04]  PB1 IO control register (0x44010004) */
N#define PB_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR2  [register's definitions]**********************/
N/*!< Offset[0x08]  PB2 IO control register (0x44010008) */
N#define PB_CR2_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR3  [register's definitions]**********************/
N/*!< Offset[0x0C]  PB3 IO control register (0x4401000C) */
N#define PB_CR3_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR4  [register's definitions]**********************/
N/*!< Offset[0x10]  PB4 IO control register (0x44010010) */
N#define PB_CR4_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR5  [register's definitions]**********************/
N/*!< Offset[0x14]  PB5 IO control register (0x44010014) */
N#define PB_CR5_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR6  [register's definitions]**********************/
N/*!< Offset[0x18]  PB6 IO control register (0x44010018) */
N#define PB_CR6_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR7  [register's definitions]**********************/
N/*!< Offset[0x1C]  PB7 IO control register (0x4401001C) */
N#define PB_CR7_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR8  [register's definitions]**********************/
N/*!< Offset[0x20]  PB8 IO control register (0x44010020) */
N#define PB_CR8_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_CR9  [register's definitions]**********************/
N/*!< Offset[0x24]  PB9 IO control register (0x44010024) */
N#define PB_CR9_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PB_CR10  [register's definitions]**********************/
N/*!< Offset[0x28]  PB10 IO control register (0x44010028) */
N#define PB_CR10_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PB_CR11  [register's definitions]**********************/
N/*!< Offset[0x2C]  PB11 IO control register (0x4401002C) */
N#define PB_CR11_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PB_CR12  [register's definitions]**********************/
N/*!< Offset[0x30]  PB12 IO control register (0x44010030) */
N#define PB_CR12_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PB_CR13  [register's definitions]**********************/
N/*!< Offset[0x34]  PB13 IO control register (0x44010034) */
N#define PB_CR13_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PB_CR14  [register's definitions]**********************/
N/*!< Offset[0x38]  PB14 IO control register (0x44010038) */
N#define PB_CR14_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PB_CR15  [register's definitions]**********************/
N/*!< Offset[0x3C]  PB15 IO control register (0x4401003C) */
N#define PB_CR15_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PB_FLT  [register's definitions]**********************/
N/*!< Offset[0x40]  PB port input filter control register (0x44010040) */
N#define PB_FLT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N///@}
N/**
N ******************************************************************************
N * @name        PC  [register's definitions]
N *              Port IO Mode/AFS Register Control Definitions
N ******************************************************************************
N */
N///@{
N
N/**********************  PC_CR0  [register's definitions]**********************/
N/*!< Offset[0x00]  PC0 IO control register (0x44020000) */
N#define PC_CR0_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR1  [register's definitions]**********************/
N/*!< Offset[0x04]  PC1 IO control register (0x44020004) */
N#define PC_CR1_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR2  [register's definitions]**********************/
N/*!< Offset[0x08]  PC2 IO control register (0x44020008) */
N#define PC_CR2_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR3  [register's definitions]**********************/
N/*!< Offset[0x0C]  PC3 IO control register (0x4402000C) */
N#define PC_CR3_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR4  [register's definitions]**********************/
N/*!< Offset[0x10]  PC4 IO control register (0x44020010) */
N#define PC_CR4_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR5  [register's definitions]**********************/
N/*!< Offset[0x14]  PC5 IO control register (0x44020014) */
N#define PC_CR5_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR6  [register's definitions]**********************/
N/*!< Offset[0x18]  PC6 IO control register (0x44020018) */
N#define PC_CR6_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR7  [register's definitions]**********************/
N/*!< Offset[0x1C]  PC7 IO control register (0x4402001C) */
N#define PC_CR7_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR8  [register's definitions]**********************/
N/*!< Offset[0x20]  PC8 IO control register (0x44020020) */
N#define PC_CR8_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_CR9  [register's definitions]**********************/
N/*!< Offset[0x24]  PC9 IO control register (0x44020024) */
N#define PC_CR9_default                              ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/*********************  PC_CR10  [register's definitions]**********************/
N/*!< Offset[0x28]  PC10 IO control register (0x44020028) */
N#define PC_CR10_default                             ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/*********************  PC_CR11  [register's definitions]**********************/
N/*!< Offset[0x2C]  PC11 IO control register (0x4402002C) */
N#define PC_CR11_default                             ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/*********************  PC_CR12  [register's definitions]**********************/
N/*!< Offset[0x30]  PC12 IO control register (0x44020030) */
N#define PC_CR12_default                             ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/*********************  PC_CR13  [register's definitions]**********************/
N/*!< Offset[0x34]  PC13 IO control register (0x44020034) */
N#define PC_CR13_default                             ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/*********************  PC_CR14  [register's definitions]**********************/
N/*!< Offset[0x38]  PC14 IO control register (0x44020038) */
N#define PC_CR14_default                             ((uint32_t)0x00000024)  /*!< Reg Reset Default Value */
N
N/**********************  PC_FLT  [register's definitions]**********************/
N/*!< Offset[0x40]  PC port input filter control register (0x44020040) */
N#define PC_FLT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N///@}
N/**
N ******************************************************************************
N * @name        PD  [register's definitions]
N *              Port IO Mode/AFS Register Control Definitions
N ******************************************************************************
N */
N///@{
N
N/**********************  PD_CR0  [register's definitions]**********************/
N/*!< Offset[0x00]  PD0 IO control register (0x44030000) */
N#define PD_CR0_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR1  [register's definitions]**********************/
N/*!< Offset[0x04]  PD1 IO control register (0x44030004) */
N#define PD_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR2  [register's definitions]**********************/
N/*!< Offset[0x08]  PD2 IO control register (0x44030008) */
N#define PD_CR2_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR3  [register's definitions]**********************/
N/*!< Offset[0x0C]  PD3 IO control register (0x4403000C) */
N#define PD_CR3_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR4  [register's definitions]**********************/
N/*!< Offset[0x10]  PD4 IO control register (0x44030010) */
N#define PD_CR4_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR5  [register's definitions]**********************/
N/*!< Offset[0x14]  PD5 IO control register (0x44030014) */
N#define PD_CR5_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR6  [register's definitions]**********************/
N/*!< Offset[0x18]  PD6 IO control register (0x44030018) */
N#define PD_CR6_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR7  [register's definitions]**********************/
N/*!< Offset[0x1C]  PD7 IO control register (0x4403001C) */
N#define PD_CR7_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR8  [register's definitions]**********************/
N/*!< Offset[0x20]  PD8 IO control register (0x44030020) */
N#define PD_CR8_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_CR9  [register's definitions]**********************/
N/*!< Offset[0x24]  PD9 IO control register (0x44030024) */
N#define PD_CR9_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PD_CR10  [register's definitions]**********************/
N/*!< Offset[0x28]  PD10 IO control register (0x44030028) */
N#define PD_CR10_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PD_CR11  [register's definitions]**********************/
N/*!< Offset[0x2C]  PD11 IO control register (0x4403002C) */
N#define PD_CR11_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PD_CR12  [register's definitions]**********************/
N/*!< Offset[0x30]  PD12 IO control register (0x44030030) */
N#define PD_CR12_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PD_CR13  [register's definitions]**********************/
N/*!< Offset[0x34]  PD13 IO control register (0x44030034) */
N#define PD_CR13_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PD_CR14  [register's definitions]**********************/
N/*!< Offset[0x38]  PD14 IO control register (0x44030038) */
N#define PD_CR14_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PD_CR15  [register's definitions]**********************/
N/*!< Offset[0x3C]  PD15 IO control register (0x4403003C) */
N#define PD_CR15_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PD_FLT  [register's definitions]**********************/
N/*!< Offset[0x40]  PD port input filter control register (0x44030040) */
N#define PD_FLT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N///@}
N/**
N ******************************************************************************
N * @name        PE  [register's definitions]
N *              Port IO Mode/AFS Register Control Definitions
N ******************************************************************************
N */
N///@{
N
N/**********************  PE_CR0  [register's definitions]**********************/
N/*!< Offset[0x00]  PE0 IO control register (0x44040000) */
N#define PE_CR0_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PE_CR1  [register's definitions]**********************/
N/*!< Offset[0x04]  PE1 IO control register (0x44040004) */
N#define PE_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PE_CR2  [register's definitions]**********************/
N/*!< Offset[0x08]  PE2 IO control register (0x44040008) */
N#define PE_CR2_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PE_CR3  [register's definitions]**********************/
N/*!< Offset[0x0C]  PE3 IO control register (0x4404000C) */
N#define PE_CR3_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PE_CR8  [register's definitions]**********************/
N/*!< Offset[0x20]  PE8 IO control register (0x44040020) */
N#define PE_CR8_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PE_CR9  [register's definitions]**********************/
N/*!< Offset[0x24]  PE9 IO control register (0x44040024) */
N#define PE_CR9_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PE_CR12  [register's definitions]**********************/
N/*!< Offset[0x30]  PE12 IO control register (0x44040030) */
N#define PE_CR12_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PE_CR13  [register's definitions]**********************/
N/*!< Offset[0x34]  PE13 IO control register (0x44040034) */
N#define PE_CR13_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PE_CR14  [register's definitions]**********************/
N/*!< Offset[0x38]  PE14 IO control register (0x44040038) */
N#define PE_CR14_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/*********************  PE_CR15  [register's definitions]**********************/
N/*!< Offset[0x3C]  PE15 IO control register (0x4404003C) */
N#define PE_CR15_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/**********************  PE_FLT  [register's definitions]**********************/
N/*!< Offset[0x40]  PE port input filter control register (0x44040040) */
N#define PE_FLT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N///@}
N
N#endif  // _MG32x02z_GPIO_H
N
N/*----------------------------------------------------------------------------*/
N/*                        End of file MG32x02z_GPIO.h                         */
N/*----------------------------------------------------------------------------*/
L 46 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_GPIO_Init.h" 2
N
N// <<< Use Configuration Wizard in Context Menu >>>
N
N#define MG32x02z_PIN0_Mask        0x0001
N#define MG32x02z_PIN1_Mask        0x0002
N#define MG32x02z_PIN2_Mask        0x0004
N#define MG32x02z_PIN3_Mask        0x0008
N#define MG32x02z_PIN4_Mask        0x0010
N#define MG32x02z_PIN5_Mask        0x0020
N#define MG32x02z_PIN6_Mask        0x0040
N#define MG32x02z_PIN7_Mask        0x0080
N#define MG32x02z_PIN8_Mask        0x0100
N#define MG32x02z_PIN9_Mask        0x0200
N#define MG32x02z_PIN10_Mask       0x0400
N#define MG32x02z_PIN11_Mask       0x0800
N#define MG32x02z_PIN12_Mask       0x1000
N#define MG32x02z_PIN13_Mask       0x2000
N#define MG32x02z_PIN14_Mask       0x4000
N#define MG32x02z_PIN15_Mask       0x8000
N
N
N#define PA_OUT_ADR               GPIOA_Base + 0
N#define PA_FLT_ADR               IOMA_Base + 0x40
N#define PA0_CR_ADR               IOMA_Base + 4*0
N#define PA1_CR_ADR               IOMA_Base + 4*1
N#define PA2_CR_ADR               IOMA_Base + 4*2
N#define PA3_CR_ADR               IOMA_Base + 4*3
N#define PA4_CR_ADR               IOMA_Base + 4*4
N#define PA5_CR_ADR               IOMA_Base + 4*5
N#define PA6_CR_ADR               IOMA_Base + 4*6
N#define PA7_CR_ADR               IOMA_Base + 4*7
N#define PA8_CR_ADR               IOMA_Base + 4*8
N#define PA9_CR_ADR               IOMA_Base + 4*9
N#define PA10_CR_ADR              IOMA_Base + 4*10
N#define PA11_CR_ADR              IOMA_Base + 4*11
N#define PA12_CR_ADR              IOMA_Base + 4*12
N#define PA13_CR_ADR              IOMA_Base + 4*13
N#define PA14_CR_ADR              IOMA_Base + 4*14
N#define PA15_CR_ADR              IOMA_Base + 4*15
N
N#define PB_OUT_ADR               GPIOB_Base + 0
N#define PB_FLT_ADR               IOMB_Base + 0x40
N#define PB0_CR_ADR               IOMB_Base + 4*0
N#define PB1_CR_ADR               IOMB_Base + 4*1
N#define PB2_CR_ADR               IOMB_Base + 4*2
N#define PB3_CR_ADR               IOMB_Base + 4*3
N#define PB4_CR_ADR               IOMB_Base + 4*4
N#define PB5_CR_ADR               IOMB_Base + 4*5
N#define PB6_CR_ADR               IOMB_Base + 4*6
N#define PB7_CR_ADR               IOMB_Base + 4*7
N#define PB8_CR_ADR               IOMB_Base + 4*8
N#define PB9_CR_ADR               IOMB_Base + 4*9
N#define PB10_CR_ADR              IOMB_Base + 4*10
N#define PB11_CR_ADR              IOMB_Base + 4*11
N#define PB12_CR_ADR              IOMB_Base + 4*12
N#define PB13_CR_ADR              IOMB_Base + 4*13
N#define PB14_CR_ADR              IOMB_Base + 4*14
N#define PB15_CR_ADR              IOMB_Base + 4*15
N
N#define PC_OUT_ADR               GPIOC_Base + 0
N#define PC_FLT_ADR               IOMC_Base + 0x40
N#define PC0_CR_ADR               IOMC_Base + 4*0
N#define PC1_CR_ADR               IOMC_Base + 4*1
N#define PC2_CR_ADR               IOMC_Base + 4*2
N#define PC3_CR_ADR               IOMC_Base + 4*3
N#define PC4_CR_ADR               IOMC_Base + 4*4
N#define PC5_CR_ADR               IOMC_Base + 4*5
N#define PC6_CR_ADR               IOMC_Base + 4*6
N#define PC7_CR_ADR               IOMC_Base + 4*7
N#define PC8_CR_ADR               IOMC_Base + 4*8
N#define PC9_CR_ADR               IOMC_Base + 4*9
N#define PC10_CR_ADR              IOMC_Base + 4*10
N#define PC11_CR_ADR              IOMC_Base + 4*11
N#define PC12_CR_ADR              IOMC_Base + 4*12
N#define PC13_CR_ADR              IOMC_Base + 4*13
N#define PC14_CR_ADR              IOMC_Base + 4*14
N#define PC15_CR_ADR              IOMC_Base + 4*15
N
N#define PD_OUT_ADR               GPIOD_Base + 0
N#define PD_FLT_ADR               IOMD_Base + 0x40
N#define PD0_CR_ADR               IOMD_Base + 4*0
N#define PD1_CR_ADR               IOMD_Base + 4*1
N#define PD2_CR_ADR               IOMD_Base + 4*2
N#define PD3_CR_ADR               IOMD_Base + 4*3
N#define PD4_CR_ADR               IOMD_Base + 4*4
N#define PD5_CR_ADR               IOMD_Base + 4*5
N#define PD6_CR_ADR               IOMD_Base + 4*6
N#define PD7_CR_ADR               IOMD_Base + 4*7
N#define PD8_CR_ADR               IOMD_Base + 4*8
N#define PD9_CR_ADR               IOMD_Base + 4*9
N#define PD10_CR_ADR              IOMD_Base + 4*10
N#define PD11_CR_ADR              IOMD_Base + 4*11
N#define PD12_CR_ADR              IOMD_Base + 4*12
N#define PD13_CR_ADR              IOMD_Base + 4*13
N#define PD14_CR_ADR              IOMD_Base + 4*14
N#define PD15_CR_ADR              IOMD_Base + 4*15
N
N#define PE_OUT_ADR               GPIOE_Base + 0
N#define PE_FLT_ADR               IOME_Base + 0x40
N#define PE0_CR_ADR               IOME_Base + 4*0
N#define PE1_CR_ADR               IOME_Base + 4*1
N#define PE2_CR_ADR               IOME_Base + 4*2
N#define PE3_CR_ADR               IOME_Base + 4*3
N#define PE4_CR_ADR               IOME_Base + 4*4
N#define PE5_CR_ADR               IOME_Base + 4*5
N#define PE6_CR_ADR               IOME_Base + 4*6
N#define PE7_CR_ADR               IOME_Base + 4*7
N#define PE8_CR_ADR               IOME_Base + 4*8
N#define PE9_CR_ADR               IOME_Base + 4*9
N#define PE10_CR_ADR              IOME_Base + 4*10
N#define PE11_CR_ADR              IOME_Base + 4*11
N#define PE12_CR_ADR              IOME_Base + 4*12
N#define PE13_CR_ADR              IOME_Base + 4*13
N#define PE14_CR_ADR              IOME_Base + 4*14
N#define PE15_CR_ADR              IOME_Base + 4*15
N
N/**
N ******************************************************************************
N *
N * @brief       GPIO Initial Configure - MG32F02A132 (LQFP80-Package)
N *
N ******************************************************************************
N */
N//<h> GPIO Initial Configure - MG32F02A132 (LQFP80-Package)
N
N//
N//==============================  PA IO Setting  ===============================
N//
N//  <e0> GPIOA Configuration
N//      <o1> PA Output setting<0x0000-0xFFFF>
N//          <i> GPIO PA output data bit 0~15. These bits are mapping to PA0 ~ PA15.
N//      <o2> PA Input filter clock source select <0=> CLK_AHB <1=> CLK_AHB_DIV8 <2=> CLK_ILRCO <3=> TM00_TRGO <4=> CK_UT
N//          <i> PA port input deglitch filter clock source select for all pins of the port.
N//          <i> Default:  = CLK_AHB
N//      <e3.0> PA0 Configuration
N//          <o4.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o4.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o4.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o4.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o4.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o4.12..15>     AFS : Alternate function select             <0=> GPA0 <8=> MA0
N//          <i> Default: AFS = GPA0
N//      </e> 
N//      <e3.1> PA1 Configuration
N//          <o5.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o5.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o5.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o5.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o5.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o5.12..15>     AFS : Alternate function select             <0=> GPA1 <8=> MA1
N//          <i> Default: AFS = GPA1
N//      </e> 
N//      <e3.2> PA2 Configuration
N//          <o6.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o6.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o6.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o6.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o6.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o6.12..15>     AFS : Alternate function select             <0=> GPA2 <8=> MA2
N//          <i> Default: AFS = GPA2
N//      </e> 
N//      <e3.3> PA3 Configuration
N//          <o7.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o7.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o7.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o7.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o7.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o7.12..15>     AFS : Alternate function select             <0=> GPA3 <8=> MA3
N//          <i> Default: AFS = GPA3
N//      </e> 
N//      <e3.4> PA4 Configuration
N//          <o8.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o8.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o8.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o8.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o8.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o8.12..15>     AFS : Alternate function select             <0=> GPA4 <8=> MA4
N//          <i> Default: AFS = GPA4
N//      </e> 
N//      <e3.5> PA5 Configuration
N//          <o9.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o9.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o9.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o9.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o9.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o9.12..15>     AFS : Alternate function select             <0=> GPA5 <8=> MA5
N//          <i> Default: AFS = GPA5
N//      </e> 
N//      <e3.6> PA6 Configuration
N//          <o10.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o10.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o10.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o10.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o10.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o10.12..15>    AFS : Alternate function select             <0=> GPA6 <8=> MA6
N//          <i> Default: AFS = GPA6
N//      </e> 
N//      <e3.7> PA7 Configuration
N//          <o11.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o11.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o11.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o11.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o11.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o11.12..15>    AFS : Alternate function select             <0=> GPA7 <8=> MA7
N//          <i> Default: AFS = GPA7
N//      </e> 
N//      <e3.8> PA8 Configuration
N//          <o12.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o12.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o12.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o12.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o12.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o12.12..15>    AFS : Alternate function select             <0=> GPA8 <8=> MA8
N//          <i> Default: AFS = GPA8
N//      </e> 
N//      <e3.9> PA9 Configuration
N//          <o13.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o13.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o13.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o13.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o13.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o13.12..15>    AFS : Alternate function select             <0=> GPA9 <8=> MA9
N//          <i> Default: AFS = GPA9
N//      </e> 
N//      <e3.10> PA10 Configuration
N//          <o14.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o14.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o14.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o14.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o14.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o14.12..15>    AFS : Alternate function select             <0=> GPA10 <8=> MA10
N//          <i> Default: AFS = GPA10
N//      </e> 
N//      <e3.11> PA11 Configuration
N//          <o15.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o15.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o15.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o15.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o15.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o15.12..15>    AFS : Alternate function select             <0=> GPA11 <8=> MA11
N//          <i> Default: AFS = GPA11
N//      </e> 
N//      <e3.12> PA12 Configuration
N//          <o16.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o16.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o16.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o16.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o16.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o16.12..15>    AFS : Alternate function select             <0=> GPA12 <8=> MA12
N//          <i> Default: AFS = GPA12
N//      </e> 
N//      <e3.13> PA13 Configuration
N//          <o17.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o17.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o17.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o17.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o17.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o17.12..15>    AFS : Alternate function select             <0=> GPA13 <8=> MA13
N//          <i> Default: AFS = GPA13
N//      </e> 
N//      <e3.14> PA14 Configuration
N//          <o18.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o18.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o18.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o18.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o18.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o18.12..15>    AFS : Alternate function select             <0=> GPA14 <8=> MA14
N//          <i> Default: AFS = GPA14
N//      </e> 
N//      <e3.15> PA15 Configuration
N//          <o19.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o19.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o19.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o19.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o19.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o19.12..15>    AFS : Alternate function select             <0=> GPA15 <8=> MA15
N//          <i> Default: AFS = GPA15
N//      </e> 
N        #define CONF_GPIOAInit_EN           0
N        #define CONF_PA_OUTPUT_DEFAULT      0xFFFF
N        #define CONF_PA_FILTER_CLK          0
N        #define CONF_GPIOAInit_Mask         0x0000
N        #define CONF_PA0_CR                 0x00000000
N        #define CONF_PA1_CR                 0x00000000
N        #define CONF_PA2_CR                 0x00000000
N        #define CONF_PA3_CR                 0x00000000
N        #define CONF_PA4_CR                 0x00000000
N        #define CONF_PA5_CR                 0x00000000
N        #define CONF_PA6_CR                 0x00000000
N        #define CONF_PA7_CR                 0x00000000
N        #define CONF_PA8_CR                 0x00000000
N        #define CONF_PA9_CR                 0x00000000
N        #define CONF_PA10_CR                0x00000000
N        #define CONF_PA11_CR                0x00000000
N        #define CONF_PA12_CR                0x00000000
N        #define CONF_PA13_CR                0x00000000
N        #define CONF_PA14_CR                0x00000000
N        #define CONF_PA15_CR                0x00000000
N//  </e> 
N
N//
N//==============================  PB IO Setting  ===============================
N//
N//  <e0> GPIOB Configuration
N//      <o1> PB Output setting<0x0000-0xFFFF>
N//          <i> GPIO PB output data bit 0~15. These bits are mapping to PB0 ~ PB15.
N//      <o2> PB Input filter clock source select <0=> CLK_AHB <1=> CLK_AHB_DIV8 <2=> CLK_ILRCO <3=> TM00_TRGO <4=> CK_UT
N//          <i> PB port input deglitch filter clock source select for all pins of the port.
N//          <i> Default: AFS = CLK_AHB
N//      <e3.0> PB0 Configuration
N//          <o4.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o4.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o4.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o4.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o4.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o4.12..15>     AFS : Alternate function select             <0=> GPB0 <1=> I2C1_SCL <2=> SPI0_NSS <3=> TM01_ETR <4=> TM00_CKO <5=> TM16_ETR <6=> TM26_IC0 <8=> MA15
N//          <i> Default: AFS = GPB0
N//      </e> 
N//      <e3.1> PB1 Configuration
N//          <o5.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o5.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o5.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o5.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o5.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o5.12..15>     AFS : Alternate function select             <0=> GPB1 <1=> I2C1_SDA <2=> SPI0_MISO <3=> TM01_TRGO <4=> TM10_CKO <5=> TM16_TRGO <6=> TM26_IC1
N//          <i> Default: AFS = GPB1
N//      </e> 
N//      <e3.2> PB2 Configuration
N//          <o6.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o6.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o6.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o6.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o6.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o6.12..15>     AFS : Alternate function select             <0=> GPB2 <1=> ADC0_TRG <2=> SPI0_CLK <3=> TM01_CKO <4=> URT2_TX <5=> TM16_CKO <6=> TM26_OC0H
N//          <i> Default: AFS = GPB2
N//      </e> 
N//      <e3.3> PB3 Configuration
N//          <o7.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o7.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o7.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o7.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o7.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o7.12..15>     AFS : Alternate function select             <0=> GPB3 <1=> ADC0_OUT <2=> SPI0_MOSI <4=> URT2_RX <6=> TM26_OC1H
N//          <i> Default: AFS = GPB3
N//      </e> 
N//      <e3.4> PB4 Configuration
N//          <o8.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o8.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o8.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o8.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o8.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o8.12..15>     AFS : Alternate function select             <0=> GPB4 <1=> TM01_CKO <2=> SPI0_D3 <3=> TM26_TRGO <4=> URT2_CLK <5=> TM20_IC0 <6=> TM36_IC0 <8=> MALE <9=> MAD8
N//          <i> Default: AFS = GPB4
N//      </e> 
N//      <e3.5> PB5 Configuration
N//          <o9.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o9.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o9.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o9.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o9.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o9.12..15>     AFS : Alternate function select             <0=> GPB5 <1=> TM16_CKO <2=> SPI0_D2 <3=> TM26_ETR <4=> URT2_NSS <5=> TM20_IC1 <6=> TM36_IC1 <8=> MOE <9=> MAD9
N//          <i> Default: AFS = GPB5
N//      </e> 
N//      <e3.6> PB6 Configuration
N//          <o10.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o10.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o10.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o10.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o10.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o10.12..15>    AFS : Alternate function select             <0=> GPB6 <1=> CPU_RXEV <2=> SPI0_NSSI <3=> URT0_BRO <4=> URT2_CTS <5=> TM20_ETR <6=> TM36_IC2 <8=> MWE <9=> MAD10
N//          <i> Default: AFS = GPB6
N//      </e> 
N//      <e3.7> PB7 Configuration
N//          <o11.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o11.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o11.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o11.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o11.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o11.12..15>    AFS : Alternate function select             <0=> GPB7 <1=> CPU_TXEV <3=> URT0_TMO <4=> URT2_RTS <5=> TM20_TRGO <6=> TM36_IC3 <8=> MCE <9=> MALE2
N//          <i> Default: AFS = GPB7
N//      </e> 
N//      <e3.8> PB8 Configuration
N//          <o12.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o12.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o12.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o12.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o12.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o12.12..15>    AFS : Alternate function select             <0=> GPB8 <1=> CMP0_P0 <2=> RTC_OUT <3=> URT0_TX <4=> URT2_BRO <5=> TM20_OC01 <6=> TM36_OC01 <8=> MAD0
N//          <i> Default: AFS = GPB8
N//      </e> 
N//      <e3.9> PB9 Configuration
N//          <o13.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o13.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o13.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o13.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o13.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o13.12..15>    AFS : Alternate function select             <0=> GPB9 <1=> CMP1_P0 <2=> RTC_TS <3=> URT0_RX <4=> URT2_TMO <5=> TM20_OC02 <6=> TM36_OC02 <8=> MAD1 <9=> MAD8
N//          <i> Default: AFS = GPB9
N//      </e> 
N//      <e3.10> PB10 Configuration
N//          <o14.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o14.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o14.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o14.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o14.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o14.12..15>    AFS : Alternate function select             <0=> GPB10 <1=> CMP2_P0 <2=> I2C0_SCL <3=> URT0_NSS <4=> URT2_DE <5=> TM20_OC11 <6=> TM36_OC11 <8=> MAD2 <9=> MAD1
N//          <i> Default: AFS = GPB10
N//      </e> 
N//      <e3.11> PB11 Configuration
N//          <o15.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o15.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o15.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o15.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o15.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o15.12..15>    AFS : Alternate function select             <0=> GPB11 <1=> CMP3_P0 <2=> I2C0_SDA <3=> URT0_DE <5=> TM20_OC12 <6=> TM36_OC12 <8=> MAD3 <9=> MAD9
N//          <i> Default: AFS = GPB11
N//      </e> 
N//      <e3.12> PB12 Configuration
N//          <o16.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o16.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o16.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o16.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o16.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o16.12..15>    AFS : Alternate function select             <0=> GPB12 <1=> DMA_TRG0 <8=> MAD4 <9=> MAD2
N//          <i> Default: AFS = GPB12
N//      </e> 
N//      <e3.13> PB13 Configuration
N//          <o17.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o17.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o17.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o17.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o17.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o17.12..15>    AFS : Alternate function select             <0=> GPB13 <1=> DAC_TRG0 <2=> TM00_ETR <3=> URT0_CTS <4=> URT3_RX <5=> TM20_ETR <6=> TM36_ETR <8=> MAD5 <9=> MAD10
N//          <i> Default: AFS = GPB13
N//      </e> 
N//      <e3.14> PB14 Configuration
N//          <o18.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o18.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o18.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o18.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o18.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o18.12..15>    AFS : Alternate function select             <0=> GPB14 <2=> TM00_TRGO <3=> URT0_RTS <4=> URT3_TX <5=> TM20_TRGO <6=> TM36_BK0 <8=> MAD6 <9=> MAD3
N//          <i> Default: AFS = GPB14
N//      </e> 
N//      <e3.15> PB15 Configuration
N//          <o19.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o19.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o19.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o19.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o19.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o19.12..15>    AFS : Alternate function select             <0=> GPB15 <1=> IR_OUT <8=> MAD7 <9=> MAD11
N//          <i> Default: AFS = GPB15
N//      </e> 
N        #define CONF_GPIOBInit_EN           0
N        #define CONF_PB_OUTPUT_DEFAULT      0xFFFF
N        #define CONF_PB_FILTER_CLK          0
N        #define CONF_GPIOBInit_Mask         0x0000
N        #define CONF_PB0_CR                 0x00000000
N        #define CONF_PB1_CR                 0x00000000
N        #define CONF_PB2_CR                 0x00000000
N        #define CONF_PB3_CR                 0x00000000
N        #define CONF_PB4_CR                 0x00000000
N        #define CONF_PB5_CR                 0x00000000
N        #define CONF_PB6_CR                 0x00000000
N        #define CONF_PB7_CR                 0x00000000
N        #define CONF_PB8_CR                 0x00000000
N        #define CONF_PB9_CR                 0x00000000
N        #define CONF_PB10_CR                0x00000000
N        #define CONF_PB11_CR                0x00000000
N        #define CONF_PB12_CR                0x00000000
N        #define CONF_PB13_CR                0x00000000
N        #define CONF_PB14_CR                0x00000000
N        #define CONF_PB15_CR                0x00000000
N//  </e> 
N
N//
N//==============================  PC IO Setting  ===============================
N//
N//  <e0> GPIOC Configuration
N//      <o1> PC Output setting<0x0000-0xFFFF>
N//          <i> GPIO PC output data bit 0~15. These bits are mapping to PC0 ~ PC15.
N//      <o2> PC Input filter clock source select <0=> CLK_AHB <1=> CLK_AHB_DIV8 <2=> CLK_ILRCO <3=> TM00_TRGO <4=> CK_UT
N//          <i> PC port input deglitch filter clock source select for all pins of the port.
N//          <i> Default: AFS = CLK_AHB
N//      <e3.0> PC0 Configuration
N//          <o4.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o4.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o4.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o4.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o4.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o4.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o4.12..15>     AFS : Alternate function select             <0=> GPC0 <1=> ICKO <2=> TM00_CKO <3=> URT0_CLK <4=> URT2_CLK <5=> TM20_OC00 <6=> TM36_OC00 <8=> MCLK <9=> MWE
N//          <i> Default: AFS = GPC0
N//      </e> 
N//      <e3.1> PC1 Configuration
N//          <o5.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o5.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o5.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o5.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o5.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o5.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o5.12..15>     AFS : Alternate function select             <0=> GPC1 <1=> ADC0_TRG <2=> TM01_CKO <4=> URT1_CLK <5=> TM20_OC0N <6=> TM36_OC0N <8=> MAD8 <9=> MAD4
N//          <i> Default: AFS = GPC1
N//      </e> 
N//      <e3.2> PC2 Configuration
N//          <o6.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o6.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o6.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o6.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o6.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o6.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o6.12..15>     AFS : Alternate function select             <0=> GPC2 <1=> ADC0_OUT <2=> TM10_CKO <4=> URT2_CLK <5=> TM20_OC10 <6=> TM36_OC10 <8=> MAD9 <9=> MAD12
N//          <i> Default: AFS = GPC2
N//      </e> 
N//      <e3.3> PC3 Configuration
N//          <o7.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o7.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o7.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o7.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o7.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o7.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o7.12..15>     AFS : Alternate function select             <0=> GPC3 <1=> OBM_P1 <2=> TM16_CKO <3=> URT0_CLK <4=> URT1_CLK <5=> TM20_OC1N <6=> TM36_OC1N <8=> MAD10 <9=> MAD5
N//          <i> Default: AFS = GPC3
N//      </e> 
N//      <e3.4> PC4 Configuration
N//          <o8.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o8.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o8.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o8.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o8.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o8.12..15>     AFS : Alternate function select             <0=> GPC4 <1=> SWCLK <2=> I2C0_SCL <3=> URT0_RX <4=> URT1_RX
N//          <i> Default: AFS = GPC4
N//      </e> 
N//      <e3.5> PC5 Configuration
N//          <o9.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o9.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o9.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o9.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o9.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o9.12..15>     AFS : Alternate function select             <0=> GPC5 <1=> SWDIO <2=> I2C0_SDA <3=> URT0_TX <4=> URT1_TX
N//          <i> Default: AFS = GPC5
N//      </e> 
N//      <e3.6> PC6 Configuration
N//          <o10.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o10.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o10.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o10.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o10.12..15>    AFS : Alternate function select             <0=> GPC6 <1=> RSTN <2=> RTC_TS <3=> URT0_NSS <5=> TM20_ETR <6=> TM26_ETR <8=> MBW1 <9=> MALE
N//          <i> Default: AFS = GPC6
N//      </e> 
N//      <e3.7> PC7 Configuration
N//          <o11.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o11.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o11.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o11.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o11.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o11.12..15>    AFS : Alternate function select             <0=> GPC7 <1=> ADC0_TRG <2=> RTC_OUT <3=> URT0_DE <6=> TM36_TRGO <8=> MBW0 <9=> MCE
N//          <i> Default: AFS = GPC7
N//      </e> 
N//      <e3.8> PC8 Configuration
N//          <o12.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o12.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o12.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o12.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o12.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o12.12..15>    AFS : Alternate function select             <0=> GPC8 <1=> ADC0_OUT <2=> I2C0_SCL <3=> URT0_BRO <4=> URT1_TX <5=> TM20_OC0H <6=> TM36_OC0H <8=> MAD11 <9=> MAD13
N//          <i> Default: AFS = GPC8
N//      </e> 
N//      <e3.9> PC9 Configuration
N//          <o13.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o13.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o13.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o13.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o13.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o13.12..15>    AFS : Alternate function select             <0=> GPC9 <1=> CMP0_P0 <2=> I2C0_SDA <3=> URT0_TMO <4=> URT1_RX <5=> TM20_OC1H <6=> TM36_OC1H <8=> MAD12 <9=> MAD6
N//          <i> Default: AFS = GPC9
N//      </e> 
N//      <e3.10> PC10 Configuration
N//          <o14.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o14.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o14.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o14.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o14.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o14.12..15>    AFS : Alternate function select             <0=> GPC10 <1=> CMP1_P0 <2=> I2C1_SCL <3=> URT0_TX <4=> URT2_TX <6=> TM36_OC2H <8=> MAD13 <9=> MAD14
N//          <i> Default: AFS = GPC10
N//      </e> 
N//      <e3.11> PC11 Configuration
N//          <o15.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o15.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o15.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o15.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o15.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o15.12..15>    AFS : Alternate function select             <0=> GPC11 <1=> CMP2_P0 <2=> I2C1_SDA <3=> URT0_RX <4=> URT2_RX <6=> TM36_OC3H <8=> MAD14 <9=> MAD7
N//          <i> Default: AFS = GPC11
N//      </e> 
N//      <e3.12> PC12 Configuration
N//          <o16.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o16.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o16.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o16.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o16.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o16.12..15>    AFS : Alternate function select             <0=> GPC12 <1=> CMP3_P0 <2=> IR_OUT <3=> DAC_TRG0 <5=> TM10_TRGO <6=> TM36_OC3 <8=> MAD15
N//          <i> Default: AFS = GPC12
N//      </e> 
N//      <e3.13> PC13 Configuration
N//          <o17.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o17.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o17.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o17.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o17.12..15>    AFS : Alternate function select             <0=> GPC13 <1=> XIN <3=> URT0_CTS <4=> URT2_RX <5=> TM10_ETR <6=> TM26_ETR
N//          <i> Default: AFS = GPC13
N//      </e> 
N//      <e3.14> PC14 Configuration
N//          <o18.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN <4=> QB
N//          <i> Default: IOM = QB
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//             <i> [4] QB : Quasi-Bidirectional output drive high one CLK
N//          <o18.3>         HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o18.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = ENABLE
N//          <o18.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o18.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o18.12..15>    AFS : Alternate function select             <0=> GPC14 <1=> XOUT <3=> URT0_RTS <4=> URT2_TX <5=> TM10_CKO <6=> TM26_TRGO
N//          <i> Default: AFS = GPC14
N//      </e> 
N        #define CONF_GPIOCInit_EN           0
N        #define CONF_PC_OUTPUT_DEFAULT      0x7FFF
N        #define CONF_PC_FILTER_CLK          0
N        #define CONF_GPIOCInit_Mask         0x0000
N        #define CONF_PC0_CR                 0x00000024
N        #define CONF_PC1_CR                 0x00000024
N        #define CONF_PC2_CR                 0x00000024
N        #define CONF_PC3_CR                 0x00000024
N        #define CONF_PC4_CR                 0x80000024
N        #define CONF_PC5_CR                 0x80000024
N        #define CONF_PC6_CR                 0x80000024
N        #define CONF_PC7_CR                 0x00000024
N        #define CONF_PC8_CR                 0x00000024
N        #define CONF_PC9_CR                 0x00000024
N        #define CONF_PC10_CR                0x00000024
N        #define CONF_PC11_CR                0x00000024
N        #define CONF_PC12_CR                0x00000024
N        #define CONF_PC13_CR                0x00000024
N        #define CONF_PC14_CR                0x00000024
N        #define CONF_PC15_CR                0x00000000
N//  </e> 
N
N//
N//==============================  PD IO Setting  ===============================
N//
N//  <e0> GPIOD Configuration
N//      <o1> PD Output setting<0x0000-0xFFFF>
N//          <i> GPIO PD output data bit 0~15. These bits are mapping to PD0 ~ PD15.
N//      <o2> PD Input filter clock source select <0=> CLK_AHB <1=> CLK_AHB_DIV8 <2=> CLK_ILRCO <3=> TM00_TRGO <4=> CK_UT
N//          <i> PD port input deglitch filter clock source select for all pins of the port.
N//          <i> Default: AFS = CLK_AHB
N//      <e3.0> PD0 Configuration
N//          <o4.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o4.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o4.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o4.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o4.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o4.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o4.12..15>     AFS : Alternate function select             <0=> GPD0 <1=> OBM_I0 <2=> TM10_CKO <3=> URT0_CLK <5=> TM20_CKO <6=> TM36_OC2 <9=> MCLK
N//          <i> Default: AFS = GPD0
N//      </e> 
N//      <e3.1> PD1 Configuration
N//          <o5.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o5.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o5.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o5.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o5.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o5.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o5.12..15>     AFS : Alternate function select             <0=> GPD1 <1=> OBM_I1 <2=> TM16_CKO <3=> URT0_CLK <5=> TM26_CKO <6=> TM36_OC2N <7=> SPI0_CLK
N//          <i> Default: AFS = GPD1
N//      </e> 
N//      <e3.2> PD2 Configuration
N//          <o6.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o6.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o6.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o6.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o6.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o6.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o6.12..15>     AFS : Alternate function select             <0=> GPD2 <2=> TM00_CKO <3=> URT1_CLK <4=> TM26_OC00 <5=> TM20_CKO <6=> TM36_CKO <7=> SPI0_MOSI <9=> MAD4
N//          <i> Default: AFS = GPD2
N//      </e> 
N//      <e3.3> PD3 Configuration
N//          <o7.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o7.3>          HS : Output high speed                      <0=> DISABLE <1=> ENABLE
N//          <i> Default: HS = DISABLE
N//          <o7.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o7.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o7.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o7.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o7.12..15>     AFS : Alternate function select             <0=> GPD3 <2=> TM01_CKO <3=> URT1_CLK <4=> URT3_CLK <6=> TM26_CKO <7=> SPI0_D3 <9=> MAD7
N//          <i> Default: AFS = GPD3
N//      </e> 
N//      <e3.4> PD4 Configuration
N//          <o8.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o8.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o8.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o8.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o8.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o8.12..15>     AFS : Alternate function select             <0=> GPD4 <1=> TM00_TRGO <2=> TM01_TRGO <3=> URT1_TX <4=> URT3_RTS <6=> TM26_OC00 <7=> SPI0_D2 <9=> MAD6
N//          <i> Default: AFS = GPD4
N//      </e> 
N//      <e3.5> PD5 Configuration
N//          <o9.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o9.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o9.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o9.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o9.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o9.12..15>     AFS : Alternate function select             <0=> GPD5 <1=> TM00_ETR <3=> URT1_RX <4=> URT3_CTS <6=> TM26_OC01 <7=> SPI0_MISO <9=> MAD5
N//          <i> Default: AFS = GPD5
N//      </e> 
N//      <e3.6> PD6 Configuration
N//          <o10.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o10.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o10.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o10.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o10.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o10.12..15>    AFS : Alternate function select             <0=> GPD6 <1=> CPU_NMI <3=> URT1_NSS <4=> URT3_DE <5=> SPI0_NSSI <6=> TM26_OC02 <7=> SPI0_NSS
N//          <i> Default: AFS = GPD6
N//      </e> 
N//      <e3.7> PD7 Configuration
N//          <o11.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o11.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o11.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o11.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o11.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o11.12..15>    AFS : Alternate function select             <0=> GPD7 <1=> TM00_CKO <2=> TM01_ETR <3=> URT1_DE <4=> URT3_NSS <6=> TM26_OC0N <7=> SPI0_D4 <9=> MAD0
N//          <i> Default: AFS = GPD7
N//      </e> 
N//      <e3.8> PD8 Configuration
N//          <o12.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o12.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o12.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o12.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o12.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o12.12..15>    AFS : Alternate function select             <0=> GPD8 <3=> URT1_RTS <4=> URT3_TX <6=> TM26_OC10 <7=> SPI0_D7 <9=> MAD3
N//          <i> Default: AFS = GPD8
N//      </e> 
N//      <e3.9> PD9 Configuration
N//          <o13.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o13.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o13.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o13.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o13.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o13.12..15>    AFS : Alternate function select             <0=> GPD9 <3=> URT1_CTS <4=> URT3_RX <6=> TM26_OC11 <7=> SPI0_D6 <9=> MAD2
N//          <i> Default: AFS = GPD9
N//      </e> 
N//      <e3.10> PD10 Configuration
N//          <o14.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o14.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o14.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o14.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o14.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o14.12..15>    AFS : Alternate function select             <0=> GPD10 <3=> URT1_BRO <4=> URT3_BRO <6=> TM26_OC12 <7=> SPI0_D5 <9=> MAD1
N//          <i> Default: AFS = GPD10
N//      </e> 
N//      <e3.11> PD11 Configuration
N//          <o15.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o15.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o15.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o15.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o15.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o15.12..15>    AFS : Alternate function select             <0=> GPD11 <1=> CPU_NMI <2=> DMA_TRG1 <3=> URT1_TMO <4=> URT3_TMO <6=> TM26_OC1N <7=> SPI0_NSS <9=> MWE
N//          <i> Default: AFS = GPD11
N//      </e> 
N//      <e3.12> PD12 Configuration
N//          <o16.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o16.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o16.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o16.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o16.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o16.12..15>    AFS : Alternate function select             <0=> GPD12 <1=> CMP0_P0 <4=> TM00_CKO <5=> SPI0_CLK <6=> TM20_OC0H <7=> TM26_OC0H <9=> MALE2
N//          <i> Default: AFS = GPD12
N//      </e> 
N//      <e3.13> PD13 Configuration
N//          <o17.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o17.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o17.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o17.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o17.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o17.12..15>    AFS : Alternate function select             <0=> GPD13 <1=> CMP1_P0 <3=> OBM_P1 <4=> TM00_TRGO <6=> TM20_OC1H <7=> TM26_OC1H <9=> MCE
N//          <i> Default: AFS = GPD13
N//      </e> 
N//      <e3.14> PD14 Configuration
N//          <o18.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o18.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o18.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o18.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o18.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o18.12..15>    AFS : Alternate function select             <0=> GPD14 <1=> CMP2_P0 <3=> DAC_TRG0 <4=> TM00_ETR <6=> TM20_IC0 <7=> TM26_IC0 <9=> MOE
N//          <i> Default: AFS = GPD14
N//      </e> 
N//      <e3.15> PD15 Configuration
N//          <o19.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o19.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o19.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o19.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o19.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o19.12..15>    AFS : Alternate function select             <0=> GPD15 <1=> CMP3_P0 <3=> IR_OUT <4=> DMA_TRG0 <6=> TM20_IC1 <7=> TM26_IC1
N//          <i> Default: AFS = GPD15
N//      </e> 
N        #define CONF_GPIODInit_EN           0
N        #define CONF_PD_OUTPUT_DEFAULT      0xFFFF
N        #define CONF_PD_FILTER_CLK          0
N        #define CONF_GPIODInit_Mask         0x0000
N        #define CONF_PD0_CR                 0x00000000
N        #define CONF_PD1_CR                 0x00000000
N        #define CONF_PD2_CR                 0x00000000
N        #define CONF_PD3_CR                 0x00000000
N        #define CONF_PD4_CR                 0x00000000
N        #define CONF_PD5_CR                 0x00000000
N        #define CONF_PD6_CR                 0x00000000
N        #define CONF_PD7_CR                 0x00000000
N        #define CONF_PD8_CR                 0x00000000
N        #define CONF_PD9_CR                 0x00000000
N        #define CONF_PD10_CR                0x00000000
N        #define CONF_PD11_CR                0x00000000
N        #define CONF_PD12_CR                0x00000000
N        #define CONF_PD13_CR                0x00000000
N        #define CONF_PD14_CR                0x00000000
N        #define CONF_PD15_CR                0x00000000
N//  </e> 
N
N//
N//==============================  PE IO Setting  ===============================
N//
N//  <e0> GPIOE Configuration
N//      <o1> PE Output setting<0x0000-0xFFFF>
N//          <i> GPIO PE output data bit 0~15. These bits are mapping to PE0 ~ PE15.
N//      <o2> PE Input filter clock source select <0=> CLK_AHB <1=> CLK_AHB_DIV8 <2=> CLK_ILRCO <3=> TM00_TRGO <4=> CK_UT
N//          <i> PE port input deglitch filter clock source select for all pins of the port.
N//          <i> Default: AFS = CLK_AHB
N//      <e3.0> PE0 Configuration
N//          <o4.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o4.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o4.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o4.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <1=> LEVEL1 <2=> LEVEL2 <3=> LEVEL3
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [1] LEVEL1 : Drive strength-1/2
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//             <i> [3] LEVEL3 : Drive strength-1/8
N//          <o4.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o4.12..15>     AFS : Alternate function select             <0=> GPE0 <1=> OBM_I0 <3=> URT0_TX <6=> TM20_OC00 <7=> TM26_OC00 <8=> MALE
N//          <i> Default: AFS = GPE0
N//      </e> 
N//      <e3.1> PE1 Configuration
N//          <o5.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o5.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o5.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o5.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <1=> LEVEL1 <2=> LEVEL2 <3=> LEVEL3
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [1] LEVEL1 : Drive strength-1/2
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//             <i> [3] LEVEL3 : Drive strength-1/8
N//          <o5.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o5.12..15>     AFS : Alternate function select             <0=> GPE1 <1=> OBM_I1 <3=> URT0_RX <4=> DMA_TRG1 <6=> TM20_OC01 <7=> TM26_OC01 <8=> MOE
N//          <i> Default: AFS = GPE1
N//      </e> 
N//      <e3.2> PE2 Configuration
N//          <o6.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o6.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o6.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o6.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <1=> LEVEL1 <2=> LEVEL2 <3=> LEVEL3
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [1] LEVEL1 : Drive strength-1/2
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//             <i> [3] LEVEL3 : Drive strength-1/8
N//          <o6.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o6.12..15>     AFS : Alternate function select             <0=> GPE2 <3=> URT1_TX <6=> TM20_OC02 <7=> TM26_OC02 <8=> MWE
N//          <i> Default: AFS = GPE2
N//      </e> 
N//      <e3.3> PE3 Configuration
N//          <o7.0..2>       IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o7.5>          PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o7.7>          INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o7.8..9>       ODC : Output drive strength                 <0=> LEVEL0 <1=> LEVEL1 <2=> LEVEL2 <3=> LEVEL3
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [1] LEVEL1 : Drive strength-1/2
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//             <i> [3] LEVEL3 : Drive strength-1/8
N//          <o7.10..11>     FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o7.12..15>     AFS : Alternate function select             <0=> GPE3 <1=> OBM_P1 <3=> URT1_RX <6=> TM20_OC0N <7=> TM26_OC0N <8=> MCE <9=> MALE2
N//          <i> Default: AFS = GPE3
N//      </e> 
N//      <e3.8> PE8 Configuration
N//          <o12.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o12.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o12.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o12.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o12.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o12.12..15>    AFS : Alternate function select             <0=> GPE8 <1=> CPU_TXEV <2=> OBM_I0 <3=> URT2_TX <5=> TM36_CKO <6=> TM20_CKO <7=> TM26_CKO
N//          <i> Default: AFS = GPE8
N//      </e> 
N//      <e3.9> PE9 Configuration
N//          <o13.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o13.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o13.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o13.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o13.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o13.12..15>    AFS : Alternate function select             <0=> GPE9 <1=> CPU_RXEV <2=> OBM_I1 <3=> URT2_RX <5=> TM36_TRGO <6=> TM20_TRGO <7=> TM26_TRGO <9=> MOE
N//          <i> Default: AFS = GPE9
N//      </e> 
N//      <e3.12> PE12 Configuration
N//          <o16.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o16.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o16.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o16.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o16.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o16.12..15>    AFS : Alternate function select             <0=> GPE12 <1=> ADC0_TRG <3=> URT3_TX <4=> TM01_CKO <5=> TM16_CKO <6=> TM20_OC10 <7=> TM26_OC10 <8=> MBW0
N//          <i> Default: AFS = GPE12
N//      </e> 
N//      <e3.13> PE13 Configuration
N//          <o17.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o17.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o17.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o17.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o17.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o17.12..15>    AFS : Alternate function select             <0=> GPE13 <1=> ADC0_OUT <3=> URT3_RX <4=> TM01_TRGO <5=> TM16_TRGO <6=> TM20_OC11 <7=> TM26_OC11 <8=> MBW1
N//          <i> Default: AFS = GPE13
N//      </e> 
N//      <e3.14> PE14 Configuration
N//          <o18.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o18.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o18.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o18.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o18.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o18.12..15>    AFS : Alternate function select             <0=> GPE14 <1=> RTC_OUT <4=> TM01_ETR <5=> TM16_ETR <6=> TM20_OC12 <7=> TM26_OC12 <8=> MALE2
N//          <i> Default: AFS = GPE14
N//      </e> 
N//      <e3.15> PE15 Configuration
N//          <o19.0..2>      IOM : IO mode control                       <0=> AIO <1=> ODO <2=> PPO <3=> DIN
N//          <i> Default: IOM = AIO
N//             <i> [0] AIO : analog IO
N//             <i> [1] ODO : open drain output
N//             <i> [2] PPO : push pull output
N//             <i> [3] DIN : Digital input
N//          <o19.5>         PU : Pull-up resister                       <0=> DISABLE <1=> ENABLE
N//          <i> Default: PU = DISABLE
N//          <o19.7>         INV : Input inverse                         <0=> DISABLE <1=> ENABLE
N//          <i> Default: INV = DISABLE
N//          <o19.8..9>      ODC : Output drive strength                 <0=> LEVEL0 <2=> LEVEL2
N//          <i> Default: ODC = LEVEL0
N//             <i> [0] LEVEL0 : Drive strength-full
N//             <i> [2] LEVEL2 : Drive strength-1/4
N//          <o19.10..11>    FDIV : Input filter clock divider           <0=> BYPASS <1=> DIV1 <2=> DIV4 <3=> DIV16
N//          <i> Default: FDIV = BYPASS
N//             <i> [0] BYPASS : Bypass filter
N//             <i> [1] DIV1 : Divided by 1
N//             <i> [2] DIV4 : Divided by 4
N//             <i> [3] DIV16 : Divided by 16
N//          <o19.12..15>    AFS : Alternate function select             <0=> GPE15 <1=> RTC_TS <5=> TM36_ETR <6=> TM20_OC1N <7=> TM26_OC1N <8=> MALE
N//          <i> Default: AFS = GPE15
N//      </e> 
N        #define CONF_GPIOEInit_EN           0
N        #define CONF_PE_OUTPUT_DEFAULT      0xFFFF
N        #define CONF_PE_FILTER_CLK          0
N        #define CONF_GPIOEInit_Mask         0x0000
N        #define CONF_PE0_CR                 0x00000000
N        #define CONF_PE1_CR                 0x00000000
N        #define CONF_PE2_CR                 0x00000000
N        #define CONF_PE3_CR                 0x00000000
N        #define CONF_PE4_CR                 0x00000000
N        #define CONF_PE5_CR                 0x00000000
N        #define CONF_PE6_CR                 0x00000000
N        #define CONF_PE7_CR                 0x00000000
N        #define CONF_PE8_CR                 0x00000000
N        #define CONF_PE9_CR                 0x00000000
N        #define CONF_PE10_CR                0x00000000
N        #define CONF_PE11_CR                0x00000000
N        #define CONF_PE12_CR                0x00000000
N        #define CONF_PE13_CR                0x00000000
N        #define CONF_PE14_CR                0x00000000
N        #define CONF_PE15_CR                0x00000000
N//  </e> 
N//</h> 
N
N/**
N ******************************************************************************
N *
N * @brief       GPIO Initial Mask Matrix - MG32F02A132 (LQFP80-Package)
N *
N ******************************************************************************
N */
N    static const uint32_t GPIO_CFG[]=
N    {
N        #if CONF_GPIOAInit_EN == 1
X        #if 0 == 1
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN0_Mask) == MG32x02z_PIN0_Mask
S                PA0_CR_ADR,CONF_PA0_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN1_Mask) == MG32x02z_PIN1_Mask
S                PA1_CR_ADR,CONF_PA1_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN2_Mask) == MG32x02z_PIN2_Mask
S                PA2_CR_ADR,CONF_PA2_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN3_Mask) == MG32x02z_PIN3_Mask
S                PA3_CR_ADR,CONF_PA3_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN4_Mask) == MG32x02z_PIN4_Mask
S                PA4_CR_ADR,CONF_PA4_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN5_Mask) == MG32x02z_PIN5_Mask
S                PA5_CR_ADR,CONF_PA5_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN6_Mask) == MG32x02z_PIN6_Mask
S                PA6_CR_ADR,CONF_PA6_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN7_Mask) == MG32x02z_PIN7_Mask
S                PA7_CR_ADR,CONF_PA7_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN8_Mask) == MG32x02z_PIN8_Mask
S                PA8_CR_ADR,CONF_PA8_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN9_Mask) == MG32x02z_PIN9_Mask
S                PA9_CR_ADR,CONF_PA9_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN10_Mask) == MG32x02z_PIN10_Mask
S                PA10_CR_ADR,CONF_PA10_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN11_Mask) == MG32x02z_PIN11_Mask
S                PA11_CR_ADR,CONF_PA11_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN12_Mask) == MG32x02z_PIN12_Mask
S                PA12_CR_ADR,CONF_PA12_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN13_Mask) == MG32x02z_PIN13_Mask
S                PA13_CR_ADR,CONF_PA13_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN14_Mask) == MG32x02z_PIN14_Mask
S                PA14_CR_ADR,CONF_PA14_CR,
S            #endif
S            #if (CONF_GPIOAInit_Mask & MG32x02z_PIN15_Mask) == MG32x02z_PIN15_Mask
S                PA15_CR_ADR,CONF_PA15_CR,
S            #endif
S            PA_FLT_ADR,CONF_PA_FILTER_CLK,
S            PA_OUT_ADR,CONF_PA_OUTPUT_DEFAULT,
N        #endif
N        #if CONF_GPIOBInit_EN == 1
X        #if 0 == 1
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN0_Mask) == MG32x02z_PIN0_Mask
S                PB0_CR_ADR,CONF_PB0_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN1_Mask) == MG32x02z_PIN1_Mask
S                PB1_CR_ADR,CONF_PB1_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN2_Mask) == MG32x02z_PIN2_Mask
S                PB2_CR_ADR,CONF_PB2_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN3_Mask) == MG32x02z_PIN3_Mask
S                PB3_CR_ADR,CONF_PB3_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN4_Mask) == MG32x02z_PIN4_Mask
S                PB4_CR_ADR,CONF_PB4_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN5_Mask) == MG32x02z_PIN5_Mask
S                PB5_CR_ADR,CONF_PB5_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN6_Mask) == MG32x02z_PIN6_Mask
S                PB6_CR_ADR,CONF_PB6_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN7_Mask) == MG32x02z_PIN7_Mask
S                PB7_CR_ADR,CONF_PB7_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN8_Mask) == MG32x02z_PIN8_Mask
S                PB8_CR_ADR,CONF_PB8_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN9_Mask) == MG32x02z_PIN9_Mask
S                PB9_CR_ADR,CONF_PB9_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN10_Mask) == MG32x02z_PIN10_Mask
S                PB10_CR_ADR,CONF_PB10_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN11_Mask) == MG32x02z_PIN11_Mask
S                PB11_CR_ADR,CONF_PB11_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN12_Mask) == MG32x02z_PIN12_Mask
S                PB12_CR_ADR,CONF_PB12_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN13_Mask) == MG32x02z_PIN13_Mask
S                PB13_CR_ADR,CONF_PB13_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN14_Mask) == MG32x02z_PIN14_Mask
S                PB14_CR_ADR,CONF_PB14_CR,
S            #endif
S            #if (CONF_GPIOBInit_Mask & MG32x02z_PIN15_Mask) == MG32x02z_PIN15_Mask
S                PB15_CR_ADR,CONF_PB15_CR,
S            #endif
S            PB_FLT_ADR,CONF_PB_FILTER_CLK,
S            PB_OUT_ADR,CONF_PB_OUTPUT_DEFAULT,
N        #endif
N        #if CONF_GPIOCInit_EN == 1
X        #if 0 == 1
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN0_Mask) == MG32x02z_PIN0_Mask
S                PC0_CR_ADR,CONF_PC0_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN1_Mask) == MG32x02z_PIN1_Mask
S                PC1_CR_ADR,CONF_PC1_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN2_Mask) == MG32x02z_PIN2_Mask
S                PC2_CR_ADR,CONF_PC2_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN3_Mask) == MG32x02z_PIN3_Mask
S                PC3_CR_ADR,CONF_PC3_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN4_Mask) == MG32x02z_PIN4_Mask
S                PC4_CR_ADR,CONF_PC4_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN5_Mask) == MG32x02z_PIN5_Mask
S                PC5_CR_ADR,CONF_PC5_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN6_Mask) == MG32x02z_PIN6_Mask
S                PC6_CR_ADR,CONF_PC6_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN7_Mask) == MG32x02z_PIN7_Mask
S                PC7_CR_ADR,CONF_PC7_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN8_Mask) == MG32x02z_PIN8_Mask
S                PC8_CR_ADR,CONF_PC8_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN9_Mask) == MG32x02z_PIN9_Mask
S                PC9_CR_ADR,CONF_PC9_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN10_Mask) == MG32x02z_PIN10_Mask
S                PC10_CR_ADR,CONF_PC10_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN11_Mask) == MG32x02z_PIN11_Mask
S                PC11_CR_ADR,CONF_PC11_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN12_Mask) == MG32x02z_PIN12_Mask
S                PC12_CR_ADR,CONF_PC12_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN13_Mask) == MG32x02z_PIN13_Mask
S                PC13_CR_ADR,CONF_PC13_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN14_Mask) == MG32x02z_PIN14_Mask
S                PC14_CR_ADR,CONF_PC14_CR,
S            #endif
S            #if (CONF_GPIOCInit_Mask & MG32x02z_PIN15_Mask) == MG32x02z_PIN15_Mask
S                PC15_CR_ADR,CONF_PC15_CR,
S            #endif
S            PC_FLT_ADR,CONF_PC_FILTER_CLK,
S            PC_OUT_ADR,CONF_PC_OUTPUT_DEFAULT,
N        #endif
N        #if CONF_GPIODInit_EN == 1
X        #if 0 == 1
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN0_Mask) == MG32x02z_PIN0_Mask
S                PD0_CR_ADR,CONF_PD0_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN1_Mask) == MG32x02z_PIN1_Mask
S                PD1_CR_ADR,CONF_PD1_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN2_Mask) == MG32x02z_PIN2_Mask
S                PD2_CR_ADR,CONF_PD2_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN3_Mask) == MG32x02z_PIN3_Mask
S                PD3_CR_ADR,CONF_PD3_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN4_Mask) == MG32x02z_PIN4_Mask
S                PD4_CR_ADR,CONF_PD4_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN5_Mask) == MG32x02z_PIN5_Mask
S                PD5_CR_ADR,CONF_PD5_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN6_Mask) == MG32x02z_PIN6_Mask
S                PD6_CR_ADR,CONF_PD6_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN7_Mask) == MG32x02z_PIN7_Mask
S                PD7_CR_ADR,CONF_PD7_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN8_Mask) == MG32x02z_PIN8_Mask
S                PD8_CR_ADR,CONF_PD8_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN9_Mask) == MG32x02z_PIN9_Mask
S                PD9_CR_ADR,CONF_PD9_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN10_Mask) == MG32x02z_PIN10_Mask
S                PD10_CR_ADR,CONF_PD10_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN11_Mask) == MG32x02z_PIN11_Mask
S                PD11_CR_ADR,CONF_PD11_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN12_Mask) == MG32x02z_PIN12_Mask
S                PD12_CR_ADR,CONF_PD12_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN13_Mask) == MG32x02z_PIN13_Mask
S                PD13_CR_ADR,CONF_PD13_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN14_Mask) == MG32x02z_PIN14_Mask
S                PD14_CR_ADR,CONF_PD14_CR,
S            #endif
S            #if (CONF_GPIODInit_Mask & MG32x02z_PIN15_Mask) == MG32x02z_PIN15_Mask
S                PD15_CR_ADR,CONF_PD15_CR,
S            #endif
S            PD_FLT_ADR,CONF_PD_FILTER_CLK,
S            PD_OUT_ADR,CONF_PD_OUTPUT_DEFAULT,
N        #endif
N        #if CONF_GPIOEInit_EN == 1
X        #if 0 == 1
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN0_Mask) == MG32x02z_PIN0_Mask
S                PE0_CR_ADR,CONF_PE0_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN1_Mask) == MG32x02z_PIN1_Mask
S                PE1_CR_ADR,CONF_PE1_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN2_Mask) == MG32x02z_PIN2_Mask
S                PE2_CR_ADR,CONF_PE2_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN3_Mask) == MG32x02z_PIN3_Mask
S                PE3_CR_ADR,CONF_PE3_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN4_Mask) == MG32x02z_PIN4_Mask
S                PE4_CR_ADR,CONF_PE4_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN5_Mask) == MG32x02z_PIN5_Mask
S                PE5_CR_ADR,CONF_PE5_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN6_Mask) == MG32x02z_PIN6_Mask
S                PE6_CR_ADR,CONF_PE6_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN7_Mask) == MG32x02z_PIN7_Mask
S                PE7_CR_ADR,CONF_PE7_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN8_Mask) == MG32x02z_PIN8_Mask
S                PE8_CR_ADR,CONF_PE8_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN9_Mask) == MG32x02z_PIN9_Mask
S                PE9_CR_ADR,CONF_PE9_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN10_Mask) == MG32x02z_PIN10_Mask
S                PE10_CR_ADR,CONF_PE10_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN11_Mask) == MG32x02z_PIN11_Mask
S                PE11_CR_ADR,CONF_PE11_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN12_Mask) == MG32x02z_PIN12_Mask
S                PE12_CR_ADR,CONF_PE12_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN13_Mask) == MG32x02z_PIN13_Mask
S                PE13_CR_ADR,CONF_PE13_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN14_Mask) == MG32x02z_PIN14_Mask
S                PE14_CR_ADR,CONF_PE14_CR,
S            #endif
S            #if (CONF_GPIOEInit_Mask & MG32x02z_PIN15_Mask) == MG32x02z_PIN15_Mask
S                PE15_CR_ADR,CONF_PE15_CR,
S            #endif
S            PE_FLT_ADR,CONF_PE_FILTER_CLK,
S            PE_OUT_ADR,CONF_PE_OUTPUT_DEFAULT,
N        #endif
N        0,
N    };
N// <<< end of Configuration section >>>    
N 
N    
Nvoid GPIO_Init(void);    
N    
N    
N#endif  // _MG32x02z_GPIO_Init_H
L 46 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_CSC
N    #include "MG32x02z_CSC_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_CSC_Init.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CSC_Init.h
N *
N * @brief       This file is used to configure CSC setting.
N *              Device : MG32F02A132
N *
N * @par         Project
N *              MG32x02z
N * @version     V0.50
N * @date        2021/03/30 16:02 (H File Generated Date)
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************* 
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N */
N#include "MG32x02z.h"
N#include "MG32x02z_CSC.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_CSC.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CSC.h
N *
N * @brief       MG32x02z CSC Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_CSC_H
N#define _MG32x02z_CSC_H
N#define _MG32x02z_CSC_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_CSC_H_VER)
S    #error "MG32x02z_CSC_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      CSC_Struct
N *              CSC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  XOSCF         :1;     //[1] XOSC clock stable and ready detect flag
X            volatile uint8_t  XOSCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  ILRCOF        :1;     //[4] ILRCO clock stable and ready detect flag
X            volatile uint8_t  ILRCOF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  IHRCOF        :1;     //[5] IHRCO clock stable and ready detect flag
X            volatile uint8_t  IHRCOF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  PLLF          :1;     //[6] PLL clock stable and ready detect flag
X            volatile uint8_t  PLLF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  MCDF          :1;     //[7] XOSC missing clock detect failure event flag
X            volatile uint8_t  MCDF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  CSC status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] CSC interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  XOSC_IE       :1;     //[1] XOSC clock stable interrupt enable.
X            volatile uint8_t  XOSC_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  ILRCO_IE      :1;     //[4] ILRCO clock stable interrupt enable.
X            volatile uint8_t  ILRCO_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IHRCO_IE      :1;     //[5] IHRCO clock stable interrupt enable.
X            volatile uint8_t  IHRCO_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PLL_IE        :1;     //[6] PLL clock stable interrupt enable.
X            volatile uint8_t  PLL_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MCD_IE        :1;     //[7] XOSC missing clock detect failure event interrupt enable.
X            volatile uint8_t  MCD_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  CSC interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  PLL_MUL       :1;     //[8] CSC PLL multiplication factor select.
X            volatile uint8_t  PLL_MUL       :1;     
N                                        //0 = 16 : PLL input clock x 16
N                                        //1 = 24 : PLL input clock x 24
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  XOSC_GN       :2;     //[17..16] Gain control bits of XOSC. (The default value is loaded from CFG OR after Warm reset)
X            volatile uint8_t  XOSC_GN       :2;     
N                                        //0x0 = 32K_Normal (for 32KHz crystal)
N                                        //0x1 = Medium
N                                        //0x2 = 32K_Lowest (for 32KHz crystal)
N                                        //0x3 = Reserved
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }PLL;                               /*!< PLL        ~ Offset[0x08]  CSC OSC and PLL control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] CSC key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  CSC write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :3;     //[2..0] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  IHRCO_EN      :1;     //[3] IHRCO circuit enable.
X            volatile uint8_t  IHRCO_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MCD_DIS       :1;     //[4] MCD missing clock detector circuit disable.
X            volatile uint8_t  MCD_DIS       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  PLL_EN        :1;     //[5] PLL circuit enable.
X            volatile uint8_t  PLL_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  LS_SEL        :2;     //[9..8] Input low speed clock source select
X            volatile uint8_t  LS_SEL        :2;     
N                                        //0x0 = Reserved
N                                        //0x1 = XOSC
N                                        //0x2 = ILRCO
N                                        //0x3 = CK_EXT
N            __IO uint8_t  HS_SEL        :2;     //[11..10] Input high speed clock source select
X            volatile uint8_t  HS_SEL        :2;     
N                                        //0x0 = IHRCO
N                                        //0x1 = XOSC
N                                        //0x2 = ILRCO
N                                        //0x3 = CK_EXT
N            __I  uint8_t                :1;     //[12] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MAIN_SEL      :2;     //[15..14] System main clock source select.
X            volatile uint8_t  MAIN_SEL      :2;     
N                                        //0x0 = CK_HS
N                                        //0x1 = CK_PLLI
N                                        //0x2 = CK_PLLO
N                                        //0x3 = Reserved
N            __IO uint8_t  ST_SEL        :1;     //[16] System tick timer external clock source select.
X            volatile uint8_t  ST_SEL        :1;     
N                                        //0 = HCLK8 : HCLK divided by 8
N                                        //1 = CK_LS2 : CK_LS divided by 2
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IHRCO_SEL     :1;     //[18] IHRCO clock frequency trimming set select.
X            volatile uint8_t  IHRCO_SEL     :1;     
N                                        //0 = 12 : 12MHz from trimming set 0
N                                        //1 = 11 : 11.059MHz from trimming set 1
N            __I  uint8_t                :3;     //[21..19] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  MCD_SEL       :2;     //[23..22] Missing clock detection duration select.
X            volatile uint8_t  MCD_SEL       :2;     
N                                        //0x0 = 125us
N                                        //0x1 = 250us
N                                        //0x2 = 500us
N                                        //0x3 = 1ms
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  CSC clock source control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PLLI_DIV      :2;     //[1..0] PLL input clock source divider
X            volatile uint8_t  PLLI_DIV      :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV6 : divided by 6
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  PLLO_DIV      :2;     //[5..4] PLL output clock source divider
X            volatile uint8_t  PLLO_DIV      :2;     
N                                        //0x0 = DIV4 : divided by 4
N                                        //0x1 = DIV3 : divided by 3
N                                        //0x2 = DIV2 : divided by 2
N                                        //0x3 = DIV1 : divided by 1
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AHB_DIV       :4;     //[11..8] AHB clock source divider. Value 0~9 mean to divide by 1,2,4,8,16,32,64,128,256,512.
X            volatile uint8_t  AHB_DIV       :4;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N                                        //0x5 = DIV32 : divided by 32
N                                        //0x6 = DIV64 : divided by 64
N                                        //0x7 = DIV128 : divided by 128
N                                        //0x8 = DIV256 : divided by 256
N                                        //0x9 = DIV512 : divided by 512
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  APB_DIV       :3;     //[18..16] APB clock source divider. Value 0~4 mean to divide by 1,2,4,8,16.
X            volatile uint8_t  APB_DIV       :3;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  UT_DIV        :2;     //[27..26] Unit time clock source divider.
X            volatile uint8_t  UT_DIV        :2;     
N                                        //0x0 = DIV32 : divided by 32
N                                        //0x1 = DIV8 : divided by 8
N                                        //0x2 = DIV16 : divided by 16
N                                        //0x3 = DIV128 : divided by 128
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }DIV;                               /*!< DIV        ~ Offset[0x14]  CSC clock  divider register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CKO_EN        :1;     //[0] Internal clock output enable. When enables, it will reset the output divider.
X            volatile uint8_t  CKO_EN        :1;     
N                                        //0x0 = Disable
N                                        //0x1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CKO_DIV       :2;     //[3..2] Internal clock output divider
X            volatile uint8_t  CKO_DIV       :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __IO uint8_t  CKO_SEL       :3;     //[6..4] Internal clock output source select
X            volatile uint8_t  CKO_SEL       :3;     
N                                        //0x0 = CK_MAIN
N                                        //0x1 = CK_AHB
N                                        //0x2 = CK_APB
N                                        //0x3 = CK_HS
N                                        //0x4 = CK_LS
N                                        //0x5 = CK_XOSC
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CKO;                               /*!< CKO        ~ Offset[0x18]  CSC internal clock output control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IOPA_EN       :1;     //[0] IO Port A clock source enable
X            volatile uint8_t  IOPA_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IOPB_EN       :1;     //[1] IO Port B clock source enable
X            volatile uint8_t  IOPB_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IOPC_EN       :1;     //[2] IO Port C clock source enable
X            volatile uint8_t  IOPC_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IOPD_EN       :1;     //[3] IO Port D clock source enable
X            volatile uint8_t  IOPD_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IOPE_EN       :1;     //[4] IO Port E clock source enable
X            volatile uint8_t  IOPE_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  GPL_EN        :1;     //[8] GPL clock source enable.
X            volatile uint8_t  GPL_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[11..9] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  EMB_EN        :1;     //[12] External memory bus clock source enable.
X            volatile uint8_t  EMB_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[14..13] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  DMA_EN        :1;     //[15] DMA clock source enable.
X            volatile uint8_t  DMA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }AHB;                               /*!< AHB        ~ Offset[0x1C]  CSC AHB clock control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ADC0_EN       :1;     //[0] ADC module clock source enable.
X            volatile uint8_t  ADC0_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CMP_EN        :1;     //[2] CMP module clock source enable.
X            volatile uint8_t  CMP_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DAC_EN        :1;     //[3] DAC module clock source enable.
X            volatile uint8_t  DAC_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RTC_EN        :1;     //[5] RTC module clock source enable
X            volatile uint8_t  RTC_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IWDT_EN       :1;     //[6] IWDT module clock source enable
X            volatile uint8_t  IWDT_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WWDT_EN       :1;     //[7] WWDT module clock source enable. (This register is reset only by Cold reset.)
X            volatile uint8_t  WWDT_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  I2C0_EN       :1;     //[8] I2C0 module clock source enable.
X            volatile uint8_t  I2C0_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  I2C1_EN       :1;     //[9] I2C1 module clock source enable.
X            volatile uint8_t  I2C1_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SPI0_EN       :1;     //[12] SPI0 module clock source enable.
X            volatile uint8_t  SPI0_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  URT0_EN       :1;     //[16] URT0 UART module clock source enable.
X            volatile uint8_t  URT0_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  URT1_EN       :1;     //[17] URT1 UART module clock source enable.
X            volatile uint8_t  URT1_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  URT2_EN       :1;     //[18] URT2 UART module clock source enable.
X            volatile uint8_t  URT2_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  URT3_EN       :1;     //[19] URT3 UART module clock source enable.
X            volatile uint8_t  URT3_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }APB0;                              /*!< APB0       ~ Offset[0x20]  CSC APB clock control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TM00_EN       :1;     //[0] TM00 module clock source enable.
X            volatile uint8_t  TM00_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TM01_EN       :1;     //[1] TM01 module clock source enable.
X            volatile uint8_t  TM01_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  TM10_EN       :1;     //[4] TM10 module clock source enable.
X            volatile uint8_t  TM10_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[6..5] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  TM16_EN       :1;     //[7] TM11 module clock source enable.
X            volatile uint8_t  TM16_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TM20_EN       :1;     //[8] TM20 module clock source enable.
X            volatile uint8_t  TM20_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[10..9] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  TM26_EN       :1;     //[11] TM26 module clock source enable.
X            volatile uint8_t  TM26_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[14..12] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  TM36_EN       :1;     //[15] TM36 module clock source enable.
X            volatile uint8_t  TM36_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }APB1;                              /*!< APB1       ~ Offset[0x24]  CSC APB clock control register 1 */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x28]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SLP_ADC0      :1;     //[0] ADC module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_ADC0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SLP_CMP       :1;     //[2] CMP module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_CMP       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_DAC       :1;     //[3] DAC module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_DAC       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SLP_RTC       :1;     //[5] IWDT module clock enable in SLEEP mode
X            volatile uint8_t  SLP_RTC       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_IWDT      :1;     //[6] IWDT module clock enable in SLEEP mode
X            volatile uint8_t  SLP_IWDT      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_WWDT      :1;     //[7] WWDT module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_WWDT      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_I2C0      :1;     //[8] I2C0 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_I2C0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_I2C1      :1;     //[9] I2C1 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_I2C1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SLP_SPI0      :1;     //[12] SPI0 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_SPI0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  SLP_URT0      :1;     //[16] URT0 UART module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_URT0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_URT1      :1;     //[17] URT1 UART module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_URT1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_URT2      :1;     //[18] URT2 UART module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_URT2      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_URT3      :1;     //[19] URT3 UART module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_URT3      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SLP0;                              /*!< SLP0       ~ Offset[0x30]  CSC SLEEP mode clock enable register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SLP_TM00      :1;     //[0] TM00 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM00      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_TM01      :1;     //[1] TM01 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM01      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SLP_TM10      :1;     //[4] TM10 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM10      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[6..5] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SLP_TM16      :1;     //[7] TM11 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM16      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SLP_TM20      :1;     //[8] TM20 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM20      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[10..9] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SLP_TM26      :1;     //[11] TM26 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM26      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[14..12] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  SLP_TM36      :1;     //[15] TM36 module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_TM36      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  SLP_EMB       :1;     //[30] EMB module clock enable in SLEEP mode.
X            volatile uint8_t  SLP_EMB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }SLP1;                              /*!< SLP1       ~ Offset[0x34]  CSC SLEEP mode clock enable register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  STP_RTC       :1;     //[5] IWDT module clock enable in STOP mode
X            volatile uint8_t  STP_RTC       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  STP_IWDT      :1;     //[6] IWDT module clock enable in STOP mode
X            volatile uint8_t  STP_IWDT      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STP0;                              /*!< STP0       ~ Offset[0x38]  CSC STOP mode clock enable register 0 */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x3C]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ADC0_CKS      :1;     //[0] ADC0 process clock source select.
X            volatile uint8_t  ADC0_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :3;     //[3..1] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  CMP_CKS       :1;     //[4] CMP process clock source select.
X            volatile uint8_t  CMP_CKS       :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __IO uint8_t  DAC_CKS       :1;     //[5] DAC process clock source select.
X            volatile uint8_t  DAC_CKS       :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CKS0;                              /*!< CKS0       ~ Offset[0x40]  CSC clock source select register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  I2C0_CKS      :1;     //[0] I2C0 process clock source select.
X            volatile uint8_t  I2C0_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  I2C1_CKS      :1;     //[2] I2C1 process clock source select.
X            volatile uint8_t  I2C1_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  SPI0_CKS      :1;     //[8] SPI0 process clock source select.
X            volatile uint8_t  SPI0_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  URT0_CKS      :1;     //[16] URT0 process clock source select.
X            volatile uint8_t  URT0_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  URT1_CKS      :1;     //[18] URT1 process clock source select.
X            volatile uint8_t  URT1_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  URT2_CKS      :1;     //[20] URT2 process clock source select.
X            volatile uint8_t  URT2_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[21] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  URT3_CKS      :1;     //[22] URT3 process clock source select.
X            volatile uint8_t  URT3_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CKS1;                              /*!< CKS1       ~ Offset[0x44]  CSC clock source select register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TM00_CKS      :1;     //[0] TM00 process clock source select.
X            volatile uint8_t  TM00_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TM01_CKS      :1;     //[2] TM01 process clock source select.
X            volatile uint8_t  TM01_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  TM10_CKS      :1;     //[8] TM10 process clock source select.
X            volatile uint8_t  TM10_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :5;     //[13..9] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  TM16_CKS      :1;     //[14] TM11 process clock source select.
X            volatile uint8_t  TM16_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TM20_CKS      :1;     //[16] TM20 process clock source select.
X            volatile uint8_t  TM20_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :5;     //[21..17] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  TM26_CKS      :1;     //[22] TM26 process clock source select.
X            volatile uint8_t  TM26_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  TM36_CKS      :1;     //[30] TM36 process clock source select.
X            volatile uint8_t  TM36_CKS      :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_AHB
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }CKS2;                              /*!< CKS2       ~ Offset[0x48]  CSC clock source select register 2 */
N
N} CSC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        CSC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define CSC_Base                        ((uint32_t)0x4C010000)              /*!< Clock Source Controller */
N#define CSC                             ((CSC_Struct*) CSC_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        CSC  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        CSC_STA  [register's definitions]
N *              Offset[0x00]  CSC status register (0x4C010000)
N ******************************************************************************
N */
N///@{
N#define CSC_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_STA */
N#define CSC_STA_MCDF_mask_w                         ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CSC_STA_MCDF_mask_h0                        ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CSC_STA_MCDF_mask_b0                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_STA_MCDF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CSC_STA_MCDF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CSC_STA_MCDF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CSC_STA_MCDF_happened_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define CSC_STA_MCDF_happened_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define CSC_STA_MCDF_happened_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CSC_STA_PLLF_mask_w                         ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CSC_STA_PLLF_mask_h0                        ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_STA_PLLF_mask_b0                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_STA_PLLF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CSC_STA_PLLF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CSC_STA_PLLF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CSC_STA_PLLF_happened_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define CSC_STA_PLLF_happened_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define CSC_STA_PLLF_happened_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CSC_STA_IHRCOF_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_STA_IHRCOF_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_STA_IHRCOF_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_STA_IHRCOF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CSC_STA_IHRCOF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CSC_STA_IHRCOF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CSC_STA_IHRCOF_happened_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define CSC_STA_IHRCOF_happened_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define CSC_STA_IHRCOF_happened_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CSC_STA_ILRCOF_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_STA_ILRCOF_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_STA_ILRCOF_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_STA_ILRCOF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CSC_STA_ILRCOF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CSC_STA_ILRCOF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CSC_STA_ILRCOF_happened_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define CSC_STA_ILRCOF_happened_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define CSC_STA_ILRCOF_happened_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CSC_STA_XOSCF_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CSC_STA_XOSCF_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_STA_XOSCF_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_STA_XOSCF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CSC_STA_XOSCF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CSC_STA_XOSCF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CSC_STA_XOSCF_happened_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define CSC_STA_XOSCF_happened_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define CSC_STA_XOSCF_happened_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_INT  [register's definitions]
N *              Offset[0x04]  CSC interrupt enable register (0x4C010004)
N ******************************************************************************
N */
N///@{
N#define CSC_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_INT */
N#define CSC_INT_MCD_IE_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CSC_INT_MCD_IE_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CSC_INT_MCD_IE_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_INT_MCD_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_INT_MCD_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_INT_MCD_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_INT_MCD_IE_enable_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_INT_MCD_IE_enable_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_INT_MCD_IE_enable_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_INT_PLL_IE_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CSC_INT_PLL_IE_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_INT_PLL_IE_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_INT_PLL_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_INT_PLL_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_INT_PLL_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_INT_PLL_IE_enable_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_INT_PLL_IE_enable_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_INT_PLL_IE_enable_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_INT_IHRCO_IE_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_INT_IHRCO_IE_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_INT_IHRCO_IE_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_INT_IHRCO_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_INT_IHRCO_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_INT_IHRCO_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_INT_IHRCO_IE_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_INT_IHRCO_IE_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_INT_IHRCO_IE_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_INT_ILRCO_IE_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_INT_ILRCO_IE_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_INT_ILRCO_IE_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_INT_ILRCO_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_INT_ILRCO_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_INT_ILRCO_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_INT_ILRCO_IE_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_INT_ILRCO_IE_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_INT_ILRCO_IE_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_INT_XOSC_IE_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CSC_INT_XOSC_IE_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_INT_XOSC_IE_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_INT_XOSC_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_INT_XOSC_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_INT_XOSC_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_INT_XOSC_IE_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_INT_XOSC_IE_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_INT_XOSC_IE_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_PLL  [register's definitions]
N *              Offset[0x08]  CSC OSC and PLL control register (0x4C010008)
N ******************************************************************************
N */
N///@{
N#define CSC_PLL_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_PLL */
N#define CSC_PLL_XOSC_GN_mask_w                      ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define CSC_PLL_XOSC_GN_mask_h1                     ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CSC_PLL_XOSC_GN_mask_b2                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CSC_PLL_XOSC_GN_32k_normal_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):32K_Normal of 32bit */
N#define CSC_PLL_XOSC_GN_32k_normal_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0x0):32K_Normal of 16bit */
N#define CSC_PLL_XOSC_GN_32k_normal_b2               ((uint8_t )0x00)        /*!< Bit Value =(0x0):32K_Normal of 8bit */
N#define CSC_PLL_XOSC_GN_medium_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Medium of 32bit */
N#define CSC_PLL_XOSC_GN_medium_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Medium of 16bit */
N#define CSC_PLL_XOSC_GN_medium_b2                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):Medium of 8bit */
N#define CSC_PLL_XOSC_GN_32k_lowest_w                ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):32K_Lowest of 32bit */
N#define CSC_PLL_XOSC_GN_32k_lowest_h1               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):32K_Lowest of 16bit */
N#define CSC_PLL_XOSC_GN_32k_lowest_b2               ((uint8_t )0x02)        /*!< Bit Value =(0x2):32K_Lowest of 8bit */
N
N#define CSC_PLL_PLL_MUL_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_PLL_PLL_MUL_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_PLL_PLL_MUL_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_PLL_PLL_MUL_16_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):16 of 32bit */
N#define CSC_PLL_PLL_MUL_16_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):16 of 16bit */
N#define CSC_PLL_PLL_MUL_16_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):16 of 8bit */
N#define CSC_PLL_PLL_MUL_24_w                        ((uint32_t)0x00000100)  /*!< Bit Value =(1):24 of 32bit */
N#define CSC_PLL_PLL_MUL_24_h0                       ((uint16_t)0x0100)      /*!< Bit Value =(1):24 of 16bit */
N#define CSC_PLL_PLL_MUL_24_b1                       ((uint8_t )0x01)        /*!< Bit Value =(1):24 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_KEY  [register's definitions]
N *              Offset[0x0C]  CSC write protected Key register (0x4C01000C)
N ******************************************************************************
N */
N///@{
N#define CSC_KEY_default                             ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_KEY */
N#define CSC_KEY_KEY_mask_w                          ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define CSC_KEY_KEY_mask_h0                         ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define CSC_KEY_KEY_unprotected_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define CSC_KEY_KEY_unprotected_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define CSC_KEY_KEY_unprotected_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define CSC_KEY_KEY_protected_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define CSC_KEY_KEY_protected_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define CSC_KEY_KEY_protected_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_CR0  [register's definitions]
N *              Offset[0x10]  CSC clock source control register 0 (0x4C010010)
N ******************************************************************************
N */
N///@{
N#define CSC_CR0_default                             ((uint32_t)0x00000200)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_CR0 */
N#define CSC_CR0_MCD_SEL_mask_w                      ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_MCD_SEL_mask_h1                     ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_MCD_SEL_mask_b2                     ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_MCD_SEL_125us_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):125us of 32bit */
N#define CSC_CR0_MCD_SEL_125us_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):125us of 16bit */
N#define CSC_CR0_MCD_SEL_125us_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):125us of 8bit */
N#define CSC_CR0_MCD_SEL_250us_w                     ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):250us of 32bit */
N#define CSC_CR0_MCD_SEL_250us_h1                    ((uint16_t)0x0040)      /*!< Bit Value =(0x1):250us of 16bit */
N#define CSC_CR0_MCD_SEL_250us_b2                    ((uint8_t )0x40)        /*!< Bit Value =(0x1):250us of 8bit */
N#define CSC_CR0_MCD_SEL_500us_w                     ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):500us of 32bit */
N#define CSC_CR0_MCD_SEL_500us_h1                    ((uint16_t)0x0080)      /*!< Bit Value =(0x2):500us of 16bit */
N#define CSC_CR0_MCD_SEL_500us_b2                    ((uint8_t )0x80)        /*!< Bit Value =(0x2):500us of 8bit */
N#define CSC_CR0_MCD_SEL_1ms_w                       ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):1ms of 32bit */
N#define CSC_CR0_MCD_SEL_1ms_h1                      ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):1ms of 16bit */
N#define CSC_CR0_MCD_SEL_1ms_b2                      ((uint8_t )0xC0)        /*!< Bit Value =(0x3):1ms of 8bit */
N
N#define CSC_CR0_IHRCO_SEL_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_IHRCO_SEL_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_IHRCO_SEL_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_IHRCO_SEL_12_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):12 of 32bit */
N#define CSC_CR0_IHRCO_SEL_12_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):12 of 16bit */
N#define CSC_CR0_IHRCO_SEL_12_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):12 of 8bit */
N#define CSC_CR0_IHRCO_SEL_11_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):11 of 32bit */
N#define CSC_CR0_IHRCO_SEL_11_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):11 of 16bit */
N#define CSC_CR0_IHRCO_SEL_11_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):11 of 8bit */
N
N#define CSC_CR0_ST_SEL_mask_w                       ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_ST_SEL_mask_h1                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_ST_SEL_mask_b2                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_ST_SEL_hclk8_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):HCLK8 of 32bit */
N#define CSC_CR0_ST_SEL_hclk8_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):HCLK8 of 16bit */
N#define CSC_CR0_ST_SEL_hclk8_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):HCLK8 of 8bit */
N#define CSC_CR0_ST_SEL_ck_ls2_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):CK_LS2 of 32bit */
N#define CSC_CR0_ST_SEL_ck_ls2_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):CK_LS2 of 16bit */
N#define CSC_CR0_ST_SEL_ck_ls2_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):CK_LS2 of 8bit */
N
N#define CSC_CR0_MAIN_SEL_mask_w                     ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_MAIN_SEL_mask_h0                    ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_MAIN_SEL_mask_b1                    ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_MAIN_SEL_ck_hs_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_HS of 32bit */
N#define CSC_CR0_MAIN_SEL_ck_hs_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_HS of 16bit */
N#define CSC_CR0_MAIN_SEL_ck_hs_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_HS of 8bit */
N#define CSC_CR0_MAIN_SEL_ck_plli_w                  ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):CK_PLLI of 32bit */
N#define CSC_CR0_MAIN_SEL_ck_plli_h0                 ((uint16_t)0x4000)      /*!< Bit Value =(0x1):CK_PLLI of 16bit */
N#define CSC_CR0_MAIN_SEL_ck_plli_b1                 ((uint8_t )0x40)        /*!< Bit Value =(0x1):CK_PLLI of 8bit */
N#define CSC_CR0_MAIN_SEL_ck_pllo_w                  ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):CK_PLLO of 32bit */
N#define CSC_CR0_MAIN_SEL_ck_pllo_h0                 ((uint16_t)0x8000)      /*!< Bit Value =(0x2):CK_PLLO of 16bit */
N#define CSC_CR0_MAIN_SEL_ck_pllo_b1                 ((uint8_t )0x80)        /*!< Bit Value =(0x2):CK_PLLO of 8bit */
N
N#define CSC_CR0_HS_SEL_mask_w                       ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_HS_SEL_mask_h0                      ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_HS_SEL_mask_b1                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_HS_SEL_ihrco_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IHRCO of 32bit */
N#define CSC_CR0_HS_SEL_ihrco_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IHRCO of 16bit */
N#define CSC_CR0_HS_SEL_ihrco_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IHRCO of 8bit */
N#define CSC_CR0_HS_SEL_xosc_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):XOSC of 32bit */
N#define CSC_CR0_HS_SEL_xosc_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x1):XOSC of 16bit */
N#define CSC_CR0_HS_SEL_xosc_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x1):XOSC of 8bit */
N#define CSC_CR0_HS_SEL_ilrco_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):ILRCO of 32bit */
N#define CSC_CR0_HS_SEL_ilrco_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):ILRCO of 16bit */
N#define CSC_CR0_HS_SEL_ilrco_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):ILRCO of 8bit */
N#define CSC_CR0_HS_SEL_ck_ext_w                     ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):CK_EXT of 32bit */
N#define CSC_CR0_HS_SEL_ck_ext_h0                    ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):CK_EXT of 16bit */
N#define CSC_CR0_HS_SEL_ck_ext_b1                    ((uint8_t )0x0C)        /*!< Bit Value =(0x3):CK_EXT of 8bit */
N
N#define CSC_CR0_LS_SEL_mask_w                       ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_LS_SEL_mask_h0                      ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_LS_SEL_mask_b1                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_LS_SEL_xosc_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):XOSC of 32bit */
N#define CSC_CR0_LS_SEL_xosc_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):XOSC of 16bit */
N#define CSC_CR0_LS_SEL_xosc_b1                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):XOSC of 8bit */
N#define CSC_CR0_LS_SEL_ilrco_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):ILRCO of 32bit */
N#define CSC_CR0_LS_SEL_ilrco_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):ILRCO of 16bit */
N#define CSC_CR0_LS_SEL_ilrco_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):ILRCO of 8bit */
N#define CSC_CR0_LS_SEL_ck_ext_w                     ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):CK_EXT of 32bit */
N#define CSC_CR0_LS_SEL_ck_ext_h0                    ((uint16_t)0x0300)      /*!< Bit Value =(0x3):CK_EXT of 16bit */
N#define CSC_CR0_LS_SEL_ck_ext_b1                    ((uint8_t )0x03)        /*!< Bit Value =(0x3):CK_EXT of 8bit */
N
N#define CSC_CR0_PLL_EN_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_PLL_EN_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_PLL_EN_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_PLL_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_CR0_PLL_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_CR0_PLL_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_CR0_PLL_EN_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_CR0_PLL_EN_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_CR0_PLL_EN_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_CR0_MCD_DIS_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_MCD_DIS_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_MCD_DIS_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_MCD_DIS_enable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CSC_CR0_MCD_DIS_enable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CSC_CR0_MCD_DIS_enable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CSC_CR0_MCD_DIS_disable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Disable of 32bit */
N#define CSC_CR0_MCD_DIS_disable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Disable of 16bit */
N#define CSC_CR0_MCD_DIS_disable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CSC_CR0_IHRCO_EN_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CSC_CR0_IHRCO_EN_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CSC_CR0_IHRCO_EN_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_CR0_IHRCO_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_CR0_IHRCO_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_CR0_IHRCO_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_CR0_IHRCO_EN_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_CR0_IHRCO_EN_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_CR0_IHRCO_EN_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_DIV  [register's definitions]
N *              Offset[0x14]  CSC clock  divider register (0x4C010014)
N ******************************************************************************
N */
N///@{
N#define CSC_DIV_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_DIV */
N#define CSC_DIV_UT_DIV_mask_w                       ((uint32_t)0x0C000000)  /*!< Bit Mask of 32bit */
N#define CSC_DIV_UT_DIV_mask_h1                      ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define CSC_DIV_UT_DIV_mask_b3                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CSC_DIV_UT_DIV_div32_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV32 of 32bit */
N#define CSC_DIV_UT_DIV_div32_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV32 of 16bit */
N#define CSC_DIV_UT_DIV_div32_b3                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV32 of 8bit */
N#define CSC_DIV_UT_DIV_div8_w                       ((uint32_t)0x04000000)  /*!< Bit Value =(0x1):DIV8 of 32bit */
N#define CSC_DIV_UT_DIV_div8_h1                      ((uint16_t)0x0400)      /*!< Bit Value =(0x1):DIV8 of 16bit */
N#define CSC_DIV_UT_DIV_div8_b3                      ((uint8_t )0x04)        /*!< Bit Value =(0x1):DIV8 of 8bit */
N#define CSC_DIV_UT_DIV_div16_w                      ((uint32_t)0x08000000)  /*!< Bit Value =(0x2):DIV16 of 32bit */
N#define CSC_DIV_UT_DIV_div16_h1                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):DIV16 of 16bit */
N#define CSC_DIV_UT_DIV_div16_b3                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):DIV16 of 8bit */
N#define CSC_DIV_UT_DIV_div128_w                     ((uint32_t)0x0C000000)  /*!< Bit Value =(0x3):DIV128 of 32bit */
N#define CSC_DIV_UT_DIV_div128_h1                    ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):DIV128 of 16bit */
N#define CSC_DIV_UT_DIV_div128_b3                    ((uint8_t )0x0C)        /*!< Bit Value =(0x3):DIV128 of 8bit */
N
N#define CSC_DIV_APB_DIV_mask_w                      ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define CSC_DIV_APB_DIV_mask_h1                     ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define CSC_DIV_APB_DIV_mask_b2                     ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CSC_DIV_APB_DIV_div1_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CSC_DIV_APB_DIV_div1_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CSC_DIV_APB_DIV_div1_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CSC_DIV_APB_DIV_div2_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CSC_DIV_APB_DIV_div2_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CSC_DIV_APB_DIV_div2_b2                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CSC_DIV_APB_DIV_div4_w                      ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CSC_DIV_APB_DIV_div4_h1                     ((uint16_t)0x0002)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CSC_DIV_APB_DIV_div4_b2                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CSC_DIV_APB_DIV_div8_w                      ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CSC_DIV_APB_DIV_div8_h1                     ((uint16_t)0x0003)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CSC_DIV_APB_DIV_div8_b2                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define CSC_DIV_APB_DIV_div16_w                     ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define CSC_DIV_APB_DIV_div16_h1                    ((uint16_t)0x0004)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define CSC_DIV_APB_DIV_div16_b2                    ((uint8_t )0x04)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N
N#define CSC_DIV_AHB_DIV_mask_w                      ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define CSC_DIV_AHB_DIV_mask_h0                     ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define CSC_DIV_AHB_DIV_mask_b1                     ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CSC_DIV_AHB_DIV_div1_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CSC_DIV_AHB_DIV_div1_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CSC_DIV_AHB_DIV_div1_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CSC_DIV_AHB_DIV_div2_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CSC_DIV_AHB_DIV_div2_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CSC_DIV_AHB_DIV_div2_b1                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CSC_DIV_AHB_DIV_div4_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CSC_DIV_AHB_DIV_div4_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CSC_DIV_AHB_DIV_div4_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CSC_DIV_AHB_DIV_div8_w                      ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CSC_DIV_AHB_DIV_div8_h0                     ((uint16_t)0x0300)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CSC_DIV_AHB_DIV_div8_b1                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define CSC_DIV_AHB_DIV_div16_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define CSC_DIV_AHB_DIV_div16_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define CSC_DIV_AHB_DIV_div16_b1                    ((uint8_t )0x04)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N#define CSC_DIV_AHB_DIV_div32_w                     ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):DIV32 of 32bit */
N#define CSC_DIV_AHB_DIV_div32_h0                    ((uint16_t)0x0500)      /*!< Bit Value =(0x5):DIV32 of 16bit */
N#define CSC_DIV_AHB_DIV_div32_b1                    ((uint8_t )0x05)        /*!< Bit Value =(0x5):DIV32 of 8bit */
N#define CSC_DIV_AHB_DIV_div64_w                     ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):DIV64 of 32bit */
N#define CSC_DIV_AHB_DIV_div64_h0                    ((uint16_t)0x0600)      /*!< Bit Value =(0x6):DIV64 of 16bit */
N#define CSC_DIV_AHB_DIV_div64_b1                    ((uint8_t )0x06)        /*!< Bit Value =(0x6):DIV64 of 8bit */
N#define CSC_DIV_AHB_DIV_div128_w                    ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):DIV128 of 32bit */
N#define CSC_DIV_AHB_DIV_div128_h0                   ((uint16_t)0x0700)      /*!< Bit Value =(0x7):DIV128 of 16bit */
N#define CSC_DIV_AHB_DIV_div128_b1                   ((uint8_t )0x07)        /*!< Bit Value =(0x7):DIV128 of 8bit */
N#define CSC_DIV_AHB_DIV_div256_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(0x8):DIV256 of 32bit */
N#define CSC_DIV_AHB_DIV_div256_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(0x8):DIV256 of 16bit */
N#define CSC_DIV_AHB_DIV_div256_b1                   ((uint8_t )0x08)        /*!< Bit Value =(0x8):DIV256 of 8bit */
N#define CSC_DIV_AHB_DIV_div512_w                    ((uint32_t)0x00000900)  /*!< Bit Value =(0x9):DIV512 of 32bit */
N#define CSC_DIV_AHB_DIV_div512_h0                   ((uint16_t)0x0900)      /*!< Bit Value =(0x9):DIV512 of 16bit */
N#define CSC_DIV_AHB_DIV_div512_b1                   ((uint8_t )0x09)        /*!< Bit Value =(0x9):DIV512 of 8bit */
N
N#define CSC_DIV_PLLO_DIV_mask_w                     ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define CSC_DIV_PLLO_DIV_mask_h0                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CSC_DIV_PLLO_DIV_mask_b0                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CSC_DIV_PLLO_DIV_div4_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV4 of 32bit */
N#define CSC_DIV_PLLO_DIV_div4_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV4 of 16bit */
N#define CSC_DIV_PLLO_DIV_div4_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV4 of 8bit */
N#define CSC_DIV_PLLO_DIV_div3_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV3 of 32bit */
N#define CSC_DIV_PLLO_DIV_div3_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV3 of 16bit */
N#define CSC_DIV_PLLO_DIV_div3_b0                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV3 of 8bit */
N#define CSC_DIV_PLLO_DIV_div2_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV2 of 32bit */
N#define CSC_DIV_PLLO_DIV_div2_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV2 of 16bit */
N#define CSC_DIV_PLLO_DIV_div2_b0                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV2 of 8bit */
N#define CSC_DIV_PLLO_DIV_div1_w                     ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV1 of 32bit */
N#define CSC_DIV_PLLO_DIV_div1_h0                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV1 of 16bit */
N#define CSC_DIV_PLLO_DIV_div1_b0                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV1 of 8bit */
N
N#define CSC_DIV_PLLI_DIV_mask_w                     ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define CSC_DIV_PLLI_DIV_mask_h0                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CSC_DIV_PLLI_DIV_mask_b0                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CSC_DIV_PLLI_DIV_div1_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CSC_DIV_PLLI_DIV_div1_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CSC_DIV_PLLI_DIV_div1_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CSC_DIV_PLLI_DIV_div2_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CSC_DIV_PLLI_DIV_div2_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CSC_DIV_PLLI_DIV_div2_b0                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CSC_DIV_PLLI_DIV_div4_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CSC_DIV_PLLI_DIV_div4_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CSC_DIV_PLLI_DIV_div4_b0                    ((uint8_t )0x02)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CSC_DIV_PLLI_DIV_div6_w                     ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):DIV6 of 32bit */
N#define CSC_DIV_PLLI_DIV_div6_h0                    ((uint16_t)0x0003)      /*!< Bit Value =(0x3):DIV6 of 16bit */
N#define CSC_DIV_PLLI_DIV_div6_b0                    ((uint8_t )0x03)        /*!< Bit Value =(0x3):DIV6 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_CKO  [register's definitions]
N *              Offset[0x18]  CSC internal clock output control register (0x4C010018)
N ******************************************************************************
N */
N///@{
N#define CSC_CKO_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_CKO */
N#define CSC_CKO_CKO_SEL_mask_w                      ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define CSC_CKO_CKO_SEL_mask_h0                     ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define CSC_CKO_CKO_SEL_mask_b0                     ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define CSC_CKO_CKO_SEL_ck_main_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_MAIN of 32bit */
N#define CSC_CKO_CKO_SEL_ck_main_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_MAIN of 16bit */
N#define CSC_CKO_CKO_SEL_ck_main_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_MAIN of 8bit */
N#define CSC_CKO_CKO_SEL_ck_ahb_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKO_CKO_SEL_ck_ahb_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKO_CKO_SEL_ck_ahb_b0                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N#define CSC_CKO_CKO_SEL_ck_apb_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):CK_APB of 32bit */
N#define CSC_CKO_CKO_SEL_ck_apb_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(0x2):CK_APB of 16bit */
N#define CSC_CKO_CKO_SEL_ck_apb_b0                   ((uint8_t )0x20)        /*!< Bit Value =(0x2):CK_APB of 8bit */
N#define CSC_CKO_CKO_SEL_ck_hs_w                     ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):CK_HS of 32bit */
N#define CSC_CKO_CKO_SEL_ck_hs_h0                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):CK_HS of 16bit */
N#define CSC_CKO_CKO_SEL_ck_hs_b0                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):CK_HS of 8bit */
N#define CSC_CKO_CKO_SEL_ck_ls_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):CK_LS of 32bit */
N#define CSC_CKO_CKO_SEL_ck_ls_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(0x4):CK_LS of 16bit */
N#define CSC_CKO_CKO_SEL_ck_ls_b0                    ((uint8_t )0x40)        /*!< Bit Value =(0x4):CK_LS of 8bit */
N#define CSC_CKO_CKO_SEL_ck_xosc_w                   ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):CK_XOSC of 32bit */
N#define CSC_CKO_CKO_SEL_ck_xosc_h0                  ((uint16_t)0x0050)      /*!< Bit Value =(0x5):CK_XOSC of 16bit */
N#define CSC_CKO_CKO_SEL_ck_xosc_b0                  ((uint8_t )0x50)        /*!< Bit Value =(0x5):CK_XOSC of 8bit */
N
N#define CSC_CKO_CKO_DIV_mask_w                      ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define CSC_CKO_CKO_DIV_mask_h0                     ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define CSC_CKO_CKO_DIV_mask_b0                     ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CSC_CKO_CKO_DIV_div1_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CSC_CKO_CKO_DIV_div1_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CSC_CKO_CKO_DIV_div1_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CSC_CKO_CKO_DIV_div2_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CSC_CKO_CKO_DIV_div2_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CSC_CKO_CKO_DIV_div2_b0                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CSC_CKO_CKO_DIV_div4_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CSC_CKO_CKO_DIV_div4_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CSC_CKO_CKO_DIV_div4_b0                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CSC_CKO_CKO_DIV_div8_w                      ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CSC_CKO_CKO_DIV_div8_h0                     ((uint16_t)0x000C)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CSC_CKO_CKO_DIV_div8_b0                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define CSC_CKO_CKO_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_CKO_CKO_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CKO_CKO_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKO_CKO_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define CSC_CKO_CKO_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define CSC_CKO_CKO_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define CSC_CKO_CKO_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Enable of 32bit */
N#define CSC_CKO_CKO_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Enable of 16bit */
N#define CSC_CKO_CKO_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_AHB  [register's definitions]
N *              Offset[0x1C]  CSC AHB clock control register (0x4C01001C)
N ******************************************************************************
N */
N///@{
N#define CSC_AHB_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_AHB */
N#define CSC_AHB_DMA_EN_mask_w                       ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_DMA_EN_mask_h0                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_DMA_EN_mask_b1                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_DMA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_DMA_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_DMA_EN_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_DMA_EN_enable_w                     ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_DMA_EN_enable_h0                    ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_DMA_EN_enable_b1                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_EMB_EN_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_EMB_EN_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_EMB_EN_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_EMB_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_EMB_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_EMB_EN_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_EMB_EN_enable_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_EMB_EN_enable_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_EMB_EN_enable_b1                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_GPL_EN_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_GPL_EN_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_GPL_EN_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_GPL_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_GPL_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_GPL_EN_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_GPL_EN_enable_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_GPL_EN_enable_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_GPL_EN_enable_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_IOPE_EN_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_IOPE_EN_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_IOPE_EN_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_IOPE_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_IOPE_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_IOPE_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_IOPE_EN_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_IOPE_EN_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_IOPE_EN_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_IOPD_EN_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_IOPD_EN_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_IOPD_EN_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_IOPD_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_IOPD_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_IOPD_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_IOPD_EN_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_IOPD_EN_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_IOPD_EN_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_IOPC_EN_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_IOPC_EN_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_IOPC_EN_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_IOPC_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_IOPC_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_IOPC_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_IOPC_EN_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_IOPC_EN_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_IOPC_EN_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_IOPB_EN_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_IOPB_EN_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_IOPB_EN_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_IOPB_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_IOPB_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_IOPB_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_IOPB_EN_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_IOPB_EN_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_IOPB_EN_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_AHB_IOPA_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_AHB_IOPA_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_AHB_IOPA_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_AHB_IOPA_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_AHB_IOPA_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_AHB_IOPA_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_AHB_IOPA_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_AHB_IOPA_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_AHB_IOPA_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_APB0  [register's definitions]
N *              Offset[0x20]  CSC APB clock control register 0 (0x4C010020)
N ******************************************************************************
N */
N///@{
N#define CSC_APB0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_APB0 */
N#define CSC_APB0_URT3_EN_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_URT3_EN_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_URT3_EN_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_URT3_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_URT3_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_URT3_EN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_URT3_EN_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_URT3_EN_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_URT3_EN_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_URT2_EN_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_URT2_EN_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_URT2_EN_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_URT2_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_URT2_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_URT2_EN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_URT2_EN_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_URT2_EN_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_URT2_EN_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_URT1_EN_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_URT1_EN_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_URT1_EN_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_URT1_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_URT1_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_URT1_EN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_URT1_EN_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_URT1_EN_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_URT1_EN_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_URT0_EN_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_URT0_EN_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_URT0_EN_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_URT0_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_URT0_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_URT0_EN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_URT0_EN_enable_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_URT0_EN_enable_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_URT0_EN_enable_b2                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_SPI0_EN_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_SPI0_EN_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_SPI0_EN_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_SPI0_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_SPI0_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_SPI0_EN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_SPI0_EN_enable_w                   ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_SPI0_EN_enable_h0                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_SPI0_EN_enable_b1                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_I2C1_EN_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_I2C1_EN_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_I2C1_EN_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_I2C1_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_I2C1_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_I2C1_EN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_I2C1_EN_enable_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_I2C1_EN_enable_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_I2C1_EN_enable_b1                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_I2C0_EN_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_I2C0_EN_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_I2C0_EN_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_I2C0_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_I2C0_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_I2C0_EN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_I2C0_EN_enable_w                   ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_I2C0_EN_enable_h0                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_I2C0_EN_enable_b1                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_WWDT_EN_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_WWDT_EN_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_WWDT_EN_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_WWDT_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_WWDT_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_WWDT_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_WWDT_EN_enable_w                   ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_WWDT_EN_enable_h0                  ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_WWDT_EN_enable_b0                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_IWDT_EN_mask_w                     ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_IWDT_EN_mask_h0                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_IWDT_EN_mask_b0                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_IWDT_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_IWDT_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_IWDT_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_IWDT_EN_enable_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_IWDT_EN_enable_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_IWDT_EN_enable_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_RTC_EN_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_RTC_EN_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_RTC_EN_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_RTC_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_RTC_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_RTC_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_RTC_EN_enable_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_RTC_EN_enable_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_RTC_EN_enable_b0                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_DAC_EN_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_DAC_EN_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_DAC_EN_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_DAC_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_DAC_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_DAC_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_DAC_EN_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_DAC_EN_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_DAC_EN_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_CMP_EN_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_CMP_EN_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_CMP_EN_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_CMP_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_CMP_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_CMP_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_CMP_EN_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_CMP_EN_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_CMP_EN_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB0_ADC0_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_APB0_ADC0_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_APB0_ADC0_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_APB0_ADC0_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB0_ADC0_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB0_ADC0_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB0_ADC0_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB0_ADC0_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB0_ADC0_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_APB1  [register's definitions]
N *              Offset[0x24]  CSC APB clock control register 1 (0x4C010024)
N ******************************************************************************
N */
N///@{
N#define CSC_APB1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_APB1 */
N#define CSC_APB1_TM36_EN_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM36_EN_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM36_EN_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM36_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM36_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM36_EN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM36_EN_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM36_EN_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM36_EN_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB1_TM26_EN_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM26_EN_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM26_EN_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM26_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM26_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM26_EN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM26_EN_enable_w                   ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM26_EN_enable_h0                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM26_EN_enable_b1                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB1_TM20_EN_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM20_EN_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM20_EN_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM20_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM20_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM20_EN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM20_EN_enable_w                   ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM20_EN_enable_h0                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM20_EN_enable_b1                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB1_TM16_EN_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM16_EN_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM16_EN_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM16_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM16_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM16_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM16_EN_enable_w                   ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM16_EN_enable_h0                  ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM16_EN_enable_b0                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB1_TM10_EN_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM10_EN_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM10_EN_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM10_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM10_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM10_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM10_EN_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM10_EN_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM10_EN_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB1_TM01_EN_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM01_EN_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM01_EN_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM01_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM01_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM01_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM01_EN_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM01_EN_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM01_EN_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_APB1_TM00_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_APB1_TM00_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_APB1_TM00_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_APB1_TM00_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_APB1_TM00_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_APB1_TM00_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_APB1_TM00_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_APB1_TM00_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_APB1_TM00_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_SLP0  [register's definitions]
N *              Offset[0x30]  CSC SLEEP mode clock enable register 0 (0x4C010030)
N ******************************************************************************
N */
N///@{
N#define CSC_SLP0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_SLP0 */
N#define CSC_SLP0_SLP_URT3_mask_w                    ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_URT3_mask_h1                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_URT3_mask_b2                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_URT3_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_URT3_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_URT3_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_URT3_enable_w                  ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_URT3_enable_h1                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_URT3_enable_b2                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_URT2_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_URT2_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_URT2_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_URT2_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_URT2_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_URT2_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_URT2_enable_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_URT2_enable_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_URT2_enable_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_URT1_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_URT1_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_URT1_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_URT1_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_URT1_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_URT1_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_URT1_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_URT1_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_URT1_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_URT0_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_URT0_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_URT0_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_URT0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_URT0_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_URT0_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_URT0_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_URT0_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_URT0_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_SPI0_mask_w                    ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_SPI0_mask_h0                   ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_SPI0_mask_b1                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_SPI0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_SPI0_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_SPI0_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_SPI0_enable_w                  ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_SPI0_enable_h0                 ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_SPI0_enable_b1                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_I2C1_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_I2C1_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_I2C1_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_I2C1_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_I2C1_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_I2C1_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_I2C1_enable_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_I2C1_enable_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_I2C1_enable_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_I2C0_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_I2C0_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_I2C0_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_I2C0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_I2C0_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_I2C0_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_I2C0_enable_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_I2C0_enable_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_I2C0_enable_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_WWDT_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_WWDT_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_WWDT_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_WWDT_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_WWDT_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_WWDT_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_WWDT_enable_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_WWDT_enable_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_WWDT_enable_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_IWDT_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_IWDT_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_IWDT_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_IWDT_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_IWDT_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_IWDT_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_IWDT_enable_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_IWDT_enable_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_IWDT_enable_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_RTC_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_RTC_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_RTC_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_RTC_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_RTC_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_RTC_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_RTC_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_RTC_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_RTC_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_DAC_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_DAC_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_DAC_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_DAC_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_DAC_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_DAC_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_DAC_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_DAC_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_DAC_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_CMP_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_CMP_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_CMP_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_CMP_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_CMP_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_CMP_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_CMP_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_CMP_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_CMP_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP0_SLP_ADC0_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_SLP0_SLP_ADC0_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_SLP0_SLP_ADC0_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_SLP0_SLP_ADC0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP0_SLP_ADC0_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP0_SLP_ADC0_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP0_SLP_ADC0_enable_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP0_SLP_ADC0_enable_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP0_SLP_ADC0_enable_b0                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_SLP1  [register's definitions]
N *              Offset[0x34]  CSC SLEEP mode clock enable register 1 (0x4C010034)
N ******************************************************************************
N */
N///@{
N#define CSC_SLP1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_SLP1 */
N#define CSC_SLP1_SLP_EMB_mask_w                     ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_EMB_mask_h1                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_EMB_mask_b3                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_EMB_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_EMB_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_EMB_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_EMB_enable_w                   ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_EMB_enable_h1                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_EMB_enable_b3                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM36_mask_w                    ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM36_mask_h0                   ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM36_mask_b1                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM36_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM36_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM36_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM36_enable_w                  ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM36_enable_h0                 ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM36_enable_b1                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM26_mask_w                    ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM26_mask_h0                   ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM26_mask_b1                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM26_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM26_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM26_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM26_enable_w                  ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM26_enable_h0                 ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM26_enable_b1                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM20_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM20_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM20_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM20_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM20_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM20_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM20_enable_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM20_enable_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM20_enable_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM16_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM16_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM16_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM16_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM16_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM16_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM16_enable_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM16_enable_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM16_enable_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM10_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM10_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM10_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM10_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM10_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM10_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM10_enable_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM10_enable_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM10_enable_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM01_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM01_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM01_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM01_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM01_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM01_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM01_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM01_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM01_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_SLP1_SLP_TM00_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_SLP1_SLP_TM00_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_SLP1_SLP_TM00_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_SLP1_SLP_TM00_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_SLP1_SLP_TM00_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_SLP1_SLP_TM00_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_SLP1_SLP_TM00_enable_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_SLP1_SLP_TM00_enable_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_SLP1_SLP_TM00_enable_b0                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_STP0  [register's definitions]
N *              Offset[0x38]  CSC STOP mode clock enable register 0 (0x4C010038)
N ******************************************************************************
N */
N///@{
N#define CSC_STP0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_STP0 */
N#define CSC_STP0_STP_IWDT_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CSC_STP0_STP_IWDT_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_STP0_STP_IWDT_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_STP0_STP_IWDT_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_STP0_STP_IWDT_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_STP0_STP_IWDT_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_STP0_STP_IWDT_enable_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_STP0_STP_IWDT_enable_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_STP0_STP_IWDT_enable_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CSC_STP0_STP_RTC_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_STP0_STP_RTC_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_STP0_STP_RTC_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_STP0_STP_RTC_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CSC_STP0_STP_RTC_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CSC_STP0_STP_RTC_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CSC_STP0_STP_RTC_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CSC_STP0_STP_RTC_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CSC_STP0_STP_RTC_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_CKS0  [register's definitions]
N *              Offset[0x40]  CSC clock source select register 0 (0x4C010040)
N ******************************************************************************
N */
N///@{
N#define CSC_CKS0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_CKS0 */
N#define CSC_CKS0_DAC_CKS_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CSC_CKS0_DAC_CKS_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CSC_CKS0_DAC_CKS_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CSC_CKS0_DAC_CKS_ck_apb_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS0_DAC_CKS_ck_apb_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS0_DAC_CKS_ck_apb_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS0_DAC_CKS_ck_ahb_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS0_DAC_CKS_ck_ahb_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS0_DAC_CKS_ck_ahb_b0                  ((uint8_t )0x20)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS0_CMP_CKS_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CSC_CKS0_CMP_CKS_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_CKS0_CMP_CKS_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_CKS0_CMP_CKS_ck_apb_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS0_CMP_CKS_ck_apb_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS0_CMP_CKS_ck_apb_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS0_CMP_CKS_ck_ahb_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS0_CMP_CKS_ck_ahb_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS0_CMP_CKS_ck_ahb_b0                  ((uint8_t )0x10)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS0_ADC0_CKS_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_CKS0_ADC0_CKS_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CKS0_ADC0_CKS_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS0_ADC0_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS0_ADC0_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS0_ADC0_CKS_ck_apb_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS0_ADC0_CKS_ck_ahb_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS0_ADC0_CKS_ck_ahb_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS0_ADC0_CKS_ck_ahb_b0                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_CKS1  [register's definitions]
N *              Offset[0x44]  CSC clock source select register 1 (0x4C010044)
N ******************************************************************************
N */
N///@{
N#define CSC_CKS1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_CKS1 */
N#define CSC_CKS1_URT3_CKS_mask_w                    ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_URT3_CKS_mask_h1                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_URT3_CKS_mask_b2                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_URT3_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_URT3_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_URT3_CKS_ck_apb_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_URT3_CKS_ck_ahb_w                  ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_URT3_CKS_ck_ahb_h1                 ((uint16_t)0x0040)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_URT3_CKS_ck_ahb_b2                 ((uint8_t )0x40)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS1_URT2_CKS_mask_w                    ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_URT2_CKS_mask_h1                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_URT2_CKS_mask_b2                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_URT2_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_URT2_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_URT2_CKS_ck_apb_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_URT2_CKS_ck_ahb_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_URT2_CKS_ck_ahb_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_URT2_CKS_ck_ahb_b2                 ((uint8_t )0x10)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS1_URT1_CKS_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_URT1_CKS_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_URT1_CKS_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_URT1_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_URT1_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_URT1_CKS_ck_apb_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_URT1_CKS_ck_ahb_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_URT1_CKS_ck_ahb_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_URT1_CKS_ck_ahb_b2                 ((uint8_t )0x04)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS1_URT0_CKS_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_URT0_CKS_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_URT0_CKS_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_URT0_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_URT0_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_URT0_CKS_ck_apb_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_URT0_CKS_ck_ahb_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_URT0_CKS_ck_ahb_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_URT0_CKS_ck_ahb_b2                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS1_SPI0_CKS_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_SPI0_CKS_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_SPI0_CKS_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_SPI0_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_SPI0_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_SPI0_CKS_ck_apb_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_SPI0_CKS_ck_ahb_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_SPI0_CKS_ck_ahb_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_SPI0_CKS_ck_ahb_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS1_I2C1_CKS_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_I2C1_CKS_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_I2C1_CKS_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_I2C1_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_I2C1_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_I2C1_CKS_ck_apb_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_I2C1_CKS_ck_ahb_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_I2C1_CKS_ck_ahb_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_I2C1_CKS_ck_ahb_b0                 ((uint8_t )0x04)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS1_I2C0_CKS_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_CKS1_I2C0_CKS_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CKS1_I2C0_CKS_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS1_I2C0_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS1_I2C0_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS1_I2C0_CKS_ck_apb_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS1_I2C0_CKS_ck_ahb_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS1_I2C0_CKS_ck_ahb_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS1_I2C0_CKS_ck_ahb_b0                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CSC_CKS2  [register's definitions]
N *              Offset[0x48]  CSC clock source select register 2 (0x4C010048)
N ******************************************************************************
N */
N///@{
N#define CSC_CKS2_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CSC_CKS2 */
N#define CSC_CKS2_TM36_CKS_mask_w                    ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM36_CKS_mask_h1                   ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM36_CKS_mask_b3                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM36_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM36_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM36_CKS_ck_apb_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM36_CKS_ck_ahb_w                  ((uint32_t)0x40000000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM36_CKS_ck_ahb_h1                 ((uint16_t)0x4000)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM36_CKS_ck_ahb_b3                 ((uint8_t )0x40)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS2_TM26_CKS_mask_w                    ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM26_CKS_mask_h1                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM26_CKS_mask_b2                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM26_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM26_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM26_CKS_ck_apb_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM26_CKS_ck_ahb_w                  ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM26_CKS_ck_ahb_h1                 ((uint16_t)0x0040)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM26_CKS_ck_ahb_b2                 ((uint8_t )0x40)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS2_TM20_CKS_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM20_CKS_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM20_CKS_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM20_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM20_CKS_ck_apb_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM20_CKS_ck_apb_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM20_CKS_ck_ahb_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM20_CKS_ck_ahb_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM20_CKS_ck_ahb_b2                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS2_TM16_CKS_mask_w                    ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM16_CKS_mask_h0                   ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM16_CKS_mask_b1                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM16_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM16_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM16_CKS_ck_apb_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM16_CKS_ck_ahb_w                  ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM16_CKS_ck_ahb_h0                 ((uint16_t)0x4000)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM16_CKS_ck_ahb_b1                 ((uint8_t )0x40)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS2_TM10_CKS_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM10_CKS_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM10_CKS_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM10_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM10_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM10_CKS_ck_apb_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM10_CKS_ck_ahb_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM10_CKS_ck_ahb_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM10_CKS_ck_ahb_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS2_TM01_CKS_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM01_CKS_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM01_CKS_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM01_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM01_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM01_CKS_ck_apb_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM01_CKS_ck_ahb_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM01_CKS_ck_ahb_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM01_CKS_ck_ahb_b0                 ((uint8_t )0x04)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N#define CSC_CKS2_TM00_CKS_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CSC_CKS2_TM00_CKS_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CSC_CKS2_TM00_CKS_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CSC_CKS2_TM00_CKS_ck_apb_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define CSC_CKS2_TM00_CKS_ck_apb_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define CSC_CKS2_TM00_CKS_ck_apb_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define CSC_CKS2_TM00_CKS_ck_ahb_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):CK_AHB of 32bit */
N#define CSC_CKS2_TM00_CKS_ck_ahb_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):CK_AHB of 16bit */
N#define CSC_CKS2_TM00_CKS_ck_ahb_b0                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_AHB of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_CSC_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_CSC.h                         */
N/*----------------------------------------------------------------------------*/
L 30 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_CSC_Init.h" 2
N#include "MG32x02z_MEM.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_MEM.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_MEM.h
N *
N * @brief       MG32x02z MEM Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_MEM_H
N#define _MG32x02z_MEM_H
N#define _MG32x02z_MEM_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_MEM_H_VER)
S    #error "MG32x02z_MEM_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      MEM_Struct
N *              MEM  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  FBUSYF        :1;     //[0] Flash memory access busy flag.
X            volatile const  uint8_t  FBUSYF        :1;     
N                                        //0 = Normal (Not busy)
N                                        //1 = Busy
N            __IO uint8_t  EOPF          :1;     //[1] Flash memory end of processing flag
X            volatile uint8_t  EOPF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IAEF          :1;     //[4] Memory code execution illegal address error detection flag
X            volatile uint8_t  IAEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  WPEF          :1;     //[5] Flash memory write protect error detection flag
X            volatile uint8_t  WPEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  RPEF          :1;     //[6] Flash memory read protect error detection flag
X            volatile uint8_t  RPEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t  IAPSEF        :1;     //[16] IAP Flash memory size setting error flag.
X            volatile const  uint8_t  IAPSEF        :1;     
N                                        //0 = Normal (Not busy)
N                                        //1 = ERR (Size over maximum value error)
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[18] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  MEM status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] Memory controller interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EOP_IE        :1;     //[1] Flash memory end of processing interrupt enable.
X            volatile uint8_t  EOP_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IAE_IE        :1;     //[4] Memory code execution illegal address error detection interrupt enable.
X            volatile uint8_t  IAE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WPE_IE        :1;     //[5] Flash memory write protect error detection interrupt enable.
X            volatile uint8_t  WPE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RPE_IE        :1;     //[6] Flash memory read protect error detection interrupt enable.
X            volatile uint8_t  RPE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :3;     //[18..16] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IAE_RE        :1;     //[20] Memory code execution illegal address detection reset enable.
X            volatile uint8_t  IAE_RE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WPE_RE        :1;     //[21] Flash memory write protect error detection reset enable.
X            volatile uint8_t  WPE_RE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RPE_RE        :1;     //[22] Flash memory read protect error detection reset enable.
X            volatile uint8_t  RPE_RE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  MEM interrupt enable register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] Reset key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __IO uint16_t KEY2          :16;    //[31..16] Reset key register-2
X            volatile uint16_t KEY2          :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  MEM write protected key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] Memory controller enable.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  HF_EN         :1;     //[1] Flash memory data access error HardFault enable
X            volatile uint8_t  HF_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  HOLD          :1;     //[2] CPU hold control under flash memory access
X            volatile uint8_t  HOLD          :1;     
N                                        //0 = Hold
N                                        //1 = Normal
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MDS           :4;     //[7..4] AP/IAP flash memory access mode select.
X            volatile uint8_t  MDS           :4;     
N                                        //0x0 = No (No Operation)
N                                        //0x1 = Write (Write AP/IAP/ISPD Flash)
N                                        //0x2 = Erase (Erase a page of AP/IAP/ISPD Flash)
N                                        //0x3 = Reserved
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  FWAIT         :2;     //[13..12] Flash memory read access wait state selection
X            volatile uint8_t  FWAIT         :2;     
N                                        //0x0 = Zero : Zero wait state if  25 MHz > CK_AHB
N                                        //0x1 = One : One wait state if 50MHz >CK_AHB> 25 MHz
N                                        //0x3 = Two : Two wait state if 75MHz >CK_AHB> 50 MHz
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BOOT_MS       :2;     //[17..16] System reset memory select and memory is mapped at 0x0000 0000
X            volatile uint8_t  BOOT_MS       :2;     
N                                        //0x0 = Application Flash
N                                        //0x1 = Boot Flash
N                                        //0x2 = Embedded SRAM
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  HSP_EN        :1;     //[20] Flash memory read high speed mode enable during reset
X            volatile uint8_t  HSP_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IAP_AEN       :1;     //[21] IAP memory size MEM_IAP_SIZE register access enable
X            volatile uint8_t  IAP_AEN       :1;     
N                                        //0 = Disable : Register access lock
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  MEM control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  AP_WEN        :1;     //[0] Flash AP memory write enable.
X            volatile uint8_t  AP_WEN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IAP_WEN       :1;     //[1] Flash IAP memory write enable.
X            volatile uint8_t  IAP_WEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ISPD_WEN      :1;     //[2] Flash ISP data memory write enable for ISP program
X            volatile uint8_t  ISPD_WEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ISPD_REN      :1;     //[3] Flash ISP data memory read enable for ISP program
X            volatile uint8_t  ISPD_REN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IAP_EXEC      :1;     //[4] Flash IAP data memory code execution function enable.
X            volatile uint8_t  IAP_EXEC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  ISP_WEN       :1;     //[8] Flash ISP Boot memory write enable
X            volatile uint8_t  ISP_WEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ISP_REN       :1;     //[9] Flash ISP Boot memory read enable for AP program
X            volatile uint8_t  ISP_REN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OB_WEN        :1;     //[11] Flash OB0 Option-Byte memory write enable
X            volatile uint8_t  OB_WEN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  MEM control register 1 */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x18]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SKEY          :8;     //[7..0] MEM sequential key register for AP/IAP/ISPD flash
X            volatile uint8_t  SKEY          :8;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint16_t SKEY2         :16;    //[31..16] Reserved for internal using
X            volatile uint16_t SKEY2         :16;    
N        }MBIT;
N    }SKEY;                              /*!< SKEY       ~ Offset[0x1C]  MEM Flash memory protected key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t FADR          :32;    //[31..0] Flash memory access address register
X            volatile uint32_t FADR          :32;    
N        }MBIT;
N    }FADR;                              /*!< FADR       ~ Offset[0x20]  MEM Flash memory address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t FDAT          :32;    //[31..0] Flash memory access data register.
X            volatile uint32_t FDAT          :32;    
N        }MBIT;
N    }FDAT;                              /*!< FDAT       ~ Offset[0x24]  MEM Flash memory data register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  IAP_SIZE      :8;     //[15..8] IAP memory size select
X            volatile uint8_t  IAP_SIZE      :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }IAPSZ;                             /*!< IAPSZ      ~ Offset[0x28]  MEM Flash memory IAP size register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OB1_WEN       :1;     //[0] Flash OB1 Option-Byte memory write enable
X            volatile uint8_t  OB1_WEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }MCR;                               /*!< MCR        ~ Offset[0x2C]  MEM manufacturer control register */
N
N} MEM_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        MEM  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define MEM_Base                        ((uint32_t)0x4D000000)              /*!< Internal Memory Controller */
N#define MEM                             ((MEM_Struct*) MEM_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        MEM  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        MEM_STA  [register's definitions]
N *              Offset[0x00]  MEM status register (0x4D000000)
N ******************************************************************************
N */
N///@{
N#define MEM_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_STA */
N#define MEM_STA_IAPSEF_mask_w                       ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define MEM_STA_IAPSEF_mask_h1                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define MEM_STA_IAPSEF_mask_b2                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_STA_IAPSEF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define MEM_STA_IAPSEF_normal_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define MEM_STA_IAPSEF_normal_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define MEM_STA_IAPSEF_err_w                        ((uint32_t)0x00010000)  /*!< Bit Value =(1):ERR of 32bit */
N#define MEM_STA_IAPSEF_err_h1                       ((uint16_t)0x0001)      /*!< Bit Value =(1):ERR of 16bit */
N#define MEM_STA_IAPSEF_err_b2                       ((uint8_t )0x01)        /*!< Bit Value =(1):ERR of 8bit */
N
N#define MEM_STA_RPEF_mask_w                         ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define MEM_STA_RPEF_mask_h0                        ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define MEM_STA_RPEF_mask_b0                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define MEM_STA_RPEF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define MEM_STA_RPEF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define MEM_STA_RPEF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define MEM_STA_RPEF_happened_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define MEM_STA_RPEF_happened_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define MEM_STA_RPEF_happened_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define MEM_STA_WPEF_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define MEM_STA_WPEF_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define MEM_STA_WPEF_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define MEM_STA_WPEF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define MEM_STA_WPEF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define MEM_STA_WPEF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define MEM_STA_WPEF_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define MEM_STA_WPEF_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define MEM_STA_WPEF_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define MEM_STA_IAEF_mask_w                         ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define MEM_STA_IAEF_mask_h0                        ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define MEM_STA_IAEF_mask_b0                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define MEM_STA_IAEF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define MEM_STA_IAEF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define MEM_STA_IAEF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define MEM_STA_IAEF_happened_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define MEM_STA_IAEF_happened_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define MEM_STA_IAEF_happened_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define MEM_STA_EOPF_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define MEM_STA_EOPF_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define MEM_STA_EOPF_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define MEM_STA_EOPF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define MEM_STA_EOPF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define MEM_STA_EOPF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define MEM_STA_EOPF_happened_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define MEM_STA_EOPF_happened_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define MEM_STA_EOPF_happened_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define MEM_STA_FBUSYF_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define MEM_STA_FBUSYF_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define MEM_STA_FBUSYF_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_STA_FBUSYF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define MEM_STA_FBUSYF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define MEM_STA_FBUSYF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define MEM_STA_FBUSYF_busy_w                       ((uint32_t)0x00000001)  /*!< Bit Value =(1):Busy of 32bit */
N#define MEM_STA_FBUSYF_busy_h0                      ((uint16_t)0x0001)      /*!< Bit Value =(1):Busy of 16bit */
N#define MEM_STA_FBUSYF_busy_b0                      ((uint8_t )0x01)        /*!< Bit Value =(1):Busy of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_INT  [register's definitions]
N *              Offset[0x04]  MEM interrupt enable register (0x4D000004)
N ******************************************************************************
N */
N///@{
N#define MEM_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_INT */
N#define MEM_INT_RPE_RE_mask_w                       ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define MEM_INT_RPE_RE_mask_h1                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define MEM_INT_RPE_RE_mask_b2                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define MEM_INT_RPE_RE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_RPE_RE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_RPE_RE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_RPE_RE_enable_w                     ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_RPE_RE_enable_h1                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_RPE_RE_enable_b2                    ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_WPE_RE_mask_w                       ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define MEM_INT_WPE_RE_mask_h1                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define MEM_INT_WPE_RE_mask_b2                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define MEM_INT_WPE_RE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_WPE_RE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_WPE_RE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_WPE_RE_enable_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_WPE_RE_enable_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_WPE_RE_enable_b2                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_IAE_RE_mask_w                       ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define MEM_INT_IAE_RE_mask_h1                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define MEM_INT_IAE_RE_mask_b2                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define MEM_INT_IAE_RE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_IAE_RE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_IAE_RE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_IAE_RE_enable_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_IAE_RE_enable_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_IAE_RE_enable_b2                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_RPE_IE_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define MEM_INT_RPE_IE_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define MEM_INT_RPE_IE_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define MEM_INT_RPE_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_RPE_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_RPE_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_RPE_IE_enable_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_RPE_IE_enable_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_RPE_IE_enable_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_WPE_IE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define MEM_INT_WPE_IE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define MEM_INT_WPE_IE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define MEM_INT_WPE_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_WPE_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_WPE_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_WPE_IE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_WPE_IE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_WPE_IE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_IAE_IE_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define MEM_INT_IAE_IE_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define MEM_INT_IAE_IE_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define MEM_INT_IAE_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_IAE_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_IAE_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_IAE_IE_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_IAE_IE_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_IAE_IE_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_EOP_IE_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define MEM_INT_EOP_IE_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define MEM_INT_EOP_IE_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define MEM_INT_EOP_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_EOP_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_EOP_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_EOP_IE_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_EOP_IE_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_EOP_IE_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define MEM_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define MEM_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_KEY  [register's definitions]
N *              Offset[0x0C]  MEM write protected key register (0x4D00000C)
N ******************************************************************************
N */
N///@{
N#define MEM_KEY_default                             ((uint32_t)0x00010001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_KEY */
N#define MEM_KEY_KEY2_mask_w                         ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define MEM_KEY_KEY2_mask_h1                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define MEM_KEY_KEY2_unprotected_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define MEM_KEY_KEY2_unprotected_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define MEM_KEY_KEY2_unprotected_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define MEM_KEY_KEY2_protected_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Protected of 32bit */
N#define MEM_KEY_KEY2_protected_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define MEM_KEY_KEY2_protected_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N#define MEM_KEY_KEY_mask_w                          ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define MEM_KEY_KEY_mask_h0                         ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define MEM_KEY_KEY_unprotected_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define MEM_KEY_KEY_unprotected_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define MEM_KEY_KEY_unprotected_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define MEM_KEY_KEY_protected_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define MEM_KEY_KEY_protected_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define MEM_KEY_KEY_protected_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_CR0  [register's definitions]
N *              Offset[0x10]  MEM control register 0 (0x4D000010)
N ******************************************************************************
N */
N///@{
N#define MEM_CR0_default                             ((uint32_t)0x00200002)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_CR0 */
N#define MEM_CR0_IAP_AEN_mask_w                      ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_IAP_AEN_mask_h1                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_IAP_AEN_mask_b2                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_IAP_AEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR0_IAP_AEN_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR0_IAP_AEN_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR0_IAP_AEN_enable_w                    ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR0_IAP_AEN_enable_h1                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR0_IAP_AEN_enable_b2                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR0_HSP_EN_mask_w                       ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_HSP_EN_mask_h1                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_HSP_EN_mask_b2                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_HSP_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR0_HSP_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR0_HSP_EN_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR0_HSP_EN_enable_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR0_HSP_EN_enable_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR0_HSP_EN_enable_b2                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR0_BOOT_MS_mask_w                      ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_BOOT_MS_mask_h1                     ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_BOOT_MS_mask_b2                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_BOOT_MS_application_flash_w         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Application Flash of 32bit */
N#define MEM_CR0_BOOT_MS_application_flash_h1        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Application Flash of 16bit */
N#define MEM_CR0_BOOT_MS_application_flash_b2        ((uint8_t )0x00)        /*!< Bit Value =(0x0):Application Flash of 8bit */
N#define MEM_CR0_BOOT_MS_boot_flash_w                ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Boot Flash of 32bit */
N#define MEM_CR0_BOOT_MS_boot_flash_h1               ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Boot Flash of 16bit */
N#define MEM_CR0_BOOT_MS_boot_flash_b2               ((uint8_t )0x01)        /*!< Bit Value =(0x1):Boot Flash of 8bit */
N#define MEM_CR0_BOOT_MS_embedded_sram_w             ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Embedded SRAM of 32bit */
N#define MEM_CR0_BOOT_MS_embedded_sram_h1            ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Embedded SRAM of 16bit */
N#define MEM_CR0_BOOT_MS_embedded_sram_b2            ((uint8_t )0x02)        /*!< Bit Value =(0x2):Embedded SRAM of 8bit */
N
N#define MEM_CR0_FWAIT_mask_w                        ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_FWAIT_mask_h0                       ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_FWAIT_mask_b1                       ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_FWAIT_zero_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Zero of 32bit */
N#define MEM_CR0_FWAIT_zero_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Zero of 16bit */
N#define MEM_CR0_FWAIT_zero_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):Zero of 8bit */
N#define MEM_CR0_FWAIT_one_w                         ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):One of 32bit */
N#define MEM_CR0_FWAIT_one_h0                        ((uint16_t)0x1000)      /*!< Bit Value =(0x1):One of 16bit */
N#define MEM_CR0_FWAIT_one_b1                        ((uint8_t )0x10)        /*!< Bit Value =(0x1):One of 8bit */
N#define MEM_CR0_FWAIT_two_w                         ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Two of 32bit */
N#define MEM_CR0_FWAIT_two_h0                        ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Two of 16bit */
N#define MEM_CR0_FWAIT_two_b1                        ((uint8_t )0x30)        /*!< Bit Value =(0x3):Two of 8bit */
N
N#define MEM_CR0_MDS_mask_w                          ((uint32_t)0x000000F0)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_MDS_mask_h0                         ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_MDS_mask_b0                         ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_MDS_no_w                            ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define MEM_CR0_MDS_no_h0                           ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define MEM_CR0_MDS_no_b0                           ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define MEM_CR0_MDS_write_w                         ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Write of 32bit */
N#define MEM_CR0_MDS_write_h0                        ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Write of 16bit */
N#define MEM_CR0_MDS_write_b0                        ((uint8_t )0x10)        /*!< Bit Value =(0x1):Write of 8bit */
N#define MEM_CR0_MDS_erase_w                         ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Erase of 32bit */
N#define MEM_CR0_MDS_erase_h0                        ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Erase of 16bit */
N#define MEM_CR0_MDS_erase_b0                        ((uint8_t )0x20)        /*!< Bit Value =(0x2):Erase of 8bit */
N
N#define MEM_CR0_HOLD_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_HOLD_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_HOLD_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_HOLD_hold_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Hold of 32bit */
N#define MEM_CR0_HOLD_hold_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Hold of 16bit */
N#define MEM_CR0_HOLD_hold_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Hold of 8bit */
N#define MEM_CR0_HOLD_normal_w                       ((uint32_t)0x00000004)  /*!< Bit Value =(1):Normal of 32bit */
N#define MEM_CR0_HOLD_normal_h0                      ((uint16_t)0x0004)      /*!< Bit Value =(1):Normal of 16bit */
N#define MEM_CR0_HOLD_normal_b0                      ((uint8_t )0x04)        /*!< Bit Value =(1):Normal of 8bit */
N
N#define MEM_CR0_HF_EN_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_HF_EN_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_HF_EN_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_HF_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR0_HF_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR0_HF_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR0_HF_EN_enable_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR0_HF_EN_enable_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR0_HF_EN_enable_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define MEM_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define MEM_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_CR1  [register's definitions]
N *              Offset[0x14]  MEM control register 1 (0x4D000014)
N ******************************************************************************
N */
N///@{
N#define MEM_CR1_default                             ((uint32_t)0x00000010)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_CR1 */
N#define MEM_CR1_OB_WEN_mask_w                       ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_OB_WEN_mask_h0                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_OB_WEN_mask_b1                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_OB_WEN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_OB_WEN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_OB_WEN_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_OB_WEN_enable_w                     ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_OB_WEN_enable_h0                    ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_OB_WEN_enable_b1                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_ISP_REN_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_ISP_REN_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_ISP_REN_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_ISP_REN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_ISP_REN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_ISP_REN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_ISP_REN_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_ISP_REN_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_ISP_REN_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_ISP_WEN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_ISP_WEN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_ISP_WEN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_ISP_WEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_ISP_WEN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_ISP_WEN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_ISP_WEN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_ISP_WEN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_ISP_WEN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_IAP_EXEC_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_IAP_EXEC_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_IAP_EXEC_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_IAP_EXEC_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_IAP_EXEC_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_IAP_EXEC_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_IAP_EXEC_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_IAP_EXEC_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_IAP_EXEC_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_ISPD_REN_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_ISPD_REN_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_ISPD_REN_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_ISPD_REN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_ISPD_REN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_ISPD_REN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_ISPD_REN_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_ISPD_REN_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_ISPD_REN_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_ISPD_WEN_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_ISPD_WEN_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_ISPD_WEN_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_ISPD_WEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_ISPD_WEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_ISPD_WEN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_ISPD_WEN_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_ISPD_WEN_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_ISPD_WEN_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_IAP_WEN_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_IAP_WEN_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_IAP_WEN_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_IAP_WEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_IAP_WEN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_IAP_WEN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_IAP_WEN_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_IAP_WEN_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_IAP_WEN_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define MEM_CR1_AP_WEN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define MEM_CR1_AP_WEN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define MEM_CR1_AP_WEN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_CR1_AP_WEN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_CR1_AP_WEN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_CR1_AP_WEN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_CR1_AP_WEN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_CR1_AP_WEN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_CR1_AP_WEN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_SKEY  [register's definitions]
N *              Offset[0x1C]  MEM Flash memory protected key register (0x4D00001C)
N ******************************************************************************
N */
N///@{
N#define MEM_SKEY_default                            ((uint32_t)0x00000007)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_SKEY */
N#define MEM_SKEY_SKEY2_mask_w                       ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define MEM_SKEY_SKEY2_mask_h1                      ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define MEM_SKEY_SKEY2_shift_w                      (16)                    /*!< Bit Shift of 32bit */
N#define MEM_SKEY_SKEY2_shift_h1                     (0)                     /*!< Bit Shift of 16bit */
N#define MEM_SKEY_SKEY2_shift_b2                     (0)                     /*!< Bit Shift of 8bit */
N
N#define MEM_SKEY_SKEY_mask_w                        ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define MEM_SKEY_SKEY_mask_h0                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define MEM_SKEY_SKEY_mask_b0                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define MEM_SKEY_SKEY_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define MEM_SKEY_SKEY_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define MEM_SKEY_SKEY_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_FADR  [register's definitions]
N *              Offset[0x20]  MEM Flash memory address register (0x4D000020)
N ******************************************************************************
N */
N///@{
N#define MEM_FADR_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_FADR */
N#define MEM_FADR_FADR_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define MEM_FADR_FADR_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define MEM_FADR_FADR_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define MEM_FADR_FADR_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_FDAT  [register's definitions]
N *              Offset[0x24]  MEM Flash memory data register (0x4D000024)
N ******************************************************************************
N */
N///@{
N#define MEM_FDAT_default                            ((uint32_t)0xFFFFFFFF)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_FDAT */
N#define MEM_FDAT_FDAT_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define MEM_FDAT_FDAT_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define MEM_FDAT_FDAT_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define MEM_FDAT_FDAT_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_IAPSZ  [register's definitions]
N *              Offset[0x28]  MEM Flash memory IAP size register (0x4D000028)
N ******************************************************************************
N */
N///@{
N#define MEM_IAPSZ_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_IAPSZ */
N#define MEM_IAPSZ_IAP_SIZE_mask_w                   ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define MEM_IAPSZ_IAP_SIZE_mask_h0                  ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define MEM_IAPSZ_IAP_SIZE_mask_b1                  ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        MEM_MCR  [register's definitions]
N *              Offset[0x2C]  MEM manufacturer control register (0x4D00002C)
N ******************************************************************************
N */
N///@{
N#define MEM_MCR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of MEM_MCR */
N#define MEM_MCR_OB1_WEN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define MEM_MCR_OB1_WEN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define MEM_MCR_OB1_WEN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define MEM_MCR_OB1_WEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define MEM_MCR_OB1_WEN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define MEM_MCR_OB1_WEN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define MEM_MCR_OB1_WEN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define MEM_MCR_OB1_WEN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define MEM_MCR_OB1_WEN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_MEM_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_MEM.h                         */
N/*----------------------------------------------------------------------------*/
L 31 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_CSC_Init.h" 2
N#include "MG32x02z_GPIO.H"
N
N
N#ifndef _MG32x02z_CSC_INIT_H
N/*!< _MG32x02z_CSC_INIT_H */ 
N#define _MG32x02z_CSC_INIT_H
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N/**
N ******************************************************************************
N *
N * @brief       CSC Initial Configure
N *
N ******************************************************************************
N */
N
N//<h> CSC Initial Configure
N
N//      <o> Enter XOSC Or External Clock Frequency 1~36000000Hz <1-36000000>
N//      <i> When use CK_HS = CK_XOSC or CK_EXT, this space must be entered at the correct frequency.
N//      <i> CK_XOSC = 1~25000000Hz, CK_EXT = 1~36000000Hz
N#define CONF_XOSC_EXTCK_FREQ             12000000    // 1
N
N//      <o.18> Select IHRCO <0=> 12MHz
N//                          <1=> 11.059MHz
N//      <i> IHRCO clock source frequency select.
N#define CONF_CSC_IHRCO_SEL                0x00000000  // 2  [18] IHRCO Select
N
N//          <o.16..17> Select XOSC Gain <0=> Normal Gain For 32 KHz
N//                                      <1=> Medium Gain 4 ~ 25MHz
N//                                      <2=> Lowest Gain For 32 KHz
N//          <i> Xtal oscillator gain select. 
N#define CONF_CSC_XOSC_GN                  0x00010000  // 3  [17:16] XOSC Gain
N
N//      <q.4> Disable MCD(Missing Clock Detector)
N#define CONF_CSC_MCD_DIS                  0x00000010  // 4  [4] MCD Disable
N//      <o.22..23> Select Missing Clock Detection Duration <0=> 125us
N//                                                         <1=> 250us
N//                                                         <2=> 500us
N//                                                         <3=> 1ms
N//      <i> MCD detection duration time select. Large time selection makes slow MCD response. 
N#define CONF_CSC_MCD_SEL                  0x00000000  // 5  [23:22] MCD Duration Select
N
N//      <o.10..11> Select CK_HS Source <0=> CK_IHRCO
N//                                     <1=> CK_XOSC
N//                                     <2=> CK_ILRCO
N//                                     <3=> CK_EXT
N//      <i> When Select CK_HS Source = CK_XOSC, MG32x02z_GPIO_Init.h Wizard PC13 configutaion and PC14 configutaion must disable.
N#define CONF_CSC_HS_SEL                   0x00000000  // 6  [11:10] CK_HS Select
N
N//      <h> Configure PLL
N//          <o.0..1> Select CK_PLLI Divider <0=> CK_HSx/1
N//                                          <1=> CK_HSx/2
N//                                          <2=> CK_HSx/4
N//                                          <3=> CK_HSx/6
N#define CONF_CSC_PLLI_DIV                 0x00000001  // 9  [1:0] PLLI DIV
N//          <o.8> Select CK_PLL Multiplication Factor <0=> CK_PLLIx16
N//                                                    <1=> CK_PLLIx24
N//          <i> CK_PLL output frequency = (CK_PLLI PLL input frequency) * (value)
N#define CONF_CSC_PLL_MUL                  0x00000000  // 10
N//          <o.4..5> Select CK_PLLO Divider <0=> CK_PLL/4
N//                                          <1=> CK_PLL/3
N//                                          <2=> CK_PLL/2
N//                                          <3=> CK_PLL/1
N#define CONF_CSC_PLLO_DIV                 0x00000000  // 12  [5:4] PLLO DIV
N//      </h>
N
N//      <o.14..15> Select CK_MAIN Source <0=> CK_HS
N//                                       <1=> CK_PLLI
N//                                       <2=> CK_PLLO 
N//      <i> When Select CK_MAIN Source = CK_PPLI, the PLL must enable.
N#define CONF_CSC_MAIN_SEL                 0x00000000  // 14  [15:14] CK_MAIN Select
N
N//      <o.8..9> Select CK_LS Source <1=> CK_XOSC
N//                                   <2=> CK_ILRCO
N//                                   <3=> CK_EXT
N//      <i> When Select CK_LS Source = CK_XOSC, MG32x02z_GPIO_Init.h Wizard PC13 configutaion and PC14 configutaion  must disable.
N#define CONF_CSC_LS_SEL                   0x00000200  // 15  [9:8] CK_LS Select
N
N//      <o.16> Select CK_ST Source <0=> HCLK/8
N//                                 <1=> CK_LS/2
N//      <i> System tick timer external clock source select.
N//      <i> This function is valid when CPU_CLKSOURCE is set 0(default).
N#define CONF_CSC_ST_SEL                   0x00000000  // 16  [16] CK_ST Select
N
N/**/
N//      <e.0> IHRCO/PLL Enable or XOSC/EXTCK AFS Pin Disable
N//      <i> The functions enable or disable by C-code checking if this CheckBox unchecked.
N//      <i> The functions enable or disable by following user setting if this CheckBox checked.
N#define CONF_CSC_CKIP_EN                  0x00000000  // 17  [0] 0=C-code auto checking
N
N//            <q.3> IHRCO_EN
N//            <i> IHRCO device enable
N#define CONF_CSC_CR0_IHRCO_EN             0x00000008  // 18  [3] IHRCO_EN
N
N
N//            <q.5> PLL_EN
N//            <i> PLL device enable
N#define CONF_CSC_CR0_PLL_EN               0x00000000  // 19  [5] PLL_EN (CSC_init.c and .h not used)
N
N
N//            <q.31> XOSC_EN
N//            <i> Crystal Oscillator and XIN/XOUT pins enable
N#define CONF_CFG_XOSC_EN                  0x00000000  // 20  [31] XOSC_EN
N
N
N//            <q.31> EXTCK_EN
N//            <i> External clock input and XIN pin enable if CK_EXT was selected in any HS/HS2/LS Mux
N#define CONF_CFG_EXTCK_EN                 0x00000000  // 21  [31] EXTCK pin enable (CSC_init.c and .h not used)
N
N//      </e>
N
N//      <o.16..18> Select APB Prescaler <0x00=> CK_MAIN/1
N//                                      <0x01=> CK_MAIN/2
N//                                      <0x02=> CK_MAIN/4
N//                                      <0x03=> CK_MAIN/8
N//                                      <0x04=> CK_MAIN/16
N//          <i> CK_APB frequency = (CK_MAIN frequency) / (selected Divider Value)
N#define CONF_CSC_APB_DIV                  0x00000000  // 22  [18:16] APB DIV
N
N//      <o.8..11> Select AHB Prescaler <0x00=> CK_APB/1
N//                                     <0x01=> CK_APB/2
N//                                     <0x02=> CK_APB/4
N//                                     <0x03=> CK_APB/8
N//                                     <0x04=> CK_APB/16
N//                                     <0x05=> CK_APB/32
N//                                     <0x06=> CK_APB/64
N//                                     <0x07=> CK_APB/128
N//                                     <0x08=> CK_APB/256
N//                                     <0x09=> CK_APB/512
N//          <i> CK_AHB frequency = (CK_APB frequency) / (selected Divider Value)
N#define CONF_CSC_AHB_DIV                  0x00000000  // 23  [11:8] AHB DIV
N
N//      <o.26..27> Select CK_UT Divider <0x00=> ILRCO/32
N//                                      <0x01=> ILRCO/8
N//                                      <0x02=> ILRCO/16
N//                                      <0x03=> ILRCO/128
N//          <i> CK_UT frequency = (ILRCO frequency) / (selected Divider Value)
N#define CONF_CSC_UT_DIV                   0x00000000  // 24  [27:26] UT DIV
N
N//      <h> Configure Peripheral ON Mode Clock
N//      <i> Peripheral module process clock enable when MCU is running ON mode.
N//          <q.0>  Port A
N//          <i> PA module process clock and register write-access enable.
N#define CONF_CSC_IOPA_EN                  0x00000001  // 30
N//          <q.1>  Port B
N//          <i> PB module process clock and register write-access enable.
N#define CONF_CSC_IOPB_EN                  0x00000002  // 31
N//          <q.2>  Port C
N//          <i> PC module process clock and register write-access enable.
N#define CONF_CSC_IOPC_EN                  0x00000004  // 32
N//          <q.3>  Port D
N//          <i> PD module process clock and register write-access enable.
N#define CONF_CSC_IOPD_EN                  0x00000008  // 33
N//          <q.4>  Port E
N//          <i> PE module process clock and register write-access enable.
N#define CONF_CSC_IOPE_EN                  0x00000010  // 34
N//          <q.8>  GPL
N//          <i> GPL clock source enable.
N#define CONF_CSC_GPL_EN                   0x00000100  // 35
N//          <q.12> EMB
N//          <i> EMB clock source enable.
N#define CONF_CSC_EMB_EN                   0x00001000  // 36
N//          <q.15> DMA
N//          <i> DMA clock source enable.
N#define CONF_CSC_DMA_EN                   0x00008000  // 37
N//          <e.0>  ADC0
N//          <i> ADC clock source enable.
N#define CONF_CSC_ADC0                     0x00000001  // 38
N//              <o.0>  Select ADCx_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> ADC Process clock source select.
N#define CONF_CSC_ADC0_CKS                 0x00000000  // 39
N//          </e>
N//          <e.2>  CMP
N//          <i> CMP clock source enable.
N#define CONF_CSC_CMP_EN                   0x00000004  // 40
N//              <o.4>  Select CMP_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> CMP Process clock source select.
N#define CONF_CSC_CMP_CKS                  0x00000004  // 41
N//          </e>
N//          <e.3>  DAC
N#define CONF_CSC_DAC_EN                   0x00000008  // 42
N//          <i> DAC clock source enable.
N//              <o.5>  Select CMP_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> DAC Process clock source select.
N#define CONF_CSC_DAC_CKS                  0x00000000  // 43
N//          </e>
N//          <q.5>  RTC
N//          <i> RTC clock source enable.
N#define CONF_CSC_RTC_EN                   0x00000020  // 50
N//          <q.6>  IWDT
N//          <i> IWDT clock source enable.
N#define CONF_CSC_IWDT_EN                  0x00000040  // 51
N//          <q.7>  WWDT
N//          <i> WWDT clock source enable.
N#define CONF_CSC_WWDT_EN                  0x00000080  // 52
N//          <e.8>  I2C0
N//          <i> I2C0 clock source enable.
N#define CONF_CSC_I2C0_EN                  0x00000100  // 53
N//              <o.0>  Select I2C0_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_I2C0_CKS                 0x00000000  // 54
N//          </e>
N//          <e.9>  I2C1
N//          <i> I2C1 clock source enable.
N#define CONF_CSC_I2C1_EN                  0x00000200  // 55
N//              <o.2>  Select I2C0_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_I2C1_CKS                 0x00000000  // 56
N//          </e>
N//          <e.12> SPI0
N//          <i> SPI0 clock source enable.
N#define CONF_CSC_SPI0_EN                  0x00001000  // 57
N//              <o.8>  Select SPI0_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_SPI0_CKS                 0x00000000  // 58
N//          </e>
N//          <e.16> URT0
N//          <i> URT0 clock source enable.
N#define CONF_CSC_URT0_EN                  0x00010000  // 59
N//              <o.16> Select URT0_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_URT0_CKS                 0x00000000  // 60
N//          </e>
N//          <e.17> URT1
N//          <i> URT1 clock source enable.
N#define CONF_CSC_URT1_EN                  0x00020000  // 61
N//              <o.18> Select URT1_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_URT1_CKS                 0x00000000  // 62
N//          </e>
N//          <e.18> URT2
N//          <i> URT2 clock source enable.
N#define CONF_CSC_URT2_EN                  0x00040000  // 63
N//              <o.20> Select URT2_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_URT2_CKS                 0x00000000  // 64
N//          </e>
N//          <e.19> URT3
N//          <i> URT3 clock source enable.
N#define CONF_CSC_URT3_EN                  0x00080000  // 65
N//              <o.22> Select URT3_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_URT3_CKS                 0x00000000  // 66
N//          </e>
N//          <e.0>  TM00
N//          <i> TM00 clock source enable.
N#define CONF_CSC_TM00_EN                  0x00000001  // 79
N//              <o.0>  Select TM00_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM00_CKS                 0x00000000  // 80
N//          </e>
N//          <e.1>  TM01
N//          <i> TM01 clock source enable.
N#define CONF_CSC_TM01_EN                  0x00000002  // 81
N//              <o.2>  Select TM01_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM01_CKS                 0x00000000  // 82
N//          </e>
N//          <e.4>  TM10
N//          <i> TM10 clock source enable.
N#define CONF_CSC_TM10_EN                  0x00000010  // 83
N//              <o.8>  Select TM10_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM10_CKS                 0x00000000  // 84
N//          </e>
N//          <e.7>  TM16
N//          <i> TM16 clock source enable.
N#define CONF_CSC_TM16_EN                  0x00000080  // 85
N//              <o.14> Select TM16_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM16_CKS                 0x00000000  // 86
N//          </e>
N//          <e.8>  TM20
N//          <i> TM20 clock source enable.
N#define CONF_CSC_TM20_EN                  0x00000100  // 87
N//              <o.16> Select TM20_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM20_CKS                 0x00000000  // 88
N//          </e>
N//          <e.11>  TM26
N//          <i> TM20 clock source enable.
N#define CONF_CSC_TM26_EN                  0x00000800  // 89
N//              <o.22> Select TM26_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM26_CKS                 0x00000000  // 90
N//          </e>
N//          <e.15> TM36
N//          <i> TM36 clock source enable.
N#define CONF_CSC_TM36_EN                  0x00008000  // 91
N//              <o.30> Select TM36_PR Source <0=> CK_APB <1=> CK_AHB
N//              <i> Process clock source select.
N#define CONF_CSC_TM36_CKS                 0x00000000  // 92
N//          </e>
N//      </h>
N
N//      <h> Configure Peripheral SLEEP Mode Clock
N//      <i> Peripheral module process clock enable when MCU is entering SLEEP mode.
N//          <q.0>  ADC0
N#define CONF_CSC_SLP_ADC0                 0x00000000  // 100
N//          <q.2>  CMP
N#define CONF_CSC_SLP_CMP                  0x00000000  // 101
N//          <q.3>  DAC
N#define CONF_CSC_SLP_DAC                  0x00000000  // 102
N//          <q.5>  RTC
N#define CONF_CSC_SLP_RTC                  0x00000000  // 103
N//          <q.6>  IWDT
N#define CONF_CSC_SLP_IWDT                 0x00000000  // 104
N//          <q.7>  WWDT
N#define CONF_CSC_SLP_WWDT                 0x00000000  // 105
N//          <q.8>  I2C0
N#define CONF_CSC_SLP_I2C0                 0x00000000  // 106
N//          <q.9>  I2C1
N#define CONF_CSC_SLP_I2C1                 0x00000000  // 107
N//          <q.12> SPI0
N#define CONF_CSC_SLP_SPI0                 0x00000000  // 108
N//          <q.16> URT0
N#define CONF_CSC_SLP_URT0                 0x00000000  // 109
N//          <q.17> URT1
N#define CONF_CSC_SLP_URT1                 0x00000000  // 110
N//          <q.18> URT2
N#define CONF_CSC_SLP_URT2                 0x00000000  // 111
N//          <q.20> URT3
N#define CONF_CSC_SLP_URT3                 0x00000000  // 112
N//          <q.0>  TM00
N#define CONF_CSC_SLP_TM00                 0x00000000  // 119
N//          <q.1>  TM01
N#define CONF_CSC_SLP_TM01                 0x00000000  // 120
N//          <q.4>  TM10
N#define CONF_CSC_SLP_TM10                 0x00000000  // 121
N//          <q.7>  TM16
N#define CONF_CSC_SLP_TM16                 0x00000000  // 122
N//          <q.8>  TM20
N#define CONF_CSC_SLP_TM20                 0x00000000  // 123
N//          <q.11> TM26
N#define CONF_CSC_SLP_TM26                 0x00000000  // 124
N//          <q.15> TM36
N#define CONF_CSC_SLP_TM36                 0x00000000  // 125
N//          <q.29> DMA
N#define CONF_CSC_SLP_DMA                  0x00000000  // 128
N//          <q.30> EMB
N#define CONF_CSC_SLP_EMB                  0x00000000  // 129
N//      </h>
N
N//      <h> Configure Peripheral STOP Mode Clock
N//      <i> Peripheral module process clock enable when MCU is entering STOP mode.
N//          <q.5>  RTC
N#define CONF_CSC_STP_RTC                  0x00000000  // 140
N//          <q.6>  IWDT
N#define CONF_CSC_STP_IWDT                 0x00000000  // 141
N//      </h>
N
N//      <e.0> Enable ICKO
N//      <i> Internal clock source output enable.
N#define CONF_CSC_CKO_EN                   0x00000000  // 150
N//          <o.2..3> Select ICKO Divider <0=> ICK/1
N//                                       <1=> ICK/2
N//                                       <2=> ICK/4
N//                                       <3=> ICK/8
N//          <i> Internal clock output divider select.
N#define CONF_CSC_CKO_DIV                  0x00000008  // 151
N//          <o.4..7> Select ICKO <0=> CK_MAIN
N//                               <1=> CK_AHB
N//                               <2=> CK_APB
N//                               <3=> CK_HS
N//                               <4=> CK_LS
N//                               <5=> CK_XOSC
N//          <i> Internal clock output source select.
N#define CONF_CSC_CKO_SEL                  0x00000000  // 152
N//      </e>
N//</h>
N
N//*** <<< end of configuration section >>>    ***
N
N// CSC_INT bit 0 ~ 31
N#define CONF_CSC_IEA                      0x00000000          // 000, 000
N#define CONF_CSC_XOSC_IE                  0x00000000          // 001, 001
N#define CONF_CSC_ILRCO_IE                 0x00000000          // 004, 004
N#define CONF_CSC_IHRCO_IE                 0x00000000          // 005, 005
N#define CONF_CSC_PLL_IE                   0x00000000          // 006, 006
N#define CONF_CSC_MCD_IE                   0x00000000          // 007, 007
N                                         
N#define CONF_CSC_PLL_MDS                  0x00000001 /*MG32_3RD must be retention and value is 0x00000001 */
N                                         
N#define CONF_CSC_STA              0X00000000
N#define CONF_CSC_INT              (CONF_CSC_IEA | CONF_CSC_XOSC_IE | CONF_CSC_ILRCO_IE | CONF_CSC_IHRCO_IE | CONF_CSC_PLL_IE | CONF_CSC_MCD_IE)
N#define CONF_CSC_KEY              0x00000000
N
N#define CONF_CSC_PLL              (CONF_CSC_PLL_MUL | CONF_CSC_XOSC_GN)
N#define CONF_CSC_CR0              (CONF_CSC_MCD_DIS | CONF_CSC_LS_SEL | CONF_CSC_HS_SEL | CONF_CSC_MAIN_SEL | CONF_CSC_ST_SEL | CONF_CSC_IHRCO_SEL | CONF_CSC_MCD_SEL)
N#define CONF_CSC_DIV              (CONF_CSC_PLLI_DIV | CONF_CSC_PLLO_DIV | CONF_CSC_AHB_DIV | CONF_CSC_APB_DIV | CONF_CSC_UT_DIV)
N
N#define CONF_CSC_CKO              (CONF_CSC_CKO_EN | CONF_CSC_CKO_DIV | CONF_CSC_CKO_SEL)
N#define CONF_CSC_AHB              (CONF_CSC_IOPA_EN | CONF_CSC_IOPB_EN | CONF_CSC_IOPC_EN | CONF_CSC_IOPD_EN | CONF_CSC_IOPE_EN | CONF_CSC_GPL_EN | CONF_CSC_EMB_EN | CONF_CSC_DMA_EN)
N#define CONF_CSC_APB0             (CONF_CSC_ADC0 | CONF_CSC_CMP_EN | CONF_CSC_DAC_EN | CONF_CSC_RTC_EN | CONF_CSC_IWDT_EN | CONF_CSC_WWDT_EN | CONF_CSC_I2C0_EN | CONF_CSC_I2C1_EN | CONF_CSC_SPI0_EN | CONF_CSC_URT0_EN | CONF_CSC_URT1_EN | CONF_CSC_URT2_EN | CONF_CSC_URT3_EN)
N#define CONF_CSC_APB1             (CONF_CSC_TM00_EN | CONF_CSC_TM01_EN | CONF_CSC_TM10_EN | CONF_CSC_TM16_EN | CONF_CSC_TM20_EN | CONF_CSC_TM26_EN | CONF_CSC_TM36_EN)
N#define CONF_CSC_SLP0             (CONF_CSC_SLP_ADC0 | CONF_CSC_SLP_CMP | CONF_CSC_SLP_DAC | CONF_CSC_SLP_RTC | CONF_CSC_SLP_IWDT | CONF_CSC_SLP_WWDT | CONF_CSC_SLP_I2C0 | CONF_CSC_SLP_I2C1 | CONF_CSC_SLP_SPI0 | CONF_CSC_SLP_URT0 | CONF_CSC_SLP_URT1 | CONF_CSC_SLP_URT2 | CONF_CSC_SLP_URT3)
N#define CONF_CSC_SLP1             (CONF_CSC_SLP_TM00 | CONF_CSC_SLP_TM01 | CONF_CSC_SLP_TM10 | CONF_CSC_SLP_TM16 | CONF_CSC_SLP_TM20 | CONF_CSC_SLP_TM26 | CONF_CSC_SLP_TM36 | CONF_CSC_SLP_EMB )
N#define CONF_CSC_STP0             (CONF_CSC_STP_RTC | CONF_CSC_STP_IWDT)
N#define CONF_CSC_STP1             0x00000000
N#define CONF_CSC_CSK0             (CONF_CSC_ADC0_CKS |  CONF_CSC_CMP_CKS |  CONF_CSC_DAC_CKS)
N#define CONF_CSC_CSK1             (CONF_CSC_I2C0_CKS | CONF_CSC_I2C1_CKS | CONF_CSC_SPI0_CKS | CONF_CSC_URT0_CKS | CONF_CSC_URT1_CKS | CONF_CSC_URT2_CKS | CONF_CSC_URT3_CKS)
N#define CONF_CSC_CSK2             (CONF_CSC_TM00_CKS | CONF_CSC_TM01_CKS | CONF_CSC_TM10_CKS | CONF_CSC_TM16_CKS | CONF_CSC_TM20_CKS | CONF_CSC_TM26_CKS | CONF_CSC_TM36_CKS)
N
N    /* Calculate CK_xxx Frequency */
N// CONF_CK_HS_FREQ
N#if CONF_CSC_HS_SEL == 0x00000000
X#if 0x00000000 == 0x00000000
N    #if CONF_CSC_IHRCO_SEL == 0x00000000
X    #if 0x00000000 == 0x00000000
N        #define CONF_CK_HS_FREQ   12000000
N    #else
S        #define CONF_CK_HS_FREQ   11059200
N    #endif
N#elif CONF_CSC_HS_SEL == 0x00000400
S    #define CONF_CK_HS_FREQ   CONF_XOSC_EXTCK_FREQ
S#elif CONF_CSC_HS_SEL == 0x00000800
S    #define CONF_CK_HS_FREQ   32000
S#elif CONF_CSC_HS_SEL == 0x00000C00
S    #define CONF_CK_HS_FREQ   CONF_XOSC_EXTCK_FREQ
N#endif
N
N// CONF_PLLI_DIV
N#if CONF_CSC_PLLI_DIV == 0x00000000
X#if 0x00000001 == 0x00000000
S    #define CONF_PLLI_DIV     1
N#elif CONF_CSC_PLLI_DIV == 0x00000001
X#elif 0x00000001 == 0x00000001
N    #define CONF_PLLI_DIV     2
N#elif CONF_CSC_PLLI_DIV == 0x00000002
S    #define CONF_PLLI_DIV     4
S#elif CONF_CSC_PLLI_DIV == 0x00000003
S    #define CONF_PLLI_DIV     6
N#endif
N
N// CONF_PLL_MUL
N    #if CONF_CSC_PLL_MUL == 0x00000000
X    #if 0x00000000 == 0x00000000
N        #define CONF_CSC_PLL_MUL_VAL      16
N    #elif CONF_CSC_PLL_MUL == 0x00000100
S        #define CONF_CSC_PLL_MUL_VAL      24
N    #endif
N// CONF_PLLO_DIV
N#if CONF_CSC_PLLO_DIV == 0x00000000
X#if 0x00000000 == 0x00000000
N    #define CONF_PLLO_DIV     4
N#elif CONF_CSC_PLLO_DIV == 0x00000010
S    #define CONF_PLLO_DIV     3
S#elif CONF_CSC_PLLO_DIV == 0x00000020
S    #define CONF_PLLO_DIV     2
S#elif CONF_CSC_PLLO_DIV == 0x00000030
S    #define CONF_PLLO_DIV     1
N#endif
N// CONF_CK_MAIN_FREQ
N#if CONF_CSC_MAIN_SEL == 0x00000000
X#if 0x00000000 == 0x00000000
N    #define CONF_CK_MAIN_FREQ     CONF_CK_HS_FREQ
N// When CK_AMIN = CK_PLLI
N#elif CONF_CSC_MAIN_SEL == 0x00004000
S    // When CSC_PLLI_SEL == CK_HS
S    #if CONF_CSC_PLLI_SEL == 0x00000000
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS_FREQ/CONF_PLLI_DIV
S    // When CSC_PLLI_SEL == CK_HS2
S    #else
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS2_FREQ/CONF_PLLI_DIV
S    #endif
S
S// When CK_MAIN == CK_PLLO 
S#elif CONF_CSC_MAIN_SEL == 0x00008000
S    // When CSC_PLLI_SEL == CK_HS
S    #if CONF_CSC_PLLI_SEL == 0x00000000
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS_FREQ /CONF_PLLI_DIV *CONF_CSC_PLL_MUL_VAL /CONF_PLLO_DIV
S    // When CSC_PLLI_SEL == CK_HS2
S    #else
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS2_FREQ /CONF_PLLI_DIV *CONF_CSC_PLL_MUL_VAL /CONF_PLLO_DIV
S    #endif
N#endif
N
N// CONF_CK_APB_FREQ
N#if CONF_CSC_APB_DIV == 0x00000000
X#if 0x00000000 == 0x00000000
N    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /1
N#elif CONF_CSC_APB_DIV == 0x00010000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /2
S#elif CONF_CSC_APB_DIV == 0x00020000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /4
S#elif CONF_CSC_APB_DIV == 0x00030000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /8
S#elif CONF_CSC_APB_DIV == 0x00040000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /16
N#endif
N
N// CONF_CK_AHB_FREQ
N#if CONF_CSC_AHB_DIV == 0x00000000
X#if 0x00000000 == 0x00000000
N    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /1
N#elif CONF_CSC_AHB_DIV == 0x00000100
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /2
S#elif CONF_CSC_AHB_DIV == 0x00000200
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /4
S#elif CONF_CSC_AHB_DIV == 0x00000300
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /8
S#elif CONF_CSC_AHB_DIV == 0x00000400
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /16
S#elif CONF_CSC_AHB_DIV == 0x00000500
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /32
S#elif CONF_CSC_AHB_DIV == 0x00000600
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /64
S#elif CONF_CSC_AHB_DIV == 0x00000700
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /128
S#elif CONF_CSC_AHB_DIV == 0x00000800
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /256
S#elif CONF_CSC_AHB_DIV == 0x00000900
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /512
N#endif
N
N// Flash wait state setting
N#if CONF_CK_AHB_FREQ <= 25000000
X#if 12000000 /1 /1 <= 25000000
N    #define CONF_FLASH_WAIT_STATE    MEM_CR0_FWAIT_zero_w
N#elif CONF_CK_AHB_FREQ <= 50000000
S    #define CONF_FLASH_WAIT_STATE    MEM_CR0_FWAIT_one_w
S#elif CONF_CK_AHB_FREQ > 50000000
S    #define CONF_FLASH_WAIT_STATE    MEM_CR0_FWAIT_two_w
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      CONF_CSC_InitConfig[]
N *              CSC initial configuration array
N *
N ******************************************************************************
N */
Nstatic const unsigned int CSC_InitConfig[] =
N{
N    CONF_CSC_STA,     /* CSC_STA 0 not use */
X    0X00000000,      
N    CONF_CSC_INT,     /* CSC_INT 1 not use */
X    (0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000),      
N    CONF_CSC_PLL,     /* CSC_PLL 2 */
X    (0x00000000 | 0x00010000),      
N    CONF_CSC_KEY,     /* CSC_KEY 3 not use */
X    0x00000000,      
N    CONF_CSC_CR0,     /* CSC_CR0 4 */
X    (0x00000010 | 0x00000200 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000),      
N    CONF_CSC_DIV,     /* CSC_DIV 5 */
X    (0x00000001 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000),      
N    CONF_CSC_CKO,     /* CSC_CKO 6 */
X    (0x00000000 | 0x00000008 | 0x00000000),      
N    CONF_CSC_AHB,     /* CSC_AHB 7 */
X    (0x00000001 | 0x00000002 | 0x00000004 | 0x00000008 | 0x00000010 | 0x00000100 | 0x00001000 | 0x00008000),      
N    CONF_CSC_APB0,    /* CSC_APB0 8 */
X    (0x00000001 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000040 | 0x00000080 | 0x00000100 | 0x00000200 | 0x00001000 | 0x00010000 | 0x00020000 | 0x00040000 | 0x00080000),     
N    CONF_CSC_APB1,    /* CSC_APB1 9 */
X    (0x00000001 | 0x00000002 | 0x00000010 | 0x00000080 | 0x00000100 | 0x00000800 | 0x00008000),     
N    CONF_CSC_SLP0,    /* CSC_SLP0 10 */
X    (0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000),     
N    CONF_CSC_SLP1,    /* CSC_SLP1 11 */
X    (0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 ),     
N    CONF_CSC_STP0,    /* CSC_STP0 12 */
X    (0x00000000 | 0x00000000),     
N    CONF_CSC_STP1,    /* CSC_STP1 13 */
X    0x00000000,     
N    CONF_CSC_CSK0,    /* CSC_CSK0 14 */
X    (0x00000000 | 0x00000004 | 0x00000000),     
N    CONF_CSC_CSK1,    /* CSC_CSK1 15 */
X    (0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000),     
N    CONF_CSC_CSK2,    /* CSC_CSK2 16 */
X    (0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000 | 0x00000000),     
N    0x000000000,      /* CSC_OTHER 17 . bit0: 0: extern clock, 1: crystal clock */
N    CONF_XOSC_EXTCK_FREQ,    /* XOSC_EXTCLK_FREQ 18 */
X    12000000,     
N    CONF_FLASH_WAIT_STATE,   /* CK_APB_FREQ 19 */
X    ((uint32_t)0x00000000),    
N};
N
N
N/**
N * @name    Function announce
N *   
N */
N///@{  
Nvoid CSC_Init (uint32_t* CSC_CFG);
N///@}
N
N
N#endif  // _MG32x02z_CSC_INIT_H
N
L 50 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_EXIC
N    #include "MG32x02z_EXIC_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_EXIC_Init.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EXIC_Init.h
N *
N * @brief       This file is used to configure EXIC setting.
N *              Device : MG32F02A132
N *              Package: LQFP80
N *
N * @par         Project
N *              MG32x02z
N * @version     V0.30
N * @date        2021/04/27 14:40 (H File Generated Date)
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer
N *      The Demo software is provided "AS IS"  without any warranty, either
N *      expressed or implied, including, but not limited to, the implied warranties
N *      of merchantability and fitness for a particular purpose.  The author will
N *      not be liable for any special, incidental, consequential or indirect
N *      damages due to loss of data or any other reason.
N *      These statements agree with the world wide and local dictated laws about
N *      authorship and violence against these laws.
N ******************************************************************************
N @if HIDE
N *Modify History:
N *>>
N *--
N *--
N *>>
N *>>
N *
N @endif
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_EXIC_Init_H
N#define _MG32x02z_EXIC_Init_H
N
N#include "MG32x02z_EXIC.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_EXIC.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EXIC.h
N *
N * @brief       MG32x02z EXIC Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_EXIC_H
N#define _MG32x02z_EXIC_H
N#define _MG32x02z_EXIC_H_VER                        3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_EXIC_H_VER)
S    #error "MG32x02z_EXIC_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      EXIC_Struct
N *              EXIC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  PA_OF         :1;     //[0] External interrupt PAx OR path interrupt flag. (set and clear by hardware)
X            volatile const  uint8_t  PA_OF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  PA_AF         :1;     //[1] External interrupt PAx AND path interrupt flag 
X            volatile uint8_t  PA_AF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  PB_OF         :1;     //[4] External interrupt PBx OR path interrupt flag. (set and clear by hardware)
X            volatile const  uint8_t  PB_OF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  PB_AF         :1;     //[5] External interrupt PBx AND path interrupt flag
X            volatile uint8_t  PB_AF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  PC_OF         :1;     //[8] External interrupt PCx OR path interrupt flag. (set and clear by hardware)
X            volatile const  uint8_t  PC_OF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  PC_AF         :1;     //[9] External interrupt PCx AND path interrupt flag
X            volatile uint8_t  PC_AF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  PD_OF         :1;     //[12] External interrupt PDx OR path interrupt flag. (set and clear by hardware)
X            volatile const  uint8_t  PD_OF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  PD_AF         :1;     //[13] External interrupt PDx AND path interrupt flag
X            volatile uint8_t  PD_AF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  EXIC interrupt status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PA_IEA        :1;     //[0] EXIC port PA external interrupt all enable
X            volatile uint8_t  PA_IEA        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PB_IEA        :1;     //[1] EXIC port PB external interrupt all enable
X            volatile uint8_t  PB_IEA        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PC_IEA        :1;     //[2] EXIC port PC external interrupt all enable
X            volatile uint8_t  PC_IEA        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PD_IEA        :1;     //[3] EXIC port PD external interrupt all enable
X            volatile uint8_t  PD_IEA        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  EXIC interrupt enable register */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  NMI_SW        :1;     //[1] Software NMI trigger bit. (set by software and clear by hardware)
X            volatile uint8_t  NMI_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  EM_NMI        :1;     //[8] Interrupt event mask control bit for NMI.
X            volatile uint8_t  EM_NMI        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  EM_RXEV       :1;     //[9] Interrupt event mask control bit for RXEV.
X            volatile uint8_t  EM_RXEV       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  PA_AINV       :1;     //[24] External interrupt PAx AND path signal inverse enable bit.
X            volatile uint8_t  PA_AINV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  PB_AINV       :1;     //[25] External interrupt PBx AND path signal inverse enable bit.
X            volatile uint8_t  PB_AINV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  PC_AINV       :1;     //[26] External interrupt PCx AND path signal inverse enable bit.
X            volatile uint8_t  PC_AINV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  PD_AINV       :1;     //[27] External interrupt PDx AND path signal inverse enable bit.
X            volatile uint8_t  PD_AINV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  EXIC control register 0 */
N
N    __I uint32_t  RESERVED1[3];         /*!< RESERVED1  ~ Offset[0x14]  Reserved */
X    volatile const uint32_t  RESERVED1[3];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PA0_PF        :1;     //[0] EXIC pin input interrupt pending flag x for external input interrupt pin PAx
X            volatile uint8_t  PA0_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA1_PF        :1;     //[1] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA1_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA2_PF        :1;     //[2] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA2_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA3_PF        :1;     //[3] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA3_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA4_PF        :1;     //[4] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA4_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA5_PF        :1;     //[5] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA5_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA6_PF        :1;     //[6] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA6_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA7_PF        :1;     //[7] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA7_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA8_PF        :1;     //[8] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA8_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA9_PF        :1;     //[9] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA9_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA10_PF       :1;     //[10] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA10_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA11_PF       :1;     //[11] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA11_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA12_PF       :1;     //[12] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA12_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA13_PF       :1;     //[13] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA13_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA14_PF       :1;     //[14] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA14_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PA15_PF       :1;     //[15] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PA15_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PA_PF;                             /*!< PA_PF      ~ Offset[0x20]  EXIC PA input interrupt pending flag register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PA0_TRGS      :2;     //[1..0] External interrupt pin edge/level trigger event select
X            volatile uint8_t  PA0_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA1_TRGS      :2;     //[3..2] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA1_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA2_TRGS      :2;     //[5..4] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA2_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA3_TRGS      :2;     //[7..6] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA3_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA4_TRGS      :2;     //[9..8] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA4_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA5_TRGS      :2;     //[11..10] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA5_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA6_TRGS      :2;     //[13..12] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA6_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA7_TRGS      :2;     //[15..14] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA7_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA8_TRGS      :2;     //[17..16] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA8_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA9_TRGS      :2;     //[19..18] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA9_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA10_TRGS     :2;     //[21..20] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA10_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA11_TRGS     :2;     //[23..22] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA11_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA12_TRGS     :2;     //[25..24] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA12_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA13_TRGS     :2;     //[27..26] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA13_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA14_TRGS     :2;     //[29..28] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA14_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PA15_TRGS     :2;     //[31..30] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PA15_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N        }MBIT;
N    }PA_TRGS;                           /*!< PA_TRGS    ~ Offset[0x24]  EXIC PA Pad input trigger select register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PA0_OM        :1;     //[0] External interrupt PAx OR mask bit x
X            volatile uint8_t  PA0_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA1_OM        :1;     //[1] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA1_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA2_OM        :1;     //[2] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA2_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA3_OM        :1;     //[3] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA3_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA4_OM        :1;     //[4] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA4_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA5_OM        :1;     //[5] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA5_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA6_OM        :1;     //[6] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA6_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA7_OM        :1;     //[7] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA7_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA8_OM        :1;     //[8] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA8_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA9_OM        :1;     //[9] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA9_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA10_OM       :1;     //[10] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA10_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA11_OM       :1;     //[11] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA11_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA12_OM       :1;     //[12] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA12_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA13_OM       :1;     //[13] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA13_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA14_OM       :1;     //[14] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA14_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA15_OM       :1;     //[15] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PA15_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA0_AM        :1;     //[16] External interrupt PAx AND mask bit x
X            volatile uint8_t  PA0_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable 
N            __IO uint8_t  PA1_AM        :1;     //[17] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA1_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA2_AM        :1;     //[18] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA2_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA3_AM        :1;     //[19] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA3_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA4_AM        :1;     //[20] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA4_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA5_AM        :1;     //[21] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA5_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA6_AM        :1;     //[22] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA6_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA7_AM        :1;     //[23] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA7_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA8_AM        :1;     //[24] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA8_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA9_AM        :1;     //[25] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA9_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA10_AM       :1;     //[26] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA10_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA11_AM       :1;     //[27] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA11_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA12_AM       :1;     //[28] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA12_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA13_AM       :1;     //[29] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA13_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA14_AM       :1;     //[30] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA14_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PA15_AM       :1;     //[31] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PA15_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N        }MBIT;
N    }PA_MSK;                            /*!< PA_MSK     ~ Offset[0x28]  EXIC PA AOI Mask register */
N
N    __I uint32_t  RESERVED2;            /*!< RESERVED2  ~ Offset[0x2C]  Reserved */
X    volatile const uint32_t  RESERVED2;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PB0_PF        :1;     //[0] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB0_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB1_PF        :1;     //[1] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB1_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB2_PF        :1;     //[2] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB2_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB3_PF        :1;     //[3] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB3_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB4_PF        :1;     //[4] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB4_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB5_PF        :1;     //[5] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB5_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB6_PF        :1;     //[6] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB6_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB7_PF        :1;     //[7] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB7_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB8_PF        :1;     //[8] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB8_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB9_PF        :1;     //[9] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB9_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB10_PF       :1;     //[10] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB10_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB11_PF       :1;     //[11] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB11_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB12_PF       :1;     //[12] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB12_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB13_PF       :1;     //[13] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB13_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB14_PF       :1;     //[14] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB14_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PB15_PF       :1;     //[15] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PB15_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PB_PF;                             /*!< PB_PF      ~ Offset[0x30]  EXIC PB input interrupt pending flag register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PB0_TRGS      :2;     //[1..0] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB0_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB1_TRGS      :2;     //[3..2] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB1_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB2_TRGS      :2;     //[5..4] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB2_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB3_TRGS      :2;     //[7..6] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB3_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB4_TRGS      :2;     //[9..8] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB4_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB5_TRGS      :2;     //[11..10] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB5_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB6_TRGS      :2;     //[13..12] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB6_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB7_TRGS      :2;     //[15..14] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB7_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB8_TRGS      :2;     //[17..16] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB8_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB9_TRGS      :2;     //[19..18] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB9_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB10_TRGS     :2;     //[21..20] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB10_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB11_TRGS     :2;     //[23..22] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB11_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB12_TRGS     :2;     //[25..24] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB12_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB13_TRGS     :2;     //[27..26] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB13_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB14_TRGS     :2;     //[29..28] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB14_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PB15_TRGS     :2;     //[31..30] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PB15_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N        }MBIT;
N    }PB_TRGS;                           /*!< PB_TRGS    ~ Offset[0x34]  EXIC PB Pad input trigger select register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PB0_OM        :1;     //[0] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB0_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB1_OM        :1;     //[1] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB1_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB2_OM        :1;     //[2] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB2_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB3_OM        :1;     //[3] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB3_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB4_OM        :1;     //[4] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB4_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB5_OM        :1;     //[5] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB5_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB6_OM        :1;     //[6] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB6_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB7_OM        :1;     //[7] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB7_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB8_OM        :1;     //[8] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB8_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB9_OM        :1;     //[9] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB9_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB10_OM       :1;     //[10] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB10_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB11_OM       :1;     //[11] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB11_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB12_OM       :1;     //[12] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB12_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB13_OM       :1;     //[13] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB13_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB14_OM       :1;     //[14] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB14_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB15_OM       :1;     //[15] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PB15_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB0_AM        :1;     //[16] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB0_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB1_AM        :1;     //[17] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB1_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB2_AM        :1;     //[18] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB2_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB3_AM        :1;     //[19] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB3_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB4_AM        :1;     //[20] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB4_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB5_AM        :1;     //[21] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB5_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB6_AM        :1;     //[22] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB6_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB7_AM        :1;     //[23] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB7_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB8_AM        :1;     //[24] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB8_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB9_AM        :1;     //[25] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB9_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB10_AM       :1;     //[26] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB10_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB11_AM       :1;     //[27] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB11_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB12_AM       :1;     //[28] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB12_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB13_AM       :1;     //[29] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB13_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB14_AM       :1;     //[30] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB14_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PB15_AM       :1;     //[31] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PB15_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N        }MBIT;
N    }PB_MSK;                            /*!< PB_MSK     ~ Offset[0x38]  EXIC PB AOI Mask register */
N
N    __I uint32_t  RESERVED3;            /*!< RESERVED3  ~ Offset[0x3C]  Reserved */
X    volatile const uint32_t  RESERVED3;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PC0_PF        :1;     //[0] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC0_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC1_PF        :1;     //[1] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC1_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC2_PF        :1;     //[2] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC2_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC3_PF        :1;     //[3] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC3_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC4_PF        :1;     //[4] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC4_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC5_PF        :1;     //[5] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC5_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC6_PF        :1;     //[6] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC6_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC7_PF        :1;     //[7] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC7_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC8_PF        :1;     //[8] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC8_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC9_PF        :1;     //[9] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC9_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC10_PF       :1;     //[10] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC10_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC11_PF       :1;     //[11] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC11_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC12_PF       :1;     //[12] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC12_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC13_PF       :1;     //[13] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC13_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PC14_PF       :1;     //[14] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PC14_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PC_PF;                             /*!< PC_PF      ~ Offset[0x40]  EXIC PC input interrupt pending flag register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PC0_TRGS      :2;     //[1..0] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC0_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC1_TRGS      :2;     //[3..2] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC1_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC2_TRGS      :2;     //[5..4] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC2_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC3_TRGS      :2;     //[7..6] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC3_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC4_TRGS      :2;     //[9..8] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC4_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC5_TRGS      :2;     //[11..10] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC5_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC6_TRGS      :2;     //[13..12] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC6_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC7_TRGS      :2;     //[15..14] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC7_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC8_TRGS      :2;     //[17..16] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC8_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC9_TRGS      :2;     //[19..18] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC9_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC10_TRGS     :2;     //[21..20] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC10_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC11_TRGS     :2;     //[23..22] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC11_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC12_TRGS     :2;     //[25..24] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC12_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC13_TRGS     :2;     //[27..26] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC13_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PC14_TRGS     :2;     //[29..28] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PC14_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }PC_TRGS;                           /*!< PC_TRGS    ~ Offset[0x44]  EXIC PC Pad input trigger select register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PC0_OM        :1;     //[0] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC0_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC1_OM        :1;     //[1] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC1_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC2_OM        :1;     //[2] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC2_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC3_OM        :1;     //[3] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC3_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC4_OM        :1;     //[4] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC4_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC5_OM        :1;     //[5] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC5_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC6_OM        :1;     //[6] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC6_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC7_OM        :1;     //[7] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC7_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC8_OM        :1;     //[8] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC8_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC9_OM        :1;     //[9] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC9_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC10_OM       :1;     //[10] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC10_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC11_OM       :1;     //[11] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC11_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC12_OM       :1;     //[12] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC12_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC13_OM       :1;     //[13] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC13_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC14_OM       :1;     //[14] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PC14_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PC0_AM        :1;     //[16] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC0_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC1_AM        :1;     //[17] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC1_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC2_AM        :1;     //[18] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC2_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC3_AM        :1;     //[19] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC3_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC4_AM        :1;     //[20] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC4_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC5_AM        :1;     //[21] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC5_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC6_AM        :1;     //[22] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC6_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC7_AM        :1;     //[23] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC7_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC8_AM        :1;     //[24] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC8_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC9_AM        :1;     //[25] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC9_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC10_AM       :1;     //[26] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC10_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC11_AM       :1;     //[27] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC11_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC12_AM       :1;     //[28] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC12_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC13_AM       :1;     //[29] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC13_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PC14_AM       :1;     //[30] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PC14_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }PC_MSK;                            /*!< PC_MSK     ~ Offset[0x48]  EXIC  PC AOI Mask register */
N
N    __I uint32_t  RESERVED4;            /*!< RESERVED4  ~ Offset[0x4C]  Reserved */
X    volatile const uint32_t  RESERVED4;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PD0_PF        :1;     //[0] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD0_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD1_PF        :1;     //[1] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD1_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD2_PF        :1;     //[2] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD2_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD3_PF        :1;     //[3] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD3_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD4_PF        :1;     //[4] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD4_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD5_PF        :1;     //[5] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD5_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD6_PF        :1;     //[6] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD6_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD7_PF        :1;     //[7] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD7_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD8_PF        :1;     //[8] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD8_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD9_PF        :1;     //[9] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD9_PF        :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD10_PF       :1;     //[10] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD10_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD11_PF       :1;     //[11] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD11_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD12_PF       :1;     //[12] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD12_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD13_PF       :1;     //[13] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD13_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD14_PF       :1;     //[14] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD14_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __IO uint8_t  PD15_PF       :1;     //[15] Refer to EXIC_PA0_PF.
X            volatile uint8_t  PD15_PF       :1;     
N                                        //0 = Normal : No event occurred
N                                        //1 = Happened : Event happened
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PD_PF;                             /*!< PD_PF      ~ Offset[0x50]  EXIC PD input interrupt pending flag register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PD0_TRGS      :2;     //[1..0] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD0_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD1_TRGS      :2;     //[3..2] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD1_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD2_TRGS      :2;     //[5..4] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD2_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD3_TRGS      :2;     //[7..6] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD3_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD4_TRGS      :2;     //[9..8] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD4_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD5_TRGS      :2;     //[11..10] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD5_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD6_TRGS      :2;     //[13..12] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD6_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD7_TRGS      :2;     //[15..14] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD7_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD8_TRGS      :2;     //[17..16] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD8_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD9_TRGS      :2;     //[19..18] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD9_TRGS      :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD10_TRGS     :2;     //[21..20] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD10_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD11_TRGS     :2;     //[23..22] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD11_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD12_TRGS     :2;     //[25..24] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD12_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD13_TRGS     :2;     //[27..26] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD13_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD14_TRGS     :2;     //[29..28] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD14_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  PD15_TRGS     :2;     //[31..30] Refer to EXIC_PA0_TRGS.
X            volatile uint8_t  PD15_TRGS     :2;     
N                                        //0x0 = No : No updated flag
N                                        //0x1 = Level
N                                        //0x2 = Edge
N                                        //0x3 = Dual-edge
N        }MBIT;
N    }PD_TRGS;                           /*!< PD_TRGS    ~ Offset[0x54]  EXIC PD Pad input trigger select register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PD0_OM        :1;     //[0] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD0_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD1_OM        :1;     //[1] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD1_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD2_OM        :1;     //[2] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD2_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD3_OM        :1;     //[3] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD3_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD4_OM        :1;     //[4] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD4_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD5_OM        :1;     //[5] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD5_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD6_OM        :1;     //[6] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD6_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD7_OM        :1;     //[7] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD7_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD8_OM        :1;     //[8] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD8_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD9_OM        :1;     //[9] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD9_OM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD10_OM       :1;     //[10] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD10_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD11_OM       :1;     //[11] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD11_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD12_OM       :1;     //[12] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD12_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD13_OM       :1;     //[13] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD13_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD14_OM       :1;     //[14] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD14_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD15_OM       :1;     //[15] Refer to EXIC_PA0_OM.
X            volatile uint8_t  PD15_OM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD0_AM        :1;     //[16] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD0_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD1_AM        :1;     //[17] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD1_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD2_AM        :1;     //[18] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD2_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD3_AM        :1;     //[19] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD3_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD4_AM        :1;     //[20] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD4_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD5_AM        :1;     //[21] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD5_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD6_AM        :1;     //[22] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD6_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD7_AM        :1;     //[23] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD7_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD8_AM        :1;     //[24] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD8_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD9_AM        :1;     //[25] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD9_AM        :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD10_AM       :1;     //[26] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD10_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD11_AM       :1;     //[27] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD11_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD12_AM       :1;     //[28] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD12_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD13_AM       :1;     //[29] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD13_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD14_AM       :1;     //[30] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD14_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N            __IO uint8_t  PD15_AM       :1;     //[31] Refer to EXIC_PA0_AM.
X            volatile uint8_t  PD15_AM       :1;     
N                                        //0 = Disable (Mask)
N                                        //1 = Enable
N        }MBIT;
N    }PD_MSK;                            /*!< PD_MSK     ~ Offset[0x58]  EXIC  PD AOI Mask register */
N
N    __I uint32_t  RESERVED5;            /*!< RESERVED5  ~ Offset[0x5C]  Reserved */
X    volatile const uint32_t  RESERVED5;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID0           :8;     //[7..0] Interrupt source-0 identity.
X            volatile const  uint8_t  ID0           :8;     
N                                        //0x1 = WWDT
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID1           :8;     //[15..8] Interrupt source-1 identity.
X            volatile const  uint8_t  ID1           :8;     
N                                        //0x1 = IWDT
N                                        //0x2 = PW
N                                        //0x4 = Reserved
N                                        //0x8 = RTC
N                                        //0x10 = CSC
N                                        //0x20 = APB
N                                        //0x40 = MEM
N                                        //0x80 = EMB
N            __I  uint8_t  ID2           :8;     //[23..16] Interrupt source-2 identity.
X            volatile const  uint8_t  ID2           :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID3           :8;     //[31..24] Interrupt source-3 identity.
X            volatile const  uint8_t  ID3           :8;     
N                                        //0x1 = EXINT0
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC0;                              /*!< SRC0       ~ Offset[0x60]  EXIC Interrupt source identity register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID4           :8;     //[7..0] Interrupt source-4 identity.
X            volatile const  uint8_t  ID4           :8;     
N                                        //0x1 = EXINT1
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID5           :8;     //[15..8] Interrupt source-5 identity.
X            volatile const  uint8_t  ID5           :8;     
N                                        //0x1 = EXINT2
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID6           :8;     //[23..16] Interrupt source-6 identity.
X            volatile const  uint8_t  ID6           :8;     
N                                        //0x1 = EXINT3
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID7           :8;     //[31..24] Interrupt source-7 identity.
X            volatile const  uint8_t  ID7           :8;     
N                                        //0x1 = CMP
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC1;                              /*!< SRC1       ~ Offset[0x64]  EXIC interrupt source identity register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID8           :8;     //[7..0] Interrupt source-8 identity.
X            volatile const  uint8_t  ID8           :8;     
N                                        //0x1 = DMA
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID9           :8;     //[15..8] Interrupt source-9 identity.
X            volatile const  uint8_t  ID9           :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID10          :8;     //[23..16] Interrupt source-10 identity.
X            volatile const  uint8_t  ID10          :8;     
N                                        //0x1 = ADC
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID11          :8;     //[31..24] Interrupt source-11 identity.
X            volatile const  uint8_t  ID11          :8;     
N                                        //0x1 = DAC
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC2;                              /*!< SRC2       ~ Offset[0x68]  EXIC interrupt source identity register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID12          :8;     //[7..0] Interrupt source-12 identity.
X            volatile const  uint8_t  ID12          :8;     
N                                        //0x1 = TM00
N                                        //0x2 = TM01
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID13          :8;     //[15..8] Interrupt source-13 identity.
X            volatile const  uint8_t  ID13          :8;     
N                                        //0x1 = TM10
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID14          :8;     //[23..16] Interrupt source-14 identity.
X            volatile const  uint8_t  ID14          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = TM16
N                                        //0x8 = Reserved
N            __I  uint8_t  ID15          :8;     //[31..24] Interrupt source-15 identity.
X            volatile const  uint8_t  ID15          :8;     
N                                        //0x1 = TM20
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC3;                              /*!< SRC3       ~ Offset[0x6C]  EXIC interrupt source identity register 3 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID16          :8;     //[7..0] Interrupt source-16 identity.
X            volatile const  uint8_t  ID16          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = TM26
N                                        //0x8 = Reserved
N            __I  uint8_t  ID17          :8;     //[15..8] Interrupt source-17 identity.
X            volatile const  uint8_t  ID17          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = TM36
N                                        //0x8 = Reserved
N            __I  uint8_t  ID18          :8;     //[23..16] Interrupt source-18 identity.
X            volatile const  uint8_t  ID18          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID19          :8;     //[31..24] Interrupt source-19 identity.
X            volatile const  uint8_t  ID19          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC4;                              /*!< SRC4       ~ Offset[0x70]  EXIC interrupt source identity register 4 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID20          :8;     //[7..0] Interrupt source-20 identity.
X            volatile const  uint8_t  ID20          :8;     
N                                        //0x1 = URT0
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID21          :8;     //[15..8] Interrupt source-21 identity.
X            volatile const  uint8_t  ID21          :8;     
N                                        //0x1 = URT1
N                                        //0x2 = URT2
N                                        //0x4 = URT3
N                                        //0x8 = Reserved
N            __I  uint8_t  ID22          :8;     //[23..16] Interrupt source-22 identity.
X            volatile const  uint8_t  ID22          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID23          :8;     //[31..24] Interrupt source-23 identity.
X            volatile const  uint8_t  ID23          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC5;                              /*!< SRC5       ~ Offset[0x74]  EXIC interrupt source identity register 5 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID24          :8;     //[7..0] Interrupt source-24 identity.
X            volatile const  uint8_t  ID24          :8;     
N                                        //0x1 = SPI0
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID25          :8;     //[15..8] Interrupt source-25 identity.
X            volatile const  uint8_t  ID25          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID26          :8;     //[23..16] Interrupt source-26 identity.
X            volatile const  uint8_t  ID26          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID27          :8;     //[31..24] Interrupt source-27 identity.
X            volatile const  uint8_t  ID27          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC6;                              /*!< SRC6       ~ Offset[0x78]  EXIC interrupt source identity register 6 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  ID28          :8;     //[7..0] Interrupt source-28 identity.
X            volatile const  uint8_t  ID28          :8;     
N                                        //0x1 = I2C0
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID29          :8;     //[15..8] Interrupt source-29 identity.
X            volatile const  uint8_t  ID29          :8;     
N                                        //0x1 = I2C1
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID30          :8;     //[23..16] Interrupt source-30 identity.
X            volatile const  uint8_t  ID30          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N            __I  uint8_t  ID31          :8;     //[31..24] Interrupt source-31 identity.
X            volatile const  uint8_t  ID31          :8;     
N                                        //0x1 = Reserved
N                                        //0x2 = Reserved
N                                        //0x4 = Reserved
N                                        //0x8 = Reserved
N        }MBIT;
N    }SRC7;                              /*!< SRC7       ~ Offset[0x7C]  EXIC interrupt source identity register 7 */
N
N} EXIC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        EXIC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define EXIC_Base                       ((uint32_t)0x50000000)              /*!< External Interrupt Controller */
N#define EXIC                            ((EXIC_Struct*) EXIC_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        EXIC  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        EXIC_STA  [register's definitions]
N *              Offset[0x00]  EXIC interrupt status register (0x50000000)
N ******************************************************************************
N */
N///@{
N#define EXIC_STA_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_STA */
N#define EXIC_STA_PD_AF_mask_w                       ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PD_AF_mask_h0                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PD_AF_mask_b1                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PD_AF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PD_AF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PD_AF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PD_AF_happened_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PD_AF_happened_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PD_AF_happened_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PD_OF_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PD_OF_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PD_OF_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PD_OF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PD_OF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PD_OF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PD_OF_happened_w                   ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PD_OF_happened_h0                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PD_OF_happened_b1                  ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PC_AF_mask_w                       ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PC_AF_mask_h0                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PC_AF_mask_b1                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PC_AF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PC_AF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PC_AF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PC_AF_happened_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PC_AF_happened_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PC_AF_happened_b1                  ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PC_OF_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PC_OF_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PC_OF_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PC_OF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PC_OF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PC_OF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PC_OF_happened_w                   ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PC_OF_happened_h0                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PC_OF_happened_b1                  ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PB_AF_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PB_AF_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PB_AF_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PB_AF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PB_AF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PB_AF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PB_AF_happened_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PB_AF_happened_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PB_AF_happened_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PB_OF_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PB_OF_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PB_OF_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PB_OF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PB_OF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PB_OF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PB_OF_happened_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PB_OF_happened_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PB_OF_happened_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PA_AF_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PA_AF_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PA_AF_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PA_AF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PA_AF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PA_AF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PA_AF_happened_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PA_AF_happened_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PA_AF_happened_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_STA_PA_OF_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_STA_PA_OF_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_STA_PA_OF_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_STA_PA_OF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_STA_PA_OF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_STA_PA_OF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_STA_PA_OF_happened_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_STA_PA_OF_happened_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_STA_PA_OF_happened_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_INT  [register's definitions]
N *              Offset[0x04]  EXIC interrupt enable register (0x50000004)
N ******************************************************************************
N */
N///@{
N#define EXIC_INT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_INT */
N#define EXIC_INT_PD_IEA_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_INT_PD_IEA_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_INT_PD_IEA_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_INT_PD_IEA_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_INT_PD_IEA_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_INT_PD_IEA_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_INT_PD_IEA_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_INT_PD_IEA_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_INT_PD_IEA_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_INT_PC_IEA_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_INT_PC_IEA_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_INT_PC_IEA_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_INT_PC_IEA_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_INT_PC_IEA_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_INT_PC_IEA_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_INT_PC_IEA_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_INT_PC_IEA_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_INT_PC_IEA_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_INT_PB_IEA_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_INT_PB_IEA_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_INT_PB_IEA_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_INT_PB_IEA_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_INT_PB_IEA_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_INT_PB_IEA_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_INT_PB_IEA_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_INT_PB_IEA_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_INT_PB_IEA_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_INT_PA_IEA_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_INT_PA_IEA_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_INT_PA_IEA_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_INT_PA_IEA_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_INT_PA_IEA_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_INT_PA_IEA_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_INT_PA_IEA_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_INT_PA_IEA_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_INT_PA_IEA_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_CR0  [register's definitions]
N *              Offset[0x10]  EXIC control register 0 (0x50000010)
N ******************************************************************************
N */
N///@{
N#define EXIC_CR0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_CR0 */
N#define EXIC_CR0_PD_AINV_mask_w                     ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_PD_AINV_mask_h1                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_PD_AINV_mask_b3                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_PD_AINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_PD_AINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_PD_AINV_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_PD_AINV_enable_w                   ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_PD_AINV_enable_h1                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_PD_AINV_enable_b3                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_CR0_PC_AINV_mask_w                     ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_PC_AINV_mask_h1                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_PC_AINV_mask_b3                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_PC_AINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_PC_AINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_PC_AINV_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_PC_AINV_enable_w                   ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_PC_AINV_enable_h1                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_PC_AINV_enable_b3                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_CR0_PB_AINV_mask_w                     ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_PB_AINV_mask_h1                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_PB_AINV_mask_b3                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_PB_AINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_PB_AINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_PB_AINV_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_PB_AINV_enable_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_PB_AINV_enable_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_PB_AINV_enable_b3                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_CR0_PA_AINV_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_PA_AINV_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_PA_AINV_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_PA_AINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_PA_AINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_PA_AINV_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_PA_AINV_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_PA_AINV_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_PA_AINV_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_CR0_EM_RXEV_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_EM_RXEV_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_EM_RXEV_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_EM_RXEV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_EM_RXEV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_EM_RXEV_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_EM_RXEV_enable_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_EM_RXEV_enable_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_EM_RXEV_enable_b1                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_CR0_EM_NMI_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_EM_NMI_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_EM_NMI_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_EM_NMI_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_EM_NMI_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_EM_NMI_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_EM_NMI_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_EM_NMI_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_EM_NMI_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_CR0_NMI_SW_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_CR0_NMI_SW_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_CR0_NMI_SW_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_CR0_NMI_SW_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_CR0_NMI_SW_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_CR0_NMI_SW_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_CR0_NMI_SW_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_CR0_NMI_SW_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_CR0_NMI_SW_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PA_PF  [register's definitions]
N *              Offset[0x20]  EXIC PA input interrupt pending flag register (0x50000020)
N ******************************************************************************
N */
N///@{
N#define EXIC_PA_PF_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PA_PF */
N#define EXIC_PA_PF_PA15_PF_mask_w                   ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA15_PF_mask_h0                  ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA15_PF_mask_b1                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA15_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA15_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA15_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA15_PF_happened_w               ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA15_PF_happened_h0              ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA15_PF_happened_b1              ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA14_PF_mask_w                   ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA14_PF_mask_h0                  ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA14_PF_mask_b1                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA14_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA14_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA14_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA14_PF_happened_w               ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA14_PF_happened_h0              ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA14_PF_happened_b1              ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA13_PF_mask_w                   ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA13_PF_mask_h0                  ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA13_PF_mask_b1                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA13_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA13_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA13_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA13_PF_happened_w               ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA13_PF_happened_h0              ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA13_PF_happened_b1              ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA12_PF_mask_w                   ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA12_PF_mask_h0                  ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA12_PF_mask_b1                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA12_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA12_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA12_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA12_PF_happened_w               ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA12_PF_happened_h0              ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA12_PF_happened_b1              ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA11_PF_mask_w                   ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA11_PF_mask_h0                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA11_PF_mask_b1                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA11_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA11_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA11_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA11_PF_happened_w               ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA11_PF_happened_h0              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA11_PF_happened_b1              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA10_PF_mask_w                   ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA10_PF_mask_h0                  ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA10_PF_mask_b1                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA10_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA10_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA10_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA10_PF_happened_w               ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA10_PF_happened_h0              ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA10_PF_happened_b1              ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA9_PF_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA9_PF_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA9_PF_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA9_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA9_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA9_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA9_PF_happened_w                ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA9_PF_happened_h0               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA9_PF_happened_b1               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA8_PF_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA8_PF_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA8_PF_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA8_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA8_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA8_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA8_PF_happened_w                ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA8_PF_happened_h0               ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA8_PF_happened_b1               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA7_PF_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA7_PF_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA7_PF_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA7_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA7_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA7_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA7_PF_happened_w                ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA7_PF_happened_h0               ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA7_PF_happened_b0               ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA6_PF_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA6_PF_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA6_PF_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA6_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA6_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA6_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA6_PF_happened_w                ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA6_PF_happened_h0               ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA6_PF_happened_b0               ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA5_PF_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA5_PF_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA5_PF_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA5_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA5_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA5_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA5_PF_happened_w                ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA5_PF_happened_h0               ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA5_PF_happened_b0               ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA4_PF_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA4_PF_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA4_PF_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA4_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA4_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA4_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA4_PF_happened_w                ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA4_PF_happened_h0               ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA4_PF_happened_b0               ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA3_PF_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA3_PF_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA3_PF_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA3_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA3_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA3_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA3_PF_happened_w                ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA3_PF_happened_h0               ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA3_PF_happened_b0               ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA2_PF_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA2_PF_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA2_PF_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA2_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA2_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA2_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA2_PF_happened_w                ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA2_PF_happened_h0               ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA2_PF_happened_b0               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA1_PF_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA1_PF_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA1_PF_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA1_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA1_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA1_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA1_PF_happened_w                ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA1_PF_happened_h0               ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA1_PF_happened_b0               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PA_PF_PA0_PF_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_PF_PA0_PF_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_PF_PA0_PF_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_PF_PA0_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PA_PF_PA0_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PA_PF_PA0_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PA_PF_PA0_PF_happened_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PA_PF_PA0_PF_happened_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PA_PF_PA0_PF_happened_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PA_TRGS  [register's definitions]
N *              Offset[0x24]  EXIC PA Pad input trigger select register (0x50000024)
N ******************************************************************************
N */
N///@{
N#define EXIC_PA_TRGS_default                        ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PA_TRGS */
N#define EXIC_PA_TRGS_PA15_TRGS_mask_w               ((uint32_t)0xC0000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA15_TRGS_mask_h1              ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA15_TRGS_mask_b3              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA15_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA15_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA15_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA15_TRGS_level_w              ((uint32_t)0x40000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA15_TRGS_level_h1             ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA15_TRGS_level_b3             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA15_TRGS_edge_w               ((uint32_t)0x80000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA15_TRGS_edge_h1              ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA15_TRGS_edge_b3              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA15_TRGS_dual_edge_w          ((uint32_t)0xC0000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA15_TRGS_dual_edge_h1         ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA15_TRGS_dual_edge_b3         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA14_TRGS_mask_w               ((uint32_t)0x30000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA14_TRGS_mask_h1              ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA14_TRGS_mask_b3              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA14_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA14_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA14_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA14_TRGS_level_w              ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA14_TRGS_level_h1             ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA14_TRGS_level_b3             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA14_TRGS_edge_w               ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA14_TRGS_edge_h1              ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA14_TRGS_edge_b3              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA14_TRGS_dual_edge_w          ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA14_TRGS_dual_edge_h1         ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA14_TRGS_dual_edge_b3         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA13_TRGS_mask_w               ((uint32_t)0x0C000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA13_TRGS_mask_h1              ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA13_TRGS_mask_b3              ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA13_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA13_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA13_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA13_TRGS_level_w              ((uint32_t)0x04000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA13_TRGS_level_h1             ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA13_TRGS_level_b3             ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA13_TRGS_edge_w               ((uint32_t)0x08000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA13_TRGS_edge_h1              ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA13_TRGS_edge_b3              ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA13_TRGS_dual_edge_w          ((uint32_t)0x0C000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA13_TRGS_dual_edge_h1         ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA13_TRGS_dual_edge_b3         ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA12_TRGS_mask_w               ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA12_TRGS_mask_h1              ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA12_TRGS_mask_b3              ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA12_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA12_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA12_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA12_TRGS_level_w              ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA12_TRGS_level_h1             ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA12_TRGS_level_b3             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA12_TRGS_edge_w               ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA12_TRGS_edge_h1              ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA12_TRGS_edge_b3              ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA12_TRGS_dual_edge_w          ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA12_TRGS_dual_edge_h1         ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA12_TRGS_dual_edge_b3         ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA11_TRGS_mask_w               ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA11_TRGS_mask_h1              ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA11_TRGS_mask_b2              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA11_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA11_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA11_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA11_TRGS_level_w              ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA11_TRGS_level_h1             ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA11_TRGS_level_b2             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA11_TRGS_edge_w               ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA11_TRGS_edge_h1              ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA11_TRGS_edge_b2              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA11_TRGS_dual_edge_w          ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA11_TRGS_dual_edge_h1         ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA11_TRGS_dual_edge_b2         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA10_TRGS_mask_w               ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA10_TRGS_mask_h1              ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA10_TRGS_mask_b2              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA10_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA10_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA10_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA10_TRGS_level_w              ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA10_TRGS_level_h1             ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA10_TRGS_level_b2             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA10_TRGS_edge_w               ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA10_TRGS_edge_h1              ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA10_TRGS_edge_b2              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA10_TRGS_dual_edge_w          ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA10_TRGS_dual_edge_h1         ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA10_TRGS_dual_edge_b2         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA9_TRGS_mask_w                ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA9_TRGS_mask_h1               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA9_TRGS_mask_b2               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA9_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA9_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA9_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA9_TRGS_level_w               ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA9_TRGS_level_h1              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA9_TRGS_level_b2              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA9_TRGS_edge_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA9_TRGS_edge_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA9_TRGS_edge_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA9_TRGS_dual_edge_w           ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA9_TRGS_dual_edge_h1          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA9_TRGS_dual_edge_b2          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA8_TRGS_mask_w                ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA8_TRGS_mask_h1               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA8_TRGS_mask_b2               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA8_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA8_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA8_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA8_TRGS_level_w               ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA8_TRGS_level_h1              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA8_TRGS_level_b2              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA8_TRGS_edge_w                ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA8_TRGS_edge_h1               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA8_TRGS_edge_b2               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA8_TRGS_dual_edge_w           ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA8_TRGS_dual_edge_h1          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA8_TRGS_dual_edge_b2          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA7_TRGS_mask_w                ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA7_TRGS_mask_h0               ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA7_TRGS_mask_b1               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA7_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA7_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA7_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA7_TRGS_level_w               ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA7_TRGS_level_h0              ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA7_TRGS_level_b1              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA7_TRGS_edge_w                ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA7_TRGS_edge_h0               ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA7_TRGS_edge_b1               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA7_TRGS_dual_edge_w           ((uint32_t)0x0000C000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA7_TRGS_dual_edge_h0          ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA7_TRGS_dual_edge_b1          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA6_TRGS_mask_w                ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA6_TRGS_mask_h0               ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA6_TRGS_mask_b1               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA6_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA6_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA6_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA6_TRGS_level_w               ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA6_TRGS_level_h0              ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA6_TRGS_level_b1              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA6_TRGS_edge_w                ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA6_TRGS_edge_h0               ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA6_TRGS_edge_b1               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA6_TRGS_dual_edge_w           ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA6_TRGS_dual_edge_h0          ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA6_TRGS_dual_edge_b1          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA5_TRGS_mask_w                ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA5_TRGS_mask_h0               ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA5_TRGS_mask_b1               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA5_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA5_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA5_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA5_TRGS_level_w               ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA5_TRGS_level_h0              ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA5_TRGS_level_b1              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA5_TRGS_edge_w                ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA5_TRGS_edge_h0               ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA5_TRGS_edge_b1               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA5_TRGS_dual_edge_w           ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA5_TRGS_dual_edge_h0          ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA5_TRGS_dual_edge_b1          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA4_TRGS_mask_w                ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA4_TRGS_mask_h0               ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA4_TRGS_mask_b1               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA4_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA4_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA4_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA4_TRGS_level_w               ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA4_TRGS_level_h0              ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA4_TRGS_level_b1              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA4_TRGS_edge_w                ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA4_TRGS_edge_h0               ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA4_TRGS_edge_b1               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA4_TRGS_dual_edge_w           ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA4_TRGS_dual_edge_h0          ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA4_TRGS_dual_edge_b1          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA3_TRGS_mask_w                ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA3_TRGS_mask_h0               ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA3_TRGS_mask_b0               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA3_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA3_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA3_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA3_TRGS_level_w               ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA3_TRGS_level_h0              ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA3_TRGS_level_b0              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA3_TRGS_edge_w                ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA3_TRGS_edge_h0               ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA3_TRGS_edge_b0               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA3_TRGS_dual_edge_w           ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA3_TRGS_dual_edge_h0          ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA3_TRGS_dual_edge_b0          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA2_TRGS_mask_w                ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA2_TRGS_mask_h0               ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA2_TRGS_mask_b0               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA2_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA2_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA2_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA2_TRGS_level_w               ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA2_TRGS_level_h0              ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA2_TRGS_level_b0              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA2_TRGS_edge_w                ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA2_TRGS_edge_h0               ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA2_TRGS_edge_b0               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA2_TRGS_dual_edge_w           ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA2_TRGS_dual_edge_h0          ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA2_TRGS_dual_edge_b0          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA1_TRGS_mask_w                ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA1_TRGS_mask_h0               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA1_TRGS_mask_b0               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA1_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA1_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA1_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA1_TRGS_level_w               ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA1_TRGS_level_h0              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA1_TRGS_level_b0              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA1_TRGS_edge_w                ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA1_TRGS_edge_h0               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA1_TRGS_edge_b0               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA1_TRGS_dual_edge_w           ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA1_TRGS_dual_edge_h0          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA1_TRGS_dual_edge_b0          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PA_TRGS_PA0_TRGS_mask_w                ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_TRGS_PA0_TRGS_mask_h0               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_TRGS_PA0_TRGS_mask_b0               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_TRGS_PA0_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PA_TRGS_PA0_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PA_TRGS_PA0_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PA_TRGS_PA0_TRGS_level_w               ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PA_TRGS_PA0_TRGS_level_h0              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PA_TRGS_PA0_TRGS_level_b0              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PA_TRGS_PA0_TRGS_edge_w                ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PA_TRGS_PA0_TRGS_edge_h0               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PA_TRGS_PA0_TRGS_edge_b0               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PA_TRGS_PA0_TRGS_dual_edge_w           ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PA_TRGS_PA0_TRGS_dual_edge_h0          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PA_TRGS_PA0_TRGS_dual_edge_b0          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PA_MSK  [register's definitions]
N *              Offset[0x28]  EXIC PA AOI Mask register (0x50000028)
N ******************************************************************************
N */
N///@{
N#define EXIC_PA_MSK_default                         ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PA_MSK */
N#define EXIC_PA_MSK_PA15_AM_mask_w                  ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA15_AM_mask_h1                 ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA15_AM_mask_b3                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA15_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA15_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA15_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA15_AM_enable_w                ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA15_AM_enable_h1               ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA15_AM_enable_b3               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA14_AM_mask_w                  ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA14_AM_mask_h1                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA14_AM_mask_b3                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA14_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA14_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA14_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA14_AM_enable_w                ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA14_AM_enable_h1               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA14_AM_enable_b3               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA13_AM_mask_w                  ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA13_AM_mask_h1                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA13_AM_mask_b3                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA13_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA13_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA13_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA13_AM_enable_w                ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA13_AM_enable_h1               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA13_AM_enable_b3               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA12_AM_mask_w                  ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA12_AM_mask_h1                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA12_AM_mask_b3                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA12_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA12_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA12_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA12_AM_enable_w                ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA12_AM_enable_h1               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA12_AM_enable_b3               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA11_AM_mask_w                  ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA11_AM_mask_h1                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA11_AM_mask_b3                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA11_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA11_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA11_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA11_AM_enable_w                ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA11_AM_enable_h1               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA11_AM_enable_b3               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA10_AM_mask_w                  ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA10_AM_mask_h1                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA10_AM_mask_b3                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA10_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA10_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA10_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA10_AM_enable_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA10_AM_enable_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA10_AM_enable_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA9_AM_mask_w                   ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA9_AM_mask_h1                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA9_AM_mask_b3                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA9_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA9_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA9_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA9_AM_enable_w                 ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA9_AM_enable_h1                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA9_AM_enable_b3                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA8_AM_mask_w                   ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA8_AM_mask_h1                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA8_AM_mask_b3                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA8_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA8_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA8_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA8_AM_enable_w                 ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA8_AM_enable_h1                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA8_AM_enable_b3                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA7_AM_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA7_AM_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA7_AM_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA7_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA7_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA7_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA7_AM_enable_w                 ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA7_AM_enable_h1                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA7_AM_enable_b2                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA6_AM_mask_w                   ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA6_AM_mask_h1                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA6_AM_mask_b2                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA6_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA6_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA6_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA6_AM_enable_w                 ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA6_AM_enable_h1                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA6_AM_enable_b2                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA5_AM_mask_w                   ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA5_AM_mask_h1                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA5_AM_mask_b2                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA5_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA5_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA5_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA5_AM_enable_w                 ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA5_AM_enable_h1                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA5_AM_enable_b2                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA4_AM_mask_w                   ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA4_AM_mask_h1                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA4_AM_mask_b2                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA4_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA4_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA4_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA4_AM_enable_w                 ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA4_AM_enable_h1                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA4_AM_enable_b2                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA3_AM_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA3_AM_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA3_AM_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA3_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA3_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA3_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA3_AM_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA3_AM_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA3_AM_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA2_AM_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA2_AM_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA2_AM_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA2_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA2_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA2_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA2_AM_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA2_AM_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA2_AM_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA1_AM_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA1_AM_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA1_AM_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA1_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA1_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA1_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA1_AM_enable_w                 ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA1_AM_enable_h1                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA1_AM_enable_b2                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA0_AM_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA0_AM_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA0_AM_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA0_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA0_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA0_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA0_AM_enable_w                 ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA0_AM_enable_h1                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA0_AM_enable_b2                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA15_OM_mask_w                  ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA15_OM_mask_h0                 ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA15_OM_mask_b1                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA15_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA15_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA15_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA15_OM_enable_w                ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA15_OM_enable_h0               ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA15_OM_enable_b1               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA14_OM_mask_w                  ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA14_OM_mask_h0                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA14_OM_mask_b1                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA14_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA14_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA14_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA14_OM_enable_w                ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA14_OM_enable_h0               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA14_OM_enable_b1               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA13_OM_mask_w                  ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA13_OM_mask_h0                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA13_OM_mask_b1                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA13_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA13_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA13_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA13_OM_enable_w                ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA13_OM_enable_h0               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA13_OM_enable_b1               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA12_OM_mask_w                  ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA12_OM_mask_h0                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA12_OM_mask_b1                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA12_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA12_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA12_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA12_OM_enable_w                ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA12_OM_enable_h0               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA12_OM_enable_b1               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA11_OM_mask_w                  ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA11_OM_mask_h0                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA11_OM_mask_b1                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA11_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA11_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA11_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA11_OM_enable_w                ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA11_OM_enable_h0               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA11_OM_enable_b1               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA10_OM_mask_w                  ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA10_OM_mask_h0                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA10_OM_mask_b1                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA10_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA10_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA10_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA10_OM_enable_w                ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA10_OM_enable_h0               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA10_OM_enable_b1               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA9_OM_mask_w                   ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA9_OM_mask_h0                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA9_OM_mask_b1                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA9_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA9_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA9_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA9_OM_enable_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA9_OM_enable_h0                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA9_OM_enable_b1                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA8_OM_mask_w                   ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA8_OM_mask_h0                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA8_OM_mask_b1                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA8_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA8_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA8_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA8_OM_enable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA8_OM_enable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA8_OM_enable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA7_OM_mask_w                   ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA7_OM_mask_h0                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA7_OM_mask_b0                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA7_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA7_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA7_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA7_OM_enable_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA7_OM_enable_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA7_OM_enable_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA6_OM_mask_w                   ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA6_OM_mask_h0                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA6_OM_mask_b0                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA6_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA6_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA6_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA6_OM_enable_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA6_OM_enable_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA6_OM_enable_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA5_OM_mask_w                   ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA5_OM_mask_h0                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA5_OM_mask_b0                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA5_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA5_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA5_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA5_OM_enable_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA5_OM_enable_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA5_OM_enable_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA4_OM_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA4_OM_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA4_OM_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA4_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA4_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA4_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA4_OM_enable_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA4_OM_enable_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA4_OM_enable_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA3_OM_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA3_OM_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA3_OM_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA3_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA3_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA3_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA3_OM_enable_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA3_OM_enable_h0                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA3_OM_enable_b0                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA2_OM_mask_w                   ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA2_OM_mask_h0                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA2_OM_mask_b0                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA2_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA2_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA2_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA2_OM_enable_w                 ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA2_OM_enable_h0                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA2_OM_enable_b0                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA1_OM_mask_w                   ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA1_OM_mask_h0                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA1_OM_mask_b0                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA1_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA1_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA1_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA1_OM_enable_w                 ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA1_OM_enable_h0                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA1_OM_enable_b0                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PA_MSK_PA0_OM_mask_w                   ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PA_MSK_PA0_OM_mask_h0                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PA_MSK_PA0_OM_mask_b0                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PA_MSK_PA0_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PA_MSK_PA0_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PA_MSK_PA0_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PA_MSK_PA0_OM_enable_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PA_MSK_PA0_OM_enable_h0                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PA_MSK_PA0_OM_enable_b0                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PB_PF  [register's definitions]
N *              Offset[0x30]  EXIC PB input interrupt pending flag register (0x50000030)
N ******************************************************************************
N */
N///@{
N#define EXIC_PB_PF_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PB_PF */
N#define EXIC_PB_PF_PB15_PF_mask_w                   ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB15_PF_mask_h0                  ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB15_PF_mask_b1                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB15_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB15_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB15_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB15_PF_happened_w               ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB15_PF_happened_h0              ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB15_PF_happened_b1              ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB14_PF_mask_w                   ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB14_PF_mask_h0                  ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB14_PF_mask_b1                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB14_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB14_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB14_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB14_PF_happened_w               ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB14_PF_happened_h0              ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB14_PF_happened_b1              ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB13_PF_mask_w                   ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB13_PF_mask_h0                  ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB13_PF_mask_b1                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB13_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB13_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB13_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB13_PF_happened_w               ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB13_PF_happened_h0              ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB13_PF_happened_b1              ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB12_PF_mask_w                   ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB12_PF_mask_h0                  ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB12_PF_mask_b1                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB12_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB12_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB12_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB12_PF_happened_w               ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB12_PF_happened_h0              ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB12_PF_happened_b1              ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB11_PF_mask_w                   ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB11_PF_mask_h0                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB11_PF_mask_b1                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB11_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB11_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB11_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB11_PF_happened_w               ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB11_PF_happened_h0              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB11_PF_happened_b1              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB10_PF_mask_w                   ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB10_PF_mask_h0                  ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB10_PF_mask_b1                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB10_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB10_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB10_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB10_PF_happened_w               ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB10_PF_happened_h0              ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB10_PF_happened_b1              ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB9_PF_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB9_PF_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB9_PF_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB9_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB9_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB9_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB9_PF_happened_w                ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB9_PF_happened_h0               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB9_PF_happened_b1               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB8_PF_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB8_PF_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB8_PF_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB8_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB8_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB8_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB8_PF_happened_w                ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB8_PF_happened_h0               ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB8_PF_happened_b1               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB7_PF_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB7_PF_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB7_PF_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB7_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB7_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB7_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB7_PF_happened_w                ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB7_PF_happened_h0               ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB7_PF_happened_b0               ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB6_PF_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB6_PF_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB6_PF_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB6_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB6_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB6_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB6_PF_happened_w                ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB6_PF_happened_h0               ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB6_PF_happened_b0               ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB5_PF_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB5_PF_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB5_PF_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB5_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB5_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB5_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB5_PF_happened_w                ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB5_PF_happened_h0               ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB5_PF_happened_b0               ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB4_PF_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB4_PF_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB4_PF_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB4_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB4_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB4_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB4_PF_happened_w                ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB4_PF_happened_h0               ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB4_PF_happened_b0               ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB3_PF_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB3_PF_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB3_PF_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB3_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB3_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB3_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB3_PF_happened_w                ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB3_PF_happened_h0               ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB3_PF_happened_b0               ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB2_PF_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB2_PF_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB2_PF_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB2_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB2_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB2_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB2_PF_happened_w                ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB2_PF_happened_h0               ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB2_PF_happened_b0               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB1_PF_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB1_PF_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB1_PF_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB1_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB1_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB1_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB1_PF_happened_w                ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB1_PF_happened_h0               ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB1_PF_happened_b0               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PB_PF_PB0_PF_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_PF_PB0_PF_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_PF_PB0_PF_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_PF_PB0_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PB_PF_PB0_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PB_PF_PB0_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PB_PF_PB0_PF_happened_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PB_PF_PB0_PF_happened_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PB_PF_PB0_PF_happened_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PB_TRGS  [register's definitions]
N *              Offset[0x34]  EXIC PB Pad input trigger select register (0x50000034)
N ******************************************************************************
N */
N///@{
N#define EXIC_PB_TRGS_default                        ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PB_TRGS */
N#define EXIC_PB_TRGS_PB15_TRGS_mask_w               ((uint32_t)0xC0000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB15_TRGS_mask_h1              ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB15_TRGS_mask_b3              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB15_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB15_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB15_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB15_TRGS_level_w              ((uint32_t)0x40000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB15_TRGS_level_h1             ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB15_TRGS_level_b3             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB15_TRGS_edge_w               ((uint32_t)0x80000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB15_TRGS_edge_h1              ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB15_TRGS_edge_b3              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB15_TRGS_dual_edge_w          ((uint32_t)0xC0000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB15_TRGS_dual_edge_h1         ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB15_TRGS_dual_edge_b3         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB14_TRGS_mask_w               ((uint32_t)0x30000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB14_TRGS_mask_h1              ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB14_TRGS_mask_b3              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB14_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB14_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB14_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB14_TRGS_level_w              ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB14_TRGS_level_h1             ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB14_TRGS_level_b3             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB14_TRGS_edge_w               ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB14_TRGS_edge_h1              ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB14_TRGS_edge_b3              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB14_TRGS_dual_edge_w          ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB14_TRGS_dual_edge_h1         ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB14_TRGS_dual_edge_b3         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB13_TRGS_mask_w               ((uint32_t)0x0C000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB13_TRGS_mask_h1              ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB13_TRGS_mask_b3              ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB13_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB13_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB13_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB13_TRGS_level_w              ((uint32_t)0x04000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB13_TRGS_level_h1             ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB13_TRGS_level_b3             ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB13_TRGS_edge_w               ((uint32_t)0x08000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB13_TRGS_edge_h1              ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB13_TRGS_edge_b3              ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB13_TRGS_dual_edge_w          ((uint32_t)0x0C000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB13_TRGS_dual_edge_h1         ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB13_TRGS_dual_edge_b3         ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB12_TRGS_mask_w               ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB12_TRGS_mask_h1              ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB12_TRGS_mask_b3              ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB12_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB12_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB12_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB12_TRGS_level_w              ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB12_TRGS_level_h1             ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB12_TRGS_level_b3             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB12_TRGS_edge_w               ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB12_TRGS_edge_h1              ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB12_TRGS_edge_b3              ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB12_TRGS_dual_edge_w          ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB12_TRGS_dual_edge_h1         ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB12_TRGS_dual_edge_b3         ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB11_TRGS_mask_w               ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB11_TRGS_mask_h1              ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB11_TRGS_mask_b2              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB11_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB11_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB11_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB11_TRGS_level_w              ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB11_TRGS_level_h1             ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB11_TRGS_level_b2             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB11_TRGS_edge_w               ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB11_TRGS_edge_h1              ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB11_TRGS_edge_b2              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB11_TRGS_dual_edge_w          ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB11_TRGS_dual_edge_h1         ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB11_TRGS_dual_edge_b2         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB10_TRGS_mask_w               ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB10_TRGS_mask_h1              ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB10_TRGS_mask_b2              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB10_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB10_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB10_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB10_TRGS_level_w              ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB10_TRGS_level_h1             ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB10_TRGS_level_b2             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB10_TRGS_edge_w               ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB10_TRGS_edge_h1              ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB10_TRGS_edge_b2              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB10_TRGS_dual_edge_w          ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB10_TRGS_dual_edge_h1         ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB10_TRGS_dual_edge_b2         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB9_TRGS_mask_w                ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB9_TRGS_mask_h1               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB9_TRGS_mask_b2               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB9_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB9_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB9_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB9_TRGS_level_w               ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB9_TRGS_level_h1              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB9_TRGS_level_b2              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB9_TRGS_edge_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB9_TRGS_edge_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB9_TRGS_edge_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB9_TRGS_dual_edge_w           ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB9_TRGS_dual_edge_h1          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB9_TRGS_dual_edge_b2          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB8_TRGS_mask_w                ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB8_TRGS_mask_h1               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB8_TRGS_mask_b2               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB8_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB8_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB8_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB8_TRGS_level_w               ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB8_TRGS_level_h1              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB8_TRGS_level_b2              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB8_TRGS_edge_w                ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB8_TRGS_edge_h1               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB8_TRGS_edge_b2               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB8_TRGS_dual_edge_w           ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB8_TRGS_dual_edge_h1          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB8_TRGS_dual_edge_b2          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB7_TRGS_mask_w                ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB7_TRGS_mask_h0               ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB7_TRGS_mask_b1               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB7_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB7_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB7_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB7_TRGS_level_w               ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB7_TRGS_level_h0              ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB7_TRGS_level_b1              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB7_TRGS_edge_w                ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB7_TRGS_edge_h0               ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB7_TRGS_edge_b1               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB7_TRGS_dual_edge_w           ((uint32_t)0x0000C000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB7_TRGS_dual_edge_h0          ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB7_TRGS_dual_edge_b1          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB6_TRGS_mask_w                ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB6_TRGS_mask_h0               ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB6_TRGS_mask_b1               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB6_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB6_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB6_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB6_TRGS_level_w               ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB6_TRGS_level_h0              ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB6_TRGS_level_b1              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB6_TRGS_edge_w                ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB6_TRGS_edge_h0               ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB6_TRGS_edge_b1               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB6_TRGS_dual_edge_w           ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB6_TRGS_dual_edge_h0          ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB6_TRGS_dual_edge_b1          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB5_TRGS_mask_w                ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB5_TRGS_mask_h0               ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB5_TRGS_mask_b1               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB5_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB5_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB5_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB5_TRGS_level_w               ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB5_TRGS_level_h0              ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB5_TRGS_level_b1              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB5_TRGS_edge_w                ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB5_TRGS_edge_h0               ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB5_TRGS_edge_b1               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB5_TRGS_dual_edge_w           ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB5_TRGS_dual_edge_h0          ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB5_TRGS_dual_edge_b1          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB4_TRGS_mask_w                ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB4_TRGS_mask_h0               ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB4_TRGS_mask_b1               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB4_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB4_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB4_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB4_TRGS_level_w               ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB4_TRGS_level_h0              ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB4_TRGS_level_b1              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB4_TRGS_edge_w                ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB4_TRGS_edge_h0               ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB4_TRGS_edge_b1               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB4_TRGS_dual_edge_w           ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB4_TRGS_dual_edge_h0          ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB4_TRGS_dual_edge_b1          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB3_TRGS_mask_w                ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB3_TRGS_mask_h0               ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB3_TRGS_mask_b0               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB3_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB3_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB3_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB3_TRGS_level_w               ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB3_TRGS_level_h0              ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB3_TRGS_level_b0              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB3_TRGS_edge_w                ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB3_TRGS_edge_h0               ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB3_TRGS_edge_b0               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB3_TRGS_dual_edge_w           ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB3_TRGS_dual_edge_h0          ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB3_TRGS_dual_edge_b0          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB2_TRGS_mask_w                ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB2_TRGS_mask_h0               ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB2_TRGS_mask_b0               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB2_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB2_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB2_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB2_TRGS_level_w               ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB2_TRGS_level_h0              ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB2_TRGS_level_b0              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB2_TRGS_edge_w                ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB2_TRGS_edge_h0               ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB2_TRGS_edge_b0               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB2_TRGS_dual_edge_w           ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB2_TRGS_dual_edge_h0          ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB2_TRGS_dual_edge_b0          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB1_TRGS_mask_w                ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB1_TRGS_mask_h0               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB1_TRGS_mask_b0               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB1_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB1_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB1_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB1_TRGS_level_w               ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB1_TRGS_level_h0              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB1_TRGS_level_b0              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB1_TRGS_edge_w                ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB1_TRGS_edge_h0               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB1_TRGS_edge_b0               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB1_TRGS_dual_edge_w           ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB1_TRGS_dual_edge_h0          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB1_TRGS_dual_edge_b0          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PB_TRGS_PB0_TRGS_mask_w                ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_TRGS_PB0_TRGS_mask_h0               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_TRGS_PB0_TRGS_mask_b0               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_TRGS_PB0_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PB_TRGS_PB0_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PB_TRGS_PB0_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PB_TRGS_PB0_TRGS_level_w               ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PB_TRGS_PB0_TRGS_level_h0              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PB_TRGS_PB0_TRGS_level_b0              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PB_TRGS_PB0_TRGS_edge_w                ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PB_TRGS_PB0_TRGS_edge_h0               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PB_TRGS_PB0_TRGS_edge_b0               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PB_TRGS_PB0_TRGS_dual_edge_w           ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PB_TRGS_PB0_TRGS_dual_edge_h0          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PB_TRGS_PB0_TRGS_dual_edge_b0          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PB_MSK  [register's definitions]
N *              Offset[0x38]  EXIC PB AOI Mask register (0x50000038)
N ******************************************************************************
N */
N///@{
N#define EXIC_PB_MSK_default                         ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PB_MSK */
N#define EXIC_PB_MSK_PB15_AM_mask_w                  ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB15_AM_mask_h1                 ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB15_AM_mask_b3                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB15_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB15_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB15_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB15_AM_enable_w                ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB15_AM_enable_h1               ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB15_AM_enable_b3               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB14_AM_mask_w                  ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB14_AM_mask_h1                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB14_AM_mask_b3                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB14_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB14_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB14_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB14_AM_enable_w                ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB14_AM_enable_h1               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB14_AM_enable_b3               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB13_AM_mask_w                  ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB13_AM_mask_h1                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB13_AM_mask_b3                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB13_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB13_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB13_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB13_AM_enable_w                ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB13_AM_enable_h1               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB13_AM_enable_b3               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB12_AM_mask_w                  ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB12_AM_mask_h1                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB12_AM_mask_b3                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB12_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB12_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB12_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB12_AM_enable_w                ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB12_AM_enable_h1               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB12_AM_enable_b3               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB11_AM_mask_w                  ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB11_AM_mask_h1                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB11_AM_mask_b3                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB11_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB11_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB11_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB11_AM_enable_w                ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB11_AM_enable_h1               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB11_AM_enable_b3               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB10_AM_mask_w                  ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB10_AM_mask_h1                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB10_AM_mask_b3                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB10_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB10_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB10_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB10_AM_enable_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB10_AM_enable_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB10_AM_enable_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB9_AM_mask_w                   ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB9_AM_mask_h1                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB9_AM_mask_b3                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB9_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB9_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB9_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB9_AM_enable_w                 ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB9_AM_enable_h1                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB9_AM_enable_b3                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB8_AM_mask_w                   ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB8_AM_mask_h1                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB8_AM_mask_b3                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB8_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB8_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB8_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB8_AM_enable_w                 ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB8_AM_enable_h1                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB8_AM_enable_b3                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB7_AM_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB7_AM_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB7_AM_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB7_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB7_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB7_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB7_AM_enable_w                 ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB7_AM_enable_h1                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB7_AM_enable_b2                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB6_AM_mask_w                   ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB6_AM_mask_h1                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB6_AM_mask_b2                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB6_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB6_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB6_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB6_AM_enable_w                 ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB6_AM_enable_h1                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB6_AM_enable_b2                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB5_AM_mask_w                   ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB5_AM_mask_h1                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB5_AM_mask_b2                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB5_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB5_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB5_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB5_AM_enable_w                 ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB5_AM_enable_h1                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB5_AM_enable_b2                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB4_AM_mask_w                   ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB4_AM_mask_h1                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB4_AM_mask_b2                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB4_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB4_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB4_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB4_AM_enable_w                 ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB4_AM_enable_h1                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB4_AM_enable_b2                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB3_AM_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB3_AM_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB3_AM_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB3_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB3_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB3_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB3_AM_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB3_AM_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB3_AM_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB2_AM_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB2_AM_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB2_AM_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB2_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB2_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB2_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB2_AM_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB2_AM_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB2_AM_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB1_AM_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB1_AM_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB1_AM_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB1_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB1_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB1_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB1_AM_enable_w                 ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB1_AM_enable_h1                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB1_AM_enable_b2                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB0_AM_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB0_AM_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB0_AM_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB0_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB0_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB0_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB0_AM_enable_w                 ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB0_AM_enable_h1                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB0_AM_enable_b2                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB15_OM_mask_w                  ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB15_OM_mask_h0                 ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB15_OM_mask_b1                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB15_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB15_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB15_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB15_OM_enable_w                ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB15_OM_enable_h0               ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB15_OM_enable_b1               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB14_OM_mask_w                  ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB14_OM_mask_h0                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB14_OM_mask_b1                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB14_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB14_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB14_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB14_OM_enable_w                ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB14_OM_enable_h0               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB14_OM_enable_b1               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB13_OM_mask_w                  ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB13_OM_mask_h0                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB13_OM_mask_b1                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB13_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB13_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB13_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB13_OM_enable_w                ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB13_OM_enable_h0               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB13_OM_enable_b1               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB12_OM_mask_w                  ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB12_OM_mask_h0                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB12_OM_mask_b1                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB12_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB12_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB12_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB12_OM_enable_w                ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB12_OM_enable_h0               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB12_OM_enable_b1               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB11_OM_mask_w                  ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB11_OM_mask_h0                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB11_OM_mask_b1                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB11_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB11_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB11_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB11_OM_enable_w                ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB11_OM_enable_h0               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB11_OM_enable_b1               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB10_OM_mask_w                  ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB10_OM_mask_h0                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB10_OM_mask_b1                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB10_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB10_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB10_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB10_OM_enable_w                ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB10_OM_enable_h0               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB10_OM_enable_b1               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB9_OM_mask_w                   ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB9_OM_mask_h0                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB9_OM_mask_b1                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB9_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB9_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB9_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB9_OM_enable_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB9_OM_enable_h0                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB9_OM_enable_b1                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB8_OM_mask_w                   ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB8_OM_mask_h0                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB8_OM_mask_b1                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB8_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB8_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB8_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB8_OM_enable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB8_OM_enable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB8_OM_enable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB7_OM_mask_w                   ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB7_OM_mask_h0                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB7_OM_mask_b0                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB7_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB7_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB7_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB7_OM_enable_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB7_OM_enable_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB7_OM_enable_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB6_OM_mask_w                   ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB6_OM_mask_h0                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB6_OM_mask_b0                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB6_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB6_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB6_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB6_OM_enable_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB6_OM_enable_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB6_OM_enable_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB5_OM_mask_w                   ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB5_OM_mask_h0                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB5_OM_mask_b0                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB5_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB5_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB5_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB5_OM_enable_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB5_OM_enable_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB5_OM_enable_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB4_OM_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB4_OM_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB4_OM_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB4_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB4_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB4_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB4_OM_enable_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB4_OM_enable_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB4_OM_enable_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB3_OM_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB3_OM_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB3_OM_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB3_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB3_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB3_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB3_OM_enable_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB3_OM_enable_h0                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB3_OM_enable_b0                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB2_OM_mask_w                   ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB2_OM_mask_h0                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB2_OM_mask_b0                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB2_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB2_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB2_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB2_OM_enable_w                 ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB2_OM_enable_h0                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB2_OM_enable_b0                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB1_OM_mask_w                   ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB1_OM_mask_h0                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB1_OM_mask_b0                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB1_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB1_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB1_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB1_OM_enable_w                 ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB1_OM_enable_h0                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB1_OM_enable_b0                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PB_MSK_PB0_OM_mask_w                   ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PB_MSK_PB0_OM_mask_h0                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PB_MSK_PB0_OM_mask_b0                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PB_MSK_PB0_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PB_MSK_PB0_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PB_MSK_PB0_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PB_MSK_PB0_OM_enable_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PB_MSK_PB0_OM_enable_h0                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PB_MSK_PB0_OM_enable_b0                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PC_PF  [register's definitions]
N *              Offset[0x40]  EXIC PC input interrupt pending flag register (0x50000040)
N ******************************************************************************
N */
N///@{
N#define EXIC_PC_PF_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PC_PF */
N#define EXIC_PC_PF_PC14_PF_mask_w                   ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC14_PF_mask_h0                  ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC14_PF_mask_b1                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC14_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC14_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC14_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC14_PF_happened_w               ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC14_PF_happened_h0              ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC14_PF_happened_b1              ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC13_PF_mask_w                   ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC13_PF_mask_h0                  ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC13_PF_mask_b1                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC13_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC13_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC13_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC13_PF_happened_w               ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC13_PF_happened_h0              ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC13_PF_happened_b1              ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC12_PF_mask_w                   ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC12_PF_mask_h0                  ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC12_PF_mask_b1                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC12_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC12_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC12_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC12_PF_happened_w               ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC12_PF_happened_h0              ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC12_PF_happened_b1              ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC11_PF_mask_w                   ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC11_PF_mask_h0                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC11_PF_mask_b1                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC11_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC11_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC11_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC11_PF_happened_w               ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC11_PF_happened_h0              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC11_PF_happened_b1              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC10_PF_mask_w                   ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC10_PF_mask_h0                  ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC10_PF_mask_b1                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC10_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC10_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC10_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC10_PF_happened_w               ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC10_PF_happened_h0              ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC10_PF_happened_b1              ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC9_PF_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC9_PF_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC9_PF_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC9_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC9_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC9_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC9_PF_happened_w                ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC9_PF_happened_h0               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC9_PF_happened_b1               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC8_PF_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC8_PF_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC8_PF_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC8_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC8_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC8_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC8_PF_happened_w                ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC8_PF_happened_h0               ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC8_PF_happened_b1               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC7_PF_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC7_PF_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC7_PF_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC7_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC7_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC7_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC7_PF_happened_w                ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC7_PF_happened_h0               ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC7_PF_happened_b0               ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC6_PF_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC6_PF_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC6_PF_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC6_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC6_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC6_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC6_PF_happened_w                ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC6_PF_happened_h0               ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC6_PF_happened_b0               ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC5_PF_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC5_PF_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC5_PF_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC5_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC5_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC5_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC5_PF_happened_w                ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC5_PF_happened_h0               ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC5_PF_happened_b0               ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC4_PF_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC4_PF_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC4_PF_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC4_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC4_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC4_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC4_PF_happened_w                ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC4_PF_happened_h0               ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC4_PF_happened_b0               ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC3_PF_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC3_PF_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC3_PF_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC3_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC3_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC3_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC3_PF_happened_w                ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC3_PF_happened_h0               ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC3_PF_happened_b0               ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC2_PF_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC2_PF_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC2_PF_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC2_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC2_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC2_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC2_PF_happened_w                ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC2_PF_happened_h0               ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC2_PF_happened_b0               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC1_PF_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC1_PF_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC1_PF_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC1_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC1_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC1_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC1_PF_happened_w                ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC1_PF_happened_h0               ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC1_PF_happened_b0               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PC_PF_PC0_PF_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_PF_PC0_PF_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_PF_PC0_PF_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_PF_PC0_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PC_PF_PC0_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PC_PF_PC0_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PC_PF_PC0_PF_happened_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PC_PF_PC0_PF_happened_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PC_PF_PC0_PF_happened_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PC_TRGS  [register's definitions]
N *              Offset[0x44]  EXIC PC Pad input trigger select register (0x50000044)
N ******************************************************************************
N */
N///@{
N#define EXIC_PC_TRGS_default                        ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PC_TRGS */
N#define EXIC_PC_TRGS_PC14_TRGS_mask_w               ((uint32_t)0x30000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC14_TRGS_mask_h1              ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC14_TRGS_mask_b3              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC14_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC14_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC14_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC14_TRGS_level_w              ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC14_TRGS_level_h1             ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC14_TRGS_level_b3             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC14_TRGS_edge_w               ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC14_TRGS_edge_h1              ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC14_TRGS_edge_b3              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC14_TRGS_dual_edge_w          ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC14_TRGS_dual_edge_h1         ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC14_TRGS_dual_edge_b3         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC13_TRGS_mask_w               ((uint32_t)0x0C000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC13_TRGS_mask_h1              ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC13_TRGS_mask_b3              ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC13_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC13_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC13_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC13_TRGS_level_w              ((uint32_t)0x04000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC13_TRGS_level_h1             ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC13_TRGS_level_b3             ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC13_TRGS_edge_w               ((uint32_t)0x08000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC13_TRGS_edge_h1              ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC13_TRGS_edge_b3              ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC13_TRGS_dual_edge_w          ((uint32_t)0x0C000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC13_TRGS_dual_edge_h1         ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC13_TRGS_dual_edge_b3         ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC12_TRGS_mask_w               ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC12_TRGS_mask_h1              ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC12_TRGS_mask_b3              ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC12_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC12_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC12_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC12_TRGS_level_w              ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC12_TRGS_level_h1             ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC12_TRGS_level_b3             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC12_TRGS_edge_w               ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC12_TRGS_edge_h1              ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC12_TRGS_edge_b3              ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC12_TRGS_dual_edge_w          ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC12_TRGS_dual_edge_h1         ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC12_TRGS_dual_edge_b3         ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC11_TRGS_mask_w               ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC11_TRGS_mask_h1              ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC11_TRGS_mask_b2              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC11_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC11_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC11_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC11_TRGS_level_w              ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC11_TRGS_level_h1             ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC11_TRGS_level_b2             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC11_TRGS_edge_w               ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC11_TRGS_edge_h1              ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC11_TRGS_edge_b2              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC11_TRGS_dual_edge_w          ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC11_TRGS_dual_edge_h1         ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC11_TRGS_dual_edge_b2         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC10_TRGS_mask_w               ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC10_TRGS_mask_h1              ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC10_TRGS_mask_b2              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC10_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC10_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC10_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC10_TRGS_level_w              ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC10_TRGS_level_h1             ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC10_TRGS_level_b2             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC10_TRGS_edge_w               ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC10_TRGS_edge_h1              ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC10_TRGS_edge_b2              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC10_TRGS_dual_edge_w          ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC10_TRGS_dual_edge_h1         ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC10_TRGS_dual_edge_b2         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC9_TRGS_mask_w                ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC9_TRGS_mask_h1               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC9_TRGS_mask_b2               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC9_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC9_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC9_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC9_TRGS_level_w               ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC9_TRGS_level_h1              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC9_TRGS_level_b2              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC9_TRGS_edge_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC9_TRGS_edge_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC9_TRGS_edge_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC9_TRGS_dual_edge_w           ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC9_TRGS_dual_edge_h1          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC9_TRGS_dual_edge_b2          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC8_TRGS_mask_w                ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC8_TRGS_mask_h1               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC8_TRGS_mask_b2               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC8_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC8_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC8_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC8_TRGS_level_w               ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC8_TRGS_level_h1              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC8_TRGS_level_b2              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC8_TRGS_edge_w                ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC8_TRGS_edge_h1               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC8_TRGS_edge_b2               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC8_TRGS_dual_edge_w           ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC8_TRGS_dual_edge_h1          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC8_TRGS_dual_edge_b2          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC7_TRGS_mask_w                ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC7_TRGS_mask_h0               ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC7_TRGS_mask_b1               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC7_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC7_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC7_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC7_TRGS_level_w               ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC7_TRGS_level_h0              ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC7_TRGS_level_b1              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC7_TRGS_edge_w                ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC7_TRGS_edge_h0               ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC7_TRGS_edge_b1               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC7_TRGS_dual_edge_w           ((uint32_t)0x0000C000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC7_TRGS_dual_edge_h0          ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC7_TRGS_dual_edge_b1          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC6_TRGS_mask_w                ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC6_TRGS_mask_h0               ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC6_TRGS_mask_b1               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC6_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC6_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC6_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC6_TRGS_level_w               ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC6_TRGS_level_h0              ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC6_TRGS_level_b1              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC6_TRGS_edge_w                ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC6_TRGS_edge_h0               ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC6_TRGS_edge_b1               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC6_TRGS_dual_edge_w           ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC6_TRGS_dual_edge_h0          ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC6_TRGS_dual_edge_b1          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC5_TRGS_mask_w                ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC5_TRGS_mask_h0               ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC5_TRGS_mask_b1               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC5_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC5_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC5_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC5_TRGS_level_w               ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC5_TRGS_level_h0              ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC5_TRGS_level_b1              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC5_TRGS_edge_w                ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC5_TRGS_edge_h0               ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC5_TRGS_edge_b1               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC5_TRGS_dual_edge_w           ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC5_TRGS_dual_edge_h0          ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC5_TRGS_dual_edge_b1          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC4_TRGS_mask_w                ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC4_TRGS_mask_h0               ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC4_TRGS_mask_b1               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC4_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC4_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC4_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC4_TRGS_level_w               ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC4_TRGS_level_h0              ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC4_TRGS_level_b1              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC4_TRGS_edge_w                ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC4_TRGS_edge_h0               ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC4_TRGS_edge_b1               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC4_TRGS_dual_edge_w           ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC4_TRGS_dual_edge_h0          ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC4_TRGS_dual_edge_b1          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC3_TRGS_mask_w                ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC3_TRGS_mask_h0               ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC3_TRGS_mask_b0               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC3_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC3_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC3_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC3_TRGS_level_w               ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC3_TRGS_level_h0              ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC3_TRGS_level_b0              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC3_TRGS_edge_w                ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC3_TRGS_edge_h0               ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC3_TRGS_edge_b0               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC3_TRGS_dual_edge_w           ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC3_TRGS_dual_edge_h0          ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC3_TRGS_dual_edge_b0          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC2_TRGS_mask_w                ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC2_TRGS_mask_h0               ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC2_TRGS_mask_b0               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC2_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC2_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC2_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC2_TRGS_level_w               ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC2_TRGS_level_h0              ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC2_TRGS_level_b0              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC2_TRGS_edge_w                ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC2_TRGS_edge_h0               ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC2_TRGS_edge_b0               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC2_TRGS_dual_edge_w           ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC2_TRGS_dual_edge_h0          ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC2_TRGS_dual_edge_b0          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC1_TRGS_mask_w                ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC1_TRGS_mask_h0               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC1_TRGS_mask_b0               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC1_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC1_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC1_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC1_TRGS_level_w               ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC1_TRGS_level_h0              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC1_TRGS_level_b0              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC1_TRGS_edge_w                ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC1_TRGS_edge_h0               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC1_TRGS_edge_b0               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC1_TRGS_dual_edge_w           ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC1_TRGS_dual_edge_h0          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC1_TRGS_dual_edge_b0          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PC_TRGS_PC0_TRGS_mask_w                ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_TRGS_PC0_TRGS_mask_h0               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_TRGS_PC0_TRGS_mask_b0               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_TRGS_PC0_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PC_TRGS_PC0_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PC_TRGS_PC0_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PC_TRGS_PC0_TRGS_level_w               ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PC_TRGS_PC0_TRGS_level_h0              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PC_TRGS_PC0_TRGS_level_b0              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PC_TRGS_PC0_TRGS_edge_w                ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PC_TRGS_PC0_TRGS_edge_h0               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PC_TRGS_PC0_TRGS_edge_b0               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PC_TRGS_PC0_TRGS_dual_edge_w           ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PC_TRGS_PC0_TRGS_dual_edge_h0          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PC_TRGS_PC0_TRGS_dual_edge_b0          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PC_MSK  [register's definitions]
N *              Offset[0x48]  EXIC  PC AOI Mask register (0x50000048)
N ******************************************************************************
N */
N///@{
N#define EXIC_PC_MSK_default                         ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PC_MSK */
N#define EXIC_PC_MSK_PC14_AM_mask_w                  ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC14_AM_mask_h1                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC14_AM_mask_b3                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC14_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC14_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC14_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC14_AM_enable_w                ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC14_AM_enable_h1               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC14_AM_enable_b3               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC13_AM_mask_w                  ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC13_AM_mask_h1                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC13_AM_mask_b3                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC13_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC13_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC13_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC13_AM_enable_w                ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC13_AM_enable_h1               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC13_AM_enable_b3               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC12_AM_mask_w                  ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC12_AM_mask_h1                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC12_AM_mask_b3                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC12_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC12_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC12_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC12_AM_enable_w                ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC12_AM_enable_h1               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC12_AM_enable_b3               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC11_AM_mask_w                  ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC11_AM_mask_h1                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC11_AM_mask_b3                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC11_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC11_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC11_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC11_AM_enable_w                ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC11_AM_enable_h1               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC11_AM_enable_b3               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC10_AM_mask_w                  ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC10_AM_mask_h1                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC10_AM_mask_b3                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC10_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC10_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC10_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC10_AM_enable_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC10_AM_enable_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC10_AM_enable_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC9_AM_mask_w                   ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC9_AM_mask_h1                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC9_AM_mask_b3                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC9_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC9_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC9_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC9_AM_enable_w                 ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC9_AM_enable_h1                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC9_AM_enable_b3                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC8_AM_mask_w                   ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC8_AM_mask_h1                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC8_AM_mask_b3                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC8_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC8_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC8_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC8_AM_enable_w                 ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC8_AM_enable_h1                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC8_AM_enable_b3                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC7_AM_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC7_AM_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC7_AM_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC7_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC7_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC7_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC7_AM_enable_w                 ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC7_AM_enable_h1                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC7_AM_enable_b2                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC6_AM_mask_w                   ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC6_AM_mask_h1                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC6_AM_mask_b2                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC6_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC6_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC6_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC6_AM_enable_w                 ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC6_AM_enable_h1                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC6_AM_enable_b2                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC5_AM_mask_w                   ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC5_AM_mask_h1                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC5_AM_mask_b2                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC5_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC5_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC5_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC5_AM_enable_w                 ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC5_AM_enable_h1                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC5_AM_enable_b2                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC4_AM_mask_w                   ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC4_AM_mask_h1                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC4_AM_mask_b2                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC4_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC4_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC4_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC4_AM_enable_w                 ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC4_AM_enable_h1                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC4_AM_enable_b2                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC3_AM_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC3_AM_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC3_AM_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC3_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC3_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC3_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC3_AM_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC3_AM_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC3_AM_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC2_AM_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC2_AM_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC2_AM_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC2_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC2_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC2_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC2_AM_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC2_AM_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC2_AM_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC1_AM_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC1_AM_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC1_AM_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC1_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC1_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC1_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC1_AM_enable_w                 ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC1_AM_enable_h1                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC1_AM_enable_b2                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC0_AM_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC0_AM_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC0_AM_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC0_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC0_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC0_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC0_AM_enable_w                 ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC0_AM_enable_h1                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC0_AM_enable_b2                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC14_OM_mask_w                  ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC14_OM_mask_h0                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC14_OM_mask_b1                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC14_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC14_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC14_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC14_OM_enable_w                ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC14_OM_enable_h0               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC14_OM_enable_b1               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC13_OM_mask_w                  ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC13_OM_mask_h0                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC13_OM_mask_b1                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC13_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC13_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC13_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC13_OM_enable_w                ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC13_OM_enable_h0               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC13_OM_enable_b1               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC12_OM_mask_w                  ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC12_OM_mask_h0                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC12_OM_mask_b1                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC12_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC12_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC12_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC12_OM_enable_w                ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC12_OM_enable_h0               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC12_OM_enable_b1               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC11_OM_mask_w                  ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC11_OM_mask_h0                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC11_OM_mask_b1                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC11_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC11_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC11_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC11_OM_enable_w                ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC11_OM_enable_h0               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC11_OM_enable_b1               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC10_OM_mask_w                  ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC10_OM_mask_h0                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC10_OM_mask_b1                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC10_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC10_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC10_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC10_OM_enable_w                ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC10_OM_enable_h0               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC10_OM_enable_b1               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC9_OM_mask_w                   ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC9_OM_mask_h0                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC9_OM_mask_b1                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC9_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC9_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC9_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC9_OM_enable_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC9_OM_enable_h0                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC9_OM_enable_b1                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC8_OM_mask_w                   ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC8_OM_mask_h0                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC8_OM_mask_b1                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC8_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC8_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC8_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC8_OM_enable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC8_OM_enable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC8_OM_enable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC7_OM_mask_w                   ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC7_OM_mask_h0                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC7_OM_mask_b0                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC7_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC7_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC7_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC7_OM_enable_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC7_OM_enable_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC7_OM_enable_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC6_OM_mask_w                   ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC6_OM_mask_h0                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC6_OM_mask_b0                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC6_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC6_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC6_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC6_OM_enable_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC6_OM_enable_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC6_OM_enable_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC5_OM_mask_w                   ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC5_OM_mask_h0                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC5_OM_mask_b0                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC5_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC5_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC5_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC5_OM_enable_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC5_OM_enable_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC5_OM_enable_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC4_OM_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC4_OM_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC4_OM_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC4_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC4_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC4_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC4_OM_enable_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC4_OM_enable_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC4_OM_enable_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC3_OM_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC3_OM_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC3_OM_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC3_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC3_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC3_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC3_OM_enable_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC3_OM_enable_h0                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC3_OM_enable_b0                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC2_OM_mask_w                   ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC2_OM_mask_h0                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC2_OM_mask_b0                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC2_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC2_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC2_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC2_OM_enable_w                 ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC2_OM_enable_h0                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC2_OM_enable_b0                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC1_OM_mask_w                   ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC1_OM_mask_h0                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC1_OM_mask_b0                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC1_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC1_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC1_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC1_OM_enable_w                 ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC1_OM_enable_h0                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC1_OM_enable_b0                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PC_MSK_PC0_OM_mask_w                   ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PC_MSK_PC0_OM_mask_h0                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PC_MSK_PC0_OM_mask_b0                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PC_MSK_PC0_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PC_MSK_PC0_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PC_MSK_PC0_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PC_MSK_PC0_OM_enable_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PC_MSK_PC0_OM_enable_h0                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PC_MSK_PC0_OM_enable_b0                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PD_PF  [register's definitions]
N *              Offset[0x50]  EXIC PD input interrupt pending flag register (0x50000050)
N ******************************************************************************
N */
N///@{
N#define EXIC_PD_PF_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PD_PF */
N#define EXIC_PD_PF_PD15_PF_mask_w                   ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD15_PF_mask_h0                  ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD15_PF_mask_b1                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD15_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD15_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD15_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD15_PF_happened_w               ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD15_PF_happened_h0              ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD15_PF_happened_b1              ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD14_PF_mask_w                   ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD14_PF_mask_h0                  ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD14_PF_mask_b1                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD14_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD14_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD14_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD14_PF_happened_w               ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD14_PF_happened_h0              ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD14_PF_happened_b1              ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD13_PF_mask_w                   ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD13_PF_mask_h0                  ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD13_PF_mask_b1                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD13_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD13_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD13_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD13_PF_happened_w               ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD13_PF_happened_h0              ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD13_PF_happened_b1              ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD12_PF_mask_w                   ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD12_PF_mask_h0                  ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD12_PF_mask_b1                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD12_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD12_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD12_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD12_PF_happened_w               ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD12_PF_happened_h0              ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD12_PF_happened_b1              ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD11_PF_mask_w                   ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD11_PF_mask_h0                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD11_PF_mask_b1                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD11_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD11_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD11_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD11_PF_happened_w               ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD11_PF_happened_h0              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD11_PF_happened_b1              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD10_PF_mask_w                   ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD10_PF_mask_h0                  ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD10_PF_mask_b1                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD10_PF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD10_PF_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD10_PF_normal_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD10_PF_happened_w               ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD10_PF_happened_h0              ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD10_PF_happened_b1              ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD9_PF_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD9_PF_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD9_PF_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD9_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD9_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD9_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD9_PF_happened_w                ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD9_PF_happened_h0               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD9_PF_happened_b1               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD8_PF_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD8_PF_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD8_PF_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD8_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD8_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD8_PF_normal_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD8_PF_happened_w                ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD8_PF_happened_h0               ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD8_PF_happened_b1               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD7_PF_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD7_PF_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD7_PF_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD7_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD7_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD7_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD7_PF_happened_w                ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD7_PF_happened_h0               ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD7_PF_happened_b0               ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD6_PF_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD6_PF_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD6_PF_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD6_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD6_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD6_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD6_PF_happened_w                ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD6_PF_happened_h0               ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD6_PF_happened_b0               ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD5_PF_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD5_PF_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD5_PF_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD5_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD5_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD5_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD5_PF_happened_w                ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD5_PF_happened_h0               ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD5_PF_happened_b0               ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD4_PF_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD4_PF_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD4_PF_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD4_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD4_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD4_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD4_PF_happened_w                ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD4_PF_happened_h0               ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD4_PF_happened_b0               ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD3_PF_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD3_PF_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD3_PF_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD3_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD3_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD3_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD3_PF_happened_w                ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD3_PF_happened_h0               ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD3_PF_happened_b0               ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD2_PF_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD2_PF_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD2_PF_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD2_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD2_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD2_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD2_PF_happened_w                ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD2_PF_happened_h0               ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD2_PF_happened_b0               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD1_PF_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD1_PF_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD1_PF_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD1_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD1_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD1_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD1_PF_happened_w                ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD1_PF_happened_h0               ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD1_PF_happened_b0               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EXIC_PD_PF_PD0_PF_mask_w                    ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_PF_PD0_PF_mask_h0                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_PF_PD0_PF_mask_b0                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_PF_PD0_PF_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EXIC_PD_PF_PD0_PF_normal_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EXIC_PD_PF_PD0_PF_normal_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EXIC_PD_PF_PD0_PF_happened_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define EXIC_PD_PF_PD0_PF_happened_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define EXIC_PD_PF_PD0_PF_happened_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PD_TRGS  [register's definitions]
N *              Offset[0x54]  EXIC PD Pad input trigger select register (0x50000054)
N ******************************************************************************
N */
N///@{
N#define EXIC_PD_TRGS_default                        ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PD_TRGS */
N#define EXIC_PD_TRGS_PD15_TRGS_mask_w               ((uint32_t)0xC0000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD15_TRGS_mask_h1              ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD15_TRGS_mask_b3              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD15_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD15_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD15_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD15_TRGS_level_w              ((uint32_t)0x40000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD15_TRGS_level_h1             ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD15_TRGS_level_b3             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD15_TRGS_edge_w               ((uint32_t)0x80000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD15_TRGS_edge_h1              ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD15_TRGS_edge_b3              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD15_TRGS_dual_edge_w          ((uint32_t)0xC0000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD15_TRGS_dual_edge_h1         ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD15_TRGS_dual_edge_b3         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD14_TRGS_mask_w               ((uint32_t)0x30000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD14_TRGS_mask_h1              ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD14_TRGS_mask_b3              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD14_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD14_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD14_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD14_TRGS_level_w              ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD14_TRGS_level_h1             ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD14_TRGS_level_b3             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD14_TRGS_edge_w               ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD14_TRGS_edge_h1              ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD14_TRGS_edge_b3              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD14_TRGS_dual_edge_w          ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD14_TRGS_dual_edge_h1         ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD14_TRGS_dual_edge_b3         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD13_TRGS_mask_w               ((uint32_t)0x0C000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD13_TRGS_mask_h1              ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD13_TRGS_mask_b3              ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD13_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD13_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD13_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD13_TRGS_level_w              ((uint32_t)0x04000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD13_TRGS_level_h1             ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD13_TRGS_level_b3             ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD13_TRGS_edge_w               ((uint32_t)0x08000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD13_TRGS_edge_h1              ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD13_TRGS_edge_b3              ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD13_TRGS_dual_edge_w          ((uint32_t)0x0C000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD13_TRGS_dual_edge_h1         ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD13_TRGS_dual_edge_b3         ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD12_TRGS_mask_w               ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD12_TRGS_mask_h1              ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD12_TRGS_mask_b3              ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD12_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD12_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD12_TRGS_no_b3                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD12_TRGS_level_w              ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD12_TRGS_level_h1             ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD12_TRGS_level_b3             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD12_TRGS_edge_w               ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD12_TRGS_edge_h1              ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD12_TRGS_edge_b3              ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD12_TRGS_dual_edge_w          ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD12_TRGS_dual_edge_h1         ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD12_TRGS_dual_edge_b3         ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD11_TRGS_mask_w               ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD11_TRGS_mask_h1              ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD11_TRGS_mask_b2              ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD11_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD11_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD11_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD11_TRGS_level_w              ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD11_TRGS_level_h1             ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD11_TRGS_level_b2             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD11_TRGS_edge_w               ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD11_TRGS_edge_h1              ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD11_TRGS_edge_b2              ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD11_TRGS_dual_edge_w          ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD11_TRGS_dual_edge_h1         ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD11_TRGS_dual_edge_b2         ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD10_TRGS_mask_w               ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD10_TRGS_mask_h1              ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD10_TRGS_mask_b2              ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD10_TRGS_no_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD10_TRGS_no_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD10_TRGS_no_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD10_TRGS_level_w              ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD10_TRGS_level_h1             ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD10_TRGS_level_b2             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD10_TRGS_edge_w               ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD10_TRGS_edge_h1              ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD10_TRGS_edge_b2              ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD10_TRGS_dual_edge_w          ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD10_TRGS_dual_edge_h1         ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD10_TRGS_dual_edge_b2         ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD9_TRGS_mask_w                ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD9_TRGS_mask_h1               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD9_TRGS_mask_b2               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD9_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD9_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD9_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD9_TRGS_level_w               ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD9_TRGS_level_h1              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD9_TRGS_level_b2              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD9_TRGS_edge_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD9_TRGS_edge_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD9_TRGS_edge_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD9_TRGS_dual_edge_w           ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD9_TRGS_dual_edge_h1          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD9_TRGS_dual_edge_b2          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD8_TRGS_mask_w                ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD8_TRGS_mask_h1               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD8_TRGS_mask_b2               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD8_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD8_TRGS_no_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD8_TRGS_no_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD8_TRGS_level_w               ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD8_TRGS_level_h1              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD8_TRGS_level_b2              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD8_TRGS_edge_w                ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD8_TRGS_edge_h1               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD8_TRGS_edge_b2               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD8_TRGS_dual_edge_w           ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD8_TRGS_dual_edge_h1          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD8_TRGS_dual_edge_b2          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD7_TRGS_mask_w                ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD7_TRGS_mask_h0               ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD7_TRGS_mask_b1               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD7_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD7_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD7_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD7_TRGS_level_w               ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD7_TRGS_level_h0              ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD7_TRGS_level_b1              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD7_TRGS_edge_w                ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD7_TRGS_edge_h0               ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD7_TRGS_edge_b1               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD7_TRGS_dual_edge_w           ((uint32_t)0x0000C000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD7_TRGS_dual_edge_h0          ((uint16_t)0xC000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD7_TRGS_dual_edge_b1          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD6_TRGS_mask_w                ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD6_TRGS_mask_h0               ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD6_TRGS_mask_b1               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD6_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD6_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD6_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD6_TRGS_level_w               ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD6_TRGS_level_h0              ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD6_TRGS_level_b1              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD6_TRGS_edge_w                ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD6_TRGS_edge_h0               ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD6_TRGS_edge_b1               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD6_TRGS_dual_edge_w           ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD6_TRGS_dual_edge_h0          ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD6_TRGS_dual_edge_b1          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD5_TRGS_mask_w                ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD5_TRGS_mask_h0               ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD5_TRGS_mask_b1               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD5_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD5_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD5_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD5_TRGS_level_w               ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD5_TRGS_level_h0              ((uint16_t)0x0400)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD5_TRGS_level_b1              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD5_TRGS_edge_w                ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD5_TRGS_edge_h0               ((uint16_t)0x0800)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD5_TRGS_edge_b1               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD5_TRGS_dual_edge_w           ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD5_TRGS_dual_edge_h0          ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD5_TRGS_dual_edge_b1          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD4_TRGS_mask_w                ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD4_TRGS_mask_h0               ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD4_TRGS_mask_b1               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD4_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD4_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD4_TRGS_no_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD4_TRGS_level_w               ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD4_TRGS_level_h0              ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD4_TRGS_level_b1              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD4_TRGS_edge_w                ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD4_TRGS_edge_h0               ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD4_TRGS_edge_b1               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD4_TRGS_dual_edge_w           ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD4_TRGS_dual_edge_h0          ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD4_TRGS_dual_edge_b1          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD3_TRGS_mask_w                ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD3_TRGS_mask_h0               ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD3_TRGS_mask_b0               ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD3_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD3_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD3_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD3_TRGS_level_w               ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD3_TRGS_level_h0              ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD3_TRGS_level_b0              ((uint8_t )0x40)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD3_TRGS_edge_w                ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD3_TRGS_edge_h0               ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD3_TRGS_edge_b0               ((uint8_t )0x80)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD3_TRGS_dual_edge_w           ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD3_TRGS_dual_edge_h0          ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD3_TRGS_dual_edge_b0          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD2_TRGS_mask_w                ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD2_TRGS_mask_h0               ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD2_TRGS_mask_b0               ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD2_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD2_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD2_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD2_TRGS_level_w               ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD2_TRGS_level_h0              ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD2_TRGS_level_b0              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD2_TRGS_edge_w                ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD2_TRGS_edge_h0               ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD2_TRGS_edge_b0               ((uint8_t )0x20)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD2_TRGS_dual_edge_w           ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD2_TRGS_dual_edge_h0          ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD2_TRGS_dual_edge_b0          ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD1_TRGS_mask_w                ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD1_TRGS_mask_h0               ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD1_TRGS_mask_b0               ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD1_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD1_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD1_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD1_TRGS_level_w               ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD1_TRGS_level_h0              ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD1_TRGS_level_b0              ((uint8_t )0x04)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD1_TRGS_edge_w                ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD1_TRGS_edge_h0               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD1_TRGS_edge_b0               ((uint8_t )0x08)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD1_TRGS_dual_edge_w           ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD1_TRGS_dual_edge_h0          ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD1_TRGS_dual_edge_b0          ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define EXIC_PD_TRGS_PD0_TRGS_mask_w                ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_TRGS_PD0_TRGS_mask_h0               ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_TRGS_PD0_TRGS_mask_b0               ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_TRGS_PD0_TRGS_no_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EXIC_PD_TRGS_PD0_TRGS_no_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EXIC_PD_TRGS_PD0_TRGS_no_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EXIC_PD_TRGS_PD0_TRGS_level_w               ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Level of 32bit */
N#define EXIC_PD_TRGS_PD0_TRGS_level_h0              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Level of 16bit */
N#define EXIC_PD_TRGS_PD0_TRGS_level_b0              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Level of 8bit */
N#define EXIC_PD_TRGS_PD0_TRGS_edge_w                ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Edge of 32bit */
N#define EXIC_PD_TRGS_PD0_TRGS_edge_h0               ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Edge of 16bit */
N#define EXIC_PD_TRGS_PD0_TRGS_edge_b0               ((uint8_t )0x02)        /*!< Bit Value =(0x2):Edge of 8bit */
N#define EXIC_PD_TRGS_PD0_TRGS_dual_edge_w           ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define EXIC_PD_TRGS_PD0_TRGS_dual_edge_h0          ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define EXIC_PD_TRGS_PD0_TRGS_dual_edge_b0          ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_PD_MSK  [register's definitions]
N *              Offset[0x58]  EXIC  PD AOI Mask register (0x50000058)
N ******************************************************************************
N */
N///@{
N#define EXIC_PD_MSK_default                         ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_PD_MSK */
N#define EXIC_PD_MSK_PD15_AM_mask_w                  ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD15_AM_mask_h1                 ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD15_AM_mask_b3                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD15_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD15_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD15_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD15_AM_enable_w                ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD15_AM_enable_h1               ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD15_AM_enable_b3               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD14_AM_mask_w                  ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD14_AM_mask_h1                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD14_AM_mask_b3                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD14_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD14_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD14_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD14_AM_enable_w                ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD14_AM_enable_h1               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD14_AM_enable_b3               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD13_AM_mask_w                  ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD13_AM_mask_h1                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD13_AM_mask_b3                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD13_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD13_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD13_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD13_AM_enable_w                ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD13_AM_enable_h1               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD13_AM_enable_b3               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD12_AM_mask_w                  ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD12_AM_mask_h1                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD12_AM_mask_b3                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD12_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD12_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD12_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD12_AM_enable_w                ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD12_AM_enable_h1               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD12_AM_enable_b3               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD11_AM_mask_w                  ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD11_AM_mask_h1                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD11_AM_mask_b3                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD11_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD11_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD11_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD11_AM_enable_w                ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD11_AM_enable_h1               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD11_AM_enable_b3               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD10_AM_mask_w                  ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD10_AM_mask_h1                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD10_AM_mask_b3                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD10_AM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD10_AM_disable_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD10_AM_disable_b3              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD10_AM_enable_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD10_AM_enable_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD10_AM_enable_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD9_AM_mask_w                   ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD9_AM_mask_h1                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD9_AM_mask_b3                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD9_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD9_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD9_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD9_AM_enable_w                 ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD9_AM_enable_h1                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD9_AM_enable_b3                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD8_AM_mask_w                   ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD8_AM_mask_h1                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD8_AM_mask_b3                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD8_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD8_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD8_AM_disable_b3               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD8_AM_enable_w                 ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD8_AM_enable_h1                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD8_AM_enable_b3                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD7_AM_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD7_AM_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD7_AM_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD7_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD7_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD7_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD7_AM_enable_w                 ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD7_AM_enable_h1                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD7_AM_enable_b2                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD6_AM_mask_w                   ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD6_AM_mask_h1                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD6_AM_mask_b2                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD6_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD6_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD6_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD6_AM_enable_w                 ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD6_AM_enable_h1                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD6_AM_enable_b2                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD5_AM_mask_w                   ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD5_AM_mask_h1                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD5_AM_mask_b2                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD5_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD5_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD5_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD5_AM_enable_w                 ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD5_AM_enable_h1                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD5_AM_enable_b2                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD4_AM_mask_w                   ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD4_AM_mask_h1                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD4_AM_mask_b2                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD4_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD4_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD4_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD4_AM_enable_w                 ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD4_AM_enable_h1                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD4_AM_enable_b2                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD3_AM_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD3_AM_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD3_AM_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD3_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD3_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD3_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD3_AM_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD3_AM_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD3_AM_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD2_AM_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD2_AM_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD2_AM_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD2_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD2_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD2_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD2_AM_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD2_AM_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD2_AM_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD1_AM_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD1_AM_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD1_AM_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD1_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD1_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD1_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD1_AM_enable_w                 ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD1_AM_enable_h1                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD1_AM_enable_b2                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD0_AM_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD0_AM_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD0_AM_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD0_AM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD0_AM_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD0_AM_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD0_AM_enable_w                 ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD0_AM_enable_h1                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD0_AM_enable_b2                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD15_OM_mask_w                  ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD15_OM_mask_h0                 ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD15_OM_mask_b1                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD15_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD15_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD15_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD15_OM_enable_w                ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD15_OM_enable_h0               ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD15_OM_enable_b1               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD14_OM_mask_w                  ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD14_OM_mask_h0                 ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD14_OM_mask_b1                 ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD14_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD14_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD14_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD14_OM_enable_w                ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD14_OM_enable_h0               ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD14_OM_enable_b1               ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD13_OM_mask_w                  ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD13_OM_mask_h0                 ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD13_OM_mask_b1                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD13_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD13_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD13_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD13_OM_enable_w                ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD13_OM_enable_h0               ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD13_OM_enable_b1               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD12_OM_mask_w                  ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD12_OM_mask_h0                 ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD12_OM_mask_b1                 ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD12_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD12_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD12_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD12_OM_enable_w                ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD12_OM_enable_h0               ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD12_OM_enable_b1               ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD11_OM_mask_w                  ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD11_OM_mask_h0                 ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD11_OM_mask_b1                 ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD11_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD11_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD11_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD11_OM_enable_w                ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD11_OM_enable_h0               ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD11_OM_enable_b1               ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD10_OM_mask_w                  ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD10_OM_mask_h0                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD10_OM_mask_b1                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD10_OM_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD10_OM_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD10_OM_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD10_OM_enable_w                ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD10_OM_enable_h0               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD10_OM_enable_b1               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD9_OM_mask_w                   ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD9_OM_mask_h0                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD9_OM_mask_b1                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD9_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD9_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD9_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD9_OM_enable_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD9_OM_enable_h0                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD9_OM_enable_b1                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD8_OM_mask_w                   ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD8_OM_mask_h0                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD8_OM_mask_b1                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD8_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD8_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD8_OM_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD8_OM_enable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD8_OM_enable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD8_OM_enable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD7_OM_mask_w                   ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD7_OM_mask_h0                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD7_OM_mask_b0                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD7_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD7_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD7_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD7_OM_enable_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD7_OM_enable_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD7_OM_enable_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD6_OM_mask_w                   ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD6_OM_mask_h0                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD6_OM_mask_b0                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD6_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD6_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD6_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD6_OM_enable_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD6_OM_enable_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD6_OM_enable_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD5_OM_mask_w                   ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD5_OM_mask_h0                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD5_OM_mask_b0                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD5_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD5_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD5_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD5_OM_enable_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD5_OM_enable_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD5_OM_enable_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD4_OM_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD4_OM_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD4_OM_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD4_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD4_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD4_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD4_OM_enable_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD4_OM_enable_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD4_OM_enable_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD3_OM_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD3_OM_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD3_OM_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD3_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD3_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD3_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD3_OM_enable_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD3_OM_enable_h0                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD3_OM_enable_b0                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD2_OM_mask_w                   ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD2_OM_mask_h0                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD2_OM_mask_b0                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD2_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD2_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD2_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD2_OM_enable_w                 ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD2_OM_enable_h0                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD2_OM_enable_b0                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD1_OM_mask_w                   ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD1_OM_mask_h0                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD1_OM_mask_b0                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD1_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD1_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD1_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD1_OM_enable_w                 ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD1_OM_enable_h0                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD1_OM_enable_b0                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EXIC_PD_MSK_PD0_OM_mask_w                   ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EXIC_PD_MSK_PD0_OM_mask_h0                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EXIC_PD_MSK_PD0_OM_mask_b0                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EXIC_PD_MSK_PD0_OM_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EXIC_PD_MSK_PD0_OM_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EXIC_PD_MSK_PD0_OM_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EXIC_PD_MSK_PD0_OM_enable_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EXIC_PD_MSK_PD0_OM_enable_h0                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EXIC_PD_MSK_PD0_OM_enable_b0                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC0  [register's definitions]
N *              Offset[0x60]  EXIC Interrupt source identity register 0 (0x50000060)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC0_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC0 */
N#define EXIC_SRC0_ID3_mask_w                        ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC0_ID3_mask_h1                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC0_ID3_mask_b3                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC0_ID3_exint0_w                      ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):EXINT0 of 32bit */
N#define EXIC_SRC0_ID3_exint0_h1                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):EXINT0 of 16bit */
N#define EXIC_SRC0_ID3_exint0_b3                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):EXINT0 of 8bit */
N
N#define EXIC_SRC0_ID2_mask_w                        ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC0_ID2_mask_h1                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC0_ID2_mask_b2                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC0_ID1_mask_w                        ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC0_ID1_mask_h0                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC0_ID1_mask_b1                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC0_ID1_iwdt_w                        ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):IWDT of 32bit */
N#define EXIC_SRC0_ID1_iwdt_h0                       ((uint16_t)0x0100)      /*!< Bit Value =(0x1):IWDT of 16bit */
N#define EXIC_SRC0_ID1_iwdt_b1                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):IWDT of 8bit */
N#define EXIC_SRC0_ID1_pw_w                          ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):PW of 32bit */
N#define EXIC_SRC0_ID1_pw_h0                         ((uint16_t)0x0200)      /*!< Bit Value =(0x2):PW of 16bit */
N#define EXIC_SRC0_ID1_pw_b1                         ((uint8_t )0x02)        /*!< Bit Value =(0x2):PW of 8bit */
N#define EXIC_SRC0_ID1_rtc_w                         ((uint32_t)0x00000800)  /*!< Bit Value =(0x8):RTC of 32bit */
N#define EXIC_SRC0_ID1_rtc_h0                        ((uint16_t)0x0800)      /*!< Bit Value =(0x8):RTC of 16bit */
N#define EXIC_SRC0_ID1_rtc_b1                        ((uint8_t )0x08)        /*!< Bit Value =(0x8):RTC of 8bit */
N#define EXIC_SRC0_ID1_csc_w                         ((uint32_t)0x00001000)  /*!< Bit Value =(0x10):CSC of 32bit */
N#define EXIC_SRC0_ID1_csc_h0                        ((uint16_t)0x1000)      /*!< Bit Value =(0x10):CSC of 16bit */
N#define EXIC_SRC0_ID1_csc_b1                        ((uint8_t )0x10)        /*!< Bit Value =(0x10):CSC of 8bit */
N#define EXIC_SRC0_ID1_apb_w                         ((uint32_t)0x00002000)  /*!< Bit Value =(0x20):APB of 32bit */
N#define EXIC_SRC0_ID1_apb_h0                        ((uint16_t)0x2000)      /*!< Bit Value =(0x20):APB of 16bit */
N#define EXIC_SRC0_ID1_apb_b1                        ((uint8_t )0x20)        /*!< Bit Value =(0x20):APB of 8bit */
N#define EXIC_SRC0_ID1_mem_w                         ((uint32_t)0x00004000)  /*!< Bit Value =(0x40):MEM of 32bit */
N#define EXIC_SRC0_ID1_mem_h0                        ((uint16_t)0x4000)      /*!< Bit Value =(0x40):MEM of 16bit */
N#define EXIC_SRC0_ID1_mem_b1                        ((uint8_t )0x40)        /*!< Bit Value =(0x40):MEM of 8bit */
N#define EXIC_SRC0_ID1_emb_w                         ((uint32_t)0x00008000)  /*!< Bit Value =(0x80):EMB of 32bit */
N#define EXIC_SRC0_ID1_emb_h0                        ((uint16_t)0x8000)      /*!< Bit Value =(0x80):EMB of 16bit */
N#define EXIC_SRC0_ID1_emb_b1                        ((uint8_t )0x80)        /*!< Bit Value =(0x80):EMB of 8bit */
N
N#define EXIC_SRC0_ID0_mask_w                        ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC0_ID0_mask_h0                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC0_ID0_mask_b0                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC0_ID0_wwdt_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):WWDT of 32bit */
N#define EXIC_SRC0_ID0_wwdt_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(0x1):WWDT of 16bit */
N#define EXIC_SRC0_ID0_wwdt_b0                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):WWDT of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC1  [register's definitions]
N *              Offset[0x64]  EXIC interrupt source identity register 1 (0x50000064)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC1_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC1 */
N#define EXIC_SRC1_ID7_mask_w                        ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC1_ID7_mask_h1                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC1_ID7_mask_b3                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC1_ID7_cmp_w                         ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):CMP of 32bit */
N#define EXIC_SRC1_ID7_cmp_h1                        ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CMP of 16bit */
N#define EXIC_SRC1_ID7_cmp_b3                        ((uint8_t )0x01)        /*!< Bit Value =(0x1):CMP of 8bit */
N
N#define EXIC_SRC1_ID6_mask_w                        ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC1_ID6_mask_h1                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC1_ID6_mask_b2                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC1_ID6_exint3_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):EXINT3 of 32bit */
N#define EXIC_SRC1_ID6_exint3_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):EXINT3 of 16bit */
N#define EXIC_SRC1_ID6_exint3_b2                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):EXINT3 of 8bit */
N
N#define EXIC_SRC1_ID5_mask_w                        ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC1_ID5_mask_h0                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC1_ID5_mask_b1                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC1_ID5_exint2_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):EXINT2 of 32bit */
N#define EXIC_SRC1_ID5_exint2_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):EXINT2 of 16bit */
N#define EXIC_SRC1_ID5_exint2_b1                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):EXINT2 of 8bit */
N
N#define EXIC_SRC1_ID4_mask_w                        ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC1_ID4_mask_h0                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC1_ID4_mask_b0                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC1_ID4_exint1_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):EXINT1 of 32bit */
N#define EXIC_SRC1_ID4_exint1_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):EXINT1 of 16bit */
N#define EXIC_SRC1_ID4_exint1_b0                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):EXINT1 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC2  [register's definitions]
N *              Offset[0x68]  EXIC interrupt source identity register 2 (0x50000068)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC2_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC2 */
N#define EXIC_SRC2_ID11_mask_w                       ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC2_ID11_mask_h1                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC2_ID11_mask_b3                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC2_ID11_dac_w                        ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):DAC of 32bit */
N#define EXIC_SRC2_ID11_dac_h1                       ((uint16_t)0x0100)      /*!< Bit Value =(0x1):DAC of 16bit */
N#define EXIC_SRC2_ID11_dac_b3                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):DAC of 8bit */
N
N#define EXIC_SRC2_ID10_mask_w                       ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC2_ID10_mask_h1                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC2_ID10_mask_b2                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC2_ID10_adc_w                        ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):ADC of 32bit */
N#define EXIC_SRC2_ID10_adc_h1                       ((uint16_t)0x0001)      /*!< Bit Value =(0x1):ADC of 16bit */
N#define EXIC_SRC2_ID10_adc_b2                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):ADC of 8bit */
N
N#define EXIC_SRC2_ID9_mask_w                        ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC2_ID9_mask_h0                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC2_ID9_mask_b1                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC2_ID8_mask_w                        ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC2_ID8_mask_h0                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC2_ID8_mask_b0                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC2_ID8_dma_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):DMA of 32bit */
N#define EXIC_SRC2_ID8_dma_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(0x1):DMA of 16bit */
N#define EXIC_SRC2_ID8_dma_b0                        ((uint8_t )0x01)        /*!< Bit Value =(0x1):DMA of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC3  [register's definitions]
N *              Offset[0x6C]  EXIC interrupt source identity register 3 (0x5000006C)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC3_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC3 */
N#define EXIC_SRC3_ID15_mask_w                       ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC3_ID15_mask_h1                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC3_ID15_mask_b3                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC3_ID15_tm20_w                       ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TM20 of 32bit */
N#define EXIC_SRC3_ID15_tm20_h1                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TM20 of 16bit */
N#define EXIC_SRC3_ID15_tm20_b3                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):TM20 of 8bit */
N
N#define EXIC_SRC3_ID14_mask_w                       ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC3_ID14_mask_h1                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC3_ID14_mask_b2                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC3_ID14_tm16_w                       ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):TM16 of 32bit */
N#define EXIC_SRC3_ID14_tm16_h1                      ((uint16_t)0x0004)      /*!< Bit Value =(0x4):TM16 of 16bit */
N#define EXIC_SRC3_ID14_tm16_b2                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):TM16 of 8bit */
N
N#define EXIC_SRC3_ID13_mask_w                       ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC3_ID13_mask_h0                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC3_ID13_mask_b1                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC3_ID13_tm10_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):TM10 of 32bit */
N#define EXIC_SRC3_ID13_tm10_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TM10 of 16bit */
N#define EXIC_SRC3_ID13_tm10_b1                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):TM10 of 8bit */
N
N#define EXIC_SRC3_ID12_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC3_ID12_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC3_ID12_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC3_ID12_tm00_w                       ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):TM00 of 32bit */
N#define EXIC_SRC3_ID12_tm00_h0                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):TM00 of 16bit */
N#define EXIC_SRC3_ID12_tm00_b0                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):TM00 of 8bit */
N#define EXIC_SRC3_ID12_tm01_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):TM01 of 32bit */
N#define EXIC_SRC3_ID12_tm01_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):TM01 of 16bit */
N#define EXIC_SRC3_ID12_tm01_b0                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):TM01 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC4  [register's definitions]
N *              Offset[0x70]  EXIC interrupt source identity register 4 (0x50000070)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC4_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC4 */
N#define EXIC_SRC4_ID19_mask_w                       ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC4_ID19_mask_h1                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC4_ID19_mask_b3                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC4_ID18_mask_w                       ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC4_ID18_mask_h1                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC4_ID18_mask_b2                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC4_ID17_mask_w                       ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC4_ID17_mask_h0                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC4_ID17_mask_b1                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC4_ID17_tm36_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):TM36 of 32bit */
N#define EXIC_SRC4_ID17_tm36_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x4):TM36 of 16bit */
N#define EXIC_SRC4_ID17_tm36_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):TM36 of 8bit */
N
N#define EXIC_SRC4_ID16_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC4_ID16_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC4_ID16_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC4_ID16_tm26_w                       ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):TM26 of 32bit */
N#define EXIC_SRC4_ID16_tm26_h0                      ((uint16_t)0x0004)      /*!< Bit Value =(0x4):TM26 of 16bit */
N#define EXIC_SRC4_ID16_tm26_b0                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):TM26 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC5  [register's definitions]
N *              Offset[0x74]  EXIC interrupt source identity register 5 (0x50000074)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC5_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC5 */
N#define EXIC_SRC5_ID23_mask_w                       ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC5_ID23_mask_h1                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC5_ID23_mask_b3                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC5_ID22_mask_w                       ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC5_ID22_mask_h1                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC5_ID22_mask_b2                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC5_ID21_mask_w                       ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC5_ID21_mask_h0                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC5_ID21_mask_b1                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC5_ID21_urt1_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):URT1 of 32bit */
N#define EXIC_SRC5_ID21_urt1_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):URT1 of 16bit */
N#define EXIC_SRC5_ID21_urt1_b1                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):URT1 of 8bit */
N#define EXIC_SRC5_ID21_urt2_w                       ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):URT2 of 32bit */
N#define EXIC_SRC5_ID21_urt2_h0                      ((uint16_t)0x0200)      /*!< Bit Value =(0x2):URT2 of 16bit */
N#define EXIC_SRC5_ID21_urt2_b1                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):URT2 of 8bit */
N#define EXIC_SRC5_ID21_urt3_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):URT3 of 32bit */
N#define EXIC_SRC5_ID21_urt3_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x4):URT3 of 16bit */
N#define EXIC_SRC5_ID21_urt3_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):URT3 of 8bit */
N
N#define EXIC_SRC5_ID20_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC5_ID20_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC5_ID20_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC5_ID20_urt0_w                       ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):URT0 of 32bit */
N#define EXIC_SRC5_ID20_urt0_h0                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):URT0 of 16bit */
N#define EXIC_SRC5_ID20_urt0_b0                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):URT0 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC6  [register's definitions]
N *              Offset[0x78]  EXIC interrupt source identity register 6 (0x50000078)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC6_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC6 */
N#define EXIC_SRC6_ID27_mask_w                       ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC6_ID27_mask_h1                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC6_ID27_mask_b3                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC6_ID26_mask_w                       ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC6_ID26_mask_h1                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC6_ID26_mask_b2                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC6_ID25_mask_w                       ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC6_ID25_mask_h0                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC6_ID25_mask_b1                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC6_ID24_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC6_ID24_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC6_ID24_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC6_ID24_spi0_w                       ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):SPI0 of 32bit */
N#define EXIC_SRC6_ID24_spi0_h0                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):SPI0 of 16bit */
N#define EXIC_SRC6_ID24_spi0_b0                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):SPI0 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EXIC_SRC7  [register's definitions]
N *              Offset[0x7C]  EXIC interrupt source identity register 7 (0x5000007C)
N ******************************************************************************
N */
N///@{
N#define EXIC_SRC7_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EXIC_SRC7 */
N#define EXIC_SRC7_ID31_mask_w                       ((uint32_t)0xFF000000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC7_ID31_mask_h1                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC7_ID31_mask_b3                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC7_ID30_mask_w                       ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC7_ID30_mask_h1                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC7_ID30_mask_b2                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define EXIC_SRC7_ID29_mask_w                       ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC7_ID29_mask_h0                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC7_ID29_mask_b1                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC7_ID29_i2c1_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):I2C1 of 32bit */
N#define EXIC_SRC7_ID29_i2c1_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):I2C1 of 16bit */
N#define EXIC_SRC7_ID29_i2c1_b1                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):I2C1 of 8bit */
N
N#define EXIC_SRC7_ID28_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define EXIC_SRC7_ID28_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define EXIC_SRC7_ID28_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define EXIC_SRC7_ID28_i2c0_w                       ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):I2C0 of 32bit */
N#define EXIC_SRC7_ID28_i2c0_h0                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):I2C0 of 16bit */
N#define EXIC_SRC7_ID28_i2c0_b0                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):I2C0 of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_EXIC_H
N
N/*----------------------------------------------------------------------------*/
N/*                        End of file MG32x02z_EXIC.h                         */
N/*----------------------------------------------------------------------------*/
L 44 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_EXIC_Init.h" 2
N#include "MG32x02z__ExtraStruct.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z__ExtraStruct.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z__ExtraStruct.h
N *
N * @brief       MG32x02z Extra Structure Definition File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:42 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z__ExtraStruct_H
N#define _MG32x02z__ExtraStruct_H
N#define _MG32x02z__ExtraStruct_H_VER                3.9     /*!< File Version */
N
N/**
N ******************************************************************************
N *
N * @struct      DMAChannel_Struct
N *              DMAChannel  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] DMA channel operation enable.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  HOLD          :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  HOLD          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LOOP          :1;     //[2] DMA destination or peripheral transfer address auto increased enable.
X            volatile uint8_t  LOOP          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ADSEL         :1;     //[3] DMA address increased mode select
X            volatile uint8_t  ADSEL         :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  XMDS          :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  XMDS          :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  PLS           :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  PLS           :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  BSIZE         :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  BSIZE         :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  REQ           :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  REQ           :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CIE           :1;     //[17] DMA channel-x transfer complete interrupt enable.
X            volatile uint8_t  CIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  HIE           :1;     //[18] DMA channel-x transfer half interrupt enable.
X            volatile uint8_t  HIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EIE           :1;     //[19] DMA channel-x transfer error interrupt enable.
X            volatile uint8_t  EIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TC2F          :1;     //[25] DMA channel-x transfer complete flag
X            volatile uint8_t  TC2F          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  TH2F          :1;     //[26] DMA channel-x transfer half flag
X            volatile uint8_t  TH2F          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  ERR2F         :1;     //[27] DMA channel-x transfer error flag
X            volatile uint8_t  ERR2F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }A;                                 /*!< A          ~ Offset[0x20]  DMA channel-x control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SRC           :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  SRC           :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DET           :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  DET           :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SINC          :1;     //[16] DMA source or memory transfer address auto increased enable
X            volatile uint8_t  SINC          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DINC          :1;     //[17] DMA destination or peripheral transfer address auto increased enable
X            volatile uint8_t  DINC          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SSYNC         :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  SSYNC         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DSYNC         :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  DSYNC         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  XPIN          :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  XPIN          :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }B;                                 /*!< B          ~ Offset[0x24]  DMA channel-x control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t NUM           :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t NUM           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }NUM;                               /*!< NUM        ~ Offset[0x28]  DMA channel-x control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CNT           :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CNT           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x2C]  DMA channel-x control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t SSA           :32;    //[31..0] DMA source or memory transfer start address.
X            volatile uint32_t SSA           :32;    
N        }MBIT;
N    }SSA;                               /*!< SSA        ~ Offset[0x30]  DMA channel-x source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t SCA           :32;    //[31..0] DMA source or memory transfer current address
X            volatile const  uint32_t SCA           :32;    
N        }MBIT;
N    }SCA;                               /*!< SCA        ~ Offset[0x34]  DMA channel-x source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t DSA           :32;    //[31..0] DMA destination or peripheral transfer start address.
X            volatile uint32_t DSA           :32;    
N        }MBIT;
N    }DSA;                               /*!< DSA        ~ Offset[0x38]  DMA channel-x destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t DCA           :32;    //[31..0] DMA destination or peripheral transfer current address
X            volatile const  uint32_t DCA           :32;    
N        }MBIT;
N    }DCA;                               /*!< DCA        ~ Offset[0x3C]  DMA channel-x destination current address register */
N
N} DMAChannel_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        DMAChannel  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define DMAChannel0_Base                ((uint32_t)0x4BF00020)              /*!< Direct Memory Access Channel Control */
N#define DMAChannel1_Base                ((uint32_t)0x4BF00040)              /*!< Direct Memory Access Channel Control */
N#define DMAChannel2_Base                ((uint32_t)0x4BF00060)              /*!< Direct Memory Access Channel Control */
N#define DMAChannel0                     ((DMAChannel_Struct*) DMAChannel0_Base)
N#define DMAChannel1                     ((DMAChannel_Struct*) DMAChannel1_Base)
N#define DMAChannel2                     ((DMAChannel_Struct*) DMAChannel2_Base)
N///@}
N/**
N ******************************************************************************
N *
N * @struct      CMPAC_Struct
N *              CMPAC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] Analog comparator CMPx power-on enable bit
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RES           :1;     //[3] CMPx compare response time select.
X            volatile uint8_t  RES           :1;     
N                                        //0x0 = 200ns 
N                                        //0x1 = 10us (5~10us)
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  PMUX          :3;     //[10..8] CMPx Analog input positive channel selection.
X            volatile uint8_t  PMUX          :3;     
N                                        //0x0 =  IVREF
N                                        //0x1 = CMPx_I0
N                                        //0x2 = CMPx_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  NMUX          :3;     //[14..12] CMPx Analog input negative channel selection.
X            volatile uint8_t  NMUX          :3;     
N                                        //0x0 =  IVREF
N                                        //0x1 = CMPx_I0
N                                        //0x2 = CMPx_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  INV           :1;     //[16] CMPx analog comparator output signal polarity select.
X            volatile uint8_t  INV           :1;     
N                                        //0 = Positive
N                                        //1 = Negative
N            __IO uint8_t  PINV          :1;     //[17] CMPx output to pins' signal inverse enable.
X            volatile uint8_t  PINV          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  FSEL          :2;     //[19..18] CMPx analog comparator output signal select with synchronized filter
X            volatile uint8_t  FSEL          :2;     
N                                        //0x0 = Bypass
N                                        //0x1 = CMP_CK : filter with CMP_CLK 
N                                        //0x2 = TM00_TRGO : filter with TM00_TRGO
N                                        //0x3 = TM01_TRGO : filter with TM01_TRGO
N            __IO uint8_t  FDIV          :2;     //[21..20] CMPx analog comparator output synchronized filter divider.
X            volatile uint8_t  FDIV          :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CR;                                /*!< CR         ~ Offset[0x10]  CMP Analog comparator-x control register */
N
N} CMPAC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        CMPAC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define CMPAC0_Base                     ((uint32_t)0x5C000010)              /*!< Analog Comparator Control */
N#define CMPAC1_Base                     ((uint32_t)0x5C000014)              /*!< Analog Comparator Control */
N#define CMPAC2_Base                     ((uint32_t)0x5C000018)              /*!< Analog Comparator Control */
N#define CMPAC3_Base                     ((uint32_t)0x5C00001C)              /*!< Analog Comparator Control */
N#define CMPAC0                          ((CMPAC_Struct*) CMPAC0_Base)
N#define CMPAC1                          ((CMPAC_Struct*) CMPAC1_Base)
N#define CMPAC2                          ((CMPAC_Struct*) CMPAC2_Base)
N#define CMPAC3                          ((CMPAC_Struct*) CMPAC3_Base)
N///@}
N/**
N ******************************************************************************
N *
N * @struct      OBM_Struct
N *              OBM  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  MDS           :2;     //[1..0] OBMx break operation mode select
X            volatile uint8_t  MDS           :2;     
N                                        //0x0 = AND : AND signal of all break channels' output
N                                        //0x1 = CLR : STA bit is cleared by falling edge of OR signal
N                                        //0x2 = SET : STA bit is set by falling edge of OR signal
N                                        //0x3 = TOGGLE : STA bit is toggle by falling edge of OR signal
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  STA           :1;     //[4] OBMx break switching signal initial state
X            volatile uint8_t  STA           :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  LCK           :1;     //[5] OBMx break switching signal initial state write control
X            volatile uint8_t  LCK           :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BKN0          :1;     //[8] OBMx break source-0 signal inverse enable bit.
X            volatile uint8_t  BKN0          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  BKN1          :1;     //[9] OBMx break source-1 signal inverse enable bit.
X            volatile uint8_t  BKN1          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  BKN2          :1;     //[10] OBMx break source-2 signal inverse enable bit.
X            volatile uint8_t  BKN2          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  BKS0          :4;     //[19..16] OBMx break signal source channel-0 select.
X            volatile uint8_t  BKS0          :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __IO uint8_t  BKS1          :4;     //[23..20] OBMx break signal source channel-1 select.
X            volatile uint8_t  BKS1          :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __IO uint8_t  BKS2          :4;     //[27..24] OBMx break signal source channel-2 select.
X            volatile uint8_t  BKS2          :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }OBMx0;                             /*!< OBMx0      ~ Offset[0x20]  APB OBMx control register-0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  INV0          :1;     //[0] OBMx source channel-0 signal inverse enable bit.
X            volatile uint8_t  INV0          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  INV1          :1;     //[1] OBMx source channel-1 signal inverse enable bit.
X            volatile uint8_t  INV1          :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  POL           :1;     //[2] OBMx output signal inverse enable bit.
X            volatile uint8_t  POL           :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  FCKS          :2;     //[5..4] OBMx output deglitch filter clock source select
X            volatile uint8_t  FCKS          :2;     
N                                        //0x0 = Disable
N                                        //0x1 = APB : CLK_APB
N                                        //0x2 = APB_DIV8 : CLK_APB divide by 8
N                                        //0x3 = TM00_TRGO
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  MUX0          :4;     //[19..16] OBMx output source channel-0 signal select.
X            volatile uint8_t  MUX0          :4;     
N                                        //0x0 = SR0 : Output 0
N                                        //0x1 = SR1
N                                        //0x2 = SR2
N                                        //0x3 = SR3
N                                        //0x4 = SR4
N                                        //0x5 = SR5
N                                        //0x6 = SR6
N                                        //0x7 = SR7
N                                        //0x8 = SR8
N                                        //0x9 = SR9
N                                        //0xA = SR10
N                                        //0xB = SR11
N                                        //0xC = SR12
N                                        //0xD = SR13
N                                        //0xE = SR14
N                                        //0xF = SR15
N            __IO uint8_t  MUX1          :4;     //[23..20] OBMx output source channel-1 signal select.
X            volatile uint8_t  MUX1          :4;     
N                                        //0x0 = SR0 : Output 0
N                                        //0x1 = SR1
N                                        //0x2 = SR2
N                                        //0x3 = SR3
N                                        //0x4 = SR4
N                                        //0x5 = SR5
N                                        //0x6 = SR6
N                                        //0x7 = SR7
N                                        //0x8 = SR8
N                                        //0x9 = SR9
N                                        //0xA = SR10
N                                        //0xB = SR11
N                                        //0xC = SR12
N                                        //0xD = SR13
N                                        //0xE = SR14
N                                        //0xF = SR15
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OBMx1;                             /*!< OBMx1      ~ Offset[0x24]  APB OBMx control register-1 */
N
N} OBM_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        OBM  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define OBM0_Base                       ((uint32_t)0x5F000020)              /*!< APB OBM Control */
N#define OBM1_Base                       ((uint32_t)0x5F000028)              /*!< APB OBM Control */
N#define OBM0                            ((OBM_Struct*) OBM0_Base)
N#define OBM1                            ((OBM_Struct*) OBM1_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @struct      EXIC_PX_Struct
N *              EXIC_PX  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PIN0_PF        :1;     /*!< [0] EXIC pin input interrupt pending flag x for external input interrupt pin of PX*/ 
X            volatile uint8_t  PIN0_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN1_PF        :1;     /*!< [1] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN1_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN2_PF        :1;     /*!< [2] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN2_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN3_PF        :1;     /*!< [3] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN3_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN4_PF        :1;     /*!< [4] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN4_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN5_PF        :1;     /*!< [5] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN5_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN6_PF        :1;     /*!< [6] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN6_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN7_PF        :1;     /*!< [7] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN7_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN8_PF        :1;     /*!< [8] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN8_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN9_PF        :1;     /*!< [9] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN9_PF        :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN10_PF       :1;     /*!< [10] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN10_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN11_PF       :1;     /*!< [11] Refer to EXIC_PX0_PF. */ 
X            volatile uint8_t  PIN11_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN12_PF       :1;     /*!< [12] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN12_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN13_PF       :1;     /*!< [13] Refer to EXIC_PX0_PF.*/ 
X            volatile uint8_t  PIN13_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN14_PF       :1;     /*!< [14] Refer to EXIC_PX0_PF. */ 
X            volatile uint8_t  PIN14_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __IO uint8_t  PIN15_PF       :1;     /*!< [15] Refer to EXIC_PX0_PF. */ 
X            volatile uint8_t  PIN15_PF       :1;       
N                                                 /*!< 0 = Normal : No event occurred */ 
N                                                 /*!< 1 = Happened : Event happened */ 
N            __I  uint16_t               :16;     /*!< [31..16] */ 
X            volatile const  uint16_t               :16;       
N        }MBIT;
N    }PF;                                        /*!< PX_PF      ~ Offset[0x20]  EXIC PX input interrupt pending flag register */                           
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PIN0_TRGS      :2;     /*!<[1..0] External interrupt pin edge/level trigger event select */ 
X            volatile uint8_t  PIN0_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN1_TRGS      :2;     /*!<[3..2] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN1_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN2_TRGS      :2;     /*!<[5..4] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN2_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN3_TRGS      :2;     /*!<[7..6] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN3_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN4_TRGS      :2;     /*!<[9..8] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN4_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN5_TRGS      :2;     /*!<[11..10] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN5_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN6_TRGS      :2;     /*!<[13..12] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN6_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN7_TRGS      :2;     /*!<[15..14] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN7_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN8_TRGS      :2;     /*!<[17..16] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN8_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN9_TRGS      :2;     /*!<[19..18] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN9_TRGS      :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN10_TRGS     :2;     /*!<[21..20] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN10_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN11_TRGS     :2;     /*!<[23..22] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN11_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN12_TRGS     :2;     /*!<[25..24] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN12_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN13_TRGS     :2;     /*!<[27..26] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN13_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN14_TRGS     :2;     /*!<[29..28] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN14_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N            __IO uint8_t  PIN15_TRGS     :2;     /*!<[31..30] Refer to EXIC_PX0_TRGS. */ 
X            volatile uint8_t  PIN15_TRGS     :2;       
N                                                 /*!<0x0 = No : No updated flag */ 
N                                                 /*!<0x1 = Level */ 
N                                                 /*!<0x2 = Edge */ 
N                                                 /*!<0x3 = Dual-edge */ 
N        }MBIT;
N    }TRGS;                                       /*!< PX_TRGS    ~ Offset[0x24]  EXIC PX Pad input trigger select register */        
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PIN0_OM        :1;    /*!<[0] External interrupt pin of PX OR mask bit x */
X            volatile uint8_t  PIN0_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN1_OM        :1;    /*!<[1] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN1_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN2_OM        :1;    /*!<[2] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN2_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN3_OM        :1;    /*!<[3] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN3_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN4_OM        :1;    /*!<[4] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN4_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN5_OM        :1;    /*!<[5] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN5_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN6_OM        :1;    /*!<[6] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN6_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN7_OM        :1;    /*!<[7] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN7_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN8_OM        :1;    /*!<[8] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN8_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN9_OM        :1;    /*!<[9] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN9_OM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN10_OM       :1;    /*!<[10] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN10_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN11_OM       :1;    /*!<[11] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN11_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN12_OM       :1;    /*!<[12] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN12_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN13_OM       :1;    /*!<[13] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN13_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN14_OM       :1;    /*!<[14] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN14_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN15_OM       :1;    /*!<[15] Refer to EXIC_PX0_OM. */
X            volatile uint8_t  PIN15_OM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN0_AM        :1;    /*!<[16] External interrupt pin of PX AND mask bit x */
X            volatile uint8_t  PIN0_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable  */
N            __IO uint8_t  PIN1_AM        :1;    /*!<[17] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN1_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN2_AM        :1;    /*!<[18] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN2_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN3_AM        :1;    /*!<[19] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN3_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN4_AM        :1;    /*!<[20] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN4_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN5_AM        :1;    /*!<[21] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN5_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN6_AM        :1;    /*!<[22] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN6_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN7_AM        :1;    /*!<[23] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN7_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN8_AM        :1;    /*!<[24] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN8_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN9_AM        :1;    /*!<[25] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN9_AM        :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN10_AM       :1;    /*!<[26] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN10_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN11_AM       :1;    /*!<[27] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN11_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN12_AM       :1;    /*!<[28] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN12_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN13_AM       :1;    /*!<[29] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN13_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN14_AM       :1;    /*!<[30] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN14_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable */
N            __IO uint8_t  PIN15_AM       :1;    /*!<[31] Refer to EXIC_PX0_AM. */
X            volatile uint8_t  PIN15_AM       :1;     
N                                                /*!<0 = Disable (Mask) */
N                                                /*!<1 = Enable    */
N                                        
N        }MBIT;                                  
N    }MSK;                                       /*!< PX_MSK     ~ Offset[0x28]  EXIC PX AOI Mask register */
N}EXIC_PX_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        EXIC_PX  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define EXIC_PA_Base    ((uint32_t)(0x50000000+0x20))   /*!< EXIC PA Register Control Definitions base address*/
N#define EXIC_PB_Base    ((uint32_t)(0x50000000+0x30))   /*!< EXIC PB Register Control Definitions base address*/
N#define EXIC_PC_Base    ((uint32_t)(0x50000000+0x40))   /*!< EXIC PC Register Control Definitions bass address*/
N#define EXIC_PD_Base    ((uint32_t)(0x50000000+0x50))   /*!< EXIC PD Register Control Definitions bass address*/
N
N#define EXIC_PA         ((EXIC_PX_Struct*) EXIC_PA_Base)    /*!< EXIC PA Register Control Definitions */
N#define EXIC_PB         ((EXIC_PX_Struct*) EXIC_PB_Base)    /*!< EXIC PB Register Control Definitions */
N#define EXIC_PC         ((EXIC_PX_Struct*) EXIC_PC_Base)    /*!< EXIC PC Register Control Definitions */
N#define EXIC_PD         ((EXIC_PX_Struct*) EXIC_PD_Base)    /*!< EXIC PD Register Control Definitions */
N///@}
N
N
N#endif  // _MG32x02z__ExtraStruct_H
N
N/*----------------------------------------------------------------------------*/
N/*                    End of file MG32x02z__ExtraStruct.h                     */
N/*----------------------------------------------------------------------------*/
L 45 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_EXIC_Init.h" 2
N
N// <<< Use Configuration Wizard in Context Menu >>>
N
N
N/**
N ******************************************************************************
N *
N * @brief       EXIC Initial Configure - MG32F02A132 (LQFP80-Package)
N *
N ******************************************************************************
N */
N//<h> EXIC Initial Configure - MG32F02A132 (LQFP80-Package)
N
N//
N//=============================  PA EXIC Setting  ==============================
N//
N//<e0> Enable EXIC PA initial
N//<i> Port PA external interrupt configuration enable.
N    //<h> AND (KBI)
N    //<i> Port PA AND mask setting for External KBI input.
N        //<o1.16..31>AND Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PA AND mask bits. Each bit is used to disable(mask) or enable the related PAx input line.
N        //<q5> AND unmatch enable
N        //<i> External interrupt PA AND path signal inverse enable.
N    //</h>
N    //<h> OR (Interrupt)
N    //<i> Port PA OR mask setting for External interrupt input.
N        //<o1.0..15> OR  Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PA OR mask bits. Each bit is used to disable(mask) or enable the related PAx input line.
N    //</h>
N    //<h> Trigger mode
N    //<i> Port PA pin edge/level event trigger setting.
N        //<e2.1>  PA0
N        //<i> External interrupt PA0 pin edge/level event trigger enable.
N            //<o3.0..1> PIN0 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.3>  PA1
N        //<i> External interrupt PA1 pin edge/level event trigger enable.
N            //<o3.2..3> PIN1 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.5>  PA2
N        //<i> External interrupt PA2 pin edge/level event trigger enable.
N            //<o3.4..5> PIN2 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.7>  PA3
N        //<i> External interrupt PA3 pin edge/level event trigger enable.
N            //<o3.6..7> PIN3 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.9>  PA4
N        //<i> External interrupt PA4 pin edge/level event trigger enable.
N            //<o3.8..9> PIN4 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.11>  PA5
N        //<i> External interrupt PA5 pin edge/level event trigger enable.
N            //<o3.10..11> PIN5 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.13>  PA6
N        //<i> External interrupt PA6 pin edge/level event trigger enable.
N            //<o3.12..13> PIN6 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.15>  PA7
N        //<i> External interrupt PA7 pin edge/level event trigger enable.
N            //<o3.14..15> PIN7 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.17>  PA8
N        //<i> External interrupt PA8 pin edge/level event trigger enable.
N            //<o3.16..17> PIN8 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.19>  PA9
N        //<i> External interrupt PA9 pin edge/level event trigger enable.
N            //<o3.18..19> PIN9 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.21>  PA10
N        //<i> External interrupt PA10 pin edge/level event trigger enable.
N            //<o3.20..21> PIN10 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.23>  PA11
N        //<i> External interrupt PA11 pin edge/level event trigger enable.
N            //<o3.22..23> PIN11 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.25>  PA12
N        //<i> External interrupt PA12 pin edge/level event trigger enable.
N            //<o3.24..25> PIN12 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.27>  PA13
N        //<i> External interrupt PA13 pin edge/level event trigger enable.
N            //<o3.26..27> PIN13 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.29>  PA14
N        //<i> External interrupt PA14 pin edge/level event trigger enable.
N            //<o3.28..29> PIN14 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.31>  PA15
N        //<i> External interrupt PA15 pin edge/level event trigger enable.
N            //<o3.30..31> PIN15 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N    //</h>
N    //<q4> Interrupt enable
N    //<i> Port PA interrupt enable.
N//</e>
N#define CONF_ExicPAInit_EN           0
N#define CONF_ExicPAInit_AndOrMask    0x00000000
N#define CONF_ExicPAInit_Mask         0x00000000  
N#define CONF_ExicPAInit_Mode         0x55555555
N#define CONF_ExicPAInit_INT          0
N#define CONF_ExicPAInit_AINV         0
N
N
N//
N//=============================  PB EXIC Setting  ==============================
N//
N//<e0> Enable EXIC PB initial
N//<i> Port PB external interrupt configuration enable.
N    //<h> AND (KBI)
N    //<i> Port PB AND mask setting for External KBI input.
N        //<o1.16..31>AND Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PB AND mask bits. Each bit is used to disable(mask) or enable the related PBx input line.
N        //<q5> AND unmatch enable
N        //<i> External interrupt PB AND path signal inverse enable.
N    //</h>
N    //<h> OR (Interrupt)
N    //<i> Port PB OR mask setting for External interrupt input.
N        //<o1.0..15> OR  Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PB OR mask bits. Each bit is used to disable(mask) or enable the related PBx input line.
N    //</h>
N    //<h> Trigger mode
N    //<i> Port PB pin edge/level event trigger setting.
N        //<e2.1>  PB0
N        //<i> External interrupt PB0 pin edge/level event trigger enable.
N            //<o3.0..1> PIN0 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.3>  PB1
N        //<i> External interrupt PB1 pin edge/level event trigger enable.
N            //<o3.2..3> PIN1 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.5>  PB2
N        //<i> External interrupt PB2 pin edge/level event trigger enable.
N            //<o3.4..5> PIN2 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.7>  PB3
N        //<i> External interrupt PB3 pin edge/level event trigger enable.
N            //<o3.6..7> PIN3 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.9>  PB4
N        //<i> External interrupt PB4 pin edge/level event trigger enable.
N            //<o3.8..9> PIN4 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.11>  PB5
N        //<i> External interrupt PB5 pin edge/level event trigger enable.
N            //<o3.10..11> PIN5 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.13>  PB6
N        //<i> External interrupt PB6 pin edge/level event trigger enable.
N            //<o3.12..13> PIN6 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.15>  PB7
N        //<i> External interrupt PB7 pin edge/level event trigger enable.
N            //<o3.14..15> PIN7 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.17>  PB8
N        //<i> External interrupt PB8 pin edge/level event trigger enable.
N            //<o3.16..17> PIN8 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.19>  PB9
N        //<i> External interrupt PB9 pin edge/level event trigger enable.
N            //<o3.18..19> PIN9 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.21>  PB10
N        //<i> External interrupt PB10 pin edge/level event trigger enable.
N            //<o3.20..21> PIN10 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.23>  PB11
N        //<i> External interrupt PB11 pin edge/level event trigger enable.
N            //<o3.22..23> PIN11 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.25>  PB12
N        //<i> External interrupt PB12 pin edge/level event trigger enable.
N            //<o3.24..25> PIN12 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.27>  PB13
N        //<i> External interrupt PB13 pin edge/level event trigger enable.
N            //<o3.26..27> PIN13 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.29>  PB14
N        //<i> External interrupt PB14 pin edge/level event trigger enable.
N            //<o3.28..29> PIN14 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.31>  PB15
N        //<i> External interrupt PB15 pin edge/level event trigger enable.
N            //<o3.30..31> PIN15 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N    //</h>
N    //<q4> Interrupt enable
N    //<i> Port PB interrupt enable.
N//</e>
N#define CONF_ExicPBInit_EN           0
N#define CONF_ExicPBInit_AndOrMask    0x00000000
N#define CONF_ExicPBInit_Mask         0x00000000  
N#define CONF_ExicPBInit_Mode         0x55555555
N#define CONF_ExicPBInit_INT          0
N#define CONF_ExicPBInit_AINV         0
N
N
N//
N//=============================  PC EXIC Setting  ==============================
N//
N//<e0> Enable EXIC PC initial
N//<i> Port PC external interrupt configuration enable.
N    //<h> AND (KBI)
N    //<i> Port PC AND mask setting for External KBI input.
N        //<o1.16..31>AND Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PC AND mask bits. Each bit is used to disable(mask) or enable the related PCx input line.
N        //<q5> AND unmatch enable
N        //<i> External interrupt PC AND path signal inverse enable.
N    //</h>
N    //<h> OR (Interrupt)
N    //<i> Port PC OR mask setting for External interrupt input.
N        //<o1.0..15> OR  Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PC OR mask bits. Each bit is used to disable(mask) or enable the related PCx input line.
N    //</h>
N    //<h> Trigger mode
N    //<i> Port PC pin edge/level event trigger setting.
N        //<e2.1>  PC0
N        //<i> External interrupt PC0 pin edge/level event trigger enable.
N            //<o3.0..1> PIN0 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.3>  PC1
N        //<i> External interrupt PC1 pin edge/level event trigger enable.
N            //<o3.2..3> PIN1 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.5>  PC2
N        //<i> External interrupt PC2 pin edge/level event trigger enable.
N            //<o3.4..5> PIN2 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.7>  PC3
N        //<i> External interrupt PC3 pin edge/level event trigger enable.
N            //<o3.6..7> PIN3 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.9>  PC4
N        //<i> External interrupt PC4 pin edge/level event trigger enable.
N            //<o3.8..9> PIN4 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.11>  PC5
N        //<i> External interrupt PC5 pin edge/level event trigger enable.
N            //<o3.10..11> PIN5 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.13>  PC6
N        //<i> External interrupt PC6 pin edge/level event trigger enable.
N            //<o3.12..13> PIN6 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.15>  PC7
N        //<i> External interrupt PC7 pin edge/level event trigger enable.
N            //<o3.14..15> PIN7 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.17>  PC8
N        //<i> External interrupt PC8 pin edge/level event trigger enable.
N            //<o3.16..17> PIN8 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.19>  PC9
N        //<i> External interrupt PC9 pin edge/level event trigger enable.
N            //<o3.18..19> PIN9 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.21>  PC10
N        //<i> External interrupt PC10 pin edge/level event trigger enable.
N            //<o3.20..21> PIN10 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.23>  PC11
N        //<i> External interrupt PC11 pin edge/level event trigger enable.
N            //<o3.22..23> PIN11 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.25>  PC12
N        //<i> External interrupt PC12 pin edge/level event trigger enable.
N            //<o3.24..25> PIN12 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.27>  PC13
N        //<i> External interrupt PC13 pin edge/level event trigger enable.
N            //<o3.26..27> PIN13 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.29>  PC14
N        //<i> External interrupt PC14 pin edge/level event trigger enable.
N            //<o3.28..29> PIN14 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N    //</h>
N    //<q4> Interrupt enable
N    //<i> Port PC interrupt enable.
N//</e>
N#define CONF_ExicPCInit_EN           0
N#define CONF_ExicPCInit_AndOrMask    0x00000000
N#define CONF_ExicPCInit_Mask         0x00000000  
N#define CONF_ExicPCInit_Mode         0x55555555
N#define CONF_ExicPCInit_INT          0
N#define CONF_ExicPCInit_AINV         0
N
N
N//
N//=============================  PD EXIC Setting  ==============================
N//
N//<e0> Enable EXIC PD initial
N//<i> Port PD external interrupt configuration enable.
N    //<h> AND (KBI)
N    //<i> Port PD AND mask setting for External KBI input.
N        //<o1.16..31>AND Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PD AND mask bits. Each bit is used to disable(mask) or enable the related PDx input line.
N        //<q5> AND unmatch enable
N        //<i> External interrupt PD AND path signal inverse enable.
N    //</h>
N    //<h> OR (Interrupt)
N    //<i> Port PD OR mask setting for External interrupt input.
N        //<o1.0..15> OR  Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PD OR mask bits. Each bit is used to disable(mask) or enable the related PDx input line.
N    //</h>
N    //<h> Trigger mode
N    //<i> Port PD pin edge/level event trigger setting.
N        //<e2.1>  PD0
N        //<i> External interrupt PD0 pin edge/level event trigger enable.
N            //<o3.0..1> PIN0 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.3>  PD1
N        //<i> External interrupt PD1 pin edge/level event trigger enable.
N            //<o3.2..3> PIN1 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.5>  PD2
N        //<i> External interrupt PD2 pin edge/level event trigger enable.
N            //<o3.4..5> PIN2 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.7>  PD3
N        //<i> External interrupt PD3 pin edge/level event trigger enable.
N            //<o3.6..7> PIN3 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.9>  PD4
N        //<i> External interrupt PD4 pin edge/level event trigger enable.
N            //<o3.8..9> PIN4 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.11>  PD5
N        //<i> External interrupt PD5 pin edge/level event trigger enable.
N            //<o3.10..11> PIN5 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.13>  PD6
N        //<i> External interrupt PD6 pin edge/level event trigger enable.
N            //<o3.12..13> PIN6 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.15>  PD7
N        //<i> External interrupt PD7 pin edge/level event trigger enable.
N            //<o3.14..15> PIN7 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.17>  PD8
N        //<i> External interrupt PD8 pin edge/level event trigger enable.
N            //<o3.16..17> PIN8 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.19>  PD9
N        //<i> External interrupt PD9 pin edge/level event trigger enable.
N            //<o3.18..19> PIN9 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.21>  PD10
N        //<i> External interrupt PD10 pin edge/level event trigger enable.
N            //<o3.20..21> PIN10 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.23>  PD11
N        //<i> External interrupt PD11 pin edge/level event trigger enable.
N            //<o3.22..23> PIN11 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.25>  PD12
N        //<i> External interrupt PD12 pin edge/level event trigger enable.
N            //<o3.24..25> PIN12 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.27>  PD13
N        //<i> External interrupt PD13 pin edge/level event trigger enable.
N            //<o3.26..27> PIN13 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.29>  PD14
N        //<i> External interrupt PD14 pin edge/level event trigger enable.
N            //<o3.28..29> PIN14 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.31>  PD15
N        //<i> External interrupt PD15 pin edge/level event trigger enable.
N            //<o3.30..31> PIN15 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N    //</h>
N    //<q4> Interrupt enable
N    //<i> Port PD interrupt enable.
N//</e>
N#define CONF_ExicPDInit_EN           0
N#define CONF_ExicPDInit_AndOrMask    0x00000000
N#define CONF_ExicPDInit_Mask         0x00000000  
N#define CONF_ExicPDInit_Mode         0x55555555
N#define CONF_ExicPDInit_INT          0
N#define CONF_ExicPDInit_AINV         0
N
N
N//
N//=============================  PE EXIC Setting  ==============================
N//
N//<e0> Enable EXIC PE initial
N//<i> Port PE external interrupt configuration enable.
N    //<h> AND (KBI)
N    //<i> Port PE AND mask setting for External KBI input.
N        //<o1.16..31>AND Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PE AND mask bits. Each bit is used to disable(mask) or enable the related PEx input line.
N        //<q5> AND unmatch enable
N        //<i> External interrupt PE AND path signal inverse enable.
N    //</h>
N    //<h> OR (Interrupt)
N    //<i> Port PE OR mask setting for External interrupt input.
N        //<o1.0..15> OR  Mask  (0x0000 ~ 0xFFFF) <0x0000-0xFFFF>
N        //<i> External interrupt PE OR mask bits. Each bit is used to disable(mask) or enable the related PEx input line.
N    //</h>
N    //<h> Trigger mode
N    //<i> Port PE pin edge/level event trigger setting.
N        //<e2.1>  PE0
N        //<i> External interrupt PE0 pin edge/level event trigger enable.
N            //<o3.0..1> PIN0 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.3>  PE1
N        //<i> External interrupt PE1 pin edge/level event trigger enable.
N            //<o3.2..3> PIN1 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.5>  PE2
N        //<i> External interrupt PE2 pin edge/level event trigger enable.
N            //<o3.4..5> PIN2 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.7>  PE3
N        //<i> External interrupt PE3 pin edge/level event trigger enable.
N            //<o3.6..7> PIN3 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.17>  PE8
N        //<i> External interrupt PE8 pin edge/level event trigger enable.
N            //<o3.16..17> PIN8 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.19>  PE9
N        //<i> External interrupt PE9 pin edge/level event trigger enable.
N            //<o3.18..19> PIN9 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.25>  PE12
N        //<i> External interrupt PE12 pin edge/level event trigger enable.
N            //<o3.24..25> PIN12 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.27>  PE13
N        //<i> External interrupt PE13 pin edge/level event trigger enable.
N            //<o3.26..27> PIN13 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.29>  PE14
N        //<i> External interrupt PE14 pin edge/level event trigger enable.
N            //<o3.28..29> PIN14 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N        //<e2.31>  PE15
N        //<i> External interrupt PE15 pin edge/level event trigger enable.
N            //<o3.30..31> PIN15 trigger event is <1=>Level <2=>Edge <3=> Dual-edge
N            //<i> [1] Level : External input trigger by voltage level (Low or High level select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [2] Edge : External input trigger by single edge (Rising or Falling edge select by "INV : Input inverse" item in MG32x02z_GPIO_Init.h Chip Initial Wizard)
N            //<i> [3] Dual-edge : External input trigger by rising or falling edge
N        //</e>
N    //</h>
N    //<q4> Interrupt enable
N    //<i> Port PE interrupt enable.
N//</e>
N#define CONF_ExicPEInit_EN           0
N#define CONF_ExicPEInit_AndOrMask    0x00000000
N#define CONF_ExicPEInit_Mask         0x00000000  
N#define CONF_ExicPEInit_Mode         0x55555555
N#define CONF_ExicPEInit_INT          0
N#define CONF_ExicPEInit_AINV         0
N
N//<q0.1> RXEV mask enable
N//<i> Interrupt event mask control bit for RXEV (0= Disable mask, 1= Enable mask).
N//<o1> NMI interrupt source select
N//<0x00=> Disable
N//<0x01=> External PIN
N//<0x81=> WWDT 
N//<0x85=> SYS 
N//<0x8D=> EXIC0(PA)
N//<0x91=> EXIC1(PB)
N//<0x95=> EXIC2(PC)
N//<0x9D=> EXIC3(PD/PE)
N//<0xA1=> CMPx
N//<0xA5=> DMA
N//<0xAD=> ADC
N//<0xB1=> DAC
N//<0xB5=> TM0x
N//<0xBD=> TM10
N//<0xC1=> TM1x
N//<0xC5=> TM20
N//<0xCD=> TM2x
N//<0xD1=> TM3x
N//<0xD5=> URT0
N//<0xDD=> URT123
N//<0xE5=> SPI0
N//<0xED=> I2C0
N//<0xF1=> I2Cx
N//<i> SYS including of (IWDT, PW, RTC, CSC, APB, MEM, EMB) interrupts
N//<i> CMPx including of AC0/1/2/3 interrupts
N//<i> TM0x, TM1x, TM2x, TM3x separately including of TM00/TM01, TM16, TM26, TM36 interrupts
N//<i> URT4x, I2Cx separately including of URT4/5/6/7, I2C1 interrupts
N#define MG32x02z_ExicRXEV_EN            0x00
N#define MG32x02z_ExicNMI_SEL            0x00
N
N// <<< end of configuration section >>>
N
Nvoid EXIC_Init(void);
N
N
N#endif  // _MG32x02z_EXIC_Init_H
L 54 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_GPL
N    #include "MG32x02z_GPL_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_GPL_Init.h" 1
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_GPL_Init.h
N *
N * @brief       The GPL Init C file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.01
N * @date        2017/03/09
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N * 
N ******************************************************************************* 
N * @par Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N
N
N#ifndef __MG32x02z_GPL_INIT_H
N#define __MG32x02z_GPL_INIT_H
N#define __MG32x02z_GPL_INIT_H_VER                          0.01     /*!< File Version */
N
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N//  <o1.10> Data parity check polarity select. <0=>Even <1=>Odd
N//  <q1.31> Direct memory access.
N//  <q1.6> Inverse input data.
N//  <q1.1> Data byte Big/little endian change mode.
N//  <o1.2..3> Data bit order. <0=>Disable <1=>8-bits <2=>16-bits <3=>32-bits
N//  <e2.0> CRC function.
N//    <o2.2..3> CRC mode. <0=> CRC16 CCITT : polynomial 0x1021
N//                        <1=> CRC8 ATM : polynomial 0x07
N//                        <2=> CRC16 IBM : polynomial 0x8005
N//                        <3=> CRC32 IEEE802.3 : polynomial 0x4C11DB7
N//    <o2.4..5> CRC operation data size. <1=> 8-bits
N//                                       <2=> 16-bits
N//                                       <3=> 32-bits
N//    <O3> Programmable initial CRC value
N//  </e>
N//  <o2.6..7> Data output bit order reverse change mode select. <0=>Disable <1=>8-bits <2=>16-bits <3=>32-bits
N//*** <<< end of configuration section >>> ***
N#define     GPL_Config0_Enable       0
N#define     GPL_Config0_CR0          0x80000000
N#define     GPL_Config0_CR1          0x00000010
N#define     GPL_Config0_CRCINIT      0x00000000
N
N
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N
N#include "MG32x02z_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DRV.h
N *
N * @brief       This is the C Code Include format example file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.21
N * @date        2021/02/24
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N#ifndef _MG32x02z_DRV_H
N#define _MG32x02z_DRV_H
N#define _MG32x02z_DRV_H_VER                            2.20           /*!<MG32x02z Driver ver.*/
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "MG32x02z_ADC_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_ADC_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the ADC 
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.16
N * @date        2020/10/07
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N#ifndef _MG32x02z_ADC_DRV_H
N
N/*!< _MG32x02z_ADC_DRV_H */ 
N#define _MG32x02z_ADC_DRV_H
N
N
N#include "MG32x02z__Common_DRV.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z__Common_DRV.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z__Common_DRV.h
N *
N * @brief       This is the C code format driver head file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.14
N * @date        2019/04/15
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N
N#ifndef _MG32x02z_Common_DRV_H
N#define _MG32x02z_Common_DRV_H
N#define _MG32x02z_Common_DRV_H_VER                            0.1      /*!< File Version */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N#include "stdint.h"
N#include "stdio.h"
N#include "string.h"
N#include "MG32x02z.h"
N
N
N
N     // Debug Configuration Setting
N#define MG_Debug	1				/*!< 0=Normal, 1=Debug for Test Chip    */
N
N
N/**
N * @enum		DRV_Return
N * @brief		General Driver return status
N */
Ntypedef enum 
N{
N    /* common status values */
N    DRV_Logic0 = 0,             /*!<                                    */
N    DRV_Logic1 = 1,             /*!< operation failed					*/
N    DRV_Low = 0,                /*!< operation failed					*/
N    DRV_High = 1,               /*!< operation failed					*/
N    DRV_Normal = 0,             /*!< operation failed					*/
N    DRV_UnHappened = 0,         /*!< operation failed					*/
N    DRV_Happened = 1,           /*!< operation failed					*/
N    DRV_Success = 0,            /*!< successful outcome					*/
N    DRV_Failure = 1,            /*!< operation failed					*/
N    DRV_False = 0,              /*!<                                    */
N    DRV_True = !DRV_False,      /*!<                                    */
N    DRV_Unready = 0,            /*!<                                    */
N    DRV_Ready = !DRV_Unready,   /*!<                                    */
N
N    /* For PW module */
N    PW_HighThreshold = 0,
N    PW_LowThreshold = 1,
N    PW_None = 0,
N    PW_Sleep = 1,
N    PW_Stop = 2,    
N
N    DRV_Completed,              /*!< operation failed					*/
N    DRV_TimeOut,                /*!< operation failed					*/
N    DRV_OverRange,
N    DRV_OutsideLow,
N    DRV_OutsideHigh,
N    DRV_Inside,
N    DRV_Busy,                   /*!<                                    */
N    DRV_OverFlow,               /*!<                                    */
N    DRV_UnderFlow,              /*!<                                    */
N//	DRV_ERR_INVALID_HANDLE,		/*!< invalid handle						*/
N//	DRV_ERR_INVALID_ID,			/*!< invalid identifier					*/
N//	DRV_ERR_INVALID_PARAM,		/*!< invalid parameter					*/
N//	DRV_ERR_INVALID_OP,			/*!< requested operation is invalid		*/
N//	DRV_ERR_MEMORY_ALLOC,		/*!< problem allocating memory			*/
N//	DRV_ERR_MEMORY_SIZE,		/*!< problem with the size of memory	*/
N//	DRV_ERR_RESOURCE_UNAVAILABLE,
N//	DRV_ERR_TIMEOUT,			/*!< timeout							*/
N//	DRV_ERR_MAX					/*!< Max error number*/
N
N//	DRV_WARN_NO_ACTION,			/* < the function completed successfully,*/
N	                                /* < but no action was taken            */
N//	DRV_WARN_PARAM_CLIPPED,		/*!< the function has completed			*/
N//									/*!< successfully, though a parameter was	*/
N//									/*!< clipped to within a valid range.		*/
N//	DRV_WARN_BUFFER_EMPTY,
N//	DRV_WARN_BUFFER_FULL,
N//	DRV_WARN_UNINITED,			/*!< driver has not been initialized yet */
N//	DRV_WARN_INITED,			/*!< driver has been initialized already */
N
N}DRV_Return;           /*!< Driver Return Status Definitions */
N
N
N
N/**
N * @enum		Protect_Type
N * @brief		TMx interrupt enable source  
N */
Ntypedef enum { 
N    RSTprotect = (uint32_t)0x4C00000C,
N    CSCprotect = (uint32_t)0x4C01000C,  
N    PWprotect = (uint32_t)0x4C02000C,
N    MEMprotect = (uint32_t)0x4D00000C,  
N    MEMsprotect = (uint32_t)0x4D00000E,
N    CFGprotect = (uint32_t)0x4FF0000C,
N    IWDTprotect = (uint32_t)0x5D00000C,  
N    WWDTprotect = (uint32_t)0x5D01000C,  
N    RTCprotect = (uint32_t)0x5D04000C,
N}Protect_Type;          /*!< Definitions for protection function */
N
N
N
N
N/**
N * @enum		Lock_Type
N * @brief		Lock Module. 
N */
Ntypedef enum{
N    RSTLock = (uint32_t)0x4C00000E,
N    IWDTLock = (uint32_t)0x5D00000E,  
N    RTCLock = (uint32_t)0x5D04000E,
N}Lock_Type;             /*!< Definitions for locked function */
N
N
N
N#if defined(IRQHandler_Middleware_Level_)
X#if 1L
N  #define InitTick(__TickClock__, __TickPriority__) MID_InitTick(__TickPriority__)
N  #define Delay         MID_Delay
N  #define GetTick       MID_GetTick
N  #define SuspendTick   MID_SuspendTick
N  #define ResumeTick    MID_ResumeTick
N#else
S  DRV_Return InitTick(uint32_t TickClock, uint32_t TickPriority);
S  void IncTick(void);
S  void Delay(__IO uint32_t DelayTime);
S  uint32_t GetTick(void);
S  void SuspendTick(void);
S  void ResumeTick(void);
N#endif
N
NDRV_Return ProtectModuleReg(Protect_Type Module);             /*!< Protect Module Register Write */
NDRV_Return UnProtectModuleReg(Protect_Type Module);           /*!< UnProtect Module Register Write */
NDRV_Return LockModuleReg(Lock_Type Module);                   /*!< Lock Module Register Write until Chip Reset */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 37 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N#include "MG32x02z_ADC.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_ADC.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_ADC.h
N *
N * @brief       MG32x02z ADC Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_ADC_H
N#define _MG32x02z_ADC_H
N#define _MG32x02z_ADC_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_ADC_H_VER)
S    #error "MG32x02z_ADC_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      ADC_Struct
N *              ADC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESMPF         :1;     //[2] ADC sampling end flag
X            volatile uint8_t  ESMPF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  E1CNVF        :1;     //[3] ADC one-time conversion end flag
X            volatile uint8_t  E1CNVF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESCNVF        :1;     //[5] ADC channel scan conversion end flag
X            volatile uint8_t  ESCNVF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OVRF          :1;     //[7] ADC conversion overrun event flag
X            volatile uint8_t  OVRF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WDLF          :1;     //[8] ADC voltage window detect outside low event flag
X            volatile uint8_t  WDLF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WDIF          :1;     //[9] ADC voltage window detect inside event flag
X            volatile uint8_t  WDIF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WDHF          :1;     //[10] ADC voltage window detect outside high event flag
X            volatile uint8_t  WDHF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SUMUF         :1;     //[12] ADC data sum-0,1,2 accumulation underflow flag
X            volatile uint8_t  SUMUF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SUMOF         :1;     //[13] ADC data sum-0,1,2 accumulation overflow or underflow flag
X            volatile uint8_t  SUMOF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SUMCF         :1;     //[14] ADC data sum-0,1,2  accumulation complete flag
X            volatile uint8_t  SUMCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SUMOVRF       :1;     //[15] ADC data sum-0,1,2  register overrun flag
X            volatile uint8_t  SUMOVRF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  POF           :1;     //[24] ADC PGA offset calibration status bit.
X            volatile uint8_t  POF           :1;     
N            __I  uint8_t  PHS           :1;     //[25] ADC sampling phase cycle status bit.
X            volatile const  uint8_t  PHS           :1;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  ADC status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] ADC interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESMP_IE       :1;     //[2] ADC sampling end interrupt enable.
X            volatile uint8_t  ESMP_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  E1CNV_IE      :1;     //[3] ADC one-time conversion end interrupt enable.
X            volatile uint8_t  E1CNV_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESCNV_IE      :1;     //[5] ADC channel scan conversion end interrupt enable.
X            volatile uint8_t  ESCNV_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OVR_IE        :1;     //[7] ADC conversion overrun event interrupt enable.
X            volatile uint8_t  OVR_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WDL_IE        :1;     //[8] ADC voltage window detect outside low event interrupt enable.
X            volatile uint8_t  WDL_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WDI_IE        :1;     //[9] ADC voltage window detect inside event interrupt enable.
X            volatile uint8_t  WDI_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WDH_IE        :1;     //[10] ADC voltage window detect outside high event interrupt enable.
X            volatile uint8_t  WDH_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[12..11] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SUMO_IE       :1;     //[13] ADC data sum-0,1,2  accumulation overflow or underflow interrupt enable.
X            volatile uint8_t  SUMO_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SUMC_IE       :1;     //[14] ADC data sum-0,1,2  accumulation complete interrupt enable.
X            volatile uint8_t  SUMC_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SUMOVR_IE     :1;     //[15] ADC data sum-0,1,2  overrun event interrupt enable.
X            volatile uint8_t  SUMOVR_IE     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  ADC interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_DIV        :2;     //[5..4] ADC internal clock CK_ADC_INT input divider.
X            volatile uint8_t  CK_DIV        :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV16 : divided by 16
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_SEL2       :2;     //[9..8] ADC internal sampling clock CK_ADC_INT source select.
X            volatile uint8_t  CK_SEL2       :2;     
N                                        //0x0 = CK_ADC
N                                        //0x1 = CK_PLL
N                                        //0x2 = TM00_TRGO (only accept TM00_TRGO_UEV, TM00_TRGO_UEV2)
N                                        //0x3 = TM01_TRGO (only accept TM01_TRGO_UEV, TM01_TRGO_UEV2)
N            __IO uint8_t  CK_DIV2       :2;     //[11..10] ADC input clock CK_PLL divider.
X            volatile uint8_t  CK_DIV2       :2;     
N                                        //0x0 = DIV2 : divided by 2
N                                        //0x1 = DIV4 : divided by 4
N                                        //0x2 = DIV5 : divided by 5
N                                        //0x3 = DIV6 : divided by 6
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  ADC clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t WIND_LT       :12;    //[11..0] ADC Voltage window detect lower threshold
X            volatile uint16_t WIND_LT       :12;    
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint16_t WIND_HT       :12;    //[27..16] ADC voltage window detect higher threshold
X            volatile uint16_t WIND_HT       :12;    
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }WINDTH;                            /*!< WINDTH     ~ Offset[0x0C]  ADC window detect threshold register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] ADC power-on enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AUTOFF_EN     :1;     //[1] Auto-off mode enable
X            volatile uint8_t  AUTOFF_EN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WAIT_EN       :1;     //[2] Wait conversion mode enable for low CPU frequency .
X            volatile uint8_t  WAIT_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MDS           :1;     //[3] ADC conversion mode select
X            volatile uint8_t  MDS           :1;     
N                                        //0 = Single-End
N                                        //1 = Differential
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  DTEST_EN      :1;     //[5] ADC digital test mode enable for internal using
X            volatile uint8_t  DTEST_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RES_SEL       :2;     //[7..6] ADC data resolution select. register.
X            volatile uint8_t  RES_SEL       :2;     
N                                        //0x0 = 12-bit
N                                        //0x1 = 10-bit
N                                        //0x2 = 8-bit
N                                        //0x3 = Reserved
N            __IO uint8_t  CODE_FMT      :1;     //[8] ADC data code output format select
X            volatile uint8_t  CODE_FMT      :1;     
N                                        //0 = Unsigned : unsigned data format
N                                        //1 = 2S : 2's complement data format
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[13..12] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  LIM_MDS       :2;     //[15..14] ADC output code spike limit function select
X            volatile uint8_t  LIM_MDS       :2;     
N                                        //0x0 = No operation
N                                        //0x1 = Skip
N                                        //0x2 = Clamp
N                                        //0x3 = Reserved
N            __IO uint8_t  SMP_SEL       :8;     //[23..16] ADC sampling time select from 0T clock to 255T clocks. Value 0 indicates 0T clock.
X            volatile uint8_t  SMP_SEL       :8;     
N            __I  uint8_t                :7;     //[30..24] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  DMA_EN        :1;     //[31] Direct memory access enable
X            volatile uint8_t  DMA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  ADC control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  WIND_EN       :1;     //[0] ADC Voltage window detect enable bit.
X            volatile uint8_t  WIND_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WIND_MDS      :1;     //[1] ADC Voltage window detect and output code spike limit function channel mode select.
X            volatile uint8_t  WIND_MDS      :1;     
N                                        //0 = Single (Single channel)
N                                        //1 = All (All scan channels)
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ALIGN_SEL     :1;     //[3] ADC data alignment select.
X            volatile uint8_t  ALIGN_SEL     :1;     
N                                        //0 = Right (Right alignment)
N                                        //1 = Left (Left alignment)
N            __IO uint8_t  OUT_SEL       :2;     //[5..4] ADC_OUT output signal select.
X            volatile uint8_t  OUT_SEL       :2;     
N                                        //0x0 = WDL (window detect state for outside low)
N                                        //0x1 = WDI (window detect state for inside)
N                                        //0x2 = WDH (window detect state for outside high)
N                                        //0x3 = RDY (ADC_RDY internal data ready signal) 
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  OVR_MDS       :1;     //[8] ADC data buffer overrun mode select.
X            volatile uint8_t  OVR_MDS       :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old date)
N            __IO uint8_t  SOVR_MDS      :1;     //[9] ADC data sum overrun mode select.
X            volatile uint8_t  SOVR_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old date)
N            __IO uint8_t  SUM_MDS       :1;     //[10] ADC data accumulation sum channel mode select
X            volatile uint8_t  SUM_MDS       :1;     
N                                        //0 = Single (Single channel)
N                                        //1 = All (All selected scan channels)
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  SUM_NUM       :7;     //[22..16] ADC data sum accumulation data number
X            volatile uint8_t  SUM_NUM       :7;     
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  DOS_VAL       :5;     //[28..24] ADC adjusted 2s complement value of digital offset adjuster.
X            volatile uint8_t  DOS_VAL       :5;     
N            __I  uint8_t                :3;     //[31..29] 
X            volatile const  uint8_t                :3;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  ADC control register 1 */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x18]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH_MSK0       :1;     //[0] ADC channel-0 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK1       :1;     //[1] ADC channel-1 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK2       :1;     //[2] ADC channel-2 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK3       :1;     //[3] ADC channel-3 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK3       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK4       :1;     //[4] ADC channel-4 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK4       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK5       :1;     //[5] ADC channel-5 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK5       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK6       :1;     //[6] ADC channel-6 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK6       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK7       :1;     //[7] ADC channel-7 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK7       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK8       :1;     //[8] ADC channel-8 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK8       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK9       :1;     //[9] ADC channel-9 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK9       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK10      :1;     //[10] ADC channel-10 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK10      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK11      :1;     //[11] ADC channel-11 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK11      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK12      :1;     //[12] ADC channel-12 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK12      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK13      :1;     //[13] ADC channel-13 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK13      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK14      :1;     //[14] ADC channel-14 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK14      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK15      :1;     //[15] ADC channel-15 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK15      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SUM0_MUX      :4;     //[19..16] Analog input channel selection for ADC data sum-0 function.
X            volatile uint8_t  SUM0_MUX      :4;     
N            __IO uint8_t  SUM1_MUX      :4;     //[23..20] ADC input channel selection for ADC data sum-1 function.
X            volatile uint8_t  SUM1_MUX      :4;     
N            __IO uint8_t  SUM2_MUX      :4;     //[27..24] ADC input channel selection for ADC data sum-2 function.
X            volatile uint8_t  SUM2_MUX      :4;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }MSK;                               /*!< MSK        ~ Offset[0x1C]  ADC channel mask register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  START         :1;     //[0] ADC start conversion command. (set by software and clear by hardware)
X            volatile uint8_t  START         :1;     
N            __IO uint8_t  HOLD          :1;     //[1] ADC hold conversion command.
X            volatile uint8_t  HOLD          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH_MUX        :4;     //[11..8] ADC input channel Mux selection
X            volatile uint8_t  CH_MUX        :4;     
N            __IO uint8_t  CH_SEL        :1;     //[12] ADC input channel Mux external or internal channel selection
X            volatile uint8_t  CH_SEL        :1;     
N                                        //0 = EXT : external channels
N                                        //1 = INT : internal channels
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  START_SEL     :3;     //[18..16] ADC start control source select.
X            volatile uint8_t  START_SEL     :3;     
N                                        //0x0 = SW : ADC_START register setting
N                                        //0x1 = TM00 : TM00_TRGO
N                                        //0x2 = PIN : ADC_TRG : ADC external trigger pin
N                                        //0x3 = CMP0 : CMP0_OUT
N                                        //0x4 = CMP1 : CMP1_OUT
N                                        //0x5 = TM01 : TM01_TRGO
N                                        //0x6 = TM20 : TM20_TRGO
N                                        //0x7 = TM36 : TM36_TRGO
N            __IO uint8_t  TRG_CONT      :1;     //[19] ADC start trigger continuous control enable
X            volatile uint8_t  TRG_CONT      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TRG_SEL       :2;     //[21..20] ADC start trigger selection
X            volatile uint8_t  TRG_SEL       :2;     
N                                        //0x0 = Disable
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CONV_MDS      :2;     //[25..24] ADC conversion mode select.
X            volatile uint8_t  CONV_MDS      :2;     
N                                        //0x0 = One :One shot (1-time) conversion
N                                        //0x1 = Scan :Single sequence channel-scan conversion
N                                        //0x2 = Loop :Continuous loop channel-scan conversion
N                                        //0x3 = Reserved
N            __I  uint8_t                :1;     //[26] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[31..27] 
X            volatile const  uint8_t                :5;     
N        }MBIT;
N    }START;                             /*!< START      ~ Offset[0x20]  ADC start conversion register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PGA_EN        :1;     //[2] ADC input buffer and PGA enable bit.
X            volatile uint8_t  PGA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PGAOUT_EN     :1;     //[7] ADC PGA voltage output enable
X            volatile uint8_t  PGAOUT_EN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BUF_BIAS      :1;     //[12] ADC input buffer bias current control.
X            volatile uint8_t  BUF_BIAS      :1;     
N            __I  uint8_t                :2;     //[14..13] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }ANA;                               /*!< ANA        ~ Offset[0x24]  ADC analog control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CAL_AZEN      :1;     //[2] ADC calibration auto-zero function enable.
X            volatile uint8_t  CAL_AZEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CAL_POFFT     :1;     //[3] ADC PGA offset calibration function enable.
X            volatile uint8_t  CAL_POFFT     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t  REFB          :6;     //[13..8] ADC reference voltage bottom level setting.
X            volatile const  uint8_t  REFB          :6;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  REFM          :6;     //[21..16] ADC reference voltage middle level setting.
X            volatile const  uint8_t  REFM          :6;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  REFT          :6;     //[29..24] ADC reference voltage top level setting.
X            volatile const  uint8_t  REFT          :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CAL;                               /*!< CAL        ~ Offset[0x28]  ADC calibration control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  GAIN_PGA      :6;     //[5..0] ADC input PGA gain adjust bits
X            volatile uint8_t  GAIN_PGA      :6;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  OFFT_PGA      :6;     //[21..16] ADC input PGA offset adjust bits.
X            volatile uint8_t  OFFT_PGA      :6;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }GAIN;                              /*!< GAIN       ~ Offset[0x2C]  ADC gain control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t SUM0_DAT      :16;    //[15..0] ADC data accumulator sum-0 result.
X            volatile uint16_t SUM0_DAT      :16;    
N            __I  uint8_t                :4;     //[19..16] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SUM0_UF       :1;     //[20] ADC data sum-0 accumulation underflow indication status bit
X            volatile uint8_t  SUM0_UF       :1;     
N            __IO uint8_t  SUM0_OF       :1;     //[21] ADC data sum-0 accumulation overflow indication status bit
X            volatile uint8_t  SUM0_OF       :1;     
N            __IO uint8_t  SUM0_CF       :1;     //[22] ADC data sum-0 accumulation complete indication status bit
X            volatile uint8_t  SUM0_CF       :1;     
N            __IO uint8_t  SUM0_OVRF     :1;     //[23] ADC data sum register-0 overwrite/overrun indication status bit
X            volatile uint8_t  SUM0_OVRF     :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SUM0;                              /*!< SUM0       ~ Offset[0x30]  ADC accumulator sum result register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t SUM1_DAT      :16;    //[15..0] ADC data accumulator sum-1 result
X            volatile uint16_t SUM1_DAT      :16;    
N            __I  uint8_t                :4;     //[19..16] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SUM1_UF       :1;     //[20] ADC data sum-1 accumulation underflow indication status bit
X            volatile uint8_t  SUM1_UF       :1;     
N            __IO uint8_t  SUM1_OF       :1;     //[21] ADC data sum-1 accumulation overflow indication status bit
X            volatile uint8_t  SUM1_OF       :1;     
N            __IO uint8_t  SUM1_CF       :1;     //[22] ADC data sum-1 accumulation complete indication status bit
X            volatile uint8_t  SUM1_CF       :1;     
N            __IO uint8_t  SUM1_OVRF     :1;     //[23] ADC data sum register-1 overwrite/overrun indication status bit
X            volatile uint8_t  SUM1_OVRF     :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SUM1;                              /*!< SUM1       ~ Offset[0x34]  ADC accumulator sum result register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t SUM2_DAT      :16;    //[15..0] ADC data accumulator sum-2 result
X            volatile uint16_t SUM2_DAT      :16;    
N            __I  uint8_t                :4;     //[19..16] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SUM2_UF       :1;     //[20] ADC data sum-2 accumulation underflow indication status bit
X            volatile uint8_t  SUM2_UF       :1;     
N            __IO uint8_t  SUM2_OF       :1;     //[21] ADC data sum-2 accumulation overflow indication status bit
X            volatile uint8_t  SUM2_OF       :1;     
N            __IO uint8_t  SUM2_CF       :1;     //[22] ADC data sum-2 accumulation complete indication status bit
X            volatile uint8_t  SUM2_CF       :1;     
N            __IO uint8_t  SUM2_OVRF     :1;     //[23] ADC data sum register-1 overwrite/overrun indication status bit
X            volatile uint8_t  SUM2_OVRF     :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SUM2;                              /*!< SUM2       ~ Offset[0x38]  ADC accumulator sum result register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t TCAL0         :12;    //[11..0] Temperature Sensor calibration ADC value 0.
X            volatile const  uint16_t TCAL0         :12;    
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t TCAL1         :12;    //[27..16] Temperature Sensor calibration ADC value 1.
X            volatile const  uint16_t TCAL1         :12;    
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }TCAL;                              /*!< TCAL       ~ Offset[0x3C]  ADC Temperature Sensor calibration register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t DAT0          :16;    //[15..0] ADC conversion data-0
X            volatile const  uint16_t DAT0          :16;    
N            __IO uint8_t  DAT0_WDLF     :1;     //[16] ADC voltage window detect outside low event flag
X            volatile uint8_t  DAT0_WDLF     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  DAT0_WDIF     :1;     //[17] ADC voltage window detect inside event flag
X            volatile uint8_t  DAT0_WDIF     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  DAT0_WDHF     :1;     //[18] ADC voltage window detect outside high event flag
X            volatile uint8_t  DAT0_WDHF     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :3;     //[21..19] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  DAT0_CF       :1;     //[22] ADC conversion data-0 complete in 1-time and data ready status bit
X            volatile uint8_t  DAT0_CF       :1;     
N            __IO uint8_t  DAT0_OVRF     :1;     //[23] ADC conversion data register-0 overwrite/overrun indication status bit
X            volatile uint8_t  DAT0_OVRF     :1;     
N            __I  uint8_t                :4;     //[27..24] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t  DAT0_CH       :4;     //[31..28] ADC data conversion channel number
X            volatile const  uint8_t  DAT0_CH       :4;     
N        }MBIT;
N    }DAT0;                              /*!< DAT0       ~ Offset[0x40]  ADC conversion data register 0 */
N
N} ADC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        ADC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define ADC0_Base                       ((uint32_t)0x5B000000)              /*!< Analog-to-Digital Converter Control Module-0 */
N#define ADC0                            ((ADC_Struct*) ADC0_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        ADC  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        ADC_STA  [register's definitions]
N *              Offset[0x00]  ADC status register
N ******************************************************************************
N */
N///@{
N#define ADC_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_STA */
N#define ADC_STA_PHS_mask_w                          ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_PHS_mask_h1                         ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_STA_PHS_mask_b3                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_STA_PHS_shift_w                         (25)                    /*!< Bit Shift of 32bit */
N#define ADC_STA_PHS_shift_h1                        (9)                     /*!< Bit Shift of 16bit */
N#define ADC_STA_PHS_shift_b3                        (1)                     /*!< Bit Shift of 8bit */
N
N#define ADC_STA_POF_mask_w                          ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_POF_mask_h1                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_STA_POF_mask_b3                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_STA_POF_shift_w                         (24)                    /*!< Bit Shift of 32bit */
N#define ADC_STA_POF_shift_h1                        (8)                     /*!< Bit Shift of 16bit */
N#define ADC_STA_POF_shift_b3                        (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_STA_SUMOVRF_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMOVRF_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMOVRF_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMOVRF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMOVRF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMOVRF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMOVRF_happened_w                  ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMOVRF_happened_h0                 ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMOVRF_happened_b1                 ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_SUMCF_mask_w                        ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMCF_mask_h0                       ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMCF_mask_b1                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMCF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMCF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMCF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMCF_happened_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMCF_happened_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMCF_happened_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_SUMOF_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMOF_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMOF_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMOF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMOF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMOF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMOF_happened_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMOF_happened_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMOF_happened_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_SUMUF_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMUF_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMUF_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMUF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMUF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMUF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMUF_happened_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMUF_happened_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMUF_happened_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_WDHF_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_STA_WDHF_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_STA_WDHF_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_STA_WDHF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_WDHF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_WDHF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_WDHF_happened_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_WDHF_happened_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_WDHF_happened_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_WDIF_mask_w                         ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_STA_WDIF_mask_h0                        ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_STA_WDIF_mask_b1                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_STA_WDIF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_WDIF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_WDIF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_WDIF_happened_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_WDIF_happened_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_WDIF_happened_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_WDLF_mask_w                         ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_STA_WDLF_mask_h0                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_STA_WDLF_mask_b1                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_STA_WDLF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_WDLF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_WDLF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_WDLF_happened_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_WDLF_happened_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_WDLF_happened_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_OVRF_mask_w                         ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_STA_OVRF_mask_h0                        ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_STA_OVRF_mask_b0                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_STA_OVRF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_OVRF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_OVRF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_OVRF_happened_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_OVRF_happened_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_OVRF_happened_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_ESCNVF_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_STA_ESCNVF_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_STA_ESCNVF_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_STA_ESCNVF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_ESCNVF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_ESCNVF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_ESCNVF_happened_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_ESCNVF_happened_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_ESCNVF_happened_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_E1CNVF_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_STA_E1CNVF_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_STA_E1CNVF_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_STA_E1CNVF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_E1CNVF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_E1CNVF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_E1CNVF_happened_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_E1CNVF_happened_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_E1CNVF_happened_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_ESMPF_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_STA_ESMPF_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_STA_ESMPF_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_STA_ESMPF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_ESMPF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_ESMPF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_ESMPF_happened_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_ESMPF_happened_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_ESMPF_happened_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_INT  [register's definitions]
N *              Offset[0x04]  ADC interrupt enable register
N ******************************************************************************
N */
N///@{
N#define ADC_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_INT */
N#define ADC_INT_SUMOVR_IE_mask_w                    ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define ADC_INT_SUMOVR_IE_mask_h0                   ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_INT_SUMOVR_IE_mask_b1                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_INT_SUMOVR_IE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_SUMOVR_IE_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_SUMOVR_IE_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_SUMOVR_IE_enable_w                  ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_SUMOVR_IE_enable_h0                 ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_SUMOVR_IE_enable_b1                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_SUMC_IE_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define ADC_INT_SUMC_IE_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define ADC_INT_SUMC_IE_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_INT_SUMC_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_SUMC_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_SUMC_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_SUMC_IE_enable_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_SUMC_IE_enable_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_SUMC_IE_enable_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_SUMO_IE_mask_w                      ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define ADC_INT_SUMO_IE_mask_h0                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define ADC_INT_SUMO_IE_mask_b1                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_INT_SUMO_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_SUMO_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_SUMO_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_SUMO_IE_enable_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_SUMO_IE_enable_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_SUMO_IE_enable_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_WDH_IE_mask_w                       ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_INT_WDH_IE_mask_h0                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_INT_WDH_IE_mask_b1                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_INT_WDH_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_WDH_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_WDH_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_WDH_IE_enable_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_WDH_IE_enable_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_WDH_IE_enable_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_WDI_IE_mask_w                       ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_INT_WDI_IE_mask_h0                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_INT_WDI_IE_mask_b1                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_INT_WDI_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_WDI_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_WDI_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_WDI_IE_enable_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_WDI_IE_enable_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_WDI_IE_enable_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_WDL_IE_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_INT_WDL_IE_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_INT_WDL_IE_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_INT_WDL_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_WDL_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_WDL_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_WDL_IE_enable_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_WDL_IE_enable_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_WDL_IE_enable_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_OVR_IE_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_INT_OVR_IE_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_INT_OVR_IE_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_INT_OVR_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_OVR_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_OVR_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_OVR_IE_enable_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_OVR_IE_enable_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_OVR_IE_enable_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_ESCNV_IE_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_INT_ESCNV_IE_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_INT_ESCNV_IE_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_INT_ESCNV_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_ESCNV_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_ESCNV_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_ESCNV_IE_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_ESCNV_IE_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_ESCNV_IE_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_E1CNV_IE_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_INT_E1CNV_IE_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_INT_E1CNV_IE_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_INT_E1CNV_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_E1CNV_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_E1CNV_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_E1CNV_IE_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_E1CNV_IE_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_E1CNV_IE_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_ESMP_IE_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_INT_ESMP_IE_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_INT_ESMP_IE_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_INT_ESMP_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_ESMP_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_ESMP_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_ESMP_IE_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_ESMP_IE_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_ESMP_IE_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CLK  [register's definitions]
N *              Offset[0x08]  ADC clock source register
N ******************************************************************************
N */
N///@{
N#define ADC_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CLK */
N#define ADC_CLK_CK_DIV2_mask_w                      ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define ADC_CLK_CK_DIV2_mask_h0                     ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define ADC_CLK_CK_DIV2_mask_b1                     ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define ADC_CLK_CK_DIV2_div2_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV2 of 32bit */
N#define ADC_CLK_CK_DIV2_div2_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV2 of 16bit */
N#define ADC_CLK_CK_DIV2_div2_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV2 of 8bit */
N#define ADC_CLK_CK_DIV2_div4_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):DIV4 of 32bit */
N#define ADC_CLK_CK_DIV2_div4_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):DIV4 of 16bit */
N#define ADC_CLK_CK_DIV2_div4_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):DIV4 of 8bit */
N#define ADC_CLK_CK_DIV2_div5_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):DIV5 of 32bit */
N#define ADC_CLK_CK_DIV2_div5_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):DIV5 of 16bit */
N#define ADC_CLK_CK_DIV2_div5_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):DIV5 of 8bit */
N#define ADC_CLK_CK_DIV2_div6_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):DIV6 of 32bit */
N#define ADC_CLK_CK_DIV2_div6_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):DIV6 of 16bit */
N#define ADC_CLK_CK_DIV2_div6_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):DIV6 of 8bit */
N
N#define ADC_CLK_CK_SEL2_mask_w                      ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define ADC_CLK_CK_SEL2_mask_h0                     ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define ADC_CLK_CK_SEL2_mask_b1                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define ADC_CLK_CK_SEL2_ck_adc_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_ADC of 32bit */
N#define ADC_CLK_CK_SEL2_ck_adc_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_ADC of 16bit */
N#define ADC_CLK_CK_SEL2_ck_adc_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_ADC of 8bit */
N#define ADC_CLK_CK_SEL2_ck_pll_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CK_PLL of 32bit */
N#define ADC_CLK_CK_SEL2_ck_pll_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CK_PLL of 16bit */
N#define ADC_CLK_CK_SEL2_ck_pll_b1                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_PLL of 8bit */
N#define ADC_CLK_CK_SEL2_tm00_trgo_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define ADC_CLK_CK_SEL2_tm00_trgo_h0                ((uint16_t)0x0200)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define ADC_CLK_CK_SEL2_tm00_trgo_b1                ((uint8_t )0x02)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N#define ADC_CLK_CK_SEL2_tm01_trgo_w                 ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define ADC_CLK_CK_SEL2_tm01_trgo_h0                ((uint16_t)0x0300)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define ADC_CLK_CK_SEL2_tm01_trgo_b1                ((uint8_t )0x03)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N#define ADC_CLK_CK_DIV_mask_w                       ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define ADC_CLK_CK_DIV_mask_h0                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define ADC_CLK_CK_DIV_mask_b0                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define ADC_CLK_CK_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define ADC_CLK_CK_DIV_div1_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define ADC_CLK_CK_DIV_div1_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define ADC_CLK_CK_DIV_div2_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define ADC_CLK_CK_DIV_div2_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define ADC_CLK_CK_DIV_div2_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define ADC_CLK_CK_DIV_div4_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define ADC_CLK_CK_DIV_div4_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define ADC_CLK_CK_DIV_div4_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define ADC_CLK_CK_DIV_div16_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV16 of 32bit */
N#define ADC_CLK_CK_DIV_div16_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV16 of 16bit */
N#define ADC_CLK_CK_DIV_div16_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV16 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_WINDTH  [register's definitions]
N *              Offset[0x0C]  ADC window detect threshold register
N ******************************************************************************
N */
N///@{
N#define ADC_WINDTH_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_WINDTH */
N#define ADC_WINDTH_WIND_HT_mask_w                   ((uint32_t)0x0FFF0000)  /*!< Bit Mask of 32bit */
N#define ADC_WINDTH_WIND_HT_mask_h1                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_WINDTH_WIND_HT_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define ADC_WINDTH_WIND_HT_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define ADC_WINDTH_WIND_HT_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_WINDTH_WIND_LT_mask_w                   ((uint32_t)0x00000FFF)  /*!< Bit Mask of 32bit */
N#define ADC_WINDTH_WIND_LT_mask_h0                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_WINDTH_WIND_LT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define ADC_WINDTH_WIND_LT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define ADC_WINDTH_WIND_LT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CR0  [register's definitions]
N *              Offset[0x10]  ADC control register 0
N ******************************************************************************
N */
N///@{
N#define ADC_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CR0 */
N#define ADC_CR0_DMA_EN_mask_w                       ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_DMA_EN_mask_h1                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_DMA_EN_mask_b3                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_DMA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_DMA_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_DMA_EN_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_DMA_EN_enable_w                     ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_DMA_EN_enable_h1                    ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_DMA_EN_enable_b3                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_SMP_SEL_mask_w                      ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_SMP_SEL_mask_h1                     ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_SMP_SEL_mask_b2                     ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_SMP_SEL_shift_w                     (16)                    /*!< Bit Shift of 32bit */
N#define ADC_CR0_SMP_SEL_shift_h1                    (0)                     /*!< Bit Shift of 16bit */
N#define ADC_CR0_SMP_SEL_shift_b2                    (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CR0_LIM_MDS_mask_w                      ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_LIM_MDS_mask_h0                     ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_LIM_MDS_mask_b1                     ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_LIM_MDS_no_operation_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define ADC_CR0_LIM_MDS_no_operation_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define ADC_CR0_LIM_MDS_no_operation_b1             ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define ADC_CR0_LIM_MDS_skip_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):Skip of 32bit */
N#define ADC_CR0_LIM_MDS_skip_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Skip of 16bit */
N#define ADC_CR0_LIM_MDS_skip_b1                     ((uint8_t )0x40)        /*!< Bit Value =(0x1):Skip of 8bit */
N#define ADC_CR0_LIM_MDS_clamp_w                     ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):Clamp of 32bit */
N#define ADC_CR0_LIM_MDS_clamp_h0                    ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Clamp of 16bit */
N#define ADC_CR0_LIM_MDS_clamp_b1                    ((uint8_t )0x80)        /*!< Bit Value =(0x2):Clamp of 8bit */
N
N#define ADC_CR0_CODE_FMT_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_CODE_FMT_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_CODE_FMT_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_CODE_FMT_unsigned_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unsigned of 32bit */
N#define ADC_CR0_CODE_FMT_unsigned_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Unsigned of 16bit */
N#define ADC_CR0_CODE_FMT_unsigned_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Unsigned of 8bit */
N#define ADC_CR0_CODE_FMT_2s_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(1):2S of 32bit */
N#define ADC_CR0_CODE_FMT_2s_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(1):2S of 16bit */
N#define ADC_CR0_CODE_FMT_2s_b1                      ((uint8_t )0x01)        /*!< Bit Value =(1):2S of 8bit */
N
N#define ADC_CR0_RES_SEL_mask_w                      ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_RES_SEL_mask_h0                     ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_RES_SEL_mask_b0                     ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_RES_SEL_12_bit_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):12-bit of 32bit */
N#define ADC_CR0_RES_SEL_12_bit_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):12-bit of 16bit */
N#define ADC_CR0_RES_SEL_12_bit_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):12-bit of 8bit */
N#define ADC_CR0_RES_SEL_10_bit_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):10-bit of 32bit */
N#define ADC_CR0_RES_SEL_10_bit_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(0x1):10-bit of 16bit */
N#define ADC_CR0_RES_SEL_10_bit_b0                   ((uint8_t )0x40)        /*!< Bit Value =(0x1):10-bit of 8bit */
N#define ADC_CR0_RES_SEL_8_bit_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):8-bit of 32bit */
N#define ADC_CR0_RES_SEL_8_bit_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(0x2):8-bit of 16bit */
N#define ADC_CR0_RES_SEL_8_bit_b0                    ((uint8_t )0x80)        /*!< Bit Value =(0x2):8-bit of 8bit */
N
N#define ADC_CR0_DTEST_EN_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_DTEST_EN_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_DTEST_EN_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_DTEST_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_DTEST_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_DTEST_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_DTEST_EN_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_DTEST_EN_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_DTEST_EN_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_MDS_mask_w                          ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_MDS_mask_h0                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_MDS_mask_b0                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_MDS_single_end_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Single-End of 32bit */
N#define ADC_CR0_MDS_single_end_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Single-End of 16bit */
N#define ADC_CR0_MDS_single_end_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Single-End of 8bit */
N#define ADC_CR0_MDS_differential_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):Differential of 32bit */
N#define ADC_CR0_MDS_differential_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Differential of 16bit */
N#define ADC_CR0_MDS_differential_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):Differential of 8bit */
N
N#define ADC_CR0_WAIT_EN_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_WAIT_EN_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_WAIT_EN_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_WAIT_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_WAIT_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_WAIT_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_WAIT_EN_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_WAIT_EN_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_WAIT_EN_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_AUTOFF_EN_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_AUTOFF_EN_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_AUTOFF_EN_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_AUTOFF_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_AUTOFF_EN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_AUTOFF_EN_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_AUTOFF_EN_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_AUTOFF_EN_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_AUTOFF_EN_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CR1  [register's definitions]
N *              Offset[0x14]  ADC control register 1
N ******************************************************************************
N */
N///@{
N#define ADC_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CR1 */
N#define ADC_CR1_DOS_VAL_mask_w                      ((uint32_t)0x1F000000)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_DOS_VAL_mask_h1                     ((uint16_t)0x1F00)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_DOS_VAL_mask_b3                     ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_DOS_VAL_shift_w                     (24)                    /*!< Bit Shift of 32bit */
N#define ADC_CR1_DOS_VAL_shift_h1                    (8)                     /*!< Bit Shift of 16bit */
N#define ADC_CR1_DOS_VAL_shift_b3                    (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CR1_SUM_NUM_mask_w                      ((uint32_t)0x007F0000)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_SUM_NUM_mask_h1                     ((uint16_t)0x007F)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_SUM_NUM_mask_b2                     ((uint8_t )0x7F)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_SUM_NUM_shift_w                     (16)                    /*!< Bit Shift of 32bit */
N#define ADC_CR1_SUM_NUM_shift_h1                    (0)                     /*!< Bit Shift of 16bit */
N#define ADC_CR1_SUM_NUM_shift_b2                    (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CR1_SUM_MDS_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_SUM_MDS_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_SUM_MDS_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_SUM_MDS_single_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Single of 32bit */
N#define ADC_CR1_SUM_MDS_single_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Single of 16bit */
N#define ADC_CR1_SUM_MDS_single_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Single of 8bit */
N#define ADC_CR1_SUM_MDS_all_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(1):All of 32bit */
N#define ADC_CR1_SUM_MDS_all_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(1):All of 16bit */
N#define ADC_CR1_SUM_MDS_all_b1                      ((uint8_t )0x04)        /*!< Bit Value =(1):All of 8bit */
N
N#define ADC_CR1_SOVR_MDS_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_SOVR_MDS_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_SOVR_MDS_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_SOVR_MDS_overwritten_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define ADC_CR1_SOVR_MDS_overwritten_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define ADC_CR1_SOVR_MDS_overwritten_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define ADC_CR1_SOVR_MDS_keep_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Keep of 32bit */
N#define ADC_CR1_SOVR_MDS_keep_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Keep of 16bit */
N#define ADC_CR1_SOVR_MDS_keep_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define ADC_CR1_OVR_MDS_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_OVR_MDS_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_OVR_MDS_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_OVR_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define ADC_CR1_OVR_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define ADC_CR1_OVR_MDS_overwritten_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define ADC_CR1_OVR_MDS_keep_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Keep of 32bit */
N#define ADC_CR1_OVR_MDS_keep_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Keep of 16bit */
N#define ADC_CR1_OVR_MDS_keep_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define ADC_CR1_OUT_SEL_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_OUT_SEL_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_OUT_SEL_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_OUT_SEL_wdl_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):WDL of 32bit */
N#define ADC_CR1_OUT_SEL_wdl_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):WDL of 16bit */
N#define ADC_CR1_OUT_SEL_wdl_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):WDL of 8bit */
N#define ADC_CR1_OUT_SEL_wdi_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):WDI of 32bit */
N#define ADC_CR1_OUT_SEL_wdi_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):WDI of 16bit */
N#define ADC_CR1_OUT_SEL_wdi_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):WDI of 8bit */
N#define ADC_CR1_OUT_SEL_wdh_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):WDH of 32bit */
N#define ADC_CR1_OUT_SEL_wdh_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):WDH of 16bit */
N#define ADC_CR1_OUT_SEL_wdh_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):WDH of 8bit */
N#define ADC_CR1_OUT_SEL_rdy_w                       ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):RDY of 32bit */
N#define ADC_CR1_OUT_SEL_rdy_h0                      ((uint16_t)0x0030)      /*!< Bit Value =(0x3):RDY of 16bit */
N#define ADC_CR1_OUT_SEL_rdy_b0                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):RDY of 8bit */
N
N#define ADC_CR1_ALIGN_SEL_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_ALIGN_SEL_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_ALIGN_SEL_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_ALIGN_SEL_right_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Right of 32bit */
N#define ADC_CR1_ALIGN_SEL_right_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Right of 16bit */
N#define ADC_CR1_ALIGN_SEL_right_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Right of 8bit */
N#define ADC_CR1_ALIGN_SEL_left_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Left of 32bit */
N#define ADC_CR1_ALIGN_SEL_left_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Left of 16bit */
N#define ADC_CR1_ALIGN_SEL_left_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Left of 8bit */
N
N#define ADC_CR1_WIND_MDS_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_WIND_MDS_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_WIND_MDS_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_WIND_MDS_single_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Single of 32bit */
N#define ADC_CR1_WIND_MDS_single_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Single of 16bit */
N#define ADC_CR1_WIND_MDS_single_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Single of 8bit */
N#define ADC_CR1_WIND_MDS_all_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):All of 32bit */
N#define ADC_CR1_WIND_MDS_all_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):All of 16bit */
N#define ADC_CR1_WIND_MDS_all_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):All of 8bit */
N
N#define ADC_CR1_WIND_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_WIND_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_WIND_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_WIND_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR1_WIND_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR1_WIND_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR1_WIND_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR1_WIND_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR1_WIND_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_MSK  [register's definitions]
N *              Offset[0x1C]  ADC channel mask register
N ******************************************************************************
N */
N///@{
N#define ADC_MSK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_MSK */
N#define ADC_MSK_SUM2_MUX_mask_w                     ((uint32_t)0x0F000000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_SUM2_MUX_mask_h1                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_SUM2_MUX_mask_b3                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_SUM2_MUX_shift_w                    (24)                    /*!< Bit Shift of 32bit */
N#define ADC_MSK_SUM2_MUX_shift_h1                   (8)                     /*!< Bit Shift of 16bit */
N#define ADC_MSK_SUM2_MUX_shift_b3                   (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_MSK_SUM1_MUX_mask_w                     ((uint32_t)0x00F00000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_SUM1_MUX_mask_h1                    ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_SUM1_MUX_mask_b2                    ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_SUM1_MUX_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_MSK_SUM1_MUX_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_MSK_SUM1_MUX_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_MSK_SUM0_MUX_mask_w                     ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_SUM0_MUX_mask_h1                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_SUM0_MUX_mask_b2                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_SUM0_MUX_shift_w                    (16)                    /*!< Bit Shift of 32bit */
N#define ADC_MSK_SUM0_MUX_shift_h1                   (0)                     /*!< Bit Shift of 16bit */
N#define ADC_MSK_SUM0_MUX_shift_b2                   (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_MSK_CH_MSK15_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK15_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK15_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK15_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK15_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK15_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK15_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK15_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK15_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK14_mask_w                     ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK14_mask_h0                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK14_mask_b1                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK14_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK14_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK14_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK14_enable_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK14_enable_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK14_enable_b1                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK13_mask_w                     ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK13_mask_h0                    ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK13_mask_b1                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK13_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK13_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK13_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK13_enable_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK13_enable_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK13_enable_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK12_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK12_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK12_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK12_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK12_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK12_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK12_enable_w                   ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK12_enable_h0                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK12_enable_b1                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK11_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK11_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK11_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK11_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK11_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK11_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK11_enable_w                   ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK11_enable_h0                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK11_enable_b1                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK10_mask_w                     ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK10_mask_h0                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK10_mask_b1                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK10_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK10_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK10_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK10_enable_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK10_enable_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK10_enable_b1                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK9_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK9_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK9_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK9_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK9_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK9_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK9_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK9_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK9_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK8_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK8_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK8_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK8_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK8_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK8_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK8_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK8_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK8_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK7_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK7_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK7_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK7_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK7_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK7_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK7_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK7_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK7_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK6_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK6_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK6_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK6_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK6_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK6_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK6_enable_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK6_enable_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK6_enable_b0                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK5_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK5_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK5_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK5_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK5_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK5_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK5_enable_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK5_enable_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK5_enable_b0                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK4_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK4_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK4_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK4_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK4_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK4_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK4_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK4_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK4_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK3_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK3_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK3_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK3_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK3_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK3_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK3_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK3_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK3_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK2_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK2_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK2_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK2_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK2_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK2_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK2_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK2_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK2_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK1_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK1_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK1_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK1_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK1_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK1_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK1_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK1_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK0_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK0_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK0_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK0_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK0_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK0_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK0_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK0_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_START  [register's definitions]
N *              Offset[0x20]  ADC start conversion register
N ******************************************************************************
N */
N///@{
N#define ADC_START_default                           ((uint32_t)0x00001000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_START */
N#define ADC_START_CONV_MDS_mask_w                   ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define ADC_START_CONV_MDS_mask_h1                  ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define ADC_START_CONV_MDS_mask_b3                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define ADC_START_CONV_MDS_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define ADC_START_CONV_MDS_one_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define ADC_START_CONV_MDS_one_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define ADC_START_CONV_MDS_scan_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Scan of 32bit */
N#define ADC_START_CONV_MDS_scan_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Scan of 16bit */
N#define ADC_START_CONV_MDS_scan_b3                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):Scan of 8bit */
N#define ADC_START_CONV_MDS_loop_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):Loop of 32bit */
N#define ADC_START_CONV_MDS_loop_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Loop of 16bit */
N#define ADC_START_CONV_MDS_loop_b3                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Loop of 8bit */
N
N#define ADC_START_TRG_SEL_mask_w                    ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define ADC_START_TRG_SEL_mask_h1                   ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define ADC_START_TRG_SEL_mask_b2                   ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define ADC_START_TRG_SEL_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define ADC_START_TRG_SEL_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define ADC_START_TRG_SEL_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define ADC_START_TRG_SEL_rising_edge_w             ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define ADC_START_TRG_SEL_rising_edge_h1            ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define ADC_START_TRG_SEL_rising_edge_b2            ((uint8_t )0x10)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define ADC_START_TRG_SEL_falling_edge_w            ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define ADC_START_TRG_SEL_falling_edge_h1           ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define ADC_START_TRG_SEL_falling_edge_b2           ((uint8_t )0x20)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define ADC_START_TRG_SEL_dual_edge_w               ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define ADC_START_TRG_SEL_dual_edge_h1              ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define ADC_START_TRG_SEL_dual_edge_b2              ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define ADC_START_TRG_CONT_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define ADC_START_TRG_CONT_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_START_TRG_CONT_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_START_TRG_CONT_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_START_TRG_CONT_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_START_TRG_CONT_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_START_TRG_CONT_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_START_TRG_CONT_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_START_TRG_CONT_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_START_START_SEL_mask_w                  ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define ADC_START_START_SEL_mask_h1                 ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define ADC_START_START_SEL_mask_b2                 ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define ADC_START_START_SEL_sw_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SW of 32bit */
N#define ADC_START_START_SEL_sw_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SW of 16bit */
N#define ADC_START_START_SEL_sw_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):SW of 8bit */
N#define ADC_START_START_SEL_tm00_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):TM00 of 32bit */
N#define ADC_START_START_SEL_tm00_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):TM00 of 16bit */
N#define ADC_START_START_SEL_tm00_b2                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):TM00 of 8bit */
N#define ADC_START_START_SEL_pin_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):PIN of 32bit */
N#define ADC_START_START_SEL_pin_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(0x2):PIN of 16bit */
N#define ADC_START_START_SEL_pin_b2                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):PIN of 8bit */
N#define ADC_START_START_SEL_cmp0_w                  ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):CMP0 of 32bit */
N#define ADC_START_START_SEL_cmp0_h1                 ((uint16_t)0x0003)      /*!< Bit Value =(0x3):CMP0 of 16bit */
N#define ADC_START_START_SEL_cmp0_b2                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):CMP0 of 8bit */
N#define ADC_START_START_SEL_cmp1_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):CMP1 of 32bit */
N#define ADC_START_START_SEL_cmp1_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(0x4):CMP1 of 16bit */
N#define ADC_START_START_SEL_cmp1_b2                 ((uint8_t )0x04)        /*!< Bit Value =(0x4):CMP1 of 8bit */
N#define ADC_START_START_SEL_tm01_w                  ((uint32_t)0x00050000)  /*!< Bit Value =(0x5):TM01 of 32bit */
N#define ADC_START_START_SEL_tm01_h1                 ((uint16_t)0x0005)      /*!< Bit Value =(0x5):TM01 of 16bit */
N#define ADC_START_START_SEL_tm01_b2                 ((uint8_t )0x05)        /*!< Bit Value =(0x5):TM01 of 8bit */
N#define ADC_START_START_SEL_tm20_w                  ((uint32_t)0x00060000)  /*!< Bit Value =(0x6):TM20 of 32bit */
N#define ADC_START_START_SEL_tm20_h1                 ((uint16_t)0x0006)      /*!< Bit Value =(0x6):TM20 of 16bit */
N#define ADC_START_START_SEL_tm20_b2                 ((uint8_t )0x06)        /*!< Bit Value =(0x6):TM20 of 8bit */
N#define ADC_START_START_SEL_tm36_w                  ((uint32_t)0x00070000)  /*!< Bit Value =(0x7):TM36 of 32bit */
N#define ADC_START_START_SEL_tm36_h1                 ((uint16_t)0x0007)      /*!< Bit Value =(0x7):TM36 of 16bit */
N#define ADC_START_START_SEL_tm36_b2                 ((uint8_t )0x07)        /*!< Bit Value =(0x7):TM36 of 8bit */
N
N#define ADC_START_CH_SEL_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_START_CH_SEL_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_START_CH_SEL_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_START_CH_SEL_ext_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):EXT of 32bit */
N#define ADC_START_CH_SEL_ext_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):EXT of 16bit */
N#define ADC_START_CH_SEL_ext_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):EXT of 8bit */
N#define ADC_START_CH_SEL_int_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):INT of 32bit */
N#define ADC_START_CH_SEL_int_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):INT of 16bit */
N#define ADC_START_CH_SEL_int_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):INT of 8bit */
N
N#define ADC_START_CH_MUX_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define ADC_START_CH_MUX_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define ADC_START_CH_MUX_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N
N#define ADC_START_HOLD_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_START_HOLD_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_START_HOLD_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_START_HOLD_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_START_HOLD_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_START_HOLD_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_START_HOLD_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_START_HOLD_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_START_HOLD_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_START_START_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_START_START_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_START_START_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_START_START_shift_w                     (0)                     /*!< Bit Shift of 32bit */
N#define ADC_START_START_shift_h0                    (0)                     /*!< Bit Shift of 16bit */
N#define ADC_START_START_shift_b0                    (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_ANA  [register's definitions]
N *              Offset[0x24]  ADC analog control register
N ******************************************************************************
N */
N///@{
N#define ADC_ANA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_ANA */
N#define ADC_ANA_BUF_BIAS_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_ANA_BUF_BIAS_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_ANA_BUF_BIAS_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_ANA_BUF_BIAS_shift_w                    (12)                    /*!< Bit Shift of 32bit */
N#define ADC_ANA_BUF_BIAS_shift_h0                   (12)                    /*!< Bit Shift of 16bit */
N#define ADC_ANA_BUF_BIAS_shift_b1                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_ANA_PGAOUT_EN_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_ANA_PGAOUT_EN_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_ANA_PGAOUT_EN_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_ANA_PGAOUT_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_ANA_PGAOUT_EN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_ANA_PGAOUT_EN_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_ANA_PGAOUT_EN_enable_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_ANA_PGAOUT_EN_enable_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_ANA_PGAOUT_EN_enable_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_ANA_PGA_EN_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_ANA_PGA_EN_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_ANA_PGA_EN_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_ANA_PGA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_ANA_PGA_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_ANA_PGA_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_ANA_PGA_EN_enable_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_ANA_PGA_EN_enable_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_ANA_PGA_EN_enable_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CAL  [register's definitions]
N *              Offset[0x28]  ADC calibration control register
N ******************************************************************************
N */
N///@{
N#define ADC_CAL_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CAL */
N#define ADC_CAL_REFT_mask_w                         ((uint32_t)0x3F000000)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_REFT_mask_h1                        ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_REFT_mask_b3                        ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_REFT_shift_w                        (24)                    /*!< Bit Shift of 32bit */
N#define ADC_CAL_REFT_shift_h1                       (8)                     /*!< Bit Shift of 16bit */
N#define ADC_CAL_REFT_shift_b3                       (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CAL_REFM_mask_w                         ((uint32_t)0x003F0000)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_REFM_mask_h1                        ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_REFM_mask_b2                        ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_REFM_shift_w                        (16)                    /*!< Bit Shift of 32bit */
N#define ADC_CAL_REFM_shift_h1                       (0)                     /*!< Bit Shift of 16bit */
N#define ADC_CAL_REFM_shift_b2                       (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CAL_REFB_mask_w                         ((uint32_t)0x00003F00)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_REFB_mask_h0                        ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_REFB_mask_b1                        ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_REFB_shift_w                        (8)                     /*!< Bit Shift of 32bit */
N#define ADC_CAL_REFB_shift_h0                       (8)                     /*!< Bit Shift of 16bit */
N#define ADC_CAL_REFB_shift_b1                       (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CAL_CAL_POFFT_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_CAL_POFFT_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_CAL_POFFT_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_CAL_POFFT_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CAL_CAL_POFFT_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CAL_CAL_POFFT_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CAL_CAL_POFFT_enable_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CAL_CAL_POFFT_enable_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CAL_CAL_POFFT_enable_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CAL_CAL_AZEN_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_CAL_AZEN_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_CAL_AZEN_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_CAL_AZEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CAL_CAL_AZEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CAL_CAL_AZEN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CAL_CAL_AZEN_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CAL_CAL_AZEN_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CAL_CAL_AZEN_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_GAIN  [register's definitions]
N *              Offset[0x2C]  ADC gain control register
N ******************************************************************************
N */
N///@{
N#define ADC_GAIN_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_GAIN */
N#define ADC_GAIN_OFFT_PGA_mask_w                    ((uint32_t)0x003F0000)  /*!< Bit Mask of 32bit */
N#define ADC_GAIN_OFFT_PGA_mask_h1                   ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define ADC_GAIN_OFFT_PGA_mask_b2                   ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_GAIN_OFFT_PGA_shift_w                   (16)                    /*!< Bit Shift of 32bit */
N#define ADC_GAIN_OFFT_PGA_shift_h1                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_GAIN_OFFT_PGA_shift_b2                  (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_GAIN_GAIN_PGA_mask_w                    ((uint32_t)0x0000003F)  /*!< Bit Mask of 32bit */
N#define ADC_GAIN_GAIN_PGA_mask_h0                   ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define ADC_GAIN_GAIN_PGA_mask_b0                   ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_GAIN_GAIN_PGA_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_GAIN_GAIN_PGA_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_GAIN_GAIN_PGA_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_SUM0  [register's definitions]
N *              Offset[0x30]  ADC accumulator sum result register 0
N ******************************************************************************
N */
N///@{
N#define ADC_SUM0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_SUM0 */
N#define ADC_SUM0_SUM0_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_OF_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_OF_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_OF_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_OF_shift_w                    (21)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_OF_shift_h1                   (5)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_OF_shift_b2                   (5)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_UF_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_UF_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_UF_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_UF_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_UF_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_UF_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_DAT_mask_w                    ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_DAT_mask_h0                   ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_SUM1  [register's definitions]
N *              Offset[0x34]  ADC accumulator sum result register 1
N ******************************************************************************
N */
N///@{
N#define ADC_SUM1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_SUM1 */
N#define ADC_SUM1_SUM1_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_OF_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_OF_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_OF_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_OF_shift_w                    (21)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_OF_shift_h1                   (5)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_OF_shift_b2                   (5)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_UF_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_UF_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_UF_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_UF_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_UF_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_UF_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_DAT_mask_w                    ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_DAT_mask_h0                   ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_SUM2  [register's definitions]
N *              Offset[0x38]  ADC accumulator sum result register 2
N ******************************************************************************
N */
N///@{
N#define ADC_SUM2_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_SUM2 */
N#define ADC_SUM2_SUM2_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_OF_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_OF_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_OF_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_OF_shift_w                    (21)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_OF_shift_h1                   (5)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_OF_shift_b2                   (5)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_UF_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_UF_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_UF_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_UF_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_UF_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_UF_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_DAT_mask_w                    ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_DAT_mask_h0                   ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_TCAL  [register's definitions]
N *              Offset[0x3C]  ADC Temperature Sensor calibration register
N ******************************************************************************
N */
N///@{
N#define ADC_TCAL_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_TCAL */
N#define ADC_TCAL_TCAL1_mask_w                       ((uint32_t)0x0FFF0000)  /*!< Bit Mask of 32bit */
N#define ADC_TCAL_TCAL1_mask_h1                      ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_TCAL_TCAL1_shift_w                      (16)                    /*!< Bit Shift of 32bit */
N#define ADC_TCAL_TCAL1_shift_h1                     (0)                     /*!< Bit Shift of 16bit */
N#define ADC_TCAL_TCAL1_shift_b2                     (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_TCAL_TCAL0_mask_w                       ((uint32_t)0x00000FFF)  /*!< Bit Mask of 32bit */
N#define ADC_TCAL_TCAL0_mask_h0                      ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_TCAL_TCAL0_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define ADC_TCAL_TCAL0_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define ADC_TCAL_TCAL0_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_DAT0  [register's definitions]
N *              Offset[0x40]  ADC conversion data register 0
N ******************************************************************************
N */
N///@{
N#define ADC_DAT0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_DAT0 */
N#define ADC_DAT0_DAT0_CH_mask_w                     ((uint32_t)0xF0000000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_CH_mask_h1                    ((uint16_t)0xF000)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_CH_mask_b3                    ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_CH_shift_w                    (28)                    /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_CH_shift_h1                   (12)                    /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_CH_shift_b3                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_DAT0_DAT0_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_DAT0_DAT0_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_DAT0_DAT0_WDHF_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_WDHF_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_WDHF_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_WDHF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_DAT0_DAT0_WDHF_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_DAT0_DAT0_WDHF_normal_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_DAT0_DAT0_WDHF_happened_w               ((uint32_t)0x00040000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_DAT0_DAT0_WDHF_happened_h1              ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_DAT0_DAT0_WDHF_happened_b2              ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_DAT0_DAT0_WDIF_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_WDIF_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_WDIF_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_WDIF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_DAT0_DAT0_WDIF_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_DAT0_DAT0_WDIF_normal_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_DAT0_DAT0_WDIF_happened_w               ((uint32_t)0x00020000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_DAT0_DAT0_WDIF_happened_h1              ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_DAT0_DAT0_WDIF_happened_b2              ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_DAT0_DAT0_WDLF_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_WDLF_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_WDLF_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_WDLF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_DAT0_DAT0_WDLF_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_DAT0_DAT0_WDLF_normal_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_DAT0_DAT0_WDLF_happened_w               ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_DAT0_DAT0_WDLF_happened_h1              ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_DAT0_DAT0_WDLF_happened_b2              ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_DAT0_DAT0_mask_w                        ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_mask_h0                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_ADC_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_ADC.h                         */
N/*----------------------------------------------------------------------------*/
L 38 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N#include "MG32x02z_CFG_DRV.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CFG_DRV.H" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_CFG_DRV.H
N *
N * @brief       This is the C code format driver head file for CFG module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.13
N * @date        2021/01/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_CFG.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_CFG.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CFG.h
N *
N * @brief       MG32x02z CFG Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_CFG_H
N#define _MG32x02z_CFG_H
N#define _MG32x02z_CFG_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_CFG_H_VER)
S    #error "MG32x02z_CFG_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      CFG_Struct
N *              CFG  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    __I uint32_t  RESERVED0[3];         /*!< RESERVED0  ~ Offset[0x00]  Reserved */
X    volatile const uint32_t  RESERVED0[3];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] CFG key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  CFG write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  BOOT_MS       :2;     //[1..0] System cold reset boot memory select and memory is mapped at 0x0000 0000
X            volatile const  uint8_t  BOOT_MS       :2;     
N                                        //0x0 = Application Flash
N                                        //0x1 = Boot Flash
N                                        //0x2 = Embedded SRAM
N                                        //0x3 = Reserved
N            __I  uint8_t                :5;     //[6..2] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  LOCK_DIS      :1;     //[8] Main Flash code locked enable
X            volatile const  uint8_t  LOCK_DIS      :1;     
N                                        //0 = Enable
N                                        //1 = Disable (Code dump on Writer is transparent)
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t  BOD1_TH       :2;     //[17..16] BOD1 detect voltage threshold select.
X            volatile const  uint8_t  BOD1_TH       :2;     
N                                        //0x0 = 2.0v
N                                        //0x1 = 2.4v
N                                        //0x2 = 3.7v
N                                        //0x3 = 4.2v
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  BOD0_WE       :1;     //[24] BOD0 trigger Warm reset enable
X            volatile const  uint8_t  BOD0_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t  BOD1_WE       :1;     //[25] BOD1 trigger Warm reset enable
X            volatile const  uint8_t  BOD1_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }OR00;                              /*!< OR00       ~ Offset[0x10]  CFG option byte register 00 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  IAP_SIZE      :8;     //[15..8] IAP memory size select
X            volatile const  uint8_t  IAP_SIZE      :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR01;                              /*!< OR01       ~ Offset[0x14]  CFG option byte register 01 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  ISP_SIZE      :8;     //[15..8] ISP memory size select
X            volatile const  uint8_t  ISP_SIZE      :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR02;                              /*!< OR02       ~ Offset[0x18]  CFG option byte register 02 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  IWDT_EN       :1;     //[0] IWDT enable after Cold reset
X            volatile const  uint8_t  IWDT_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t  IWDT_WP       :1;     //[1] IWDT registers write protected enable
X            volatile const  uint8_t  IWDT_WP       :1;     
N                                        //0 = Disable
N                                        //1 = Enable : Write-protected
N            __I  uint8_t  IWDT_WE       :1;     //[2] IWDT reset generation enable option
X            volatile const  uint8_t  IWDT_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  IWDT_DIV      :4;     //[7..4] IWDT internal clock CK_IWDT_INT input divider select
X            volatile const  uint8_t  IWDT_DIV      :4;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N                                        //0x5 = DIV32 : divided by 32
N                                        //0x6 = DIV64 : divided by 64
N                                        //0x7 = DIV128 : divided by 128
N                                        //0x8 = DIV256 : divided by 256 
N                                        //0x9 = DIV512 : divided by 512
N                                        //0xA = DIV1024 : divided by 1024
N                                        //0xB = DIV2048 : divided by 2048
N                                        //0xC = DIV4096 : divided by 4096
N            __I  uint8_t  IWDT_SLP      :1;     //[8] IWDT counting control when chip in SLEEP mode
X            volatile const  uint8_t  IWDT_SLP      :1;     
N                                        //0 = Stop : Stop counting
N                                        //1 = Keep : Keep counting
N            __I  uint8_t  IWDT_STP      :1;     //[9] IWDT counting control when chip in STOP mode
X            volatile const  uint8_t  IWDT_STP      :1;     
N                                        //0 = Stop : Stop counting
N                                        //1 = Keep : Keep counting
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR03;                              /*!< OR03       ~ Offset[0x1C]  CFG option byte register 03 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  IAP_AEN       :1;     //[0] IAP memory size MEM_IAP_SIZE register write  access disable.
X            volatile const  uint8_t  IAP_AEN       :1;     
N                                        //0 = Disable : Register access lock
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[6..2] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  HSP_EN        :1;     //[7] Flash memory high speed mode enable.
X            volatile const  uint8_t  HSP_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR04;                              /*!< OR04       ~ Offset[0x20]  CFG option byte register 04 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  EXRST_PIN     :1;     //[0] External reset pin control after power-on
X            volatile const  uint8_t  EXRST_PIN     :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t  SWD_PIN       :1;     //[1] SWD interface pin control after power-on
X            volatile const  uint8_t  SWD_PIN       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  PON_MDS       :1;     //[8] Fast power-up time mode select.
X            volatile const  uint8_t  PON_MDS       :1;     
N                                        //0= Fast : 4ms
N                                        //1= Slow : 32ms
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  HS_SEL        :1;     //[17] CK_HS clock source select after power-on (Cold reset)
X            volatile const  uint8_t  HS_SEL        :1;     
N                                        //0 = IHRCO
N                                        //1 = ILRCO
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  PLL_CTL       :2;     //[21..20] PLL control bits
X            volatile const  uint8_t  PLL_CTL       :2;     
N            __I  uint8_t  HSWKP         :2;     //[23..22] Wakeup delay selection from STOP mode.
X            volatile const  uint8_t  HSWKP         :2;     
N                                        //0x0 = 0us
N                                        //0x1 = 30us
N                                        //0x2 = 60us
N                                        //0x3 = 120us
N            __I  uint8_t  XOSC_GN       :2;     //[25..24] Gain control bits of XOSC.
X            volatile const  uint8_t  XOSC_GN       :2;     
N                                        //0x0 = 32K_Normal (for 32KHz crystal)
N                                        //0x1 = Medium
N                                        //0x2 = 32K_Lowest (for 32KHz crystal)
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  XOSC_DB       :1;     //[28] XOSC clock debounce cycle select
X            volatile const  uint8_t  XOSC_DB       :1;     
N                                        //0 = 4096
N                                        //1 = 1024
N            __I  uint8_t                :1;     //[29] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[30] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  XOSC_EN       :1;     //[31] XOSC crystal oscillation circuit enable
X            volatile const  uint8_t  XOSC_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }OR05;                              /*!< OR05       ~ Offset[0x24]  CFG option byte register 05 */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x28]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  CG21          :1;     //[1] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  CG21          :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  CG22          :1;     //[2] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  CG22          :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  LVRDE         :1;     //[5] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  LVRDE         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  LVRDS0        :1;     //[6] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  LVRDS0        :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  LVRDS1        :1;     //[7] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  LVRDS1        :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  PNDCE         :1;     //[8] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  PNDCE         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  PNDRC         :1;     //[9] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  PNDRC         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  PORDS         :1;     //[10] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  PORDS         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  DPORDS        :1;     //[11] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  DPORDS        :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  CGIL          :1;     //[12] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  CGIL          :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  GF            :3;     //[15..13] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  GF            :3;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR07;                              /*!< OR07       ~ Offset[0x2C]  CFG option byte register 07 */
N
N    __I uint32_t  RESERVED2;            /*!< RESERVED2  ~ Offset[0x30]  Reserved */
X    volatile const uint32_t  RESERVED2;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  VBG_OTRM      :3;     //[2..0] BandGap reference voltage output trimming bits.
X            volatile uint8_t  VBG_OTRM      :3;     
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  VBG_BTRM      :4;     //[11..8] BandGap buffer output trimming bits.
X            volatile uint8_t  VBG_BTRM      :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DAC_CTRM0     :5;     //[20..16] DAC-0 output current trimming bits.
X            volatile uint8_t  DAC_CTRM0     :5;     
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OR11;                              /*!< OR11       ~ Offset[0x34]  CFG option byte register 11 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  BOD1_TRM      :4;     //[11..8] Reserved
X            volatile uint8_t  BOD1_TRM      :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  LVR_TRM       :4;     //[19..16] Reserved
X            volatile uint8_t  LVR_TRM       :4;     
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OR12;                              /*!< OR12       ~ Offset[0x38]  CFG option byte register 12 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IHR0_FTRM     :7;     //[6..0] Reserved
X            volatile uint8_t  IHR0_FTRM     :7;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IHR0_CTRM     :2;     //[9..8] Reserved
X            volatile uint8_t  IHR0_CTRM     :2;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IHR1_FTRM     :7;     //[22..16] Reserved
X            volatile uint8_t  IHR1_FTRM     :7;     
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IHR1_CTRM     :2;     //[25..24] Reserved
X            volatile uint8_t  IHR1_CTRM     :2;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }OR13;                              /*!< OR13       ~ Offset[0x3C]  CFG option byte register 13 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ILR_TRM       :2;     //[1..0] Reserved
X            volatile uint8_t  ILR_TRM       :2;     
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IHR_BGTV      :2;     //[9..8] Reserved
X            volatile uint8_t  IHR_BGTV      :2;     
N            __I  uint8_t                :3;     //[12..10] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  IHR_BGTI      :3;     //[15..13] Reserved
X            volatile uint8_t  IHR_BGTI      :3;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR14;                              /*!< OR14       ~ Offset[0x40]  CFG option byte register 14 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  ADC0_REFB     :6;     //[13..8] ADC0 reference voltage bottom level setting.
X            volatile uint8_t  ADC0_REFB     :6;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  ADC0_REFM     :6;     //[21..16] ADC0 reference voltage middle level setting.
X            volatile uint8_t  ADC0_REFM     :6;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  ADC0_REFT     :6;     //[29..24] ADC0 reference voltage top level setting.
X            volatile uint8_t  ADC0_REFT     :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }OR15;                              /*!< OR15       ~ Offset[0x44]  CFG option byte register 15 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t TEMP_CAL0     :12;    //[11..0] Temperature Sensor calibration value acquired at 25 degree-C.
X            volatile uint16_t TEMP_CAL0     :12;    
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint16_t TEMP_CAL1     :12;    //[27..16] Temperature Sensor calibration value acquired at 60 degree-C.
X            volatile uint16_t TEMP_CAL1     :12;    
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }OR16;                              /*!< OR16       ~ Offset[0x48]  CFG option byte register 16 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  LDO_TRM       :3;     //[2..0] Reserved
X            volatile uint8_t  LDO_TRM       :3;     
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR17;                              /*!< OR17       ~ Offset[0x4C]  CFG option byte register 17 */
N
N    __I uint32_t  RESERVED3[4];         /*!< RESERVED3  ~ Offset[0x50]  Reserved */
X    volatile const uint32_t  RESERVED3[4];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  POF0          :1;     //[0] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  POF0          :1;     
N            __IO uint8_t  POF1          :1;     //[1] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  POF1          :1;     
N            __IO uint8_t  POF2          :1;     //[2] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  POF2          :1;     
N            __IO uint8_t  DPORF         :1;     //[3] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  DPORF         :1;     
N            __IO uint8_t  LVRF0         :1;     //[4] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  LVRF0         :1;     
N            __IO uint8_t  DBLVRF        :1;     //[5] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  DBLVRF        :1;     
N            __IO uint8_t  PNDF          :1;     //[6] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  PNDF          :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }TST0;                              /*!< TST0       ~ Offset[0x60]  CFG Test register 0 (not load from flash memory) */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  FLH_WE        :1;     //[0] Enable flash write operation when BOD0 active(low voltage).
X            volatile uint8_t  FLH_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  BOD_OE        :1;     //[8] BOD0/1 output enable
X            volatile uint8_t  BOD_OE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LVR_DIS       :1;     //[9] LVR disable bit
X            volatile uint8_t  LVR_DIS       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IHRCK_OE      :1;     //[16] IHRCO clock output enable
X            volatile uint8_t  IHRCK_OE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ILRCK_OE      :1;     //[17] ILRCO clock output enable
X            volatile uint8_t  ILRCK_OE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ILRCO_EN      :1;     //[18] Internal Low frequency RC Oscillator Enable
X            volatile uint8_t  ILRCO_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  PLL_TST       :1;     //[24] PLL test enable.
X            volatile uint8_t  PLL_TST       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }TST1;                              /*!< TST1       ~ Offset[0x64]  CFG Test register 1 (not load from flash memory) */
N
N} CFG_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        CFG  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define CFG_Base                        ((uint32_t)0x4FF00000)              /*!< Hardware Option Bytes Configure Control */
N#define CFG                             ((CFG_Struct*) CFG_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        CFG  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        CFG_KEY  [register's definitions]
N *              Offset[0x0C]  CFG write protected Key register (0x4FF0000C)
N ******************************************************************************
N */
N///@{
N#define CFG_KEY_default                             ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_KEY */
N#define CFG_KEY_KEY_mask_w                          ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define CFG_KEY_KEY_mask_h0                         ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define CFG_KEY_KEY_unprotected_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define CFG_KEY_KEY_unprotected_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define CFG_KEY_KEY_unprotected_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define CFG_KEY_KEY_protected_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define CFG_KEY_KEY_protected_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define CFG_KEY_KEY_protected_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR00  [register's definitions]
N *              Offset[0x10]  CFG option byte register 00 (0x4FF00010)
N ******************************************************************************
N */
N///@{
N#define CFG_OR00_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR00 */
N#define CFG_OR00_BOD1_WE_mask_w                     ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOD1_WE_mask_h1                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOD1_WE_mask_b3                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOD1_WE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR00_BOD1_WE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR00_BOD1_WE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR00_BOD1_WE_enable_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR00_BOD1_WE_enable_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR00_BOD1_WE_enable_b3                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR00_BOD0_WE_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOD0_WE_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOD0_WE_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOD0_WE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR00_BOD0_WE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR00_BOD0_WE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR00_BOD0_WE_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR00_BOD0_WE_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR00_BOD0_WE_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR00_BOD1_TH_mask_w                     ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOD1_TH_mask_h1                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOD1_TH_mask_b2                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOD1_TH_2_0v_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):2.0v of 32bit */
N#define CFG_OR00_BOD1_TH_2_0v_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):2.0v of 16bit */
N#define CFG_OR00_BOD1_TH_2_0v_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):2.0v of 8bit */
N#define CFG_OR00_BOD1_TH_2_4v_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):2.4v of 32bit */
N#define CFG_OR00_BOD1_TH_2_4v_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):2.4v of 16bit */
N#define CFG_OR00_BOD1_TH_2_4v_b2                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):2.4v of 8bit */
N#define CFG_OR00_BOD1_TH_3_7v_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):3.7v of 32bit */
N#define CFG_OR00_BOD1_TH_3_7v_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(0x2):3.7v of 16bit */
N#define CFG_OR00_BOD1_TH_3_7v_b2                    ((uint8_t )0x02)        /*!< Bit Value =(0x2):3.7v of 8bit */
N#define CFG_OR00_BOD1_TH_4_2v_w                     ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):4.2v of 32bit */
N#define CFG_OR00_BOD1_TH_4_2v_h1                    ((uint16_t)0x0003)      /*!< Bit Value =(0x3):4.2v of 16bit */
N#define CFG_OR00_BOD1_TH_4_2v_b2                    ((uint8_t )0x03)        /*!< Bit Value =(0x3):4.2v of 8bit */
N
N#define CFG_OR00_LOCK_DIS_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_LOCK_DIS_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_LOCK_DIS_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_LOCK_DIS_enable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_OR00_LOCK_DIS_enable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_OR00_LOCK_DIS_enable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_OR00_LOCK_DIS_disable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_OR00_LOCK_DIS_disable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_OR00_LOCK_DIS_disable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CFG_OR00_BOOT_MS_mask_w                     ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOOT_MS_mask_h0                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOOT_MS_mask_b0                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOOT_MS_application_flash_w        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Application Flash of 32bit */
N#define CFG_OR00_BOOT_MS_application_flash_h0       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Application Flash of 16bit */
N#define CFG_OR00_BOOT_MS_application_flash_b0       ((uint8_t )0x00)        /*!< Bit Value =(0x0):Application Flash of 8bit */
N#define CFG_OR00_BOOT_MS_boot_flash_w               ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Boot Flash of 32bit */
N#define CFG_OR00_BOOT_MS_boot_flash_h0              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Boot Flash of 16bit */
N#define CFG_OR00_BOOT_MS_boot_flash_b0              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Boot Flash of 8bit */
N#define CFG_OR00_BOOT_MS_embedded_sram_w            ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Embedded SRAM of 32bit */
N#define CFG_OR00_BOOT_MS_embedded_sram_h0           ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Embedded SRAM of 16bit */
N#define CFG_OR00_BOOT_MS_embedded_sram_b0           ((uint8_t )0x02)        /*!< Bit Value =(0x2):Embedded SRAM of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR01  [register's definitions]
N *              Offset[0x14]  CFG option byte register 01 (0x4FF00014)
N ******************************************************************************
N */
N///@{
N#define CFG_OR01_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR01 */
N#define CFG_OR01_IAP_SIZE_mask_w                    ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define CFG_OR01_IAP_SIZE_mask_h0                   ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define CFG_OR01_IAP_SIZE_mask_b1                   ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define CFG_OR01_IAP_SIZE_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR01_IAP_SIZE_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR01_IAP_SIZE_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR02  [register's definitions]
N *              Offset[0x18]  CFG option byte register 02 (0x4FF00018)
N ******************************************************************************
N */
N///@{
N#define CFG_OR02_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR02 */
N#define CFG_OR02_ISP_SIZE_mask_w                    ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define CFG_OR02_ISP_SIZE_mask_h0                   ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define CFG_OR02_ISP_SIZE_mask_b1                   ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define CFG_OR02_ISP_SIZE_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR02_ISP_SIZE_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR02_ISP_SIZE_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR03  [register's definitions]
N *              Offset[0x1C]  CFG option byte register 03 (0x4FF0001C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR03_default                            ((uint32_t)0x000000C0)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR03 */
N#define CFG_OR03_IWDT_STP_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_STP_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_STP_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_STP_stop_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define CFG_OR03_IWDT_STP_stop_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define CFG_OR03_IWDT_STP_stop_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define CFG_OR03_IWDT_STP_keep_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Keep of 32bit */
N#define CFG_OR03_IWDT_STP_keep_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Keep of 16bit */
N#define CFG_OR03_IWDT_STP_keep_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define CFG_OR03_IWDT_SLP_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_SLP_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_SLP_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_SLP_stop_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define CFG_OR03_IWDT_SLP_stop_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define CFG_OR03_IWDT_SLP_stop_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define CFG_OR03_IWDT_SLP_keep_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Keep of 32bit */
N#define CFG_OR03_IWDT_SLP_keep_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Keep of 16bit */
N#define CFG_OR03_IWDT_SLP_keep_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define CFG_OR03_IWDT_DIV_mask_w                    ((uint32_t)0x000000F0)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_DIV_mask_h0                   ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_DIV_mask_b0                   ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_DIV_div1_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CFG_OR03_IWDT_DIV_div1_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CFG_OR03_IWDT_DIV_div1_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CFG_OR03_IWDT_DIV_div2_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CFG_OR03_IWDT_DIV_div2_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CFG_OR03_IWDT_DIV_div2_b0                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CFG_OR03_IWDT_DIV_div4_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CFG_OR03_IWDT_DIV_div4_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CFG_OR03_IWDT_DIV_div4_b0                   ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CFG_OR03_IWDT_DIV_div8_w                    ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CFG_OR03_IWDT_DIV_div8_h0                   ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CFG_OR03_IWDT_DIV_div8_b0                   ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define CFG_OR03_IWDT_DIV_div16_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define CFG_OR03_IWDT_DIV_div16_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define CFG_OR03_IWDT_DIV_div16_b0                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N#define CFG_OR03_IWDT_DIV_div32_w                   ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):DIV32 of 32bit */
N#define CFG_OR03_IWDT_DIV_div32_h0                  ((uint16_t)0x0050)      /*!< Bit Value =(0x5):DIV32 of 16bit */
N#define CFG_OR03_IWDT_DIV_div32_b0                  ((uint8_t )0x50)        /*!< Bit Value =(0x5):DIV32 of 8bit */
N#define CFG_OR03_IWDT_DIV_div64_w                   ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):DIV64 of 32bit */
N#define CFG_OR03_IWDT_DIV_div64_h0                  ((uint16_t)0x0060)      /*!< Bit Value =(0x6):DIV64 of 16bit */
N#define CFG_OR03_IWDT_DIV_div64_b0                  ((uint8_t )0x60)        /*!< Bit Value =(0x6):DIV64 of 8bit */
N#define CFG_OR03_IWDT_DIV_div128_w                  ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):DIV128 of 32bit */
N#define CFG_OR03_IWDT_DIV_div128_h0                 ((uint16_t)0x0070)      /*!< Bit Value =(0x7):DIV128 of 16bit */
N#define CFG_OR03_IWDT_DIV_div128_b0                 ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIV128 of 8bit */
N#define CFG_OR03_IWDT_DIV_div256_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(0x8):DIV256 of 32bit */
N#define CFG_OR03_IWDT_DIV_div256_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(0x8):DIV256 of 16bit */
N#define CFG_OR03_IWDT_DIV_div256_b0                 ((uint8_t )0x80)        /*!< Bit Value =(0x8):DIV256 of 8bit */
N#define CFG_OR03_IWDT_DIV_div512_w                  ((uint32_t)0x00000090)  /*!< Bit Value =(0x9):DIV512 of 32bit */
N#define CFG_OR03_IWDT_DIV_div512_h0                 ((uint16_t)0x0090)      /*!< Bit Value =(0x9):DIV512 of 16bit */
N#define CFG_OR03_IWDT_DIV_div512_b0                 ((uint8_t )0x90)        /*!< Bit Value =(0x9):DIV512 of 8bit */
N#define CFG_OR03_IWDT_DIV_div1024_w                 ((uint32_t)0x000000A0)  /*!< Bit Value =(0xA):DIV1024 of 32bit */
N#define CFG_OR03_IWDT_DIV_div1024_h0                ((uint16_t)0x00A0)      /*!< Bit Value =(0xA):DIV1024 of 16bit */
N#define CFG_OR03_IWDT_DIV_div1024_b0                ((uint8_t )0xA0)        /*!< Bit Value =(0xA):DIV1024 of 8bit */
N#define CFG_OR03_IWDT_DIV_div2048_w                 ((uint32_t)0x000000B0)  /*!< Bit Value =(0xB):DIV2048 of 32bit */
N#define CFG_OR03_IWDT_DIV_div2048_h0                ((uint16_t)0x00B0)      /*!< Bit Value =(0xB):DIV2048 of 16bit */
N#define CFG_OR03_IWDT_DIV_div2048_b0                ((uint8_t )0xB0)        /*!< Bit Value =(0xB):DIV2048 of 8bit */
N#define CFG_OR03_IWDT_DIV_div4096_w                 ((uint32_t)0x000000C0)  /*!< Bit Value =(0xC):DIV4096 of 32bit */
N#define CFG_OR03_IWDT_DIV_div4096_h0                ((uint16_t)0x00C0)      /*!< Bit Value =(0xC):DIV4096 of 16bit */
N#define CFG_OR03_IWDT_DIV_div4096_b0                ((uint8_t )0xC0)        /*!< Bit Value =(0xC):DIV4096 of 8bit */
N
N#define CFG_OR03_IWDT_WE_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_WE_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_WE_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_WE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR03_IWDT_WE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR03_IWDT_WE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR03_IWDT_WE_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR03_IWDT_WE_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR03_IWDT_WE_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR03_IWDT_WP_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_WP_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_WP_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_WP_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR03_IWDT_WP_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR03_IWDT_WP_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR03_IWDT_WP_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR03_IWDT_WP_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR03_IWDT_WP_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR03_IWDT_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR03_IWDT_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR03_IWDT_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR03_IWDT_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR03_IWDT_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR03_IWDT_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR04  [register's definitions]
N *              Offset[0x20]  CFG option byte register 04 (0x4FF00020)
N ******************************************************************************
N */
N///@{
N#define CFG_OR04_default                            ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR04 */
N#define CFG_OR04_HSP_EN_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CFG_OR04_HSP_EN_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CFG_OR04_HSP_EN_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CFG_OR04_HSP_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR04_HSP_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR04_HSP_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR04_HSP_EN_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR04_HSP_EN_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR04_HSP_EN_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR04_IAP_AEN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_OR04_IAP_AEN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_OR04_IAP_AEN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR04_IAP_AEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR04_IAP_AEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR04_IAP_AEN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR04_IAP_AEN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR04_IAP_AEN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR04_IAP_AEN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR05  [register's definitions]
N *              Offset[0x24]  CFG option byte register 05 (0x4FF00024)
N ******************************************************************************
N */
N///@{
N#define CFG_OR05_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR05 */
N#define CFG_OR05_XOSC_EN_mask_w                     ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_XOSC_EN_mask_h1                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_XOSC_EN_mask_b3                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_XOSC_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR05_XOSC_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR05_XOSC_EN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR05_XOSC_EN_enable_w                   ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR05_XOSC_EN_enable_h1                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR05_XOSC_EN_enable_b3                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR05_XOSC_DB_mask_w                     ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_XOSC_DB_mask_h1                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_XOSC_DB_mask_b3                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_XOSC_DB_4096_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):4096 of 32bit */
N#define CFG_OR05_XOSC_DB_4096_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):4096 of 16bit */
N#define CFG_OR05_XOSC_DB_4096_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):4096 of 8bit */
N#define CFG_OR05_XOSC_DB_1024_w                     ((uint32_t)0x10000000)  /*!< Bit Value =(1):1024 of 32bit */
N#define CFG_OR05_XOSC_DB_1024_h1                    ((uint16_t)0x1000)      /*!< Bit Value =(1):1024 of 16bit */
N#define CFG_OR05_XOSC_DB_1024_b3                    ((uint8_t )0x10)        /*!< Bit Value =(1):1024 of 8bit */
N
N#define CFG_OR05_XOSC_GN_mask_w                     ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_XOSC_GN_mask_h1                    ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_XOSC_GN_mask_b3                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_XOSC_GN_32k_normal_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):32K_Normal of 32bit */
N#define CFG_OR05_XOSC_GN_32k_normal_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0x0):32K_Normal of 16bit */
N#define CFG_OR05_XOSC_GN_32k_normal_b3              ((uint8_t )0x00)        /*!< Bit Value =(0x0):32K_Normal of 8bit */
N#define CFG_OR05_XOSC_GN_medium_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Medium of 32bit */
N#define CFG_OR05_XOSC_GN_medium_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Medium of 16bit */
N#define CFG_OR05_XOSC_GN_medium_b3                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):Medium of 8bit */
N#define CFG_OR05_XOSC_GN_32k_lowest_w               ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):32K_Lowest of 32bit */
N#define CFG_OR05_XOSC_GN_32k_lowest_h1              ((uint16_t)0x0200)      /*!< Bit Value =(0x2):32K_Lowest of 16bit */
N#define CFG_OR05_XOSC_GN_32k_lowest_b3              ((uint8_t )0x02)        /*!< Bit Value =(0x2):32K_Lowest of 8bit */
N
N#define CFG_OR05_HSWKP_mask_w                       ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_HSWKP_mask_h1                      ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_HSWKP_mask_b2                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_HSWKP_0us_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0us of 32bit */
N#define CFG_OR05_HSWKP_0us_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0us of 16bit */
N#define CFG_OR05_HSWKP_0us_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):0us of 8bit */
N#define CFG_OR05_HSWKP_30us_w                       ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):30us of 32bit */
N#define CFG_OR05_HSWKP_30us_h1                      ((uint16_t)0x0040)      /*!< Bit Value =(0x1):30us of 16bit */
N#define CFG_OR05_HSWKP_30us_b2                      ((uint8_t )0x40)        /*!< Bit Value =(0x1):30us of 8bit */
N#define CFG_OR05_HSWKP_60us_w                       ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):60us of 32bit */
N#define CFG_OR05_HSWKP_60us_h1                      ((uint16_t)0x0080)      /*!< Bit Value =(0x2):60us of 16bit */
N#define CFG_OR05_HSWKP_60us_b2                      ((uint8_t )0x80)        /*!< Bit Value =(0x2):60us of 8bit */
N#define CFG_OR05_HSWKP_120us_w                      ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):120us of 32bit */
N#define CFG_OR05_HSWKP_120us_h1                     ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):120us of 16bit */
N#define CFG_OR05_HSWKP_120us_b2                     ((uint8_t )0xC0)        /*!< Bit Value =(0x3):120us of 8bit */
N
N#define CFG_OR05_PLL_CTL_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_PLL_CTL_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_PLL_CTL_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_PLL_CTL_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define CFG_OR05_PLL_CTL_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define CFG_OR05_PLL_CTL_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR05_HS_SEL_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_HS_SEL_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_HS_SEL_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_HS_SEL_ihrco_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):IHRCO of 32bit */
N#define CFG_OR05_HS_SEL_ihrco_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):IHRCO of 16bit */
N#define CFG_OR05_HS_SEL_ihrco_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):IHRCO of 8bit */
N#define CFG_OR05_HS_SEL_ilrco_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(1):ILRCO of 32bit */
N#define CFG_OR05_HS_SEL_ilrco_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(1):ILRCO of 16bit */
N#define CFG_OR05_HS_SEL_ilrco_b2                    ((uint8_t )0x02)        /*!< Bit Value =(1):ILRCO of 8bit */
N
N#define CFG_OR05_PON_MDS_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_PON_MDS_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_PON_MDS_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_PON_MDS_fast_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Fast of 32bit */
N#define CFG_OR05_PON_MDS_fast_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Fast of 16bit */
N#define CFG_OR05_PON_MDS_fast_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Fast of 8bit */
N#define CFG_OR05_PON_MDS_slow_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Slow of 32bit */
N#define CFG_OR05_PON_MDS_slow_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Slow of 16bit */
N#define CFG_OR05_PON_MDS_slow_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Slow of 8bit */
N
N#define CFG_OR05_SWD_PIN_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_SWD_PIN_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_SWD_PIN_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_SWD_PIN_enable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_OR05_SWD_PIN_enable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_OR05_SWD_PIN_enable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_OR05_SWD_PIN_disable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_OR05_SWD_PIN_disable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_OR05_SWD_PIN_disable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CFG_OR05_EXRST_PIN_mask_w                   ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_EXRST_PIN_mask_h0                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_EXRST_PIN_mask_b0                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_EXRST_PIN_enable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_OR05_EXRST_PIN_enable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_OR05_EXRST_PIN_enable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_OR05_EXRST_PIN_disable_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_OR05_EXRST_PIN_disable_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_OR05_EXRST_PIN_disable_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR07  [register's definitions]
N *              Offset[0x2C]  CFG option byte register 07 (0x4FF0002C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR07_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR07 */
N#define CFG_OR07_GF_mask_w                          ((uint32_t)0x0000E000)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_GF_mask_h0                         ((uint16_t)0xE000)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_GF_mask_b1                         ((uint8_t )0xE0)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_GF_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_GF_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_GF_disable_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_GF_enable_w                        ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_GF_enable_h0                       ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_GF_enable_b1                       ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_CGIL_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_CGIL_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_CGIL_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_CGIL_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_CGIL_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_CGIL_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_CGIL_enable_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_CGIL_enable_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_CGIL_enable_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_DPORDS_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_DPORDS_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_DPORDS_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_DPORDS_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_DPORDS_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_DPORDS_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_DPORDS_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_DPORDS_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_DPORDS_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_PORDS_mask_w                       ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_PORDS_mask_h0                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_PORDS_mask_b1                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_PORDS_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_PORDS_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_PORDS_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_PORDS_enable_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_PORDS_enable_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_PORDS_enable_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_PNDRC_mask_w                       ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_PNDRC_mask_h0                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_PNDRC_mask_b1                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_PNDRC_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_PNDRC_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_PNDRC_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_PNDRC_enable_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_PNDRC_enable_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_PNDRC_enable_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_PNDCE_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_PNDCE_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_PNDCE_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_PNDCE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_PNDCE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_PNDCE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_PNDCE_enable_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_PNDCE_enable_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_PNDCE_enable_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_LVRDS1_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_LVRDS1_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_LVRDS1_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_LVRDS1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_LVRDS1_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_LVRDS1_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_LVRDS1_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_LVRDS1_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_LVRDS1_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_LVRDS0_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_LVRDS0_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_LVRDS0_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_LVRDS0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_LVRDS0_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_LVRDS0_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_LVRDS0_enable_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_LVRDS0_enable_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_LVRDS0_enable_b0                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_LVRDE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_LVRDE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_LVRDE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_LVRDE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_LVRDE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_LVRDE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_LVRDE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_LVRDE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_LVRDE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_CG22_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_CG22_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_CG22_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_CG22_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_CG22_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_CG22_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_CG22_enable_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_CG22_enable_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_CG22_enable_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_CG21_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_CG21_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_CG21_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_CG21_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_CG21_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_CG21_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_CG21_enable_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_CG21_enable_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_CG21_enable_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR11  [register's definitions]
N *              Offset[0x34]  CFG option byte register 11 (0x4FF00034)
N ******************************************************************************
N */
N///@{
N#define CFG_OR11_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR11 */
N#define CFG_OR11_DAC_CTRM0_mask_w                   ((uint32_t)0x001F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR11_DAC_CTRM0_mask_h1                  ((uint16_t)0x001F)      /*!< Bit Mask of 16bit */
N#define CFG_OR11_DAC_CTRM0_mask_b2                  ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define CFG_OR11_DAC_CTRM0_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR11_DAC_CTRM0_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR11_DAC_CTRM0_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR11_VBG_BTRM_mask_w                    ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define CFG_OR11_VBG_BTRM_mask_h0                   ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR11_VBG_BTRM_mask_b1                   ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CFG_OR11_VBG_BTRM_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR11_VBG_BTRM_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR11_VBG_BTRM_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR11_VBG_OTRM_mask_w                    ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define CFG_OR11_VBG_OTRM_mask_h0                   ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define CFG_OR11_VBG_OTRM_mask_b0                   ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CFG_OR11_VBG_OTRM_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR11_VBG_OTRM_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR11_VBG_OTRM_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR12  [register's definitions]
N *              Offset[0x38]  CFG option byte register 12 (0x4FF00038)
N ******************************************************************************
N */
N///@{
N#define CFG_OR12_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR12 */
N#define CFG_OR12_LVR_TRM_mask_w                     ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR12_LVR_TRM_mask_h1                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define CFG_OR12_LVR_TRM_mask_b2                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CFG_OR12_LVR_TRM_shift_w                    (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR12_LVR_TRM_shift_h1                   (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR12_LVR_TRM_shift_b2                   (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR12_BOD1_TRM_mask_w                    ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define CFG_OR12_BOD1_TRM_mask_h0                   ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR12_BOD1_TRM_mask_b1                   ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CFG_OR12_BOD1_TRM_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR12_BOD1_TRM_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR12_BOD1_TRM_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR13  [register's definitions]
N *              Offset[0x3C]  CFG option byte register 13 (0x4FF0003C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR13_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR13 */
N#define CFG_OR13_IHR1_CTRM_mask_w                   ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR1_CTRM_mask_h1                  ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR1_CTRM_mask_b3                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR1_CTRM_shift_w                  (24)                    /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR1_CTRM_shift_h1                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR1_CTRM_shift_b3                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR13_IHR1_FTRM_mask_w                   ((uint32_t)0x007F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR1_FTRM_mask_h1                  ((uint16_t)0x007F)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR1_FTRM_mask_b2                  ((uint8_t )0x7F)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR1_FTRM_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR1_FTRM_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR1_FTRM_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR13_IHR0_CTRM_mask_w                   ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR0_CTRM_mask_h0                  ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR0_CTRM_mask_b1                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR0_CTRM_shift_w                  (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR0_CTRM_shift_h0                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR0_CTRM_shift_b1                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR13_IHR0_FTRM_mask_w                   ((uint32_t)0x0000007F)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR0_FTRM_mask_h0                  ((uint16_t)0x007F)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR0_FTRM_mask_b0                  ((uint8_t )0x7F)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR0_FTRM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR0_FTRM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR0_FTRM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR14  [register's definitions]
N *              Offset[0x40]  CFG option byte register 14 (0x4FF00040)
N ******************************************************************************
N */
N///@{
N#define CFG_OR14_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR14 */
N#define CFG_OR14_IHR_BGTI_mask_w                    ((uint32_t)0x0000E000)  /*!< Bit Mask of 32bit */
N#define CFG_OR14_IHR_BGTI_mask_h0                   ((uint16_t)0xE000)      /*!< Bit Mask of 16bit */
N#define CFG_OR14_IHR_BGTI_mask_b1                   ((uint8_t )0xE0)        /*!< Bit Mask of 8bit */
N#define CFG_OR14_IHR_BGTI_shift_w                   (13)                    /*!< Bit Shift of 32bit */
N#define CFG_OR14_IHR_BGTI_shift_h0                  (13)                    /*!< Bit Shift of 16bit */
N#define CFG_OR14_IHR_BGTI_shift_b1                  (5)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR14_IHR_BGTV_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define CFG_OR14_IHR_BGTV_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR14_IHR_BGTV_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR14_IHR_BGTV_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR14_IHR_BGTV_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR14_IHR_BGTV_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR14_ILR_TRM_mask_w                     ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define CFG_OR14_ILR_TRM_mask_h0                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CFG_OR14_ILR_TRM_mask_b0                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR14_ILR_TRM_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR14_ILR_TRM_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR14_ILR_TRM_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR15  [register's definitions]
N *              Offset[0x44]  CFG option byte register 15 (0x4FF00044)
N ******************************************************************************
N */
N///@{
N#define CFG_OR15_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR15 */
N#define CFG_OR15_ADC0_REFT_mask_w                   ((uint32_t)0x3F000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR15_ADC0_REFT_mask_h1                  ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR15_ADC0_REFT_mask_b3                  ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define CFG_OR15_ADC0_REFT_shift_w                  (24)                    /*!< Bit Shift of 32bit */
N#define CFG_OR15_ADC0_REFT_shift_h1                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR15_ADC0_REFT_shift_b3                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR15_ADC0_REFM_mask_w                   ((uint32_t)0x003F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR15_ADC0_REFM_mask_h1                  ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define CFG_OR15_ADC0_REFM_mask_b2                  ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define CFG_OR15_ADC0_REFM_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR15_ADC0_REFM_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR15_ADC0_REFM_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR15_ADC0_REFB_mask_w                   ((uint32_t)0x00003F00)  /*!< Bit Mask of 32bit */
N#define CFG_OR15_ADC0_REFB_mask_h0                  ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR15_ADC0_REFB_mask_b1                  ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define CFG_OR15_ADC0_REFB_shift_w                  (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR15_ADC0_REFB_shift_h0                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR15_ADC0_REFB_shift_b1                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR16  [register's definitions]
N *              Offset[0x48]  CFG option byte register 16 (0x4FF00048)
N ******************************************************************************
N */
N///@{
N#define CFG_OR16_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR16 */
N#define CFG_OR16_TEMP_CAL1_mask_w                   ((uint32_t)0x0FFF0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR16_TEMP_CAL1_mask_h1                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define CFG_OR16_TEMP_CAL1_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR16_TEMP_CAL1_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR16_TEMP_CAL1_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR16_TEMP_CAL0_mask_w                   ((uint32_t)0x00000FFF)  /*!< Bit Mask of 32bit */
N#define CFG_OR16_TEMP_CAL0_mask_h0                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define CFG_OR16_TEMP_CAL0_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR16_TEMP_CAL0_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR16_TEMP_CAL0_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR17  [register's definitions]
N *              Offset[0x4C]  CFG option byte register 17 (0x4FF0004C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR17_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR17 */
N#define CFG_OR17_LDO_TRM_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define CFG_OR17_LDO_TRM_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define CFG_OR17_LDO_TRM_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CFG_OR17_LDO_TRM_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR17_LDO_TRM_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR17_LDO_TRM_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_TST0  [register's definitions]
N *              Offset[0x60]  CFG Test register 0 (not load from flash memory) (0x4FF00060)
N ******************************************************************************
N */
N///@{
N#define CFG_TST0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_TST0 */
N#define CFG_TST0_PNDF_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_PNDF_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_PNDF_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_PNDF_shift_w                       (6)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_PNDF_shift_h0                      (6)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_PNDF_shift_b0                      (6)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_DBLVRF_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_DBLVRF_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_DBLVRF_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_DBLVRF_shift_w                     (5)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_DBLVRF_shift_h0                    (5)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_DBLVRF_shift_b0                    (5)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_LVRF0_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_LVRF0_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_LVRF0_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_LVRF0_shift_w                      (4)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_LVRF0_shift_h0                     (4)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_LVRF0_shift_b0                     (4)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_DPORF_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_DPORF_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_DPORF_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_DPORF_shift_w                      (3)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_DPORF_shift_h0                     (3)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_DPORF_shift_b0                     (3)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_POF2_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_POF2_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_POF2_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_POF2_shift_w                       (2)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_POF2_shift_h0                      (2)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_POF2_shift_b0                      (2)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_POF1_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_POF1_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_POF1_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_POF1_shift_w                       (1)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_POF1_shift_h0                      (1)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_POF1_shift_b0                      (1)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_POF0_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_POF0_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_POF0_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_POF0_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_POF0_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_POF0_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_TST1  [register's definitions]
N *              Offset[0x64]  CFG Test register 1 (not load from flash memory) (0x4FF00064)
N ******************************************************************************
N */
N///@{
N#define CFG_TST1_default                            ((uint32_t)0x00040000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_TST1 */
N#define CFG_TST1_PLL_TST_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_PLL_TST_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_PLL_TST_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_PLL_TST_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_PLL_TST_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_PLL_TST_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_PLL_TST_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_PLL_TST_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_PLL_TST_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_ILRCO_EN_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_ILRCO_EN_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_ILRCO_EN_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_ILRCO_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_ILRCO_EN_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_ILRCO_EN_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_ILRCO_EN_enable_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_ILRCO_EN_enable_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_ILRCO_EN_enable_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_ILRCK_OE_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_ILRCK_OE_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_ILRCK_OE_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_ILRCK_OE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_ILRCK_OE_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_ILRCK_OE_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_ILRCK_OE_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_ILRCK_OE_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_ILRCK_OE_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_IHRCK_OE_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_IHRCK_OE_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_IHRCK_OE_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_IHRCK_OE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_IHRCK_OE_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_IHRCK_OE_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_IHRCK_OE_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_IHRCK_OE_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_IHRCK_OE_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_LVR_DIS_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_LVR_DIS_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_LVR_DIS_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_LVR_DIS_enable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_TST1_LVR_DIS_enable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_TST1_LVR_DIS_enable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_TST1_LVR_DIS_disable_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_TST1_LVR_DIS_disable_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_TST1_LVR_DIS_disable_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CFG_TST1_BOD_OE_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_BOD_OE_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_BOD_OE_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_BOD_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_BOD_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_BOD_OE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_BOD_OE_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_BOD_OE_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_BOD_OE_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_FLH_WE_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_FLH_WE_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_FLH_WE_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_FLH_WE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_FLH_WE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_FLH_WE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_FLH_WE_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_FLH_WE_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_FLH_WE_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_CFG_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_CFG.h                         */
N/*----------------------------------------------------------------------------*/
L 31 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CFG_DRV.H" 2
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define ADC_RefTopMask          CFG_OR15_ADC0_REFT_mask_b3      /*!<  */	
N#define ADC_RefMiddleMask       CFG_OR15_ADC0_REFM_mask_b2      /*!<  */
N#define ADC_RefBottomMask       CFG_OR15_ADC0_REFB_mask_b1      /*!<  */
N
N#define CFG_TempHighCalMask      CFG_OR16_TEMP_CAL1_mask_h1      /*!<  */
N#define CFG_TempLowCalMask      CFG_OR16_TEMP_CAL0_mask_h0      /*!<  */
N
N#define CFG_PNDF        CFG_TST0_PNDF_mask_w        /*!<  */
N#define CFG_DBLVRF      CFG_TST0_DBLVRF_mask_w      /*!<  */
N#define CFG_LVRF0       CFG_TST0_LVRF0_mask_w       /*!<  */
N#define CFG_DPORF       CFG_TST0_DPORF_mask_w       /*!<  */
N#define CFG_POF2        CFG_TST0_POF2_mask_w        /*!<  */
N#define CFG_POF1        CFG_TST0_POF1_mask_w        /*!<  */
N#define CFG_POF0        CFG_TST0_POF0_mask_w        /*!<  */
N#define CFG_ALLF        CFG_PNDF | CFG_DBLVRF | CFG_LVRF0 | CFG_DPORF | CFG_DPORF | CFG_POF2 | CFG_POF1 | CFG_POF0      /*!<  */
N
N/* @} */
N
N/**
N * @name    Function announce
N *
N */ 
N///@{
N#if defined(MG32_1ST)
X#if 1L
Nuint8_t CFG_GetADC0RefTop (void);
Nvoid CFG_SetADC0RefTop (uint8_t ADC_REFT);
Nuint8_t CFG_GetADC0RefMiddle (void);
Nvoid CFG_SetADC0RefMiddle (uint8_t ADC_REFM);
Nuint8_t CFG_GetADC0RefBottom (void);
Nvoid CFG_SetADC0RefBottom (uint8_t ADC_REFB);
N#endif
N
N
Nuint32_t CFG_GetAllFlagStatus (void);
NDRV_Return CFG_GetSingleFlagStatus (uint32_t CFG_ITSrc);
Nvoid CFG_ClearFlag (uint32_t CFG_ITSrc);
N///@}
L 39 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N#include "MG32x02z_PW_DRV.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_PW_DRV.H" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_PW_DRV.H
N *
N * @brief       This is the C code format driver head file for PW module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.22
N * @date        2021/04/28
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_PW.h"
N
N
N#ifndef _MG32x02z_PW_DRV_H
N/*!< _MG32x02z_PW_DRV_H */ 
N#define _MG32x02z_PW_DRV_H
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define PW_PORF     PW_STA_PORF_mask_w                          /*!< Power-On reset status flag */
N#define PW_BOD0F    PW_STA_BOD0F_mask_w                         /*!< Brown-Out detect BOD0 status flag  */
N#define PW_BOD1F    PW_STA_BOD1F_mask_w                         /*!< Brown-Out detect BOD1 interrupt flag */
N#if (defined(MG32_3RD))
X#if (0L)
S#define PW_BOD2F    PW_STA_BOD2F_mask_w                         /*!< Brown-Out detect BOD2 interrupt flag */
N#endif
N#define PW_WKF      PW_STA_WKF_mask_w                           /*!< System received wakeup event flag */
N#if (defined(MG32_1ST) || defined(MG32_2ND))
X#if (1L || 0L)
N#define PW_ALLF     PW_PORF | PW_BOD0F | PW_BOD1F | PW_WKF              /*!< All event and interrupt flag */
N#endif
N#if (defined(MG32_3RD))
X#if (0L)
S#define PW_ALLF     PW_PORF | PW_BOD0F | PW_BOD1F | PW_BOD2F | PW_WKF   /*!< All event and interrupt flag */
N#endif
N
N#define PW_INT_WK       PW_INT_WK_IE_mask_w         /*!< System received wakeup event interrupt enable bit */
N#if (defined(MG32_3RD))
X#if (0L)
S#define PW_INT_BOD2     PW_INT_BOD2_IE_mask_w       /*!< BOD2 interrupt enable */
N#endif
N#define PW_INT_BOD1     PW_INT_BOD1_IE_mask_w       /*!< BOD1 interrupt enable */
N#define PW_INT_BOD0     PW_INT_BOD0_IE_mask_w       /*!< BOD0 interrupt enable */
N/* @} */
N
N
N/*! @enum   PW_WakeUpDly_TypeDef
N    @brief  MCU wake up delay selection
N*/ 
Ntypedef enum
N{   
N    PW_WK_15us      = 0,    /*!< Wakeup delay time 15us */
N    PW_WK_45us      = 1,    /*!< Wakeup delay time 45us */
N    PW_WK_75us      = 2,    /*!< Wakeup delay time 65us */
N    PW_WK_135us     = 3     /*!< Wakeup delay time 135us */
N}PW_WakeUpDly_TypeDef;
N
N
N
N/*! @enum   PW_WakeUpMode_TypeDef
N    @brief  MCU wakeup mode selection
N*/
Ntypedef enum
N{
N    PW_Normal_SleepMode = 0,    /*!< Wakeup from normal SLEEP mode */
N    PW_LowPower_SleepMode = 1,  /*!< Wakeup from low power SLEEP mode */
N}PW_WakeUpMode_TypeDef;
N
N
N/*! @enum   PW_BOD1_TH_TypeDef
N    @brief  BOD1 detect voltage threshold select
N*/ 
Ntypedef enum
N{   
N    PW_BOD1_2V0     = 0,    /*!< BOD1 detect voltage is 2.0V */
N    PW_BOD1_2V4     = 1,    /*!< BOD1 detect voltage is 2.4V */
N    PW_BOD1_3V7     = 2,    /*!< BOD1 detect voltage is 3.7V */
N    PW_BOD1_4V2     = 3,    /*!< BOD1 detect voltage is 4.2V */
N}PW_BOD1_TH_TypeDef;
N
N
N/*! @enum   PW_BODx_TRGS_TypeDef
N    @brief  BODx Interrupt trigger selection.
N*/
Ntypedef enum
N{   
N    PW_BODx_Reserved    = 0,    /*!< BODx not interrupt trigger */
N    PW_BODx_RisingEdge  = 1,    /*!< BODx interrupt trigger at rising edge */
N    PW_BODx_FallingEdge = 2,    /*!< BODx interrupt trigger at falling edge */
N    PW_BODx_DualEdge    = 3     /*!< BODx interrupt trigger at rising edge and falling edge  */
N}PW_BODx_TRGS_TypeDef;
N
N
N/*! @enum   PW_LowPowerLdo_TypeDef
N    @brief  Low power LDO level selection
N*/
Ntypedef enum
N{   
N    PW_LV0      = 0,    /*!< Low power LDO is Lowest level */
N    PW_LV1      = 1,    /*!< Low power LDO is the same PW_LV2 */
N    PW_LV2      = 2,    /*!< Low power LDO is the same PW_LV1 */
N    PW_LV3      = 3     /*!< Low power LDO is highest level */
N}PW_LowPowerLdo_TypeDef;
N
N
N/*! @enum   PW_LDOMode_TypeDef
N    @brief  Core voltage LDO mode selection.
N*/
Ntypedef enum
N{   
N    PW_Normal_LDO   = 0,    /*!< Core voltage LDO mode select normal LDO */
N    PW_LowPower_LDO = 1     /*!< Core voltage LDO mode select low power LDO */
N}PW_LDOMode_TypeDef;
N
N
N/*! @enum   PW_WKSTP_Periph_TypeDef
N    @brief  Peripheral event wakeup from STOP mode configure.
N*/
N#if (defined(MG32_1ST))
X#if (1L)
Ntypedef enum
N{   
N    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
N    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP2   = 18,   /*!< CMP2 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP3   = 19,   /*!< CMP3 voltage detection wakeup from STOP mode */
N    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
N    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
N    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
N    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
N}PW_WKSTP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_2ND))
X#if (0L)
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD2   = 6,    /*!< BOD2 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S#if (USB_TYPE)
S    PW_WKSTP_USB    = 24,   /*!< USB module event wakeup from STOP mode */
S#endif
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
N#endif
N
N
N
N/*! @enum   PW_STP_Periph_TypeDef
N    @brief  Peripheral stop mode continuous run configure.
N*/
N#if (defined(MG32_1ST))
X#if (1L)
Ntypedef enum
N{
N    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
X    PW_STPPO_POR    = ((uint32_t)0x00000002),     
N    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
X    PW_STPPO_BOD0   = ((uint32_t)0x00000010),    
N    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
X    PW_STPPO_BOD1   = ((uint32_t)0x00000020),    
N    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP0   = ((uint32_t)0x00100000),    
N    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP1   = ((uint32_t)0x00200000),    
N    PW_STPPO_CMP2   = PW_CR1_STP_CMP2_mask_w,   /*!< CMP2 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP2   = ((uint32_t)0x00400000),    
N    PW_STPPO_CMP3   = PW_CR1_STP_CMP3_mask_w,   /*!< CMP3 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP3   = ((uint32_t)0x00800000),    
N}PW_STP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_2ND))
X#if (0L)
Stypedef enum
S{   
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S}PW_STP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Stypedef enum
S{
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD2   = PW_CR1_STP_BOD2_mask_w,   /*!< BOD2 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S#if (USB_TYPE)
S    PW_STPPO_USB    = PW_CR1_STP_USB_mask_w     /*!< USB power-on configuration after enter STOP mode */
S#endif
S}PW_STP_Periph_TypeDef;
N#endif
N
N
N
N
N/*! @enum   PW_SLP_Periph_TypeDef
N    @brief  Peripheral sleep mode continuous run configure.
N*/
N#if (defined(MG32_1ST))
X#if (1L)
Ntypedef enum
N{   
N    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP0   = ((uint32_t)0x00010000),    
N    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP1   = ((uint32_t)0x00020000),    
N    PW_SLPPO_CMP2   = PW_CR1_SLP_CMP2_mask_w,   /*!< CMP2 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP2   = ((uint32_t)0x00040000),    
N    PW_SLPPO_CMP3   = PW_CR1_SLP_CMP3_mask_w,   /*!< CMP3 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP3   = ((uint32_t)0x00080000),    
N}PW_SLP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_2ND))
X#if (0L)
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S}PW_SLP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S#if (USB_TYPE)
S    PW_SLPPO_USB    = PW_CR1_SLP_USB_mask_w     /*!< USB power-on configuration after enter SLEEP mode */
S#endif
S}PW_SLP_Periph_TypeDef;
N#endif
N
N/** @name   Function rename
N *       
N */ 
N#define PW_PeriphStopModeWakeUp_Config      PW_PeriphSTOPModeWakeUp_Config
N#define PW_StopModeLDO_Select               PW_STOPModeLDO_Select
N#define PW_OnModeLDO_Select                 PW_ONModeLDO_Select
N#define PW_PeriphStopModeContinuous_Config  PW_PeriphSTOPModeContinuous_Config
N#define PW_PeriphSleepModeContinuous_Config PW_PeriphSLEEPModeContinuous_Config
N
N/**
N * @name	Function announce
N *
N */ 
N///@{  
Nuint32_t PW_GetAllFlagStatus (void);
NDRV_Return PW_GetSingleFlagStatus (uint32_t PW_ITSrc);
Nvoid PW_ClearFlag (uint32_t PW_ITSrc);
Nvoid PW_IT_Config (uint32_t PW_ITSrc, FunctionalState NewState);
Nvoid PW_ITEA_Cmd (FunctionalState NewState);
N
Nvoid PW_PeriphSTOPModeWakeUp_Config (PW_WKSTP_Periph_TypeDef WKSTP_Periph, FunctionalState NewState);
Nvoid PW_WakeUpDelay_Select (PW_WakeUpDly_TypeDef WakeUpDly);
N#if (defined(MG32_3RD))
X#if (0L)
Svoid PW_WakeUpMode_Select (PW_WakeUpMode_TypeDef WakeUpModeSelect);
N#endif
NDRV_Return PW_GetWakeUpMode (void);;
N
Nvoid PW_BOD1Threshold_Select (PW_BOD1_TH_TypeDef BOD1_TH);
Nvoid PW_BOD1Trigger_Select (PW_BODx_TRGS_TypeDef BOD1_TRGS);
Nvoid PW_BOD1_Cmd (FunctionalState NewState);
Nvoid PW_BOD0_Cmd (FunctionalState NewState);
NDRV_Return PW_GetBod1Status (void);
N#if (defined(MG32_3RD))
X#if (0L)
Svoid PW_BOD2Trigger_Select (PW_BODx_TRGS_TypeDef BOD2_TRGS);
Svoid PW_BOD2_Cmd (FunctionalState NewState);
SDRV_Return PW_GetBod2Status (void);
N#endif
N
Nvoid PW_VoltageBuffer (FunctionalState NewState);
Nvoid PW_STOPModeLDO_Select (PW_LDOMode_TypeDef LdoSelect);
Nvoid PW_ONModeLDO_Select (PW_LDOMode_TypeDef LdoSelect);
N
Nvoid PW_PeriphSTOPModeContinuous_Config (PW_STP_Periph_TypeDef STP_Periph,FunctionalState NewState);
N#if (defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD))
X#if (1L || 0L || 0L)
Nvoid PW_PeriphSLEEPModeContinuous_Config (PW_SLP_Periph_TypeDef SLP_Periph, FunctionalState NewState);
N#endif
N///@}
N
N
N#endif  //_MG32x02z_PW_DRV_H
N
L 40 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N
N
N/** 
N * @enum		ADC_PLLClockDivDef
N * @brief		declare Timer PLL clock divider 
N */        
Ntypedef enum 
N{ 
N    ADC_PLLDIV2=0,       /*!< ADC PLL clock divder (DIV2) */
N    ADC_PLLDIV4,         /*!< ADC PLL clock divder (DIV4) */
N    ADC_PLLDIV5,         /*!< ADC PLL clock divder (DIV5) */
N    ADC_PLLDIV6          /*!< ADC PLL clock divder (DIV6) */
N} ADC_PLLClockDivDef;
N
N
N
N/** 
N * @enum		ADC_ClockSourceDef
N * @brief		declare ADC clock source
N */        
Ntypedef enum 
N{ 
N    ADC_CKADC=0,         /*!< ADC clock from CK_ADC */
N    ADC_CKPLL,           /*!< ADC clock from PLL */
N    ADC_TM00TRGO,        /*!< ADC clock from TM00 TRGO */
N    ADC_TM01TRGO,        /*!< ADC clock from TM01 TRGO */
N} ADC_ClockSourceDef;
N
N
N/** 
N * @enum		ADC_INTClockDivDef
N * @brief		declare ADC internal clock divided 
N */        
Ntypedef enum 
N{ 
N    ADC_IntDIV1=0,       /*!< ADC internal clock divider (DIV1) */
N    ADC_IntDIV2,         /*!< ADC internal clock divider (DIV2) */
N    ADC_IntDIV4,         /*!< ADC internal clock divider (DIV4) */
N    ADC_IntDIV16         /*!< ADC internal clock divider (DIV16) */
N} ADC_INTClockDivDef;
N
N
N/** 
N * @enum		ADC_SCNTClockDivDef
N * @brief		declare ADC SCNT internal clock divided 
N */        
Ntypedef enum 
N{ 
N    ADC_SCNTIntDIV1=0,  /*!< ADC SCNT internal clock divider (DIV1) */
N    ADC_SCNTIntDIV4,    /*!< ADC SCNT internal clock divider (DIV4) */
N    ADC_SCNTIntDIV16,   /*!< ADC SCNT internal clock divider (DIV16) */
N    ADC_SCNTIntDIV32    /*!< ADC SCNT internal clock divider (DIV32) */
N} ADC_SCNTClockDivDef;
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_ConversionTimeDef
S * @brief		declare ADC internal clock divided 
S */        
Stypedef enum 
S{ 
S    ADC_FastCONV=0,     /*!< Conversion time ~24 ADC clocks */
S    ADC_NormalCONV,     /*!< Conversion time ~30 ADC clocks */
S} ADC_ConversionTimeDef;
N#endif
N
N/** 
N * @enum		ADC_WindowDetectApplyDef
N * @brief		apply window detect function (single / all channels)
N */        
Ntypedef enum 
N{ 
N    ADC_WINDSingle=0,   /*!< window detect function only apply single channel */
N    ADC_WINDAll,        /*!< window detect function apply all channel */
N} ADC_WindowDetectApplyDef;
N
N/** 
N * @enum		ADC_OutputDef
N * @brief		select ADC ouput property (LF,IF,HF,Current State)
N */        
Ntypedef enum 
N{ 
N    ADC_WDL_Event=0,    /*!< WDLF - outside low */
N    ADC_WDI_Event,      /*!< WDIF - inside */
N    ADC_WDH_Event,      /*!< WDHF - outside high */
N} ADC_OutputDef;
N
N/** 
N * @enum		ADC_ConversionModeDef
N * @brief		select ADC conversion mode (ONE,Scan, Loop /w Continue)
N */        
Ntypedef enum 
N{ 
N    ADCMode,            /*!< One channel */
N    ADCContinueMode,    /*!< One + Continue */
N    ScanMode,           /*!< Scan */
N    ScanContinueMode,   /*!< Scan + continue */
N    LoopMode,           /*!< Loop */
N} ADC_ConversionModeDef;
N
N
N/** 
N * @enum		ADC_MainConversionModeDef
N * @brief		select ADC conversion mode (ONE,Scan, Loop)
N */        
Ntypedef enum 
N{ 
N    ADC_OneShot,        /*!< One shot mode */
N    ADC_Scan,           /*!< scan mode */
N    ADC_Loop,           /*!< loop mode */
N} ADC_MainConversionModeDef;
N
N/** 
N * @enum		ADC_TriggerSourceDef
N * @brief		Select ADC trigger event to start conversion
N */        
Ntypedef enum 
N{ 
N    ADC_START,          /*!< SW : ADC0_START register setting */
N    ADC_TM00_TRGO,      /*!< TM00 : TM00_TRGO */
N    ADC_TRGPin,         /*!< PIN : ADC0_TRG : ADC external trigger pin */
N    ADC_CMP0Out,        /*!< CMP0 : CMP0_OUT */
N    ADC_CMP1Out,        /*!< CMP1 : CMP1_OUT */
N    ADC_TM01_TRGO,      /*!< TM01 : TM01_TRGO */
N    ADC_TM20_TRGO,      /*!< TM20 : TM20_TRGO */
N    ADC_TM36_TRGO,      /*!< TM36 : TM36_TRGO */
N} ADC_TriggerSourceDef;
N
N/** 
N * @enum		ADC_TriggerEdgeDef
N * @brief		config external trigger event to start conversion
N */        
Ntypedef enum 
N{ 
N    ADC_DisableTrg,         /*!< Disable trigger source */
N    ADC_AcceptRisingEdge,   /*!< accept rising edge of trigger  */
N    ADC_AcceptFallingEdge,  /*!< accept falling edge of trigger  */
N    ADC_AcceptDualEdge,     /*!< accept dual (rising & falling) edge of trigger */
N} ADC_TriggerEdgeDef;
N
N
N/** 
N * @enum		ADC_ChannelMUX_Def
N * @brief		config channel for ADC channel input (external/internal)
N */        
Ntypedef enum 
N{
N    ADC_ExternalChannel,    /*!< select external channel, AIN0~15 */
N    ADC_InternalChannel,    /*!< select internal channel, ie. VSSA, IVREF, VBUF ... */
N} ADC_ChannelMUX_Def;
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N/** 
N * @enum		ADC_MskChannelDef
N * @brief		specify channel select for mask (scan/loop)
N */        
Ntypedef enum 
N{ 
N    ADC_MskAIN0 = ADC_MSK_CH_MSK0_enable_h0,    /*!< specify ADC select channel channel 0 */ 
X    ADC_MskAIN0 = ((uint16_t)0x0001),      
N    ADC_MskAIN1 = ADC_MSK_CH_MSK1_enable_h0,    /*!< specify ADC select channel channel 1 */  
X    ADC_MskAIN1 = ((uint16_t)0x0002),       
N    ADC_MskAIN2 = ADC_MSK_CH_MSK2_enable_h0,    /*!< specify ADC select channel channel 2 */  
X    ADC_MskAIN2 = ((uint16_t)0x0004),       
N    ADC_MskAIN3 = ADC_MSK_CH_MSK3_enable_h0,    /*!< specify ADC select channel channel 3 */ 
X    ADC_MskAIN3 = ((uint16_t)0x0008),      
N    ADC_MskAIN4 = ADC_MSK_CH_MSK4_enable_h0,    /*!< specify ADC select channel channel 4 */  
X    ADC_MskAIN4 = ((uint16_t)0x0010),       
N    ADC_MskAIN5 = ADC_MSK_CH_MSK5_enable_h0,    /*!< specify ADC select channel channel 5 */  
X    ADC_MskAIN5 = ((uint16_t)0x0020),       
N    ADC_MskAIN6 = ADC_MSK_CH_MSK6_enable_h0,    /*!< specify ADC select channel channel 6 */  
X    ADC_MskAIN6 = ((uint16_t)0x0040),       
N    ADC_MskAIN7 = ADC_MSK_CH_MSK7_enable_h0,    /*!< specify ADC select channel channel 7 */  
X    ADC_MskAIN7 = ((uint16_t)0x0080),       
N    ADC_MskAIN8 = ADC_MSK_CH_MSK8_enable_h0,    /*!< specify ADC select channel channel 8 */  
X    ADC_MskAIN8 = ((uint16_t)0x0100),       
N    ADC_MskAIN9 = ADC_MSK_CH_MSK9_enable_h0,    /*!< specify ADC select channel channel 9 */  
X    ADC_MskAIN9 = ((uint16_t)0x0200),       
N    ADC_MskAIN10 = ADC_MSK_CH_MSK10_enable_h0,  /*!< specify ADC select channel channel 10 */ 
X    ADC_MskAIN10 = ((uint16_t)0x0400),    
N    ADC_MskAIN11 = ADC_MSK_CH_MSK11_enable_h0,  /*!< specify ADC select channel channel 11 */ 
X    ADC_MskAIN11 = ((uint16_t)0x0800),    
N    ADC_MskAIN12 = ADC_MSK_CH_MSK12_enable_h0,  /*!< specify ADC select channel channel 12 */ 
X    ADC_MskAIN12 = ((uint16_t)0x1000),    
N    ADC_MskAIN13 = ADC_MSK_CH_MSK13_enable_h0,  /*!< specify ADC select channel channel 13 */ 
X    ADC_MskAIN13 = ((uint16_t)0x2000),    
N    ADC_MskAIN14 = ADC_MSK_CH_MSK14_enable_h0,  /*!< specify ADC select channel channel 14 */ 
X    ADC_MskAIN14 = ((uint16_t)0x4000),    
N    ADC_MskAIN15 = ADC_MSK_CH_MSK15_enable_h0,  /*!< specify ADC select channel channel 15 */ 
X    ADC_MskAIN15 = ((uint16_t)0x8000),    
N} ADC_MskChannelDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		ADC_MskChannelDef
S * @brief		specify channel select for mask (scan/loop)
S */        
Stypedef enum 
S{ 
S    ADC_MskAIN0 = ADC_MSK_CH_MSK0_enable_h0,    /*!< specify ADC select channel channel 0 */ 
S    ADC_MskAIN1 = ADC_MSK_CH_MSK1_enable_h0,    /*!< specify ADC select channel channel 1 */  
S    ADC_MskAIN2 = ADC_MSK_CH_MSK2_enable_h0,    /*!< specify ADC select channel channel 2 */  
S    ADC_MskAIN3 = ADC_MSK_CH_MSK3_enable_h0,    /*!< specify ADC select channel channel 3 */ 
S    ADC_MskAIN8 = ADC_MSK_CH_MSK8_enable_h0,    /*!< specify ADC select channel channel 8 */  
S    ADC_MskAIN9 = ADC_MSK_CH_MSK9_enable_h0,    /*!< specify ADC select channel channel 9 */  
S    ADC_MskAIN10 = ADC_MSK_CH_MSK10_enable_h0,  /*!< specify ADC select channel channel 10 */ 
S    ADC_MskAIN11 = ADC_MSK_CH_MSK11_enable_h0,  /*!< specify ADC select channel channel 11 */ 
S    ADC_MskAIN12 = ADC_MSK_CH_MSK12_enable_h0,  /*!< specify ADC select channel channel 12 */ 
S    ADC_MskAIN13 = ADC_MSK_CH_MSK13_enable_h0,  /*!< specify ADC select channel channel 13 */ 
S    ADC_MskAIN14 = ADC_MSK_CH_MSK14_enable_h0,  /*!< specify ADC select channel channel 14 */ 
S    ADC_MskAIN15 = ADC_MSK_CH_MSK15_enable_h0,  /*!< specify ADC select channel channel 15 */ 
S} ADC_MskChannelDef;
N#endif
N
N
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N/** 
N * @enum		ADC_ExtChannelDef
N * @brief		specify external channel select 
N */        
Ntypedef enum 
N{ 
N    ADC_ExtAIN0=0,		/*!< specify ADC sample external channel 0 */ 
N    ADC_ExtAIN1=1,    	/*!< specify ADC sample external channel 1 */  
N    ADC_ExtAIN2=2,    	/*!< specify ADC sample external channel 2 */  
N    ADC_ExtAIN3=3,    	/*!< specify ADC sample external channel 3 */  
N    ADC_ExtAIN4=4,    	/*!< specify ADC sample external channel 4 */  
N    ADC_ExtAIN5=5,    	/*!< specify ADC sample external channel 5 */  
N    ADC_ExtAIN6=6,    	/*!< specify ADC sample external channel 6 */  
N    ADC_ExtAIN7=7,    	/*!< specify ADC sample external channel 7 */
N    ADC_ExtAIN8=8,    	/*!< specify ADC sample external channel 8 */  
N    ADC_ExtAIN9=9,    	/*!< specify ADC sample external channel 9 */  
N    ADC_ExtAIN10=10,	/*!< specify ADC sample external channel 10 */ 
N    ADC_ExtAIN11=11,    /*!< specify ADC sample external channel 11 */ 
N    ADC_ExtAIN12=12,    /*!< specify ADC sample external channel 12 */ 
N    ADC_ExtAIN13=13,    /*!< specify ADC sample external channel 13 */ 
N    ADC_ExtAIN14=14,    /*!< specify ADC sample external channel 14 */ 
N    ADC_ExtAIN15=15,    /*!< specify ADC sample external channel 15 */ 
N} ADC_ExtChannelDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		ADC_ExtChannelDef
S * @brief		specify external channel select 
S */        
Stypedef enum 
S{ 
S    ADC_ExtAIN0=0,		/*!< specify ADC sample external channel 0 */ 
S    ADC_ExtAIN1=1,    	/*!< specify ADC sample external channel 1 */  
S    ADC_ExtAIN2=2,    	/*!< specify ADC sample external channel 2 */  
S    ADC_ExtAIN3=3,    	/*!< specify ADC sample external channel 3 */  
S    ADC_ExtAIN8=8,    	/*!< specify ADC sample external channel 8 */  
S    ADC_ExtAIN9=9,    	/*!< specify ADC sample external channel 9 */  
S    ADC_ExtAIN10=10,	/*!< specify ADC sample external channel 10 */ 
S    ADC_ExtAIN11=11,    /*!< specify ADC sample external channel 11 */ 
S    ADC_ExtAIN12=12,    /*!< specify ADC sample external channel 12 */ 
S    ADC_ExtAIN13=13,    /*!< specify ADC sample external channel 13 */ 
S    ADC_ExtAIN14=14,    /*!< specify ADC sample external channel 14 */ 
S    ADC_ExtAIN15=15,    /*!< specify ADC sample external channel 15 */ 
S} ADC_ExtChannelDef;
N#endif
N
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		ADC_IntChannelDef
N * @brief		specify internal channel select 
N */        
Ntypedef enum 
N{ 
N    ADC_INT_VSSA    = 0x10, /*!< specify ADC sample internal VSSA. */  
N    ADC_INT_IVREF   = 0x11, /*!< specify ADC sample internal IVREF. */ 
N    ADC_INT_DACP0   = 0x12, /*!< specify ADC sample internal DAC_P0. */ 
N    ADC_INT_VBUF    = 0x13, /*!< specify ADC sample internal VBUF. */ 
N} ADC_IntChannelDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		ADC_IntChannelDef
S * @brief		specify internal channel select 
S */        
Stypedef enum 
S{ 
S    ADC_INT_VSSA    = 0x10, /*!< specify ADC sample internal VSSA. */  
S    ADC_INT_IVREF   = 0x11, /*!< specify ADC sample internal IVREF. */ 
S    ADC_INT_VBUF    = 0x13, /*!< specify ADC sample internal VBUF. */ 
S    ADC_INT_LDO     = 0x18, /*!< specify ADC sample internal LDO. */ 
S} ADC_IntChannelDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_IntChannelDef
S * @brief		specify internal channel select 
S */        
Stypedef enum 
S{ 
S    ADC_INT_VSSA    = 0x10, /*!< specify ADC sample internal VSSA. */  
S    ADC_INT_DACP0   = 0x12, /*!< specify ADC sample internal DAC_P0. */ 
S    ADC_INT_VBUF    = 0x13, /*!< specify ADC sample internal VBUF. */ 
S    ADC_INT_LDO     = 0x18, /*!< specify ADC sample internal LDO VR0. */ 
S    ADC_INT_TSO     = 0x19, /*!< specify ADC sample internal Temperature sensor (TSO). */ 
S    ADC_INT_HalfVDD = 0x1A, /*!< specify ADC sample internal 1/2 VDD output. */ 
S    ADC_INT_VPG     = 0x1B, /*!< specify ADC sample internal VPG. */ 
S    ADC_INT_V33     = 0x1C, /*!< specify ADC sample internal V33 voltage. */ 
S} ADC_IntChannelDef;
N#endif
N
N
N
N
N/** 
N * @enum		ADC_ConversionTypeDef
N * @brief		config ADC conversion type
N */        
Ntypedef enum 
N{ 
N    ADC_SingleMode,         /*!< ADC single conversion mode */
N    ADC_DifferentMode,      /*!< ADC different conversion mode  */
N} ADC_ConversionTypeDef;
N
N
N
N/** 
N * @enum		ADC_LimitModeDef
N * @brief		config process mode for spike data 
N */        
Ntypedef enum 
N{ 
N    ADC_LimitNoOperation,   /*!< No operation for spike ADC conversion data */
N    ADC_LimitSkip,          /*!< Skip for spike ADC conversion data  */
N    ADC_LimitClamp,         /*!< Clamp for spike ADC conversion data */
N} ADC_LimitModeDef;
N
N
N/**
N * @name	SumXChannelSel
N *   		SumXChannelSel(SAIN0, SAIN1, SAIN2 ... AIN15)
N */ 
N///@{  
N#define SAIN0       0       /*!< External channel-0 be scan/loop channel. */    
N#define SAIN1       1       /*!< External channel-1 be scan/loop channel. */
N#define SAIN2       2       /*!< External channel-2 be scan/loop channel. */
N#define SAIN3       3       /*!< External channel-3 be scan/loop channel. */
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N    #define SAIN4       4   /*!< External channel-4 be scan/loop channel. */
N    #define SAIN5       5   /*!< External channel-5 be scan/loop channel. */
N    #define SAIN6       6   /*!< External channel-6 be scan/loop channel. */
N    #define SAIN7       7   /*!< External channel-7 be scan/loop channel. */
N#endif
N
N#define SAIN8       8       /*!< External channel-8 be scan/loop channel. */
N#define SAIN9       9       /*!< External channel-9 be scan/loop channel. */
N#define SAIN10      10      /*!< External channel-10 be scan/loop channel. */
N#define SAIN11      11      /*!< External channel-11 be scan/loop channel. */
N
N#if defined(MG32_1ST) || defined(MG32_2ND) ||  defined(MG32_3RD)
X#if 1L || 0L ||  0L
N#define SAIN12      12      /*!< External channel-12 be scan/loop channel. */
N#define SAIN13      13      /*!< External channel-13 be scan/loop channel. */
N#define SAIN14      14      /*!< External channel-14 be scan/loop channel. */
N#define SAIN15      15      /*!< External channel-15 be scan/loop channel. */
N#endif
N
N///@}
N
N/** 
N * @enum		ADC_SumChannelXDef
N * @brief		accumulate channel that single / all channel
N */        
Ntypedef enum 
N{ 
N    ADC_SumSpeciallyChannel,/*!< Single specify channel */
N    ADC_SumAllChannel,      /*!< accumulate all conversion channel data  */
N} ADC_SumChannelXDef;
N
N/** 
N * @enum		ADC_SumDataOWDef
N * @brief		config sum overrun mode 
N */        
Ntypedef enum 
N{ 
N    ADC_SumOverWritten, /*!< Overwritten by new data */
N    ADC_SumKeep,        /*!< Preserved old date */
N} ADC_SumDataOWDef;
N
N/** 
N * @enum		ADC_DataAlignModeDef
N * @brief		config data alignment mode (Right/Left alignment)
N */        
Ntypedef enum 
N{ 
N    ADC_RightJustified, /*!< Right Justified of ADC conversion data format */
N    ADC_LeftJustified,  /*!< Left Justified of ADC conversion data format  */
N} ADC_DataAlignModeDef;
N
N/** 
N * @enum		ADC_ResolutionDef
N * @brief		config data resolution (12/10 bit)
N */        
Ntypedef enum 
N{ 
N    ADC_12BitData,  /*!< data resolution = 12 bit */
N    ADC_10BitData,  /*!< data resolution = 10 bit */
N    ADC_8BitData,   /*!< data resolution = 8 bit */
N} ADC_ResolutionDef;
N
N/** 
N * @enum		ADC_DataOWDef
N * @brief		config data overrun mode 
N */        
Ntypedef enum 
N{ 
N    ADC_DataOverWritten, /*!< Overwritten by new data */
N    ADC_DataKeep,        /*!< Preserved old date */
N} ADC_DataOWDef;
N
N
N/** 
N * @enum		ADC_ITSrc
N * @brief		ADC interrupt source
N */        
Ntypedef enum 
N{ 
N    ADC_SUMOVR_IE = ADC_INT_SUMOVR_IE_enable_w, /*!< ADC0 data sum-0,1,2  overrun event interrupt enable */
X    ADC_SUMOVR_IE = ((uint32_t)0x00008000),  
N    ADC_SUMC_IE = ADC_INT_SUMC_IE_enable_w,     /*!< ADC0 data sum-0,1,2  accumulation complete interrupt  */
X    ADC_SUMC_IE = ((uint32_t)0x00004000),      
N    ADC_SUMO_IE = ADC_INT_SUMO_IE_enable_w,     /*!< ADC0 data sum-0,1,2  accumulation overflow or underflow interrupt enable */
X    ADC_SUMO_IE = ((uint32_t)0x00002000),      
N    ADC_WDH_IE = ADC_INT_WDH_IE_enable_w,       /*!< ADC0 voltage window detect outside high event interrupt enable */
X    ADC_WDH_IE = ((uint32_t)0x00000400),        
N    ADC_WDI_IE = ADC_INT_WDI_IE_enable_w,       /*!< ADC0 voltage window detect inside event interrupt enable */
X    ADC_WDI_IE = ((uint32_t)0x00000200),        
N    ADC_WDL_IE = ADC_INT_WDL_IE_enable_w,       /*!< ADC0 voltage window detect outside low event interrupt enabl */
X    ADC_WDL_IE = ((uint32_t)0x00000100),        
N    ADC_OVR_IE = ADC_INT_OVR_IE_enable_w,       /*!< ADC0 conversion overrun event interrupt enable */
X    ADC_OVR_IE = ((uint32_t)0x00000080),        
N    ADC_ESCNV_IE = ADC_INT_ESCNV_IE_enable_w,   /*!< ADC0 channel scan conversion end interrupt enable */
X    ADC_ESCNV_IE = ((uint32_t)0x00000020),    
N    ADC_E1CNV_IE = ADC_INT_E1CNV_IE_enable_w,   /*!< ADC0 one-time conversion end interrupt enable */
X    ADC_E1CNV_IE = ((uint32_t)0x00000008),    
N    ADC_ESMP_IE = ADC_INT_ESMP_IE_enable_w,     /*!< ADC0 sampling end interrupt enable */
X    ADC_ESMP_IE = ((uint32_t)0x00000004),      
N    
N} ADC_ITSrc;
N
N
N/** 
N * @enum		ADC_ITSTAFlag
N * @brief		ADC status flag 
N */    
Ntypedef enum 
N{
N    ADC_SUMOVRF =   ADC_STA_SUMOVRF_happened_w, /*!< ADC0 data sum-0,1,2  register overrun flag */
X    ADC_SUMOVRF =   ((uint32_t)0x00008000),  
N    ADC_SUMCF   =   ADC_STA_SUMCF_happened_w,   /*!< ADC0 data sum-0,1,2  accumulation complete flag */
X    ADC_SUMCF   =   ((uint32_t)0x00004000),    
N    ADC_SUMOF   =   ADC_STA_SUMOF_happened_w,   /*!< ADC0 data sum-0,1,2 accumulation overflow or underflow flag */
X    ADC_SUMOF   =   ((uint32_t)0x00002000),    
N    ADC_WDHF    =   ADC_STA_WDHF_happened_w,    /*!< ADC0 voltage window detect outside high event flag */
X    ADC_WDHF    =   ((uint32_t)0x00000400),     
N    ADC_WDIF    =   ADC_STA_WDIF_happened_w,    /*!< ADC0 voltage window detect inside event flag */
X    ADC_WDIF    =   ((uint32_t)0x00000200),     
N    ADC_WDLF    =   ADC_STA_WDLF_happened_w,    /*!< ADC0 voltage window detect outside low event flag */
X    ADC_WDLF    =   ((uint32_t)0x00000100),     
N    ADC_OVRF    =   ADC_STA_OVRF_happened_w,    /*!< ADC0 conversion overrun event flag */
X    ADC_OVRF    =   ((uint32_t)0x00000080),     
N    ADC_ESCNVF  =   ADC_STA_ESCNVF_happened_w,  /*!< ADC0 channel scan conversion end flag */
X    ADC_ESCNVF  =   ((uint32_t)0x00000020),   
N    ADC_E1CNVF  =   ADC_STA_E1CNVF_happened_w,  /*!< ADC0 one-time conversion end flagg */
X    ADC_E1CNVF  =   ((uint32_t)0x00000008),   
N    ADC_ESMPF   =   ADC_STA_ESMPF_happened_w,   /*!< ADC0 sampling end flag */
X    ADC_ESMPF   =   ((uint32_t)0x00000004),    
N} ADC_ITSTAFlag;
N
N/** 
N * @enum		ADC_OutputCodeFormatDef
N * @brief		Config ADC conversion code format
N */    
Ntypedef enum 
N{
N    ADC_UnsignedFormat,         /*!< ADC output unsigned data format */
N    ADC_2sCompletementFormat,   /*!< ADC output 2's complement data format */
N} ADC_OutputCodeFormatDef;
N
N
N/** 
N * @enum		ADC_DAT0FlagsDef
N * @brief		ADC interrupt source
N */        
Ntypedef enum 
N{ 
N    ADC_DAT0_WDLF = ADC_DAT0_DAT0_WDLF_normal_b2,   /*!< ADC voltage window detect outside low event flag */
X    ADC_DAT0_WDLF = ((uint8_t )0x00),    
N    ADC_DAT0_WDIF = ADC_DAT0_DAT0_WDIF_normal_b2,   /*!< ADC voltage window detect inside event flag */
X    ADC_DAT0_WDIF = ((uint8_t )0x00),    
N    ADC_DAT0_WDHF = ADC_DAT0_DAT0_WDHF_normal_b2,   /*!< ADC voltage window detect outside high event flag */
X    ADC_DAT0_WDHF = ((uint8_t )0x00),    
N    ADC_DAT0_CF = ADC_DAT0_DAT0_CF_mask_b2,         /*!< ADC0 conversion data-0 complete in 1-time and data ready status bit */
X    ADC_DAT0_CF = ((uint8_t )0x40),          
N    ADC_DAT0_OVRF = ADC_DAT0_DAT0_OVRF_mask_b2,     /*!< ADC0 conversion data register-0 overwrite/overrun indication status bit */
X    ADC_DAT0_OVRF = ((uint8_t )0x80),      
N} ADC_DAT0FlagsDef;
N
N
N/** 
N * @enum		ADC_SUMxFlagDef
N * @brief		ADC SUMx flag declare
N */        
Ntypedef enum 
N{ 
N    ADC_SUMxOVRF = ADC_SUM0_SUM0_OVRF_mask_h1,      /*!< ADC0 data sum-0,1,2 register overrun flag */
X    ADC_SUMxOVRF = ((uint16_t)0x0080),       
N    ADC_SUMxCF = ADC_SUM0_SUM0_CF_mask_h1,          /*!< ADC0 data sum-0,1,2 accumulation complete flag */
X    ADC_SUMxCF = ((uint16_t)0x0040),           
N    ADC_SUMxOF = ADC_SUM0_SUM0_OF_mask_h1,          /*!< ADC0 data sum-0,1,2 accumulation overflow flag */
X    ADC_SUMxOF = ((uint16_t)0x0020),           
N    ADC_SUMxUF = ADC_SUM0_SUM0_UF_mask_h1,          /*!< ADC0 data sum-0,1,2 accumulation underflow flag */
X    ADC_SUMxUF = ((uint16_t)0x0010),           
N} ADC_SUMxFlagDef;
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S/** 
S * @enum		ADC_DMADataSizeDef
S * @brief		Config ADC data size for DMA transmission
S */    
Stypedef enum 
S{
S    ADC_DMA_32bit,              /*!< ADC will transfer ADC0_DAT0 for DMA transmission */
S    ADC_DMA_16bit,              /*!< ADC will transfer the bit[15:0] of ADC0_DAT0 for DMA transmission */
S} ADC_DMADataSizeDef;
S
S/** 
S * @enum		ADC_DMAMaskE1CNVFDef
S * @brief		Config ADC mask E1CNVF during DMA transmission
S */    
Stypedef enum 
S{
S    ADC_Mask_E1CNVF,            /*!< E1CNVF flag will be masked after ADC conversion end during DMA access */
S    ADC_Assert_E1CNVF,          /*!< E1CNVF flag asserted mode select during DMA access */
S} ADC_DMAMaskE1CNVFDef;
S
S
S/** 
S * @enum		ADC_ChangeTimingDef
S * @brief		Config ADC change channel MUX timing 
S */    
Stypedef enum 
S{
S    ADC_ChangeMUX_E1CNVF,       /*!< Change channel MUX when E1CNVF happened. */
S    ADC_ChangeMUX_ESMPF,        /*!< Change channel MUX when ESMPF happened. */
S} ADC_ChangeTimingDef;
S
N#endif
N
N/** 
N * @struct  ADC_InitTypeDef
N * @brief   ADC Base initial structure
N */        
Ntypedef struct 				
N{ 
N    ADC_ClockSourceDef ADCMainClockSelect;      /*!< Specifies whether the conversion is performed in */
N    
N        ADC_INTClockDivDef ADC_IntCK_Div;       /*!< Select CK_ADC divider .
N                                                  This parameter can be Selected /1, /2, /4, /16 .*/                         
N                                                  
N        ADC_PLLClockDivDef ADC_CKPLL_Div;       /*!< Select PLL clock divider .
N                                                  This parameter can be Selected /2, /4, /5, /6 .*/    
N    
N    ADC_DataAlignModeDef ADC_DataAlign;         /*!< Specifies whether the ADC data alignment is left or righ */
N    
N    ADC_ResolutionDef ADC_ResolutionSel;        /*!< Specifies whether the ADC conversion resolution 10 or 12 bit */
N                                                                                                    
N    ADC_DataOWDef ADC_DataOverrunEvent;         /*!< Specifies the ADC data overwritten or Keep */   
N    
N} ADC_InitTypeDef;   
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_TSOVrefSel
S * @brief		Config TSO Vref source for ADC sampling
S */    
Stypedef enum 
S{
S    ADC_VREF,                   /*!< ADC keep Vref pin when ADC sample TSO. */
S    ADC_IVR24,                  /*!< ADC Vref select IVR24 (2.4V) when ADC sample TSO. */
S} ADC_TSOVrefSel;
N#endif
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_ConvTimeSel
S * @brief		ADC conversion time select
S */    
Stypedef enum 
S{
S    ADC_24ADCK,                 /*!< ADC select 24 ADC sampleing clock. */
S    ADC_30ADCK,                 /*!< ADC select 30 ADC sampleing clock. */
S} ADC_ConvTimeSel;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_ReferenceSel
S * @brief		ADC reference select
S */    
Stypedef enum 
S{
S    ADC_VREF_Pin,               /*!< external reference pin VREF+ (ADC_VREF). */
S    ADC_INT_VR24,               /*!< internal reference voltage 2.4 volt. */
S} ADC_ReferenceSel;
N#endif
N
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
Nvoid ADC_DeInit(ADC_Struct *ADCx);
N///@}
N
N///@{
Nvoid ADC_BaseStructure_Init(ADC_InitTypeDef* ADC_BaseInitStruct);
Nvoid ADC_Base_Init(ADC_Struct* ADCx, ADC_InitTypeDef* ADC_BaseInitStruct);
N///@}
N
N///@{
Nvoid ADC_SetPLLClockDivider(ADC_Struct* ADCx, ADC_PLLClockDivDef PLLClockDIV);
Nvoid ADC_ClockSource_Select(ADC_Struct* ADCx, ADC_ClockSourceDef ADCClockSrc);
Nvoid ADC_SetInternalClockDivider(ADC_Struct* ADCx, ADC_INTClockDivDef INTClockSrc);
N#if defined(MG32_3RD)
X#if 0L
S    void ADC_SetConversionTime(ADC_Struct* ADCx, ADC_ConversionTimeDef CONVTime);
N#endif
N///@}
N
N///@{
Nvoid ADC_SetLowerThreshold(ADC_Struct* ADCx, int16_t LThreshold);
Nvoid ADC_SetHigherThreshold(ADC_Struct* ADCx, int16_t HThreshold);
Nvoid ADC_WindowDetectRange_Select(ADC_Struct* ADCx, ADC_WindowDetectApplyDef WINDApply);
Nvoid ADC_WindowDetect_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_Output_Select(ADC_Struct* ADCx,ADC_OutputDef ADCOutSel);
N///@}
N
N///@{
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
Nvoid ADC_PGA_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_SetPGAGain(ADC_Struct* ADCx, uint8_t PGAGain);
Nvoid ADC_SetPGAOffset(ADC_Struct* ADCx, uint8_t PGAOFFT);
Nvoid ADC_PGAOffsetCalibration_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
N#endif
N///@}
N
N///@{
N#if defined(MG32_1ST)
X#if 1L
Nvoid ADC_VRMCalibration(ADC_Struct* ADCx,uint8_t VRMV);
N#endif
Nvoid ADC_StartCalibration(ADC_Struct* ADCx, FunctionalState NewState);
N///@}
N
N///@{
Nvoid ADC_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_DMA_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S    void ADC_DMADataSize_Select(ADC_Struct* ADCx, ADC_DMADataSizeDef DMADataSize);
S    void ADC_DMAMaskFlag_Select(ADC_Struct* ADCx, ADC_DMAMaskE1CNVFDef DMAMaskFlagDef);
S    uint8_t ADC_GetNextConversionChannel(ADC_Struct* ADCx);
N#endif
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N    void ADC_AutoOff_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
N    #if defined(MG32_3RD)
X    #if 0L
S        void ADC_SetStartupTime(ADC_Struct* ADCx, uint16_t ADCSCNTime);
S        void ADC_SetStartupDivider(ADC_Struct* ADCx, ADC_SCNTClockDivDef ADCSCNDIV);
N    #endif
N#endif
Nvoid ADC_WaitDataReadOut(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_SetExtendSampling(ADC_Struct* ADCx, uint8_t ADCSampleTime);
N///@}
N
N///@{
Nvoid ADC_ConversionMode_Select(ADC_Struct* ADCx, ADC_ConversionModeDef ADCConvMode);
Nvoid ADC_ContinueMode_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_HoldConversion_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_MainConversionMode_Select(ADC_Struct* ADCx, ADC_MainConversionModeDef MainCM);
N///@}
N
N///@{
Nvoid ADC_TriggerSource_Select(ADC_Struct* ADCx, ADC_TriggerSourceDef ADCTrgSel);
Nvoid ADC_SoftwareConversion_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_TriggerEdge_Select(ADC_Struct* ADCx, ADC_TriggerEdgeDef ADCExtEdgeSel);
N///@}
N
N///@{
Nvoid ADC_ChannelMUX_Select(ADC_Struct* ADCx, ADC_ChannelMUX_Def ChannelSel);
Nvoid ADC_ExternalChannel_Select(ADC_Struct* ADCx, ADC_ExtChannelDef ExtCHSel);
Nvoid ADC_InternalChannel_Select(ADC_Struct* ADCx, ADC_IntChannelDef IntCHSel);
Nvoid ADC_ScanLoopChannel_Enable(ADC_Struct* ADCx, uint16_t MSKChannelSel, FunctionalState NewState);
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S    void ADC_ChangeMUXTiming_Select(ADC_Struct* ADCx, ADC_ChangeTimingDef ADC_ChangTimeing);
N#endif
N///@}
N
N///@{
Nvoid ADC_SingleDifferentMode_Select(ADC_Struct* ADCx, ADC_ConversionTypeDef ADC_ConversionType);
N///@}
N
N///@{
Nvoid ADC_SetLimitFunction(ADC_Struct* ADCx, ADC_LimitModeDef ADCLimitMode);
Nvoid ADC_SetSum0Channel(ADC_Struct* ADCx,uint8_t Sum0ChannelSel);
Nvoid ADC_SetSum1Channel(ADC_Struct* ADCx,uint8_t Sum1ChannelSel);
Nvoid ADC_SetSum2Channel(ADC_Struct* ADCx,uint8_t Sum2ChannelSel);
Nvoid ADC_SumChannelMode_Select(ADC_Struct* ADCx,ADC_SumChannelXDef ADCSumChXDef);
Nvoid ADC_SetSumNumber(ADC_Struct* ADCx, uint8_t ADCSumNumbers);
Nvoid ADC_SumOverrunMode_Select(ADC_Struct* ADCx, ADC_SumDataOWDef ADCSumOW);
Nuint16_t ADC_GetSum0Flags(ADC_Struct* ADCx);
Nuint16_t ADC_GetSum1Flags(ADC_Struct* ADCx);
Nuint16_t ADC_GetSum2Flags(ADC_Struct* ADCx);
Nvoid ADC_ClearSum0Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag);
Nvoid ADC_ClearSum1Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag);
Nvoid ADC_ClearSum2Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag);
Nint16_t ADC_GetSum0Data(ADC_Struct* ADCx);
Nint16_t ADC_GetSum1Data(ADC_Struct* ADCx);
Nint16_t ADC_GetSum2Data(ADC_Struct* ADCx);
Nvoid ADC_SetSum0Data(ADC_Struct* ADCx, int16_t ADCSum0Initial);
Nvoid ADC_SetSum1Data(ADC_Struct* ADCx, int16_t ADCSum1Initial);
Nvoid ADC_SetSum2Data(ADC_Struct* ADCx, int16_t ADCSum2Initial);
N///@}
N
N///@{
Nvoid ADC_DataAlignment_Select(ADC_Struct* ADCx, ADC_DataAlignModeDef AlignMode);
Nvoid ADC_DataResolution_Select(ADC_Struct* ADCx, ADC_ResolutionDef ResolutionData);
Nvoid ADC_DataOverrunMode_Select(ADC_Struct* ADCx, ADC_DataOWDef DataOW);
Nuint8_t ADC_GetDAT0Flags(ADC_Struct* ADCx);
Nuint8_t ADC_GetDAT0Channel(ADC_Struct* ADCx);
Nint16_t ADC_GetDAT0Data(ADC_Struct* ADCx);
Nvoid ADC_SetDigitalOffset(ADC_Struct* ADCx, int8_t sDigiOffset);
Nvoid ADC_SetOutputCodeFormat(ADC_Struct* ADCx, ADC_OutputCodeFormatDef DatFormat);
N///@}
N
N
N///@{
N#if defined(MG32_3RD)
X#if 0L
Svoid ADC_TSO_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Svoid ADC_TSOVref_Select(ADC_Struct* ADCx, ADC_TSOVrefSel TSOVref);
N#endif
N#if defined(MG32_3RD)
X#if 0L
Svoid ADC_IVR24_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Svoid ADC_TopRefernce_Select(ADC_Struct* ADCx, ADC_ReferenceSel RefSel);
S///@}
N#endif
N
N
N///@{
Nvoid ADC_IT_Config(ADC_Struct* ADCx, uint32_t ADC_ITSrc, FunctionalState NewState);
Nvoid ADC_ITEA_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
NDRV_Return ADC_GetSingleFlagStatus(ADC_Struct* ADCx, uint32_t ADC_ITSTAFlag);
Nuint32_t ADC_GetAllFlagStatus(ADC_Struct* ADCx);
Nvoid ADC_ClearFlag(ADC_Struct* ADCx, uint32_t ADC_ITSTAFlag);
N///@}
N
N#endif
L 38 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_APB_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_APB_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_APB_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the APB
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.18
N * @date        2020/03/13
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N#ifndef __MG32x02z_APB_DRV_H
N#define __MG32x02z_APB_DRV_H
N//#define _MG32x02z_APB_DRV_H_VER 0.01
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_APB.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_APB.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_APB.h
N *
N * @brief       MG32x02z APB Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_APB_H
N#define _MG32x02z_APB_H
N#define _MG32x02z_APB_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_APB_H_VER)
S    #error "MG32x02z_APB_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      APB_Struct
N *              APB  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OBM1F         :1;     //[9] OBM-1 break trigger event detect flag
X            volatile uint8_t  OBM1F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  OBM1_OUT      :1;     //[17] OBM-1 output signal status.
X            volatile const  uint8_t  OBM1_OUT      :1;     
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  OBM1_SW       :1;     //[25] OBM-1 break switching signal status.
X            volatile const  uint8_t  OBM1_SW       :1;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  APB status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] APB interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OBM1_IE       :1;     //[9] OBM-1 break trigger event detect interrupt enable.
X            volatile uint8_t  OBM1_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  APB interrupt enable register */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :4;     //[3..0] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  IRCLK_INV     :1;     //[4] IR clock signal inverse enable bit.
X            volatile uint8_t  IRCLK_INV     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  IRDAT_INV     :1;     //[5] IR data envelope signal inverse enable bit.
X            volatile uint8_t  IRDAT_INV     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IRCLK_MUX     :3;     //[10..8] IR carrier clock source select.
X            volatile uint8_t  IRCLK_MUX     :3;     
N                                        //0x0 = CLK0 : Output 0
N                                        //0x1 = CLK1
N                                        //0x2 = CLK2
N                                        //0x3 = CLK3
N                                        //0x4 = CLK4
N                                        //0x5 = CLK5
N                                        //0x6 = CLK6
N                                        //0x7 = CLK7
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IRDAT_MUX     :3;     //[14..12] IR data envelope signal source select.
X            volatile uint8_t  IRDAT_MUX     :3;     
N                                        //0x0 = DAT0 : Output 0
N                                        //0x1 = DAT1
N                                        //0x2 = DAT2
N                                        //0x3 = DAT3
N                                        //0x4 = DAT4
N                                        //0x5 = DAT5
N                                        //0x6 = DAT6
N                                        //0x7 = DAT7
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  APB global control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __O  uint8_t  TM00_EN       :1;     //[0] TM00 main Timer/Counter enable bit.
X            volatile  uint8_t  TM00_EN       :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __O  uint8_t  TM01_EN       :1;     //[1] TM01 main Timer/Counter enable bit.
X            volatile  uint8_t  TM01_EN       :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __O  uint8_t  TM10_EN       :1;     //[4] TM10 main Timer/Counter enable bit.
X            volatile  uint8_t  TM10_EN       :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[6..5] 
X            volatile const  uint8_t                :2;     
N            __O  uint8_t  TM16_EN       :1;     //[7] TM16 main Timer/Counter enable bit.
X            volatile  uint8_t  TM16_EN       :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __O  uint8_t  TM20_EN       :1;     //[8] TM20 main Timer/Counter enable bit.
X            volatile  uint8_t  TM20_EN       :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __O  uint8_t  TM26_EN       :1;     //[11] TM26 main Timer/Counter enable bit.
X            volatile  uint8_t  TM26_EN       :1;     
N                                        //0 =No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[14..12] 
X            volatile const  uint8_t                :3;     
N            __O  uint8_t  TM36_EN       :1;     //[15] TM36 main Timer/Counter enable bit.
X            volatile  uint8_t  TM36_EN       :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __O  uint8_t  TM00_EN2      :1;     //[16] TM00 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM00_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __O  uint8_t  TM01_EN2      :1;     //[17] TM01 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM01_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __O  uint8_t  TM10_EN2      :1;     //[20] TM10 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM10_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[22..21] 
X            volatile const  uint8_t                :2;     
N            __O  uint8_t  TM16_EN2      :1;     //[23] TM16 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM16_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __O  uint8_t  TM20_EN2      :1;     //[24] TM20 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM20_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[26] 
X            volatile const  uint8_t                :1;     
N            __O  uint8_t  TM26_EN2      :1;     //[27] TM26 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM26_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[30..28] 
X            volatile const  uint8_t                :3;     
N            __O  uint8_t  TM36_EN2      :1;     //[31] TM36 2nd Timer/Counter enable bit.
X            volatile  uint8_t  TM36_EN2      :1;     
N                                        //0 = No : No effect
N                                        //1 = Enable
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  APB global control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ITR6_MUX      :3;     //[2..0] Timer internal common trigger source ITR6 source select
X            volatile uint8_t  ITR6_MUX      :3;     
N                                        //0x0 = TRG0
N                                        //0x1 = TRG1
N                                        //0x2 = TRG2
N                                        //0x3 = TRG3
N                                        //0x4 = TRG4
N                                        //0x5 = TRG5
N                                        //0x6 = TRG6
N                                        //0x7 = TRG7
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ITR7_MUX      :4;     //[7..4] Timer internal common trigger source ITR7 source select
X            volatile uint8_t  ITR7_MUX      :4;     
N                                        //0x0 = TRG0
N                                        //0x1 = TRG1
N                                        //0x2 = TRG2
N                                        //0x3 = TRG3
N                                        //0x4 = TRG4
N                                        //0x5 = TRG5
N                                        //0x6 = TRG6
N                                        //0x7 = TRG7
N                                        //0x8 = TRG8
N                                        //0x9 = TRG9
N                                        //0xA = TRG10
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  APB global control register 2 */
N
N    __I uint32_t  RESERVED1[3];         /*!< RESERVED1  ~ Offset[0x1C]  Reserved */
X    volatile const uint32_t  RESERVED1[3];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OBM1_MDS      :2;     //[1..0] OBM1 break operation mode select
X            volatile uint8_t  OBM1_MDS      :2;     
N                                        //0x0 = AND : AND signal of all break channels' output
N                                        //0x1 = CLR : STA bit is cleared by falling edge of OR signal
N                                        //0x2 = SET : STA bit is set by falling edge of OR signal
N                                        //0x3 = TOGGLE : STA bit is toggle by falling edge of OR signal
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  OBM1_STA      :1;     //[4] OBM1 break switching signal initial state
X            volatile uint8_t  OBM1_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OBM1_LCK      :1;     //[5] OBM1 break switching signal initial state write control
X            volatile uint8_t  OBM1_LCK      :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  OBM1_BKN0     :1;     //[8] OBM1 break source-0 signal inverse enable bit.
X            volatile uint8_t  OBM1_BKN0     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  OBM1_BKN1     :1;     //[9] OBM1 break source-1 signal inverse enable bit.
X            volatile uint8_t  OBM1_BKN1     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  OBM1_BKN2     :1;     //[10] OBM1 break source-2 signal inverse enable bit.
X            volatile uint8_t  OBM1_BKN2     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  OBM1_BKS0     :4;     //[19..16] OBM1 break signal source channel-0 select.
X            volatile uint8_t  OBM1_BKS0     :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __IO uint8_t  OBM1_BKS1     :4;     //[23..20] OBM1 break signal source channel-1 select.
X            volatile uint8_t  OBM1_BKS1     :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __IO uint8_t  OBM1_BKS2     :4;     //[27..24] OBM1 break signal source channel-2 select.
X            volatile uint8_t  OBM1_BKS2     :4;     
N                                        //0x0 = BK0 : Output 1
N                                        //0x1 = BK1
N                                        //0x2 = BK2
N                                        //0x3 = BK3
N                                        //0x4 = BK4
N                                        //0x5 = BK5
N                                        //0x6 = BK6
N                                        //0x7 = BK7
N                                        //0x8 = BK8
N                                        //0x9 = BK9
N                                        //0xA = BK10
N                                        //0xB = BK11
N                                        //0xC = BK12
N                                        //0xD = BK13
N                                        //0xE = BK14
N                                        //0xF = BK15
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }OBM10;                             /*!< OBM10      ~ Offset[0x28]  APB OBM1 control register-0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OBM1_INV0     :1;     //[0] OBM1 source channel-0 signal inverse enable bit.
X            volatile uint8_t  OBM1_INV0     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  OBM1_INV1     :1;     //[1] OBM1 source channel-1 signal inverse enable bit.
X            volatile uint8_t  OBM1_INV1     :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __IO uint8_t  OBM1_POL      :1;     //[2] OBM1 output signal inverse enable bit.
X            volatile uint8_t  OBM1_POL      :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OBM1_FCKS     :2;     //[5..4] OBM1 output deglitch filter clock source select
X            volatile uint8_t  OBM1_FCKS     :2;     
N                                        //0x0 = Disable
N                                        //0x1 = APB : CLK_APB
N                                        //0x2 = APB_DIV8 : CLK_APB divide by 8
N                                        //0x3 = TM00_TRGO
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  OBM1_MUX0     :4;     //[19..16] OBM1 output source channel-0 signal select.
X            volatile uint8_t  OBM1_MUX0     :4;     
N                                        //0x0 = SR0 : Output 0
N                                        //0x1 = SR1
N                                        //0x2 = SR2
N                                        //0x3 = SR3
N                                        //0x4 = SR4
N                                        //0x5 = SR5
N                                        //0x6 = SR6
N                                        //0x7 = SR7
N                                        //0x8 = SR8
N                                        //0x9 = SR9
N                                        //0xA = SR10
N                                        //0xB = SR11
N                                        //0xC = SR12
N                                        //0xD = SR13
N                                        //0xE = SR14
N                                        //0xF = SR15
N            __IO uint8_t  OBM1_MUX1     :4;     //[23..20] OBM1 output source channel-1 signal select.
X            volatile uint8_t  OBM1_MUX1     :4;     
N                                        //0x0 = SR0 : Output 0
N                                        //0x1 = SR1
N                                        //0x2 = SR2
N                                        //0x3 = SR3
N                                        //0x4 = SR4
N                                        //0x5 = SR5
N                                        //0x6 = SR6
N                                        //0x7 = SR7
N                                        //0x8 = SR8
N                                        //0x9 = SR9
N                                        //0xA = SR10
N                                        //0xB = SR11
N                                        //0xC = SR12
N                                        //0xD = SR13
N                                        //0xE = SR14
N                                        //0xF = SR15
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OBM11;                             /*!< OBM11      ~ Offset[0x2C]  APB OBM1 control register-1 */
N
N} APB_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        APB  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define APB_Base                        ((uint32_t)0x5F000000)              /*!< APB Module Global Control */
N#define APB                             ((APB_Struct*) APB_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        APB  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        APB_STA  [register's definitions]
N *              Offset[0x00]  APB status register (0x5F000000)
N ******************************************************************************
N */
N///@{
N#define APB_STA_default                             ((uint32_t)0x03000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_STA */
N#define APB_STA_OBM1_SW_mask_w                      ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define APB_STA_OBM1_SW_mask_h1                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define APB_STA_OBM1_SW_mask_b3                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_STA_OBM1_SW_shift_w                     (25)                    /*!< Bit Shift of 32bit */
N#define APB_STA_OBM1_SW_shift_h1                    (9)                     /*!< Bit Shift of 16bit */
N#define APB_STA_OBM1_SW_shift_b3                    (1)                     /*!< Bit Shift of 8bit */
N
N#define APB_STA_OBM1_OUT_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define APB_STA_OBM1_OUT_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define APB_STA_OBM1_OUT_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_STA_OBM1_OUT_shift_w                    (17)                    /*!< Bit Shift of 32bit */
N#define APB_STA_OBM1_OUT_shift_h1                   (1)                     /*!< Bit Shift of 16bit */
N#define APB_STA_OBM1_OUT_shift_b2                   (1)                     /*!< Bit Shift of 8bit */
N
N#define APB_STA_OBM1F_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define APB_STA_OBM1F_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define APB_STA_OBM1F_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_STA_OBM1F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define APB_STA_OBM1F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define APB_STA_OBM1F_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define APB_STA_OBM1F_happened_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define APB_STA_OBM1F_happened_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define APB_STA_OBM1F_happened_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        APB_INT  [register's definitions]
N *              Offset[0x04]  APB interrupt enable register (0x5F000004)
N ******************************************************************************
N */
N///@{
N#define APB_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_INT */
N#define APB_INT_OBM1_IE_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define APB_INT_OBM1_IE_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define APB_INT_OBM1_IE_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_INT_OBM1_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_INT_OBM1_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_INT_OBM1_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_INT_OBM1_IE_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_INT_OBM1_IE_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_INT_OBM1_IE_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define APB_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define APB_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        APB_CR0  [register's definitions]
N *              Offset[0x10]  APB global control register 0 (0x5F000010)
N ******************************************************************************
N */
N///@{
N#define APB_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_CR0 */
N#define APB_CR0_IRDAT_MUX_mask_w                    ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define APB_CR0_IRDAT_MUX_mask_h0                   ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define APB_CR0_IRDAT_MUX_mask_b1                   ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define APB_CR0_IRDAT_MUX_dat0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DAT0 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat0_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DAT0 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat0_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):DAT0 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat1_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):DAT1 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat1_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):DAT1 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat1_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):DAT1 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat2_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):DAT2 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat2_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(0x2):DAT2 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat2_b1                   ((uint8_t )0x20)        /*!< Bit Value =(0x2):DAT2 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat3_w                    ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):DAT3 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat3_h0                   ((uint16_t)0x3000)      /*!< Bit Value =(0x3):DAT3 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat3_b1                   ((uint8_t )0x30)        /*!< Bit Value =(0x3):DAT3 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat4_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):DAT4 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat4_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(0x4):DAT4 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat4_b1                   ((uint8_t )0x40)        /*!< Bit Value =(0x4):DAT4 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat5_w                    ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):DAT5 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat5_h0                   ((uint16_t)0x5000)      /*!< Bit Value =(0x5):DAT5 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat5_b1                   ((uint8_t )0x50)        /*!< Bit Value =(0x5):DAT5 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat6_w                    ((uint32_t)0x00006000)  /*!< Bit Value =(0x6):DAT6 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat6_h0                   ((uint16_t)0x6000)      /*!< Bit Value =(0x6):DAT6 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat6_b1                   ((uint8_t )0x60)        /*!< Bit Value =(0x6):DAT6 of 8bit */
N#define APB_CR0_IRDAT_MUX_dat7_w                    ((uint32_t)0x00007000)  /*!< Bit Value =(0x7):DAT7 of 32bit */
N#define APB_CR0_IRDAT_MUX_dat7_h0                   ((uint16_t)0x7000)      /*!< Bit Value =(0x7):DAT7 of 16bit */
N#define APB_CR0_IRDAT_MUX_dat7_b1                   ((uint8_t )0x70)        /*!< Bit Value =(0x7):DAT7 of 8bit */
N
N#define APB_CR0_IRCLK_MUX_mask_w                    ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define APB_CR0_IRCLK_MUX_mask_h0                   ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define APB_CR0_IRCLK_MUX_mask_b1                   ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define APB_CR0_IRCLK_MUX_clk0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CLK0 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk0_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CLK0 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk0_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):CLK0 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk1_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CLK1 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk1_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CLK1 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk1_b1                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):CLK1 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk2_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CLK2 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk2_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CLK2 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk2_b1                   ((uint8_t )0x02)        /*!< Bit Value =(0x2):CLK2 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk3_w                    ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):CLK3 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk3_h0                   ((uint16_t)0x0300)      /*!< Bit Value =(0x3):CLK3 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk3_b1                   ((uint8_t )0x03)        /*!< Bit Value =(0x3):CLK3 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk4_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):CLK4 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk4_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(0x4):CLK4 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk4_b1                   ((uint8_t )0x04)        /*!< Bit Value =(0x4):CLK4 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk5_w                    ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):CLK5 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk5_h0                   ((uint16_t)0x0500)      /*!< Bit Value =(0x5):CLK5 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk5_b1                   ((uint8_t )0x05)        /*!< Bit Value =(0x5):CLK5 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk6_w                    ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):CLK6 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk6_h0                   ((uint16_t)0x0600)      /*!< Bit Value =(0x6):CLK6 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk6_b1                   ((uint8_t )0x06)        /*!< Bit Value =(0x6):CLK6 of 8bit */
N#define APB_CR0_IRCLK_MUX_clk7_w                    ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):CLK7 of 32bit */
N#define APB_CR0_IRCLK_MUX_clk7_h0                   ((uint16_t)0x0700)      /*!< Bit Value =(0x7):CLK7 of 16bit */
N#define APB_CR0_IRCLK_MUX_clk7_b1                   ((uint8_t )0x07)        /*!< Bit Value =(0x7):CLK7 of 8bit */
N
N#define APB_CR0_IRDAT_INV_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define APB_CR0_IRDAT_INV_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define APB_CR0_IRDAT_INV_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define APB_CR0_IRDAT_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_CR0_IRDAT_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_CR0_IRDAT_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_CR0_IRDAT_INV_enable_w                  ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR0_IRDAT_INV_enable_h0                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR0_IRDAT_INV_enable_b0                 ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR0_IRCLK_INV_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define APB_CR0_IRCLK_INV_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define APB_CR0_IRCLK_INV_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define APB_CR0_IRCLK_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_CR0_IRCLK_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_CR0_IRCLK_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_CR0_IRCLK_INV_enable_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR0_IRCLK_INV_enable_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR0_IRCLK_INV_enable_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        APB_CR1  [register's definitions]
N *              Offset[0x14]  APB global control register 1 (0x5F000014)
N ******************************************************************************
N */
N///@{
N#define APB_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_CR1 */
N#define APB_CR1_TM36_EN2_mask_w                     ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM36_EN2_mask_h1                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM36_EN2_mask_b3                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM36_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM36_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM36_EN2_no_b3                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM36_EN2_enable_w                   ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM36_EN2_enable_h1                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM36_EN2_enable_b3                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM26_EN2_mask_w                     ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM26_EN2_mask_h1                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM26_EN2_mask_b3                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM26_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM26_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM26_EN2_no_b3                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM26_EN2_enable_w                   ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM26_EN2_enable_h1                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM26_EN2_enable_b3                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM20_EN2_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM20_EN2_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM20_EN2_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM20_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM20_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM20_EN2_no_b3                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM20_EN2_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM20_EN2_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM20_EN2_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM16_EN2_mask_w                     ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM16_EN2_mask_h1                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM16_EN2_mask_b2                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM16_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM16_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM16_EN2_no_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM16_EN2_enable_w                   ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM16_EN2_enable_h1                  ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM16_EN2_enable_b2                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM10_EN2_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM10_EN2_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM10_EN2_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM10_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM10_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM10_EN2_no_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM10_EN2_enable_w                   ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM10_EN2_enable_h1                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM10_EN2_enable_b2                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM01_EN2_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM01_EN2_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM01_EN2_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM01_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM01_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM01_EN2_no_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM01_EN2_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM01_EN2_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM01_EN2_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM00_EN2_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM00_EN2_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM00_EN2_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM00_EN2_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM00_EN2_no_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM00_EN2_no_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM00_EN2_enable_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM00_EN2_enable_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM00_EN2_enable_b2                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM36_EN_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM36_EN_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM36_EN_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM36_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM36_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM36_EN_no_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM36_EN_enable_w                    ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM36_EN_enable_h0                   ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM36_EN_enable_b1                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM26_EN_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM26_EN_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM26_EN_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM26_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM26_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM26_EN_no_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM26_EN_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM26_EN_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM26_EN_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM20_EN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM20_EN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM20_EN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM20_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM20_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM20_EN_no_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM20_EN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM20_EN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM20_EN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM16_EN_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM16_EN_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM16_EN_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM16_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM16_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM16_EN_no_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM16_EN_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM16_EN_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM16_EN_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM10_EN_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM10_EN_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM10_EN_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM10_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM10_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM10_EN_no_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM10_EN_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM10_EN_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM10_EN_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM01_EN_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM01_EN_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM01_EN_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM01_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM01_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM01_EN_no_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM01_EN_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM01_EN_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM01_EN_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_CR1_TM00_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define APB_CR1_TM00_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define APB_CR1_TM00_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_CR1_TM00_EN_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define APB_CR1_TM00_EN_no_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define APB_CR1_TM00_EN_no_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define APB_CR1_TM00_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_CR1_TM00_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_CR1_TM00_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        APB_CR2  [register's definitions]
N *              Offset[0x18]  APB global control register 2 (0x5F000018)
N ******************************************************************************
N */
N///@{
N#define APB_CR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_CR2 */
N#define APB_CR2_ITR7_MUX_mask_w                     ((uint32_t)0x000000F0)  /*!< Bit Mask of 32bit */
N#define APB_CR2_ITR7_MUX_mask_h0                    ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define APB_CR2_ITR7_MUX_mask_b0                    ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define APB_CR2_ITR7_MUX_trg0_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define APB_CR2_ITR7_MUX_trg0_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define APB_CR2_ITR7_MUX_trg0_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define APB_CR2_ITR7_MUX_trg1_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define APB_CR2_ITR7_MUX_trg1_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define APB_CR2_ITR7_MUX_trg1_b0                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N#define APB_CR2_ITR7_MUX_trg2_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):TRG2 of 32bit */
N#define APB_CR2_ITR7_MUX_trg2_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):TRG2 of 16bit */
N#define APB_CR2_ITR7_MUX_trg2_b0                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):TRG2 of 8bit */
N#define APB_CR2_ITR7_MUX_trg3_w                     ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):TRG3 of 32bit */
N#define APB_CR2_ITR7_MUX_trg3_h0                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):TRG3 of 16bit */
N#define APB_CR2_ITR7_MUX_trg3_b0                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):TRG3 of 8bit */
N#define APB_CR2_ITR7_MUX_trg4_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):TRG4 of 32bit */
N#define APB_CR2_ITR7_MUX_trg4_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(0x4):TRG4 of 16bit */
N#define APB_CR2_ITR7_MUX_trg4_b0                    ((uint8_t )0x40)        /*!< Bit Value =(0x4):TRG4 of 8bit */
N#define APB_CR2_ITR7_MUX_trg5_w                     ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):TRG5 of 32bit */
N#define APB_CR2_ITR7_MUX_trg5_h0                    ((uint16_t)0x0050)      /*!< Bit Value =(0x5):TRG5 of 16bit */
N#define APB_CR2_ITR7_MUX_trg5_b0                    ((uint8_t )0x50)        /*!< Bit Value =(0x5):TRG5 of 8bit */
N#define APB_CR2_ITR7_MUX_trg6_w                     ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):TRG6 of 32bit */
N#define APB_CR2_ITR7_MUX_trg6_h0                    ((uint16_t)0x0060)      /*!< Bit Value =(0x6):TRG6 of 16bit */
N#define APB_CR2_ITR7_MUX_trg6_b0                    ((uint8_t )0x60)        /*!< Bit Value =(0x6):TRG6 of 8bit */
N#define APB_CR2_ITR7_MUX_trg7_w                     ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):TRG7 of 32bit */
N#define APB_CR2_ITR7_MUX_trg7_h0                    ((uint16_t)0x0070)      /*!< Bit Value =(0x7):TRG7 of 16bit */
N#define APB_CR2_ITR7_MUX_trg7_b0                    ((uint8_t )0x70)        /*!< Bit Value =(0x7):TRG7 of 8bit */
N#define APB_CR2_ITR7_MUX_trg8_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(0x8):TRG8 of 32bit */
N#define APB_CR2_ITR7_MUX_trg8_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(0x8):TRG8 of 16bit */
N#define APB_CR2_ITR7_MUX_trg8_b0                    ((uint8_t )0x80)        /*!< Bit Value =(0x8):TRG8 of 8bit */
N#define APB_CR2_ITR7_MUX_trg9_w                     ((uint32_t)0x00000090)  /*!< Bit Value =(0x9):TRG9 of 32bit */
N#define APB_CR2_ITR7_MUX_trg9_h0                    ((uint16_t)0x0090)      /*!< Bit Value =(0x9):TRG9 of 16bit */
N#define APB_CR2_ITR7_MUX_trg9_b0                    ((uint8_t )0x90)        /*!< Bit Value =(0x9):TRG9 of 8bit */
N#define APB_CR2_ITR7_MUX_trg10_w                    ((uint32_t)0x000000A0)  /*!< Bit Value =(0xA):TRG10 of 32bit */
N#define APB_CR2_ITR7_MUX_trg10_h0                   ((uint16_t)0x00A0)      /*!< Bit Value =(0xA):TRG10 of 16bit */
N#define APB_CR2_ITR7_MUX_trg10_b0                   ((uint8_t )0xA0)        /*!< Bit Value =(0xA):TRG10 of 8bit */
N
N#define APB_CR2_ITR6_MUX_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define APB_CR2_ITR6_MUX_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define APB_CR2_ITR6_MUX_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define APB_CR2_ITR6_MUX_trg0_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define APB_CR2_ITR6_MUX_trg0_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define APB_CR2_ITR6_MUX_trg0_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define APB_CR2_ITR6_MUX_trg1_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define APB_CR2_ITR6_MUX_trg1_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define APB_CR2_ITR6_MUX_trg1_b0                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N#define APB_CR2_ITR6_MUX_trg2_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):TRG2 of 32bit */
N#define APB_CR2_ITR6_MUX_trg2_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(0x2):TRG2 of 16bit */
N#define APB_CR2_ITR6_MUX_trg2_b0                    ((uint8_t )0x02)        /*!< Bit Value =(0x2):TRG2 of 8bit */
N#define APB_CR2_ITR6_MUX_trg3_w                     ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):TRG3 of 32bit */
N#define APB_CR2_ITR6_MUX_trg3_h0                    ((uint16_t)0x0003)      /*!< Bit Value =(0x3):TRG3 of 16bit */
N#define APB_CR2_ITR6_MUX_trg3_b0                    ((uint8_t )0x03)        /*!< Bit Value =(0x3):TRG3 of 8bit */
N#define APB_CR2_ITR6_MUX_trg4_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):TRG4 of 32bit */
N#define APB_CR2_ITR6_MUX_trg4_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(0x4):TRG4 of 16bit */
N#define APB_CR2_ITR6_MUX_trg4_b0                    ((uint8_t )0x04)        /*!< Bit Value =(0x4):TRG4 of 8bit */
N#define APB_CR2_ITR6_MUX_trg5_w                     ((uint32_t)0x00000005)  /*!< Bit Value =(0x5):TRG5 of 32bit */
N#define APB_CR2_ITR6_MUX_trg5_h0                    ((uint16_t)0x0005)      /*!< Bit Value =(0x5):TRG5 of 16bit */
N#define APB_CR2_ITR6_MUX_trg5_b0                    ((uint8_t )0x05)        /*!< Bit Value =(0x5):TRG5 of 8bit */
N#define APB_CR2_ITR6_MUX_trg6_w                     ((uint32_t)0x00000006)  /*!< Bit Value =(0x6):TRG6 of 32bit */
N#define APB_CR2_ITR6_MUX_trg6_h0                    ((uint16_t)0x0006)      /*!< Bit Value =(0x6):TRG6 of 16bit */
N#define APB_CR2_ITR6_MUX_trg6_b0                    ((uint8_t )0x06)        /*!< Bit Value =(0x6):TRG6 of 8bit */
N#define APB_CR2_ITR6_MUX_trg7_w                     ((uint32_t)0x00000007)  /*!< Bit Value =(0x7):TRG7 of 32bit */
N#define APB_CR2_ITR6_MUX_trg7_h0                    ((uint16_t)0x0007)      /*!< Bit Value =(0x7):TRG7 of 16bit */
N#define APB_CR2_ITR6_MUX_trg7_b0                    ((uint8_t )0x07)        /*!< Bit Value =(0x7):TRG7 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        APB_OBM10  [register's definitions]
N *              Offset[0x28]  APB OBM1 control register-0 (0x5F000028)
N ******************************************************************************
N */
N///@{
N#define APB_OBM10_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_OBM10 */
N#define APB_OBM10_OBM1_BKS2_mask_w                  ((uint32_t)0x0F000000)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_BKS2_mask_h1                 ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_BKS2_mask_b3                 ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk0_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):BK0 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk0_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):BK0 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk0_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):BK0 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk1_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):BK1 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk1_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(0x1):BK1 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk1_b3                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):BK1 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk2_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):BK2 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk2_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):BK2 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk2_b3                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):BK2 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk3_w                   ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):BK3 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk3_h1                  ((uint16_t)0x0300)      /*!< Bit Value =(0x3):BK3 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk3_b3                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):BK3 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk4_w                   ((uint32_t)0x04000000)  /*!< Bit Value =(0x4):BK4 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk4_h1                  ((uint16_t)0x0400)      /*!< Bit Value =(0x4):BK4 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk4_b3                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):BK4 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk5_w                   ((uint32_t)0x05000000)  /*!< Bit Value =(0x5):BK5 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk5_h1                  ((uint16_t)0x0500)      /*!< Bit Value =(0x5):BK5 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk5_b3                  ((uint8_t )0x05)        /*!< Bit Value =(0x5):BK5 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk6_w                   ((uint32_t)0x06000000)  /*!< Bit Value =(0x6):BK6 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk6_h1                  ((uint16_t)0x0600)      /*!< Bit Value =(0x6):BK6 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk6_b3                  ((uint8_t )0x06)        /*!< Bit Value =(0x6):BK6 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk7_w                   ((uint32_t)0x07000000)  /*!< Bit Value =(0x7):BK7 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk7_h1                  ((uint16_t)0x0700)      /*!< Bit Value =(0x7):BK7 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk7_b3                  ((uint8_t )0x07)        /*!< Bit Value =(0x7):BK7 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk8_w                   ((uint32_t)0x08000000)  /*!< Bit Value =(0x8):BK8 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk8_h1                  ((uint16_t)0x0800)      /*!< Bit Value =(0x8):BK8 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk8_b3                  ((uint8_t )0x08)        /*!< Bit Value =(0x8):BK8 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk9_w                   ((uint32_t)0x09000000)  /*!< Bit Value =(0x9):BK9 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk9_h1                  ((uint16_t)0x0900)      /*!< Bit Value =(0x9):BK9 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk9_b3                  ((uint8_t )0x09)        /*!< Bit Value =(0x9):BK9 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk10_w                  ((uint32_t)0x0A000000)  /*!< Bit Value =(0xA):BK10 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk10_h1                 ((uint16_t)0x0A00)      /*!< Bit Value =(0xA):BK10 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk10_b3                 ((uint8_t )0x0A)        /*!< Bit Value =(0xA):BK10 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk11_w                  ((uint32_t)0x0B000000)  /*!< Bit Value =(0xB):BK11 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk11_h1                 ((uint16_t)0x0B00)      /*!< Bit Value =(0xB):BK11 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk11_b3                 ((uint8_t )0x0B)        /*!< Bit Value =(0xB):BK11 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk12_w                  ((uint32_t)0x0C000000)  /*!< Bit Value =(0xC):BK12 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk12_h1                 ((uint16_t)0x0C00)      /*!< Bit Value =(0xC):BK12 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk12_b3                 ((uint8_t )0x0C)        /*!< Bit Value =(0xC):BK12 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk13_w                  ((uint32_t)0x0D000000)  /*!< Bit Value =(0xD):BK13 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk13_h1                 ((uint16_t)0x0D00)      /*!< Bit Value =(0xD):BK13 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk13_b3                 ((uint8_t )0x0D)        /*!< Bit Value =(0xD):BK13 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk14_w                  ((uint32_t)0x0E000000)  /*!< Bit Value =(0xE):BK14 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk14_h1                 ((uint16_t)0x0E00)      /*!< Bit Value =(0xE):BK14 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk14_b3                 ((uint8_t )0x0E)        /*!< Bit Value =(0xE):BK14 of 8bit */
N#define APB_OBM10_OBM1_BKS2_bk15_w                  ((uint32_t)0x0F000000)  /*!< Bit Value =(0xF):BK15 of 32bit */
N#define APB_OBM10_OBM1_BKS2_bk15_h1                 ((uint16_t)0x0F00)      /*!< Bit Value =(0xF):BK15 of 16bit */
N#define APB_OBM10_OBM1_BKS2_bk15_b3                 ((uint8_t )0x0F)        /*!< Bit Value =(0xF):BK15 of 8bit */
N
N#define APB_OBM10_OBM1_BKS1_mask_w                  ((uint32_t)0x00F00000)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_BKS1_mask_h1                 ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_BKS1_mask_b2                 ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk0_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):BK0 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk0_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):BK0 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk0_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):BK0 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk1_w                   ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):BK1 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk1_h1                  ((uint16_t)0x0010)      /*!< Bit Value =(0x1):BK1 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk1_b2                  ((uint8_t )0x10)        /*!< Bit Value =(0x1):BK1 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk2_w                   ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):BK2 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk2_h1                  ((uint16_t)0x0020)      /*!< Bit Value =(0x2):BK2 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk2_b2                  ((uint8_t )0x20)        /*!< Bit Value =(0x2):BK2 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk3_w                   ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):BK3 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk3_h1                  ((uint16_t)0x0030)      /*!< Bit Value =(0x3):BK3 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk3_b2                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):BK3 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk4_w                   ((uint32_t)0x00400000)  /*!< Bit Value =(0x4):BK4 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk4_h1                  ((uint16_t)0x0040)      /*!< Bit Value =(0x4):BK4 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk4_b2                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):BK4 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk5_w                   ((uint32_t)0x00500000)  /*!< Bit Value =(0x5):BK5 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk5_h1                  ((uint16_t)0x0050)      /*!< Bit Value =(0x5):BK5 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk5_b2                  ((uint8_t )0x50)        /*!< Bit Value =(0x5):BK5 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk6_w                   ((uint32_t)0x00600000)  /*!< Bit Value =(0x6):BK6 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk6_h1                  ((uint16_t)0x0060)      /*!< Bit Value =(0x6):BK6 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk6_b2                  ((uint8_t )0x60)        /*!< Bit Value =(0x6):BK6 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk7_w                   ((uint32_t)0x00700000)  /*!< Bit Value =(0x7):BK7 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk7_h1                  ((uint16_t)0x0070)      /*!< Bit Value =(0x7):BK7 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk7_b2                  ((uint8_t )0x70)        /*!< Bit Value =(0x7):BK7 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk8_w                   ((uint32_t)0x00800000)  /*!< Bit Value =(0x8):BK8 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk8_h1                  ((uint16_t)0x0080)      /*!< Bit Value =(0x8):BK8 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk8_b2                  ((uint8_t )0x80)        /*!< Bit Value =(0x8):BK8 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk9_w                   ((uint32_t)0x00900000)  /*!< Bit Value =(0x9):BK9 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk9_h1                  ((uint16_t)0x0090)      /*!< Bit Value =(0x9):BK9 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk9_b2                  ((uint8_t )0x90)        /*!< Bit Value =(0x9):BK9 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk10_w                  ((uint32_t)0x00A00000)  /*!< Bit Value =(0xA):BK10 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk10_h1                 ((uint16_t)0x00A0)      /*!< Bit Value =(0xA):BK10 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk10_b2                 ((uint8_t )0xA0)        /*!< Bit Value =(0xA):BK10 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk11_w                  ((uint32_t)0x00B00000)  /*!< Bit Value =(0xB):BK11 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk11_h1                 ((uint16_t)0x00B0)      /*!< Bit Value =(0xB):BK11 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk11_b2                 ((uint8_t )0xB0)        /*!< Bit Value =(0xB):BK11 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk12_w                  ((uint32_t)0x00C00000)  /*!< Bit Value =(0xC):BK12 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk12_h1                 ((uint16_t)0x00C0)      /*!< Bit Value =(0xC):BK12 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk12_b2                 ((uint8_t )0xC0)        /*!< Bit Value =(0xC):BK12 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk13_w                  ((uint32_t)0x00D00000)  /*!< Bit Value =(0xD):BK13 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk13_h1                 ((uint16_t)0x00D0)      /*!< Bit Value =(0xD):BK13 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk13_b2                 ((uint8_t )0xD0)        /*!< Bit Value =(0xD):BK13 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk14_w                  ((uint32_t)0x00E00000)  /*!< Bit Value =(0xE):BK14 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk14_h1                 ((uint16_t)0x00E0)      /*!< Bit Value =(0xE):BK14 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk14_b2                 ((uint8_t )0xE0)        /*!< Bit Value =(0xE):BK14 of 8bit */
N#define APB_OBM10_OBM1_BKS1_bk15_w                  ((uint32_t)0x00F00000)  /*!< Bit Value =(0xF):BK15 of 32bit */
N#define APB_OBM10_OBM1_BKS1_bk15_h1                 ((uint16_t)0x00F0)      /*!< Bit Value =(0xF):BK15 of 16bit */
N#define APB_OBM10_OBM1_BKS1_bk15_b2                 ((uint8_t )0xF0)        /*!< Bit Value =(0xF):BK15 of 8bit */
N
N#define APB_OBM10_OBM1_BKS0_mask_w                  ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_BKS0_mask_h1                 ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_BKS0_mask_b2                 ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk0_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):BK0 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk0_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):BK0 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk0_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):BK0 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk1_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):BK1 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk1_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(0x1):BK1 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk1_b2                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):BK1 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk2_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):BK2 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk2_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(0x2):BK2 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk2_b2                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):BK2 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk3_w                   ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):BK3 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk3_h1                  ((uint16_t)0x0003)      /*!< Bit Value =(0x3):BK3 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk3_b2                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):BK3 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk4_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):BK4 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk4_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(0x4):BK4 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk4_b2                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):BK4 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk5_w                   ((uint32_t)0x00050000)  /*!< Bit Value =(0x5):BK5 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk5_h1                  ((uint16_t)0x0005)      /*!< Bit Value =(0x5):BK5 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk5_b2                  ((uint8_t )0x05)        /*!< Bit Value =(0x5):BK5 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk6_w                   ((uint32_t)0x00060000)  /*!< Bit Value =(0x6):BK6 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk6_h1                  ((uint16_t)0x0006)      /*!< Bit Value =(0x6):BK6 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk6_b2                  ((uint8_t )0x06)        /*!< Bit Value =(0x6):BK6 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk7_w                   ((uint32_t)0x00070000)  /*!< Bit Value =(0x7):BK7 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk7_h1                  ((uint16_t)0x0007)      /*!< Bit Value =(0x7):BK7 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk7_b2                  ((uint8_t )0x07)        /*!< Bit Value =(0x7):BK7 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk8_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(0x8):BK8 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk8_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(0x8):BK8 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk8_b2                  ((uint8_t )0x08)        /*!< Bit Value =(0x8):BK8 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk9_w                   ((uint32_t)0x00090000)  /*!< Bit Value =(0x9):BK9 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk9_h1                  ((uint16_t)0x0009)      /*!< Bit Value =(0x9):BK9 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk9_b2                  ((uint8_t )0x09)        /*!< Bit Value =(0x9):BK9 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk10_w                  ((uint32_t)0x000A0000)  /*!< Bit Value =(0xA):BK10 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk10_h1                 ((uint16_t)0x000A)      /*!< Bit Value =(0xA):BK10 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk10_b2                 ((uint8_t )0x0A)        /*!< Bit Value =(0xA):BK10 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk11_w                  ((uint32_t)0x000B0000)  /*!< Bit Value =(0xB):BK11 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk11_h1                 ((uint16_t)0x000B)      /*!< Bit Value =(0xB):BK11 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk11_b2                 ((uint8_t )0x0B)        /*!< Bit Value =(0xB):BK11 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk12_w                  ((uint32_t)0x000C0000)  /*!< Bit Value =(0xC):BK12 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk12_h1                 ((uint16_t)0x000C)      /*!< Bit Value =(0xC):BK12 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk12_b2                 ((uint8_t )0x0C)        /*!< Bit Value =(0xC):BK12 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk13_w                  ((uint32_t)0x000D0000)  /*!< Bit Value =(0xD):BK13 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk13_h1                 ((uint16_t)0x000D)      /*!< Bit Value =(0xD):BK13 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk13_b2                 ((uint8_t )0x0D)        /*!< Bit Value =(0xD):BK13 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk14_w                  ((uint32_t)0x000E0000)  /*!< Bit Value =(0xE):BK14 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk14_h1                 ((uint16_t)0x000E)      /*!< Bit Value =(0xE):BK14 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk14_b2                 ((uint8_t )0x0E)        /*!< Bit Value =(0xE):BK14 of 8bit */
N#define APB_OBM10_OBM1_BKS0_bk15_w                  ((uint32_t)0x000F0000)  /*!< Bit Value =(0xF):BK15 of 32bit */
N#define APB_OBM10_OBM1_BKS0_bk15_h1                 ((uint16_t)0x000F)      /*!< Bit Value =(0xF):BK15 of 16bit */
N#define APB_OBM10_OBM1_BKS0_bk15_b2                 ((uint8_t )0x0F)        /*!< Bit Value =(0xF):BK15 of 8bit */
N
N#define APB_OBM10_OBM1_BKN2_mask_w                  ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_BKN2_mask_h0                 ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_BKN2_mask_b1                 ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_BKN2_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_OBM10_OBM1_BKN2_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_OBM10_OBM1_BKN2_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_OBM10_OBM1_BKN2_enable_w                ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_OBM10_OBM1_BKN2_enable_h0               ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_OBM10_OBM1_BKN2_enable_b1               ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_OBM10_OBM1_BKN1_mask_w                  ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_BKN1_mask_h0                 ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_BKN1_mask_b1                 ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_BKN1_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_OBM10_OBM1_BKN1_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_OBM10_OBM1_BKN1_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_OBM10_OBM1_BKN1_enable_w                ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_OBM10_OBM1_BKN1_enable_h0               ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_OBM10_OBM1_BKN1_enable_b1               ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_OBM10_OBM1_BKN0_mask_w                  ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_BKN0_mask_h0                 ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_BKN0_mask_b1                 ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_BKN0_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_OBM10_OBM1_BKN0_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_OBM10_OBM1_BKN0_disable_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_OBM10_OBM1_BKN0_enable_w                ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_OBM10_OBM1_BKN0_enable_h0               ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_OBM10_OBM1_BKN0_enable_b1               ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_OBM10_OBM1_LCK_mask_w                   ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_LCK_mask_h0                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_LCK_mask_b0                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_LCK_locked_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define APB_OBM10_OBM1_LCK_locked_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define APB_OBM10_OBM1_LCK_locked_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define APB_OBM10_OBM1_LCK_un_locked_w              ((uint32_t)0x00000020)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define APB_OBM10_OBM1_LCK_un_locked_h0             ((uint16_t)0x0020)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define APB_OBM10_OBM1_LCK_un_locked_b0             ((uint8_t )0x20)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define APB_OBM10_OBM1_STA_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_STA_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_STA_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_STA_0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define APB_OBM10_OBM1_STA_0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define APB_OBM10_OBM1_STA_0_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define APB_OBM10_OBM1_STA_1_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(1):1 of 32bit */
N#define APB_OBM10_OBM1_STA_1_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(1):1 of 16bit */
N#define APB_OBM10_OBM1_STA_1_b0                     ((uint8_t )0x10)        /*!< Bit Value =(1):1 of 8bit */
N
N#define APB_OBM10_OBM1_MDS_mask_w                   ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define APB_OBM10_OBM1_MDS_mask_h0                  ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define APB_OBM10_OBM1_MDS_mask_b0                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define APB_OBM10_OBM1_MDS_and_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):AND of 32bit */
N#define APB_OBM10_OBM1_MDS_and_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):AND of 16bit */
N#define APB_OBM10_OBM1_MDS_and_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):AND of 8bit */
N#define APB_OBM10_OBM1_MDS_clr_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):CLR of 32bit */
N#define APB_OBM10_OBM1_MDS_clr_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(0x1):CLR of 16bit */
N#define APB_OBM10_OBM1_MDS_clr_b0                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):CLR of 8bit */
N#define APB_OBM10_OBM1_MDS_set_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):SET of 32bit */
N#define APB_OBM10_OBM1_MDS_set_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(0x2):SET of 16bit */
N#define APB_OBM10_OBM1_MDS_set_b0                   ((uint8_t )0x02)        /*!< Bit Value =(0x2):SET of 8bit */
N#define APB_OBM10_OBM1_MDS_toggle_w                 ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):TOGGLE of 32bit */
N#define APB_OBM10_OBM1_MDS_toggle_h0                ((uint16_t)0x0003)      /*!< Bit Value =(0x3):TOGGLE of 16bit */
N#define APB_OBM10_OBM1_MDS_toggle_b0                ((uint8_t )0x03)        /*!< Bit Value =(0x3):TOGGLE of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        APB_OBM11  [register's definitions]
N *              Offset[0x2C]  APB OBM1 control register-1 (0x5F00002C)
N ******************************************************************************
N */
N///@{
N#define APB_OBM11_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of APB_OBM11 */
N#define APB_OBM11_OBM1_MUX1_mask_w                  ((uint32_t)0x00F00000)  /*!< Bit Mask of 32bit */
N#define APB_OBM11_OBM1_MUX1_mask_h1                 ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define APB_OBM11_OBM1_MUX1_mask_b2                 ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr0_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SR0 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr0_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SR0 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr0_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):SR0 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr1_w                   ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):SR1 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr1_h1                  ((uint16_t)0x0010)      /*!< Bit Value =(0x1):SR1 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr1_b2                  ((uint8_t )0x10)        /*!< Bit Value =(0x1):SR1 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr2_w                   ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):SR2 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr2_h1                  ((uint16_t)0x0020)      /*!< Bit Value =(0x2):SR2 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr2_b2                  ((uint8_t )0x20)        /*!< Bit Value =(0x2):SR2 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr3_w                   ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):SR3 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr3_h1                  ((uint16_t)0x0030)      /*!< Bit Value =(0x3):SR3 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr3_b2                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):SR3 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr4_w                   ((uint32_t)0x00400000)  /*!< Bit Value =(0x4):SR4 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr4_h1                  ((uint16_t)0x0040)      /*!< Bit Value =(0x4):SR4 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr4_b2                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):SR4 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr5_w                   ((uint32_t)0x00500000)  /*!< Bit Value =(0x5):SR5 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr5_h1                  ((uint16_t)0x0050)      /*!< Bit Value =(0x5):SR5 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr5_b2                  ((uint8_t )0x50)        /*!< Bit Value =(0x5):SR5 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr6_w                   ((uint32_t)0x00600000)  /*!< Bit Value =(0x6):SR6 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr6_h1                  ((uint16_t)0x0060)      /*!< Bit Value =(0x6):SR6 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr6_b2                  ((uint8_t )0x60)        /*!< Bit Value =(0x6):SR6 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr7_w                   ((uint32_t)0x00700000)  /*!< Bit Value =(0x7):SR7 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr7_h1                  ((uint16_t)0x0070)      /*!< Bit Value =(0x7):SR7 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr7_b2                  ((uint8_t )0x70)        /*!< Bit Value =(0x7):SR7 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr8_w                   ((uint32_t)0x00800000)  /*!< Bit Value =(0x8):SR8 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr8_h1                  ((uint16_t)0x0080)      /*!< Bit Value =(0x8):SR8 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr8_b2                  ((uint8_t )0x80)        /*!< Bit Value =(0x8):SR8 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr9_w                   ((uint32_t)0x00900000)  /*!< Bit Value =(0x9):SR9 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr9_h1                  ((uint16_t)0x0090)      /*!< Bit Value =(0x9):SR9 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr9_b2                  ((uint8_t )0x90)        /*!< Bit Value =(0x9):SR9 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr10_w                  ((uint32_t)0x00A00000)  /*!< Bit Value =(0xA):SR10 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr10_h1                 ((uint16_t)0x00A0)      /*!< Bit Value =(0xA):SR10 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr10_b2                 ((uint8_t )0xA0)        /*!< Bit Value =(0xA):SR10 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr11_w                  ((uint32_t)0x00B00000)  /*!< Bit Value =(0xB):SR11 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr11_h1                 ((uint16_t)0x00B0)      /*!< Bit Value =(0xB):SR11 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr11_b2                 ((uint8_t )0xB0)        /*!< Bit Value =(0xB):SR11 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr12_w                  ((uint32_t)0x00C00000)  /*!< Bit Value =(0xC):SR12 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr12_h1                 ((uint16_t)0x00C0)      /*!< Bit Value =(0xC):SR12 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr12_b2                 ((uint8_t )0xC0)        /*!< Bit Value =(0xC):SR12 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr13_w                  ((uint32_t)0x00D00000)  /*!< Bit Value =(0xD):SR13 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr13_h1                 ((uint16_t)0x00D0)      /*!< Bit Value =(0xD):SR13 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr13_b2                 ((uint8_t )0xD0)        /*!< Bit Value =(0xD):SR13 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr14_w                  ((uint32_t)0x00E00000)  /*!< Bit Value =(0xE):SR14 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr14_h1                 ((uint16_t)0x00E0)      /*!< Bit Value =(0xE):SR14 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr14_b2                 ((uint8_t )0xE0)        /*!< Bit Value =(0xE):SR14 of 8bit */
N#define APB_OBM11_OBM1_MUX1_sr15_w                  ((uint32_t)0x00F00000)  /*!< Bit Value =(0xF):SR15 of 32bit */
N#define APB_OBM11_OBM1_MUX1_sr15_h1                 ((uint16_t)0x00F0)      /*!< Bit Value =(0xF):SR15 of 16bit */
N#define APB_OBM11_OBM1_MUX1_sr15_b2                 ((uint8_t )0xF0)        /*!< Bit Value =(0xF):SR15 of 8bit */
N
N#define APB_OBM11_OBM1_MUX0_mask_w                  ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define APB_OBM11_OBM1_MUX0_mask_h1                 ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define APB_OBM11_OBM1_MUX0_mask_b2                 ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr0_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SR0 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr0_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SR0 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr0_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):SR0 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr1_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):SR1 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr1_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(0x1):SR1 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr1_b2                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):SR1 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr2_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):SR2 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr2_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(0x2):SR2 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr2_b2                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):SR2 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr3_w                   ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):SR3 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr3_h1                  ((uint16_t)0x0003)      /*!< Bit Value =(0x3):SR3 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr3_b2                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):SR3 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr4_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):SR4 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr4_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(0x4):SR4 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr4_b2                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):SR4 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr5_w                   ((uint32_t)0x00050000)  /*!< Bit Value =(0x5):SR5 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr5_h1                  ((uint16_t)0x0005)      /*!< Bit Value =(0x5):SR5 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr5_b2                  ((uint8_t )0x05)        /*!< Bit Value =(0x5):SR5 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr6_w                   ((uint32_t)0x00060000)  /*!< Bit Value =(0x6):SR6 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr6_h1                  ((uint16_t)0x0006)      /*!< Bit Value =(0x6):SR6 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr6_b2                  ((uint8_t )0x06)        /*!< Bit Value =(0x6):SR6 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr7_w                   ((uint32_t)0x00070000)  /*!< Bit Value =(0x7):SR7 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr7_h1                  ((uint16_t)0x0007)      /*!< Bit Value =(0x7):SR7 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr7_b2                  ((uint8_t )0x07)        /*!< Bit Value =(0x7):SR7 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr8_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(0x8):SR8 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr8_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(0x8):SR8 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr8_b2                  ((uint8_t )0x08)        /*!< Bit Value =(0x8):SR8 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr9_w                   ((uint32_t)0x00090000)  /*!< Bit Value =(0x9):SR9 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr9_h1                  ((uint16_t)0x0009)      /*!< Bit Value =(0x9):SR9 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr9_b2                  ((uint8_t )0x09)        /*!< Bit Value =(0x9):SR9 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr10_w                  ((uint32_t)0x000A0000)  /*!< Bit Value =(0xA):SR10 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr10_h1                 ((uint16_t)0x000A)      /*!< Bit Value =(0xA):SR10 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr10_b2                 ((uint8_t )0x0A)        /*!< Bit Value =(0xA):SR10 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr11_w                  ((uint32_t)0x000B0000)  /*!< Bit Value =(0xB):SR11 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr11_h1                 ((uint16_t)0x000B)      /*!< Bit Value =(0xB):SR11 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr11_b2                 ((uint8_t )0x0B)        /*!< Bit Value =(0xB):SR11 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr12_w                  ((uint32_t)0x000C0000)  /*!< Bit Value =(0xC):SR12 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr12_h1                 ((uint16_t)0x000C)      /*!< Bit Value =(0xC):SR12 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr12_b2                 ((uint8_t )0x0C)        /*!< Bit Value =(0xC):SR12 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr13_w                  ((uint32_t)0x000D0000)  /*!< Bit Value =(0xD):SR13 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr13_h1                 ((uint16_t)0x000D)      /*!< Bit Value =(0xD):SR13 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr13_b2                 ((uint8_t )0x0D)        /*!< Bit Value =(0xD):SR13 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr14_w                  ((uint32_t)0x000E0000)  /*!< Bit Value =(0xE):SR14 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr14_h1                 ((uint16_t)0x000E)      /*!< Bit Value =(0xE):SR14 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr14_b2                 ((uint8_t )0x0E)        /*!< Bit Value =(0xE):SR14 of 8bit */
N#define APB_OBM11_OBM1_MUX0_sr15_w                  ((uint32_t)0x000F0000)  /*!< Bit Value =(0xF):SR15 of 32bit */
N#define APB_OBM11_OBM1_MUX0_sr15_h1                 ((uint16_t)0x000F)      /*!< Bit Value =(0xF):SR15 of 16bit */
N#define APB_OBM11_OBM1_MUX0_sr15_b2                 ((uint8_t )0x0F)        /*!< Bit Value =(0xF):SR15 of 8bit */
N
N#define APB_OBM11_OBM1_FCKS_mask_w                  ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define APB_OBM11_OBM1_FCKS_mask_h0                 ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define APB_OBM11_OBM1_FCKS_mask_b0                 ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define APB_OBM11_OBM1_FCKS_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define APB_OBM11_OBM1_FCKS_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define APB_OBM11_OBM1_FCKS_disable_b0              ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define APB_OBM11_OBM1_FCKS_apb_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):APB of 32bit */
N#define APB_OBM11_OBM1_FCKS_apb_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(0x1):APB of 16bit */
N#define APB_OBM11_OBM1_FCKS_apb_b0                  ((uint8_t )0x10)        /*!< Bit Value =(0x1):APB of 8bit */
N#define APB_OBM11_OBM1_FCKS_apb_div8_w              ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):APB_DIV8 of 32bit */
N#define APB_OBM11_OBM1_FCKS_apb_div8_h0             ((uint16_t)0x0020)      /*!< Bit Value =(0x2):APB_DIV8 of 16bit */
N#define APB_OBM11_OBM1_FCKS_apb_div8_b0             ((uint8_t )0x20)        /*!< Bit Value =(0x2):APB_DIV8 of 8bit */
N#define APB_OBM11_OBM1_FCKS_tm00_trgo_w             ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):TM00_TRGO of 32bit */
N#define APB_OBM11_OBM1_FCKS_tm00_trgo_h0            ((uint16_t)0x0030)      /*!< Bit Value =(0x3):TM00_TRGO of 16bit */
N#define APB_OBM11_OBM1_FCKS_tm00_trgo_b0            ((uint8_t )0x30)        /*!< Bit Value =(0x3):TM00_TRGO of 8bit */
N
N#define APB_OBM11_OBM1_POL_mask_w                   ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define APB_OBM11_OBM1_POL_mask_h0                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define APB_OBM11_OBM1_POL_mask_b0                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define APB_OBM11_OBM1_POL_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_OBM11_OBM1_POL_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_OBM11_OBM1_POL_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_OBM11_OBM1_POL_enable_w                 ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_OBM11_OBM1_POL_enable_h0                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_OBM11_OBM1_POL_enable_b0                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_OBM11_OBM1_INV1_mask_w                  ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define APB_OBM11_OBM1_INV1_mask_h0                 ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define APB_OBM11_OBM1_INV1_mask_b0                 ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define APB_OBM11_OBM1_INV1_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_OBM11_OBM1_INV1_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_OBM11_OBM1_INV1_disable_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_OBM11_OBM1_INV1_enable_w                ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_OBM11_OBM1_INV1_enable_h0               ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_OBM11_OBM1_INV1_enable_b0               ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define APB_OBM11_OBM1_INV0_mask_w                  ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define APB_OBM11_OBM1_INV0_mask_h0                 ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define APB_OBM11_OBM1_INV0_mask_b0                 ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define APB_OBM11_OBM1_INV0_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define APB_OBM11_OBM1_INV0_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define APB_OBM11_OBM1_INV0_disable_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define APB_OBM11_OBM1_INV0_enable_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define APB_OBM11_OBM1_INV0_enable_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define APB_OBM11_OBM1_INV0_enable_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_APB_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_APB.h                         */
N/*----------------------------------------------------------------------------*/
L 39 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_APB_DRV.h" 2
N#include "MG32x02z__ExtraStruct.h"
N
N
N
N/**
N * @brief  	simple define
N *
N */ 
N
N/** @brief OBMx unlock for update initial state */
N#define APB_OBMx_unlocked           ((uint8_t)0x20)      /*!< Bit Value =(1):Un-Locked of 8it */
N/** @brief OBMx initial to '1' state */
N#define APB_OBMx_initial_1          ((uint8_t)0x10)      /*!< Bit Value =(1):Un-Locked of 8it */
N/** @brief OBMx initial to '0' state */
N#define APB_OBMx_initial_0          ((uint8_t)0x00)      /*!< Bit Value =(1):Un-Locked of 8it */
N
N/** @brief APB Enable TM36 2nd Timer/Counter */
N#define APB_TM36_EN2                APB_CR1_TM36_EN2_enable_w
N/** @brief APB Enable TM26 2nd Timer/Counter */
N#define APB_TM26_EN2                APB_CR1_TM26_EN2_enable_w
N/** @brief APB Enable TM20 2nd Timer/Counter */
N#define APB_TM20_EN2                APB_CR1_TM20_EN2_enable_w
N/** @brief APB Enable TM16 2nd Timer/Counter */
N#define APB_TM16_EN2                APB_CR1_TM16_EN2_enable_w
N/** @brief APB Enable TM10 2nd Timer/Counter */
N#define APB_TM10_EN2                APB_CR1_TM10_EN2_enable_w
N/** @brief APB Enable TM01 2nd Timer/Counter */
N#define APB_TM01_EN2                APB_CR1_TM01_EN2_enable_w
N/** @brief APB Enable TM00 2nd Timer/Counter */
N#define APB_TM00_EN2                APB_CR1_TM00_EN2_enable_w
N
N/** @brief APB Enable TM36 main Timer/Counter */
N#define APB_TM36_EN                 APB_CR1_TM36_EN_enable_w
N/** @brief APB Enable TM26 main Timer/Counter */
N#define APB_TM26_EN                 APB_CR1_TM26_EN_enable_w
N/** @brief APB Enable TM20 main Timer/Counter */
N#define APB_TM20_EN                 APB_CR1_TM20_EN_enable_w
N/** @brief APB Enable TM16 main Timer/Counter */
N#define APB_TM16_EN                 APB_CR1_TM16_EN_enable_w
N/** @brief APB Enable TM10 main Timer/Counter */
N#define APB_TM10_EN                 APB_CR1_TM10_EN_enable_w
N/** @brief APB Enable TM01 main Timer/Counter */
N#define APB_TM01_EN                 APB_CR1_TM01_EN_enable_w
N/** @brief APB Enable TM00 main Timer/Counter */
N#define APB_TM00_EN                 APB_CR1_TM00_EN_enable_w
N
N/** @brief OBM1F trigger event flag */
N#define APB_OBM1F                   APB_STA_OBM1F_happened_w
N/** @brief OBM1 interrupt enable bit */
N#define APB_OBM1_IE                 APB_INT_OBM1_IE_enable_w
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S/** @brief OBM0F trigger event flag */
S#define APB_OBM0F                   APB_STA_OBM0F_happened_w
S/** @brief OBM0 interrupt enable bit */
S#define APB_OBM0_IE                 APB_INT_OBM0_IE_enable_w
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** @brief NCO0 adder overflow event flag */
S#define APB_NCO0F                   APB_STA_NCO0F_happened_w
S/** @brief NCO0 interrupt control bit */
S#define APB_NCO0_IE                 APB_INT_NCO0_IE_enable_w
N#endif
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		APB_TimerITR6SrcDef
N * @brief		declare ITR6 source
N */        
Ntypedef enum 
N{
N    ITR6_TM00_TRGO=0,   /*!< TM00's TRGO signal */
N    ITR6_TM10_TRGO=1,   /*!< TM10's TRGO signal */
N    ITR6_TM20_TRGO=2,   /*!< TM20's TRGO signal */
N    ITR6_TM36_TRGO=3,   /*!< TM36's TRGO signal */
N    ITR6_INT_PB=4,      /*!< INT_PB signal */
N    ITR6_URT1_TMO=5,    /*!< URT1's TMO signal */
N    ITR6_URT2_BRO=6,    /*!< URT2's BRO signal */
N    ITR6_URT2_TMO=7,    /*!< URT2's TMO signal */
N} APB_TimerITR6SrcDef;
N
N
N/** 
N * @enum		APB_TimerITR7SrcDef
N * @brief		declare ITR7 source
N */        
Ntypedef enum 
N{
N    ITR7_TM01_TRGO=0,   /*!< TM01's TRGO signal */
N    ITR7_TM16_TRGO=1,   /*!< TM16's TRGO signal */
N    ITR7_TM26_TRGO=2,   /*!< TM26's TRGO signal */
N    ITR7_ADC0_OUT=3,    /*!< ADC0_OUT signal */
N    ITR7_INT_PD=4,      /*!< INT_PD signal */
N    ITR7_URT1_BRO=5,    /*!< URT1's BRO signal */
N    ITR7_URT3_BRO=6,    /*!< URT3's BRO signal */
N    ITR7_URT3_TMO=7,    /*!< URT3's TMO signal */
N    ITR7_ICKO_INT=8,    /*!< ICKO interrupt event */
N    ITR7_RTC_OUT=9,     /*!< RTC Output signal */
N    ITR7_TM36_XOR=10,   /*!< TM36 XOR gate output signal */
N} APB_TimerITR7SrcDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		APB_TimerITR6SrcDef
S * @brief		declare ITR6 source
S */        
Stypedef enum 
S{
S    ITR6_TM00_TRGO=0,   /*!< TM00's TRGO signal */
S    ITR6_TM10_TRGO=1,   /*!< TM10's TRGO signal */
S    ITR6_TM36_TRGO=3,   /*!< TM36's TRGO signal */
S    ITR6_INT_PB=4,      /*!< INT_PB signal */
S    ITR6_URT1_TMO=5,    /*!< URT1's TMO signal */
S} APB_TimerITR6SrcDef;
S
S
S/** 
S * @enum		APB_TimerITR7SrcDef
S * @brief		declare ITR7 source
S */        
Stypedef enum 
S{
S    ITR7_TM01_TRGO=0,   /*!< TM01's TRGO signal */
S    ITR7_TM16_TRGO=1,   /*!< TM16's TRGO signal */
S    ITR7_ADC0_OUT=3,    /*!< ADC0_OUT signal */
S    ITR7_INT_PD=4,      /*!< INT_PD signal */
S    ITR7_URT1_BRO=5,    /*!< URT1's BRO signal */
S    ITR7_ICKO_INT=8,    /*!< ICKO interrupt event */
S    ITR7_RTC_OUT=9,     /*!< RTC Output signal */
S    ITR7_TM36_XOR=10,   /*!< TM36 XOR gate output signal */
S} APB_TimerITR7SrcDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		APB_TimerITR6SrcDef
S * @brief		declare ITR6 source
S */        
Stypedef enum 
S{
S    ITR6_TM00_TRGO=0,   /*!< TM00's TRGO signal */
S    ITR6_TM10_TRGO=1,   /*!< TM10's TRGO signal */
S    ITR6_TM20_TRGO=2,   /*!< TM20's TRGO signal */
S    ITR6_TM36_TRGO=3,   /*!< TM36's TRGO signal */
S    ITR6_INT_PB=4,      /*!< INT_PB signal */
S    ITR6_URT1_TMO=5,    /*!< URT1's TMO signal */
S    ITR6_URT2_BRO=6,    /*!< URT2's BRO signal */
S    ITR6_URT2_TMO=7,    /*!< URT2's TMO signal */
S} APB_TimerITR6SrcDef;
S
S
S/** 
S * @enum		APB_TimerITR7SrcDef
S * @brief		declare ITR7 source
S */        
Stypedef enum 
S{
S    ITR7_TM01_TRGO=0,   /*!< TM01's TRGO signal */
S    ITR7_TM16_TRGO=1,   /*!< TM16's TRGO signal */
S    ITR7_TM26_TRGO=2,   /*!< TM26's TRGO signal */
S    ITR7_ADC0_OUT=3,    /*!< ADC0_OUT signal */
S    ITR7_INT_PD=4,      /*!< INT_PD signal */
S    ITR7_URT1_BRO=5,    /*!< URT1's BRO signal */
S    ITR7_ICKO_INT=8,    /*!< ICKO interrupt event */
S    ITR7_RTC_OUT=9,     /*!< RTC Output signal */
S    ITR7_TM36_XOR=10,   /*!< TM36 XOR gate output signal */
S    ITR7_NCO0_OUT=11,   /*!< NCO0_OUT output signal */
S} APB_TimerITR7SrcDef;
N#endif
N
N
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		BKS0SrcDef
N * @brief		declare BKS0 source
N */        
Ntypedef enum 
N{
N    BKS0_Logic_1=0,     /*!< Output '1' state */
N    BKS0_ADC0_OUT=3,    /*!< ADC0_OUT signal state */
N    BKS0_TM00_TRGO=4,   /*!< TM00's TRGO signal */
N    BKS0_TM10_TRGO=5,   /*!< TM10's TRGO signal */
N    BKS0_TM20_OC00=8,   /*!< TM20's OC00 output state  */
N    BKS0_TM36_OC2=9,    /*!< TM36's OC2 output state */
N    BKS0_CMP0_OUT=10,   /*!< CMP0's output state  */
N    BKS0_URT0_TX=12,    /*!< URT0's TX signal */
N    BKS0_URT2_TX=13,    /*!< URT2's TX signal */
N    BKS0_URT0_RX=14,    /*!< URT0's RX signal */
N    BKS0_URT2_RX=15,    /*!< URT2's RX signal */
N} BKS0SrcDef;
N
N/** 
N * @enum		BKS1SrcDef
N * @brief		declare BKS1 source
N */        
Ntypedef enum 
N{
N    BKS1_Logic_1=0,     /*!< Output '1' state */
N    BKS1_TM01_TRGO=4,   /*!< TM01's TRGO signal */
N    BKS1_TM26_TRGO=6,   /*!< TM26's TRGO signal */
N    BKS1_TM20_OC10=8,   /*!< TM20's OC10 output state  */
N    BKS1_TM36_OC3=9,    /*!< TM36's OC3 output state */
N    BKS1_CMP1_OUT=10,   /*!< CMP1's output state  */
N    BKS1_URT1_TX=12,    /*!< URT1's TX signal */
N    BKS1_URT3_TX=13,    /*!< URT3's TX signal */
N    BKS1_URT1_RX=14,    /*!< URT1's RX signal */
N    BKS1_URT3_RX=15,    /*!< URT3's RX signal */
N} BKS1SrcDef;
N
N/** 
N * @enum		BKS2SrcDef
N * @brief		declare BKS2 source
N */        
Ntypedef enum 
N{
N    BKS2_Logic_1=0,     /*!< Output '1' state */
N    BKS2_SPI0_MOSI=3,   /*!< SPI0's MOSI output state */
N    BKS2_TM36_TRGO=6,   /*!< TM36's TRGO signal */
N    BKS2_CMP2_OUT=10,   /*!< CMP2's output state  */
N    BKS2_CMP3_OUT=11,   /*!< CMP3's output state  */
N    BKS2_URT2_BRO=12,   /*!< URT2's BRO signal */
N    BKS2_URT2_TMO=13,   /*!< URT2's TMO signal */
N    BKS2_URT3_BRO=14,   /*!< URT3's BRO signal */
N    BKS2_URT3_TMO=15,   /*!< URT3's TM0 signal */
N} BKS2SrcDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		BKS0SrcDef
S * @brief		declare BKS0 source
S */        
Stypedef enum 
S{
S    BKS0_Logic_1=0,     /*!< Output '1' state */
S    BKS0_INT_PA=1,      /*!< INT_PA signal state */
S    BKS0_INT_PC=2,      /*!< INT_PC signal state */
S    BKS0_ADC0_OUT=3,    /*!< ADC0_OUT signal state */
S    BKS0_TM00_TRGO=4,   /*!< TM00's TRGO signal */
S    BKS0_TM10_TRGO=5,   /*!< TM10's TRGO signal */
S    BKS0_TM36_OC2=9,    /*!< TM36's OC2 output state */
S    BKS0_CMP0_OUT=10,   /*!< CMP0's output state  */
S    BKS0_URT0_TX=12,    /*!< URT0's TX signal */
S    BKS0_URT0_RX=14,    /*!< URT0's RX signal */
S} BKS0SrcDef;
S
S/** 
S * @enum		BKS1SrcDef
S * @brief		declare BKS1 source
S */        
Stypedef enum 
S{
S    BKS1_Logic_1=0,     /*!< Output '1' state */
S    BKS1_INT_PB=1,      /*!< INT_PB signal state */
S    BKS1_INT_PD=2,      /*!< INT_PD signal state */
S    BKS1_INT_BOD1=3,    /*!< BOD1 signal state */
S    BKS1_TM01_TRGO=4,   /*!< TM01's TRGO signal */
S    BKS1_TM16_TRGO=5,   /*!< TM16's TRGO signal */
S    BKS1_TM36_OC3=9,    /*!< TM36's OC3 output state */
S    BKS1_CMP1_OUT=10,   /*!< CMP1's output state  */
S    BKS1_URT1_TX=12,    /*!< URT1's TX signal */
S    BKS1_URT1_RX=14,    /*!< URT1's RX signal */
S} BKS1SrcDef;
S
S/** 
S * @enum		BKS2SrcDef
S * @brief		declare BKS2 source
S */        
Stypedef enum 
S{
S    BKS2_Logic_1=0,     /*!< Output '1' state */
S    BKS2_SPI0_MOSI=3,   /*!< SPI0's MOSI output state */
S    BKS2_TM36_TRGO=6,   /*!< TM36's TRGO signal */
S} BKS2SrcDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		BKS0SrcDef
S * @brief		declare BKS0 source
S */        
Stypedef enum 
S{
S    BKS0_Logic_1=0,     /*!< Output '1' state */
S    BKS0_INT_PA=1,      /*!< INT_PA signal state */
S    BKS0_INT_PC=2,      /*!< INT_PC signal state */
S    BKS0_ADC0_OUT=3,    /*!< ADC0_OUT signal state */
S    BKS0_TM00_TRGO=4,   /*!< TM00's TRGO signal */
S    BKS0_TM10_TRGO=5,   /*!< TM10's TRGO signal */
S    BKS0_TM20_TRGO=6,   /*!< TM20's TRGO output state  */
S    BKS0_CCL_P0=7,      /*!< CCL_P0 output state  */
S    BKS0_TM20_OC00=8,   /*!< TM20's OC00 output state  */
S    BKS0_TM36_OC2=9,    /*!< TM36's OC2 output state */
S    BKS0_CMP0_OUT=10,   /*!< CMP0's output state  */
S    BKS0_URT0_TX=12,    /*!< URT0's TX signal */
S    BKS0_URT2_TX=13,    /*!< URT2's TX signal */
S    BKS0_URT0_RX=14,    /*!< URT0's RX signal */
S    BKS0_URT2_RX=15,    /*!< URT2's RX signal */
S} BKS0SrcDef;
S
S/** 
S * @enum		BKS1SrcDef
S * @brief		declare BKS1 source
S */        
Stypedef enum 
S{
S    BKS1_Logic_1=0,     /*!< Output '1' state */
S    BKS1_INT_PB=1,      /*!< INT_PB signal state */
S    BKS1_INT_PD=2,      /*!< INT_PD signal state */
S    BKS1_INT_BOD1=3,    /*!< BOD1 signal state */
S    BKS1_TM01_TRGO=4,   /*!< TM01's TRGO signal */
S    BKS1_TM16_TRGO=5,   /*!< TM16's TRGO signal */
S    BKS1_TM26_TRGO=6,   /*!< TM26's TRGO signal */
S    BKS1_CCL_P1=7,      /*!< CCL_P1 output state  */
S    BKS1_TM20_OC10=8,   /*!< TM20's OC10 output state  */
S    BKS1_TM36_OC3=9,    /*!< TM36's OC3 output state */
S    BKS1_CMP1_OUT=10,   /*!< CMP1's output state  */
S    BKS1_URT1_TX=12,    /*!< URT1's TX signal */
S    BKS1_URT1_RX=14,    /*!< URT1's RX signal */
S} BKS1SrcDef;
S
S/** 
S * @enum		BKS2SrcDef
S * @brief		declare BKS2 source
S */        
Stypedef enum 
S{
S    BKS2_Logic_1=0,     /*!< Output '1' state */
S    BKS2_INT_PE=1,      /*!< INT_PE signal state */
S    BKS2_SPI0_MOSI=3,   /*!< SPI0's MOSI output state */
S    BKS2_TM36_TRGO=6,   /*!< TM36's TRGO signal */
S    BKS2_URT2_BRO=12,   /*!< URT2's BRO signal */
S    BKS2_URT2_TMO=13,   /*!< URT2's TMO signal */
S} BKS2SrcDef;
N#endif
N
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		IRCLKSrcDef
N * @brief		declare IRCLK source
N */        
Ntypedef enum 
N{
N    IRCLK_Logic_0=0,	/*!< Output '0' state */
N    IRCLK_TM00_CKO=1,   /*!< TM00's CKO signal */
N    IRCLK_TM01_CKO=2,   /*!< TM01's CKO signal */
N    IRCLK_TM10_CKO=3,   /*!< TM10's CKO signal */
N    IRCLK_TM16_TRGO=4,  /*!< TM16's TRGO signal */
N    IRCLK_URT1_TMO=5,   /*!< URT1's TMO signal */
N    IRCLK_URT2_TMO=6,   /*!< URT2's TMO signal */
N    IRCLK_URT3_TMO=7,   /*!< URT3's TMO signal */
N} IRCLKSrcDef;
N
N/** 
N * @enum		IRDATSrcDef
N * @brief		declare IRDAT source
N */        
Ntypedef enum 
N{
N    IRDAT_Logic_0=0,	/*!< Output '0' state */
N    IRDAT_TM20_TRGO=1,  /*!< TM20's CKO signal */
N    IRDAT_TM26_TRGO=2,  /*!< TM26's CKO signal */
N    IRDAT_TM36_TRGO=3,  /*!< TM36's CKO signal */
N    IRDAT_SPI0_MOSI=4,  /*!< SPIO's MOSI signal */
N    IRDAT_URT1_TX=5,    /*!< URT1's TX signal */
N    IRDAT_URT2_TX=6,    /*!< URT2's TX signal */
N    IRDAT_URT3_TX=7,    /*!< URT3's TX signal */
N} IRDATSrcDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		IRCLKSrcDef
S * @brief		declare IRCLK source
S */        
Stypedef enum 
S{
S    IRCLK_Logic_0=0,	/*!< Output '0' state */
S    IRCLK_TM00_CKO=1,   /*!< TM00's CKO signal */
S    IRCLK_TM01_CKO=2,   /*!< TM01's CKO signal */
S    IRCLK_TM10_CKO=3,   /*!< TM10's CKO signal */
S    IRCLK_TM16_TRGO=4,  /*!< TM16's TRGO signal */
S    IRCLK_URT1_TMO=5,   /*!< URT1's TMO signal */
S} IRCLKSrcDef;
S
S/** 
S * @enum		IRDATSrcDef
S * @brief		declare IRDAT source
S */        
Stypedef enum 
S{
S    IRDAT_Logic_0=0,	/*!< Output '0' state */
S    IRDAT_TM36_TRGO=3,  /*!< TM36's CKO signal */
S    IRDAT_SPI0_MOSI=4,  /*!< SPIO's MOSI signal */
S    IRDAT_URT1_TX=5,    /*!< URT1's TX signal */
S} IRDATSrcDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		IRCLKSrcDef
S * @brief		declare IRCLK source
S */        
Stypedef enum 
S{
S    IRCLK_Logic_0=0,	/*!< Output '0' state */
S    IRCLK_TM00_CKO=1,   /*!< TM00's CKO signal */
S    IRCLK_TM01_CKO=2,   /*!< TM01's CKO signal */
S    IRCLK_TM10_CKO=3,   /*!< TM10's CKO signal */
S    IRCLK_TM16_TRGO=4,  /*!< TM16's TRGO signal */
S    IRCLK_URT1_TMO=5,   /*!< URT1's TMO signal */
S    IRCLK_URT2_TMO=6,   /*!< URT2's TMO signal */
S} IRCLKSrcDef;
S
S/** 
S * @enum		IRDATSrcDef
S * @brief		declare IRDAT source
S */        
Stypedef enum 
S{
S    IRDAT_Logic_0=0,	/*!< Output '0' state */
S    IRDAT_TM20_TRGO=1,  /*!< TM20's CKO signal */
S    IRDAT_TM26_TRGO=2,  /*!< TM26's CKO signal */
S    IRDAT_TM36_TRGO=3,  /*!< TM36's CKO signal */
S    IRDAT_SPI0_MOSI=4,  /*!< SPIO's MOSI signal */
S    IRDAT_URT1_TX=5,    /*!< URT1's TX signal */
S    IRDAT_URT2_TX=6,    /*!< URT2's TX signal */
S} IRDATSrcDef;
N#endif
N
N
N
N/** 
N * @enum		OBMxFilterTypedef
N * @brief		config OBMx with clock filter function
N */        
Ntypedef enum
N{
N    OBMx_FilterDisable, /*!< Disable clock filter */
N    OBMx_APBCLKx3,      /*!< filter clock by APB clock x 3 */
N    OBMx_APBCLKx24,     /*!< filter clock by APB clock x 8 x 3 */
N    OBMx_TM00_TRGOx3,   /*!< filter clock by TM00 TRGO x 3 */
N} OBMxFilterTypedef;
N
N/** 
N * @enum		OBMxOperateModeTypedef
N * @brief		config OBMx operation mode
N */        
Ntypedef enum
N{
N    OBMx_LevelSwitch=0,         /*!< operate in AND mode */
N    OBMx_ClearByFallingEdge=1,  /*!< accept falling edge to clear initial state */
N    OBMx_SetByFallingEdge=2,    /*!< accept falling edge to set initial state */    
N    OBMx_DualEdgeSwitch=3,      /*!< accept falling edge to toggle initial state */
N} OBMxOperateModeTypedef;
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		OBMxChannel0TypeDef
N * @brief		config OBMx channel 0 source
N */        
Ntypedef enum
N{
N    OBMxCH0_Logic_0=0,          /*!< Output '0' state */
N    OBMxCH0_INT_PA=1,           /*!< Output INT_PA state */
N    OBMxCH0_INT_PC=2,           /*!< Output INT_PC state */
N    OBMxCH0_TM00_CKO=4,         /*!< Output TM00_CKO state */
N    OBMxCH0_TM10_CKO=5,         /*!< Output TM10_CKO state */
N    OBMxCH0_TM20_CKO=6,         /*!< Output TM20_CKO state */
N    OBMxCH0_TM36_CKO=7,         /*!< Output TM36_CKO state */
N    OBMxCH0_TM20_OC00=8,        /*!< Output TM20_OC00 state */
N    OBMxCH0_TM36_OC00=9,        /*!< Output TM36_OC00 state */
N    OBMxCH0_TM36_OC2=10,        /*!< Output TM20_OC2 state */
N    OBMxCH0_OBM_I0=12,          /*!< Output OBMx Break Signal Input channel 0 state */
N    OBMxCH0_ITR6=13,            /*!< Output ITR6 state */
N} OBMxChannel0TypeDef;
N
N/** 
N * @enum		OBMxChannel1TypeDef
N * @brief		config OBMx channel 1 source
N */        
Ntypedef enum
N{
N    OBMxCH1_Logic_0=0,          /*!< Output '0' state */
N    OBMxCH1_INT_PB=1,           /*!< Output INT_PB state */
N    OBMxCH1_INT_PD=2,           /*!< Output INT_PD state */
N    OBMxCH1_TM01_CKO=4,         /*!< Output TM01_CKO state */
N    OBMxCH1_TM16_CKO=5,         /*!< Output TM16_CKO state */
N    OBMxCH1_TM26_CKO=6,         /*!< Output TM26_CKO state */
N    OBMxCH1_TM20_OC01=8,        /*!< Output TM20_OC01 state */
N    OBMxCH1_TM36_OC01=9,        /*!< Output TM36_OC01 state */
N    OBMxCH1_TM36_OC3=10,        /*!< Output TM20_OC3 state */
N    OBMxCH1_OBM_I1=12,          /*!< Output OBMx Break Signal Input channel 1 state */
N    OBMxCH1_ITR7=13,            /*!< Output ITR7 state */
N    OBMxCH1_ICKO_INT=14,        /*!< Output ICKO_INT state */
N} OBMxChannel1TypeDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		OBMxChannel0TypeDef
S * @brief		config OBMx channel 0 source
S */        
Stypedef enum
S{
S    OBMxCH0_Logic_0=0,          /*!< Output '0' state */
S    OBMxCH0_INT_PA=1,           /*!< Output INT_PA state */
S    OBMxCH0_INT_PC=2,           /*!< Output INT_PC state */
S    OBMxCH0_TM00_CKO=4,         /*!< Output TM00_CKO state */
S    OBMxCH0_TM10_CKO=5,         /*!< Output TM10_CKO state */
S    OBMxCH0_TM36_CKO=7,         /*!< Output TM36_CKO state */
S    OBMxCH0_TM36_OC00=9,        /*!< Output TM36_OC00 state */
S    OBMxCH0_TM36_OC2=10,        /*!< Output TM20_OC2 state */
S    OBMxCH0_OBM_I0=12,          /*!< Output OBMx Break Signal Input channel 0 state */
S    OBMxCH0_ITR6=13,            /*!< Output ITR6 state */
S} OBMxChannel0TypeDef;
S
S/** 
S * @enum		OBMxChannel1TypeDef
S * @brief		config OBMx channel 1 source
S */        
Stypedef enum
S{
S    OBMxCH1_Logic_0=0,          /*!< Output '0' state */
S    OBMxCH1_INT_PB=1,           /*!< Output INT_PB state */
S    OBMxCH1_INT_PD=2,           /*!< Output INT_PD state */
S    OBMxCH1_TM01_CKO=4,         /*!< Output TM01_CKO state */
S    OBMxCH1_TM16_CKO=5,         /*!< Output TM16_CKO state */
S    OBMxCH1_TM36_OC01=9,        /*!< Output TM36_OC01 state */
S    OBMxCH1_TM36_OC3=10,        /*!< Output TM20_OC3 state */
S    OBMxCH1_OBM_I1=12,          /*!< Output OBMx Break Signal Input channel 1 state */
S    OBMxCH1_ITR7=13,            /*!< Output ITR7 state */
S    OBMxCH1_ICKO_INT=14,        /*!< Output ICKO_INT state */
S} OBMxChannel1TypeDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		OBMxChannel0TypeDef
S * @brief		config OBMx channel 0 source
S */        
Stypedef enum
S{
S    OBMxCH0_Logic_0=0,          /*!< Output '0' state */
S    OBMxCH0_INT_PA=1,           /*!< Output INT_PA state */
S    OBMxCH0_INT_PC=2,           /*!< Output INT_PC state */
S    OBMxCH0_INT_PE=3,           /*!< Output INT_PE state */
S    OBMxCH0_TM00_CKO=4,         /*!< Output TM00_CKO state */
S    OBMxCH0_TM10_CKO=5,         /*!< Output TM10_CKO state */
S    OBMxCH0_TM20_CKO=6,         /*!< Output TM20_CKO state */
S    OBMxCH0_TM36_CKO=7,         /*!< Output TM36_CKO state */
S    OBMxCH0_TM20_OC00=8,        /*!< Output TM20_OC00 state */
S    OBMxCH0_TM36_OC00=9,        /*!< Output TM36_OC00 state */
S    OBMxCH0_TM36_OC2=10,        /*!< Output TM20_OC2 state */
S    OBMxCH0_OBM_I0=12,          /*!< Output OBMx Break Signal Input channel 0 state */
S    OBMxCH0_ITR6=13,            /*!< Output ITR6 state */
S} OBMxChannel0TypeDef;
S
S/** 
S * @enum		OBMxChannel1TypeDef
S * @brief		config OBMx channel 1 source
S */        
Stypedef enum
S{
S    OBMxCH1_Logic_0=0,          /*!< Output '0' state */
S    OBMxCH1_INT_PB=1,           /*!< Output INT_PB state */
S    OBMxCH1_INT_PD=2,           /*!< Output INT_PD state */
S    OBMxCH1_TM01_CKO=4,         /*!< Output TM01_CKO state */
S    OBMxCH1_TM16_CKO=5,         /*!< Output TM16_CKO state */
S    OBMxCH1_TM26_CKO=6,         /*!< Output TM26_CKO state */
S    OBMxCH1_TM20_OC01=8,        /*!< Output TM20_OC01 state */
S    OBMxCH1_TM36_OC01=9,        /*!< Output TM36_OC01 state */
S    OBMxCH1_TM36_OC3=10,        /*!< Output TM20_OC3 state */
S    OBMxCH1_OBM_I1=12,          /*!< Output OBMx Break Signal Input channel 1 state */
S    OBMxCH1_ITR7=13,            /*!< Output ITR7 state */
S    OBMxCH1_ICKO_INT=14,        /*!< Output ICKO_INT state */
S} OBMxChannel1TypeDef;
N#endif
N
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		APB_NCOInputClockSrcDef
S * @brief		APB NCO input clock Source Definition
S */        
Stypedef enum
S{
S    APB_NCO_IHRCO=0,            /*!< NCO clock from CK_IHRCO */
S    APB_NCO_CK_PLL,             /*!< NCO clock from CK_PLL */
S    APB_NCO_APB,                /*!< NCO clock from CK_APB */    
S    APB_NCO_CK_LS,              /*!< NCO clock from CK_LS */
S    APB_NCO_TM00_TRGO,          /*!< NCO clock from TM00_TRGO */
S    APB_NCO_CK0,                /*!< NCO clock from NCO_CKI */
S} APB_NCOInputClockSrcDef;
S
S/** 
S * @enum		APB_NCOOutputMode
S * @brief		APB NCO Output Mode
S */        
Stypedef enum
S{
S    APB_NCO_FDC=0,              /*!< FDC : fixed duty cycle mode */
S    APB_NCO_PFM,                /*!< PFM : pulse frequency mode */
S} APB_NCOOutputMode;
S
S/** 
S * @enum		APB_NCOPFMWidtrhSelDef
S * @brief		APB NCO PFM Width Select Definition
S */        
Stypedef enum
S{
S    APB_PFM_1Clock=0,           /*!< 1 CK_NCOn clock period */
S    APB_PFM_2Clock,             /*!< 2 CK_NCOn clock period */
S    APB_PFM_4Clock,             /*!< 4 CK_NCOn clock period */
S    APB_PFM_8Clock,             /*!< 8 CK_NCOn clock period */
S    APB_PFM_16Clock,            /*!< 16 CK_NCOn clock period */
S    APB_PFM_32Clock,            /*!< 32 CK_NCOn clock period */
S    APB_PFM_64Clock,            /*!< 64 CK_NCOn clock period */
S    APB_PFM_128Clock,           /*!< 128 CK_NCOn clock period */
S} APB_NCOPFMWidtrhSelDef;
S
N#endif
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
Nvoid APB_TimerX_Cmd(uint32_t TMxEnBit);
Nvoid APB_ITR6_Select(APB_TimerITR6SrcDef ITR6Src);
Nvoid APB_ITR7_Select(APB_TimerITR7SrcDef ITR7Src);
N///@}
N
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
N///@{
Nvoid APB_BreakSourceChannel0_Select(OBM_Struct* OBMx, BKS0SrcDef BKS0Sel);
Nvoid APB_BreakSourceChannel1_Select(OBM_Struct* OBMx, BKS1SrcDef BKS1Sel);
Nvoid APB_BreakSourceChannel2_Select(OBM_Struct* OBMx, BKS2SrcDef BKS2Sel);
Nvoid APB_InverseBKS0_Cmd(OBM_Struct* OBMx, FunctionalState NewState);
Nvoid APB_InverseBKS1_Cmd(OBM_Struct* OBMx, FunctionalState NewState);
Nvoid APB_InverseBKS2_Cmd(OBM_Struct* OBMx, FunctionalState NewState);
Nvoid APB_OBMxOpMode_Select(OBM_Struct* OBMx, OBMxOperateModeTypedef OPMode);
NDRV_Return APB_GetOBMxOutputState(OBM_Struct* OBMx);
Nvoid APB_InverseOBMxOutput_Cmd(OBM_Struct* OBMx, FunctionalState NewState);
Nvoid APB_OutputFilter_Select(OBM_Struct* OBMx, OBMxFilterTypedef FilterClks);
NDRV_Return APB_GetOBMxSwitchState(OBM_Struct* OBMx);	
Nvoid APB_SetOBMxInitState(OBM_Struct* OBMx, BitAction CurSta);
N///@}
N
N///@{
NDRV_Return APB_GetOBMxInitState(OBM_Struct* OBMx);	
Nvoid APB_OutputChannel0Source_Select(OBM_Struct* OBMx, OBMxChannel0TypeDef OBM0LSSel);
Nvoid APB_OutputChannel1Source_Select(OBM_Struct* OBMx, OBMxChannel1TypeDef OBM0HSSel);
Nvoid APB_InverseOutputChannel0_Cmd(OBM_Struct* OBMx, FunctionalState NewState);
Nvoid APB_InverseOutputChannel1_Cmd(OBM_Struct* OBMx, FunctionalState NewState);
N///@}
N#endif
N
N///@{
Nvoid APB_IRCLK_Select(IRCLKSrcDef IRCLKSel);
Nvoid APB_IRDAT_Select(IRDATSrcDef IRDATSel);
Nvoid APB_InverseIRCLK_Cmd(FunctionalState NewState);
Nvoid APB_InverseIRDAT_Cmd(FunctionalState NewState);
N///@}
N
N#if defined(MG32_3RD)
X#if 0L
S///@{
Svoid APB_NCOClockSource_Select(APB_NCOInputClockSrcDef NCOClkSrc);
Svoid APB_NCOOutputMode_Select(APB_NCOOutputMode NCOOutMode);
Svoid APB_NCOInverseOutput_Cmd(FunctionalState NewState);
Svoid APB_NCO_Cmd(FunctionalState NewState);
Svoid APB_NCOPFMWidth_Select(APB_NCOPFMWidtrhSelDef NCOPFMWidth);
Svoid APB_NCOSetINC(uint32_t NCOINCV);
Svoid APB_NCOSetACC(uint32_t NCOACCV);
SDRV_Return APB_NCOGetOutputState(void);
S///@}
N#endif
N///@{
Nvoid APB_IT_Config(APB_Struct* APBx, uint32_t ITsrc, FunctionalState NewState);
Nvoid APB_ITEA_Cmd(APB_Struct* APBx, FunctionalState NewState);
NDRV_Return APB_GetSingleFlagStatus(APB_Struct* APBx, uint32_t ITSrc);
Nuint32_t APB_GetAllFlagStatus(APB_Struct* APBx);
Nvoid APB_ClearFlag(APB_Struct* APBx, uint32_t APB_ITSrc);
N///@}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 39 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_CFG_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CFG_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_CFG_DRV.H
N *
N * @brief       This is the C code format driver head file for CFG module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.13
N * @date        2021/01/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_CFG.h"
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define ADC_RefTopMask          CFG_OR15_ADC0_REFT_mask_b3      /*!<  */	
N#define ADC_RefMiddleMask       CFG_OR15_ADC0_REFM_mask_b2      /*!<  */
N#define ADC_RefBottomMask       CFG_OR15_ADC0_REFB_mask_b1      /*!<  */
N
N#define CFG_TempHighCalMask      CFG_OR16_TEMP_CAL1_mask_h1      /*!<  */
N#define CFG_TempLowCalMask      CFG_OR16_TEMP_CAL0_mask_h0      /*!<  */
N
N#define CFG_PNDF        CFG_TST0_PNDF_mask_w        /*!<  */
N#define CFG_DBLVRF      CFG_TST0_DBLVRF_mask_w      /*!<  */
N#define CFG_LVRF0       CFG_TST0_LVRF0_mask_w       /*!<  */
N#define CFG_DPORF       CFG_TST0_DPORF_mask_w       /*!<  */
N#define CFG_POF2        CFG_TST0_POF2_mask_w        /*!<  */
N#define CFG_POF1        CFG_TST0_POF1_mask_w        /*!<  */
N#define CFG_POF0        CFG_TST0_POF0_mask_w        /*!<  */
N#define CFG_ALLF        CFG_PNDF | CFG_DBLVRF | CFG_LVRF0 | CFG_DPORF | CFG_DPORF | CFG_POF2 | CFG_POF1 | CFG_POF0      /*!<  */
N
N/* @} */
N
N/**
N * @name    Function announce
N *
N */ 
N///@{
N#if defined(MG32_1ST)
X#if 1L
Nuint8_t CFG_GetADC0RefTop (void);
Nvoid CFG_SetADC0RefTop (uint8_t ADC_REFT);
Nuint8_t CFG_GetADC0RefMiddle (void);
Nvoid CFG_SetADC0RefMiddle (uint8_t ADC_REFM);
Nuint8_t CFG_GetADC0RefBottom (void);
Nvoid CFG_SetADC0RefBottom (uint8_t ADC_REFB);
N#endif
N
N
Nuint32_t CFG_GetAllFlagStatus (void);
NDRV_Return CFG_GetSingleFlagStatus (uint32_t CFG_ITSrc);
Nvoid CFG_ClearFlag (uint32_t CFG_ITSrc);
N///@}
L 40 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_CMP_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CMP_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CMP_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the CMP 
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.18
N * @date        2021/02/08
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N#ifndef _MG32x02z_CMP_DRV_H
N
N/*!< _MG32x02z_CMP_DRV_H */ 
N#define _MG32x02z_CMP_DRV_H
N
N
N#include "MG32x02z__Common_DRV.H"
N
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
N
N#include "MG32x02z_CMP.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_CMP.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CMP.h
N *
N * @brief       MG32x02z CMP Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_CMP_H
N#define _MG32x02z_CMP_H
N#define _MG32x02z_CMP_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_CMP_H_VER)
S    #error "MG32x02z_CMP_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      CMP_Struct
N *              CMP  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  AC0_S         :1;     //[0] Analog comparator CMP0 result status
X            volatile const  uint8_t  AC0_S         :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC0_RF        :1;     //[2] Analog comparator CMP0 rising edge interrupt flag
X            volatile uint8_t  AC0_RF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  AC0_FF        :1;     //[3] Analog comparator CMP0 falling edge interrupt flag
X            volatile uint8_t  AC0_FF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  AC1_S         :1;     //[4] Analog comparator CMP1 result status
X            volatile const  uint8_t  AC1_S         :1;     
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC1_RF        :1;     //[6] Analog comparator CMP1 rising edge interrupt flag
X            volatile uint8_t  AC1_RF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  AC1_FF        :1;     //[7] Analog comparator CMP1 falling edge interrupt flag
X            volatile uint8_t  AC1_FF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  AC2_S         :1;     //[8] Analog comparator CMP2 result status
X            volatile const  uint8_t  AC2_S         :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC2_RF        :1;     //[10] Analog comparator CMP2 rising edge interrupt flag
X            volatile uint8_t  AC2_RF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  AC2_FF        :1;     //[11] Analog comparator CMP2 falling edge interrupt flag
X            volatile uint8_t  AC2_FF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  AC3_S         :1;     //[12] Analog comparator CMP3 result status
X            volatile const  uint8_t  AC3_S         :1;     
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC3_RF        :1;     //[14] Analog comparator CMP3 rising edge interrupt flag
X            volatile uint8_t  AC3_RF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  AC3_FF        :1;     //[15] Analog comparator CMP3 falling edge interrupt flag
X            volatile uint8_t  AC3_FF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  CMP Analog comparator status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] Analog comparator interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC0_RIE       :1;     //[2] Analog comparator CMP0 rising edge interrupt enable.
X            volatile uint8_t  AC0_RIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC0_FIE       :1;     //[3] Analog comparator CMP0 falling edge interrupt enable.
X            volatile uint8_t  AC0_FIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC1_RIE       :1;     //[6] Analog comparator CMP1 rising edge interrupt enable.
X            volatile uint8_t  AC1_RIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC1_FIE       :1;     //[7] Analog comparator CMP1 falling edge interrupt enable.
X            volatile uint8_t  AC1_FIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC2_RIE       :1;     //[10] Analog comparator CMP2 rising edge interrupt enable.
X            volatile uint8_t  AC2_RIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC2_FIE       :1;     //[11] Analog comparator CMP2 falling edge interrupt enable.
X            volatile uint8_t  AC2_FIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[13..12] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC3_RIE       :1;     //[14] Analog comparator CMP3 rising edge interrupt enable.
X            volatile uint8_t  AC3_RIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC3_FIE       :1;     //[15] Analog comparator CMP3 falling edge interrupt enable.
X            volatile uint8_t  AC3_FIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  CMP Analog comparator interrupt enable register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IVREF_EN      :1;     //[0] Comparator CMP0 power-on enable bit.
X            volatile uint8_t  IVREF_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IVREF_RS      :6;     //[7..2] Analog comparator main internal reference (R-ladder) voltage select
X            volatile uint8_t  IVREF_RS      :6;     
N            __IO uint8_t  IVREF2_EN     :1;     //[8] Comparator CMP1 power-on enable bit.
X            volatile uint8_t  IVREF2_EN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IVREF2_RS     :6;     //[15..10] Analog comparator 2nd internal reference (R-ladder) voltage select
X            volatile uint8_t  IVREF2_RS     :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }ANA;                               /*!< ANA        ~ Offset[0x0C]  CMP Analog comparator analog control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  AC0_EN        :1;     //[0] Analog comparator CMP0 power-on enable bit
X            volatile uint8_t  AC0_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC0_RES       :1;     //[3] CMP0 compare response time select.
X            volatile uint8_t  AC0_RES       :1;     
N                                        //0x0 = 200ns 
N                                        //0x1 = 10us (5~10us)
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC0_PMUX      :3;     //[10..8] CMP0 Analog input positive channel selection.
X            volatile uint8_t  AC0_PMUX      :3;     
N                                        //0x0 =  IVREF
N                                        //0x1 = CMP0_I0
N                                        //0x2 = CMP0_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC0_NMUX      :3;     //[14..12] CMP0 Analog input negative channel selection.
X            volatile uint8_t  AC0_NMUX      :3;     
N                                        //0x0 =  IVREF
N                                        //0x1 = CMP0_I0
N                                        //0x2 = CMP0_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC0_INV       :1;     //[16] CMP0 analog comparator output signal polarity select.
X            volatile uint8_t  AC0_INV       :1;     
N                                        //0 = Positive
N                                        //1 = Negative
N            __IO uint8_t  AC0_PINV      :1;     //[17] CMP0 output to pins' signal inverse enable.
X            volatile uint8_t  AC0_PINV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC0_FSEL      :2;     //[19..18] CMP0 analog comparator output signal select with synchronized filter
X            volatile uint8_t  AC0_FSEL      :2;     
N                                        //0x0 = Bypass
N                                        //0x1 = CMP_CK : filter with CMP_CLK 
N                                        //0x2 = TM00_TRGO : filter with TM00_TRGO
N                                        //0x3 = TM01_TRGO : filter with TM01_TRGO
N            __IO uint8_t  AC0_FDIV      :2;     //[21..20] CMP0 analog comparator output synchronized filter divider.
X            volatile uint8_t  AC0_FDIV      :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  CMP Analog comparator-0 control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  AC1_EN        :1;     //[0] Analog comparator CMP1 power-on enable bit
X            volatile uint8_t  AC1_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC1_RES       :1;     //[3] CMP1 compare response time select.
X            volatile uint8_t  AC1_RES       :1;     
N                                        //0x0 = 200ns 
N                                        //0x1 = 10us (5~10us)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  AC1_PMUX      :3;     //[10..8] CMP1 Analog input positive channel selection.
X            volatile uint8_t  AC1_PMUX      :3;     
N                                        //0x0 =  IVREF2
N                                        //0x1 = CMP1_I0
N                                        //0x2 = CMP1_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC1_NMUX      :3;     //[14..12] CMP1 Analog input negative channel selection.
X            volatile uint8_t  AC1_NMUX      :3;     
N                                        //0x0 =  IVREF2
N                                        //0x1 = CMP1_I0
N                                        //0x2 = CMP1_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC1_INV       :1;     //[16] CMP1 analog comparator output signal polarity select.
X            volatile uint8_t  AC1_INV       :1;     
N                                        //0 = Positive
N                                        //1 = Negative
N            __IO uint8_t  AC1_PINV      :1;     //[17] CMP1 output to pins' signal inverse enable.
X            volatile uint8_t  AC1_PINV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC1_FSEL      :2;     //[19..18] CMP1 analog comparator output signal select with synchronized filter
X            volatile uint8_t  AC1_FSEL      :2;     
N                                        //0x0 = Bypass
N                                        //0x1 = CMP_CK : filter with CMP_CLK 
N                                        //0x2 = TM00_TRGO : filter with TM00_TRGO
N                                        //0x3 = TM01_TRGO : filter with TM01_TRGO
N            __IO uint8_t  AC1_FDIV      :2;     //[21..20] CMP1 analog comparator output synchronized filter divider.
X            volatile uint8_t  AC1_FDIV      :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  CMP Analog comparator-1 control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  AC2_EN        :1;     //[0] Analog comparator CMP2 power-on enable bit
X            volatile uint8_t  AC2_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC2_RES       :1;     //[3] CMP2 compare response time select.
X            volatile uint8_t  AC2_RES       :1;     
N                                        //0x0 = 200ns 
N                                        //0x1 = 10us (5~10us)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  AC2_PMUX      :3;     //[10..8] CMP2 Analog input positive channel selection.
X            volatile uint8_t  AC2_PMUX      :3;     
N                                        //0x0 =  IVREF2
N                                        //0x1 = CMP2_I0
N                                        //0x2 = CMP2_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC2_NMUX      :3;     //[14..12] CMP2 Analog input negative channel selection.
X            volatile uint8_t  AC2_NMUX      :3;     
N                                        //0x0 =  IVREF2
N                                        //0x1 = CMP2_I0
N                                        //0x2 = CMP2_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC2_INV       :1;     //[16] CMP2 analog comparator output signal polarity select.
X            volatile uint8_t  AC2_INV       :1;     
N                                        //0 = Positive
N                                        //1 = Negative
N            __IO uint8_t  AC2_PINV      :1;     //[17] CMP2 output to pins' signal inverse enable.
X            volatile uint8_t  AC2_PINV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC2_FSEL      :2;     //[19..18] CMP2 analog comparator output signal select with synchronized filter
X            volatile uint8_t  AC2_FSEL      :2;     
N                                        //0x0 = Bypass
N                                        //0x1 = CMP_CK : filter with CMP_CLK 
N                                        //0x2 = TM00_TRGO : filter with TM00_TRGO
N                                        //0x3 = TM01_TRGO : filter with TM01_TRGO
N            __IO uint8_t  AC2_FDIV      :2;     //[21..20] CMP2 analog comparator output synchronized filter divider.
X            volatile uint8_t  AC2_FDIV      :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  CMP Analog comparator-2 control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  AC3_EN        :1;     //[0] Analog comparator CMP3 power-on enable bit
X            volatile uint8_t  AC3_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  AC3_RES       :1;     //[3] CMP3 compare response time select.
X            volatile uint8_t  AC3_RES       :1;     
N                                        //0x0 = 200ns 
N                                        //0x1 = 10us (5~10us)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  AC3_PMUX      :3;     //[10..8] CMP3 Analog input positive channel selection.
X            volatile uint8_t  AC3_PMUX      :3;     
N                                        //0x0 =  IVREF2
N                                        //0x1 = CMP3_I0
N                                        //0x2 = CMP3_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC3_NMUX      :3;     //[14..12] CMP3 Analog input negative channel selection.
X            volatile uint8_t  AC3_NMUX      :3;     
N                                        //0x0 =  IVREF2
N                                        //0x1 = CMP3_I0
N                                        //0x2 = CMP3_I1
N                                        //0x3 = CMP_C0
N                                        //0x4 = CMP_C1
N                                        //0x5 = LDO_Core
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  AC3_INV       :1;     //[16] CMP3 analog comparator output signal polarity select.
X            volatile uint8_t  AC3_INV       :1;     
N                                        //0 = Positive
N                                        //1 = Negative
N            __IO uint8_t  AC3_PINV      :1;     //[17] CMP3 output to pins' signal inverse enable.
X            volatile uint8_t  AC3_PINV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AC3_FSEL      :2;     //[19..18] CMP3 analog comparator output signal select with synchronized filter
X            volatile uint8_t  AC3_FSEL      :2;     
N                                        //0x0 = Bypass
N                                        //0x1 = CMP_CK : filter with CMP_CLK 
N                                        //0x2 = TM00_TRGO : filter with TM00_TRGO
N                                        //0x3 = TM01_TRGO : filter with TM01_TRGO
N            __IO uint8_t  AC3_FDIV      :2;     //[21..20] CMP3 analog comparator output synchronized filter divider.
X            volatile uint8_t  AC3_FDIV      :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR3;                               /*!< CR3        ~ Offset[0x1C]  CMP Analog comparator-3 control register */
N
N} CMP_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        CMP  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define CMP_Base                        ((uint32_t)0x5C000000)              /*!< Analog Comparator Control */
N#define CMP                             ((CMP_Struct*) CMP_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        CMP  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        CMP_STA  [register's definitions]
N *              Offset[0x00]  CMP Analog comparator status register (0x5C000000)
N ******************************************************************************
N */
N///@{
N#define CMP_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_STA */
N#define CMP_STA_AC3_FF_mask_w                       ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC3_FF_mask_h0                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC3_FF_mask_b1                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC3_FF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC3_FF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC3_FF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC3_FF_happened_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC3_FF_happened_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC3_FF_happened_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC3_RF_mask_w                       ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC3_RF_mask_h0                      ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC3_RF_mask_b1                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC3_RF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC3_RF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC3_RF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC3_RF_happened_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC3_RF_happened_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC3_RF_happened_b1                  ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC3_S_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC3_S_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC3_S_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define CMP_STA_AC2_FF_mask_w                       ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC2_FF_mask_h0                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC2_FF_mask_b1                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC2_FF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC2_FF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC2_FF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC2_FF_happened_w                   ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC2_FF_happened_h0                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC2_FF_happened_b1                  ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC2_RF_mask_w                       ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC2_RF_mask_h0                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC2_RF_mask_b1                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC2_RF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC2_RF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC2_RF_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC2_RF_happened_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC2_RF_happened_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC2_RF_happened_b1                  ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC2_S_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC2_S_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC2_S_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define CMP_STA_AC1_FF_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC1_FF_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC1_FF_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC1_FF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC1_FF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC1_FF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC1_FF_happened_w                   ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC1_FF_happened_h0                  ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC1_FF_happened_b0                  ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC1_RF_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC1_RF_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC1_RF_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC1_RF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC1_RF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC1_RF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC1_RF_happened_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC1_RF_happened_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC1_RF_happened_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC1_S_mask_w                        ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC1_S_mask_h0                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC1_S_mask_b0                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define CMP_STA_AC0_FF_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC0_FF_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC0_FF_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC0_FF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC0_FF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC0_FF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC0_FF_happened_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC0_FF_happened_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC0_FF_happened_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC0_RF_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC0_RF_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC0_RF_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CMP_STA_AC0_RF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define CMP_STA_AC0_RF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define CMP_STA_AC0_RF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define CMP_STA_AC0_RF_happened_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define CMP_STA_AC0_RF_happened_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define CMP_STA_AC0_RF_happened_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define CMP_STA_AC0_S_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_STA_AC0_S_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_STA_AC0_S_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CMP_INT  [register's definitions]
N *              Offset[0x04]  CMP Analog comparator interrupt enable register (0x5C000004)
N ******************************************************************************
N */
N///@{
N#define CMP_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_INT */
N#define CMP_INT_AC3_FIE_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC3_FIE_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC3_FIE_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC3_FIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC3_FIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC3_FIE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC3_FIE_enable_w                    ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC3_FIE_enable_h0                   ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC3_FIE_enable_b1                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC3_RIE_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC3_RIE_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC3_RIE_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC3_RIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC3_RIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC3_RIE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC3_RIE_enable_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC3_RIE_enable_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC3_RIE_enable_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC2_FIE_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC2_FIE_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC2_FIE_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC2_FIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC2_FIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC2_FIE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC2_FIE_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC2_FIE_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC2_FIE_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC2_RIE_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC2_RIE_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC2_RIE_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC2_RIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC2_RIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC2_RIE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC2_RIE_enable_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC2_RIE_enable_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC2_RIE_enable_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC1_FIE_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC1_FIE_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC1_FIE_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC1_FIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC1_FIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC1_FIE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC1_FIE_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC1_FIE_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC1_FIE_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC1_RIE_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC1_RIE_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC1_RIE_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC1_RIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC1_RIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC1_RIE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC1_RIE_enable_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC1_RIE_enable_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC1_RIE_enable_b0                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC0_FIE_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC0_FIE_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC0_FIE_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC0_FIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC0_FIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC0_FIE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC0_FIE_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC0_FIE_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC0_FIE_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_AC0_RIE_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CMP_INT_AC0_RIE_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CMP_INT_AC0_RIE_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CMP_INT_AC0_RIE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_AC0_RIE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_AC0_RIE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_AC0_RIE_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_AC0_RIE_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_AC0_RIE_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CMP_ANA  [register's definitions]
N *              Offset[0x0C]  CMP Analog comparator analog control register (0x5C00000C)
N ******************************************************************************
N */
N///@{
N#define CMP_ANA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_ANA */
N#define CMP_ANA_IVREF2_RS_mask_w                    ((uint32_t)0x0000FC00)  /*!< Bit Mask of 32bit */
N#define CMP_ANA_IVREF2_RS_mask_h0                   ((uint16_t)0xFC00)      /*!< Bit Mask of 16bit */
N#define CMP_ANA_IVREF2_RS_mask_b1                   ((uint8_t )0xFC)        /*!< Bit Mask of 8bit */
N#define CMP_ANA_IVREF2_RS_shift_w                   (10)                    /*!< Bit Shift of 32bit */
N#define CMP_ANA_IVREF2_RS_shift_h0                  (10)                    /*!< Bit Shift of 16bit */
N#define CMP_ANA_IVREF2_RS_shift_b1                  (2)                     /*!< Bit Shift of 8bit */
N
N#define CMP_ANA_IVREF2_EN_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CMP_ANA_IVREF2_EN_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CMP_ANA_IVREF2_EN_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_ANA_IVREF2_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_ANA_IVREF2_EN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_ANA_IVREF2_EN_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_ANA_IVREF2_EN_enable_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_ANA_IVREF2_EN_enable_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_ANA_IVREF2_EN_enable_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_ANA_IVREF_RS_mask_w                     ((uint32_t)0x000000FC)  /*!< Bit Mask of 32bit */
N#define CMP_ANA_IVREF_RS_mask_h0                    ((uint16_t)0x00FC)      /*!< Bit Mask of 16bit */
N#define CMP_ANA_IVREF_RS_mask_b0                    ((uint8_t )0xFC)        /*!< Bit Mask of 8bit */
N#define CMP_ANA_IVREF_RS_shift_w                    (2)                     /*!< Bit Shift of 32bit */
N#define CMP_ANA_IVREF_RS_shift_h0                   (2)                     /*!< Bit Shift of 16bit */
N#define CMP_ANA_IVREF_RS_shift_b0                   (2)                     /*!< Bit Shift of 8bit */
N
N#define CMP_ANA_IVREF_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_ANA_IVREF_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_ANA_IVREF_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_ANA_IVREF_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_ANA_IVREF_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_ANA_IVREF_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_ANA_IVREF_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_ANA_IVREF_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_ANA_IVREF_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CMP_CR0  [register's definitions]
N *              Offset[0x10]  CMP Analog comparator-0 control register (0x5C000010)
N ******************************************************************************
N */
N///@{
N#define CMP_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_CR0 */
N#define CMP_CR0_AC0_FDIV_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_FDIV_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_FDIV_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_FDIV_div1_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CMP_CR0_AC0_FDIV_div1_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CMP_CR0_AC0_FDIV_div1_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CMP_CR0_AC0_FDIV_div2_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CMP_CR0_AC0_FDIV_div2_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CMP_CR0_AC0_FDIV_div2_b2                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CMP_CR0_AC0_FDIV_div4_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CMP_CR0_AC0_FDIV_div4_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CMP_CR0_AC0_FDIV_div4_b2                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CMP_CR0_AC0_FDIV_div8_w                     ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CMP_CR0_AC0_FDIV_div8_h1                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CMP_CR0_AC0_FDIV_div8_b2                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define CMP_CR0_AC0_FSEL_mask_w                     ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_FSEL_mask_h1                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_FSEL_mask_b2                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_FSEL_bypass_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Bypass of 32bit */
N#define CMP_CR0_AC0_FSEL_bypass_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Bypass of 16bit */
N#define CMP_CR0_AC0_FSEL_bypass_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Bypass of 8bit */
N#define CMP_CR0_AC0_FSEL_cmp_ck_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):CMP_CK of 32bit */
N#define CMP_CR0_AC0_FSEL_cmp_ck_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CMP_CK of 16bit */
N#define CMP_CR0_AC0_FSEL_cmp_ck_b2                  ((uint8_t )0x04)        /*!< Bit Value =(0x1):CMP_CK of 8bit */
N#define CMP_CR0_AC0_FSEL_tm00_trgo_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define CMP_CR0_AC0_FSEL_tm00_trgo_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define CMP_CR0_AC0_FSEL_tm00_trgo_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N#define CMP_CR0_AC0_FSEL_tm01_trgo_w                ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define CMP_CR0_AC0_FSEL_tm01_trgo_h1               ((uint16_t)0x000C)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define CMP_CR0_AC0_FSEL_tm01_trgo_b2               ((uint8_t )0x0C)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N#define CMP_CR0_AC0_PINV_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_PINV_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_PINV_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_PINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR0_AC0_PINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR0_AC0_PINV_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR0_AC0_PINV_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR0_AC0_PINV_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR0_AC0_PINV_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_CR0_AC0_INV_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_INV_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_INV_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_INV_positive_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Positive of 32bit */
N#define CMP_CR0_AC0_INV_positive_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Positive of 16bit */
N#define CMP_CR0_AC0_INV_positive_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Positive of 8bit */
N#define CMP_CR0_AC0_INV_negative_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Negative of 32bit */
N#define CMP_CR0_AC0_INV_negative_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Negative of 16bit */
N#define CMP_CR0_AC0_INV_negative_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Negative of 8bit */
N
N#define CMP_CR0_AC0_NMUX_mask_w                     ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_NMUX_mask_h0                    ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_NMUX_mask_b1                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_NMUX_ivref_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF of 32bit */
N#define CMP_CR0_AC0_NMUX_ivref_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF of 16bit */
N#define CMP_CR0_AC0_NMUX_ivref_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF of 8bit */
N#define CMP_CR0_AC0_NMUX_cmp0_i0_w                  ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):CMP0_I0 of 32bit */
N#define CMP_CR0_AC0_NMUX_cmp0_i0_h0                 ((uint16_t)0x1000)      /*!< Bit Value =(0x1):CMP0_I0 of 16bit */
N#define CMP_CR0_AC0_NMUX_cmp0_i0_b1                 ((uint8_t )0x10)        /*!< Bit Value =(0x1):CMP0_I0 of 8bit */
N#define CMP_CR0_AC0_NMUX_cmp0_i1_w                  ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):CMP0_I1 of 32bit */
N#define CMP_CR0_AC0_NMUX_cmp0_i1_h0                 ((uint16_t)0x2000)      /*!< Bit Value =(0x2):CMP0_I1 of 16bit */
N#define CMP_CR0_AC0_NMUX_cmp0_i1_b1                 ((uint8_t )0x20)        /*!< Bit Value =(0x2):CMP0_I1 of 8bit */
N#define CMP_CR0_AC0_NMUX_cmp_c0_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR0_AC0_NMUX_cmp_c0_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR0_AC0_NMUX_cmp_c0_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR0_AC0_NMUX_cmp_c1_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR0_AC0_NMUX_cmp_c1_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR0_AC0_NMUX_cmp_c1_b1                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR0_AC0_NMUX_ldo_core_w                 ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR0_AC0_NMUX_ldo_core_h0                ((uint16_t)0x5000)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR0_AC0_NMUX_ldo_core_b1                ((uint8_t )0x50)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR0_AC0_PMUX_mask_w                     ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_PMUX_mask_h0                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_PMUX_mask_b1                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_PMUX_ivref_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF of 32bit */
N#define CMP_CR0_AC0_PMUX_ivref_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF of 16bit */
N#define CMP_CR0_AC0_PMUX_ivref_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF of 8bit */
N#define CMP_CR0_AC0_PMUX_cmp0_i0_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CMP0_I0 of 32bit */
N#define CMP_CR0_AC0_PMUX_cmp0_i0_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CMP0_I0 of 16bit */
N#define CMP_CR0_AC0_PMUX_cmp0_i0_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CMP0_I0 of 8bit */
N#define CMP_CR0_AC0_PMUX_cmp0_i1_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CMP0_I1 of 32bit */
N#define CMP_CR0_AC0_PMUX_cmp0_i1_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CMP0_I1 of 16bit */
N#define CMP_CR0_AC0_PMUX_cmp0_i1_b1                 ((uint8_t )0x02)        /*!< Bit Value =(0x2):CMP0_I1 of 8bit */
N#define CMP_CR0_AC0_PMUX_cmp_c0_w                   ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR0_AC0_PMUX_cmp_c0_h0                  ((uint16_t)0x0300)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR0_AC0_PMUX_cmp_c0_b1                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR0_AC0_PMUX_cmp_c1_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR0_AC0_PMUX_cmp_c1_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR0_AC0_PMUX_cmp_c1_b1                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR0_AC0_PMUX_ldo_core_w                 ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR0_AC0_PMUX_ldo_core_h0                ((uint16_t)0x0500)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR0_AC0_PMUX_ldo_core_b1                ((uint8_t )0x05)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR0_AC0_RES_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_RES_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_RES_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_RES_200ns_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):200ns of 32bit */
N#define CMP_CR0_AC0_RES_200ns_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):200ns of 16bit */
N#define CMP_CR0_AC0_RES_200ns_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):200ns of 8bit */
N#define CMP_CR0_AC0_RES_10us_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):10us of 32bit */
N#define CMP_CR0_AC0_RES_10us_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(0x1):10us of 16bit */
N#define CMP_CR0_AC0_RES_10us_b0                     ((uint8_t )0x08)        /*!< Bit Value =(0x1):10us of 8bit */
N
N#define CMP_CR0_AC0_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_CR0_AC0_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR0_AC0_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR0_AC0_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR0_AC0_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR0_AC0_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR0_AC0_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR0_AC0_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR0_AC0_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CMP_CR1  [register's definitions]
N *              Offset[0x14]  CMP Analog comparator-1 control register (0x5C000014)
N ******************************************************************************
N */
N///@{
N#define CMP_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_CR1 */
N#define CMP_CR1_AC1_FDIV_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_FDIV_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_FDIV_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_FDIV_div1_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CMP_CR1_AC1_FDIV_div1_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CMP_CR1_AC1_FDIV_div1_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CMP_CR1_AC1_FDIV_div2_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CMP_CR1_AC1_FDIV_div2_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CMP_CR1_AC1_FDIV_div2_b2                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CMP_CR1_AC1_FDIV_div4_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CMP_CR1_AC1_FDIV_div4_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CMP_CR1_AC1_FDIV_div4_b2                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CMP_CR1_AC1_FDIV_div8_w                     ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CMP_CR1_AC1_FDIV_div8_h1                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CMP_CR1_AC1_FDIV_div8_b2                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define CMP_CR1_AC1_FSEL_mask_w                     ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_FSEL_mask_h1                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_FSEL_mask_b2                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_FSEL_bypass_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Bypass of 32bit */
N#define CMP_CR1_AC1_FSEL_bypass_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Bypass of 16bit */
N#define CMP_CR1_AC1_FSEL_bypass_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Bypass of 8bit */
N#define CMP_CR1_AC1_FSEL_cmp_ck_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):CMP_CK of 32bit */
N#define CMP_CR1_AC1_FSEL_cmp_ck_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CMP_CK of 16bit */
N#define CMP_CR1_AC1_FSEL_cmp_ck_b2                  ((uint8_t )0x04)        /*!< Bit Value =(0x1):CMP_CK of 8bit */
N#define CMP_CR1_AC1_FSEL_tm00_trgo_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define CMP_CR1_AC1_FSEL_tm00_trgo_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define CMP_CR1_AC1_FSEL_tm00_trgo_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N#define CMP_CR1_AC1_FSEL_tm01_trgo_w                ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define CMP_CR1_AC1_FSEL_tm01_trgo_h1               ((uint16_t)0x000C)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define CMP_CR1_AC1_FSEL_tm01_trgo_b2               ((uint8_t )0x0C)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N#define CMP_CR1_AC1_PINV_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_PINV_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_PINV_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_PINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR1_AC1_PINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR1_AC1_PINV_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR1_AC1_PINV_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR1_AC1_PINV_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR1_AC1_PINV_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_CR1_AC1_INV_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_INV_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_INV_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_INV_positive_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Positive of 32bit */
N#define CMP_CR1_AC1_INV_positive_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Positive of 16bit */
N#define CMP_CR1_AC1_INV_positive_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Positive of 8bit */
N#define CMP_CR1_AC1_INV_negative_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Negative of 32bit */
N#define CMP_CR1_AC1_INV_negative_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Negative of 16bit */
N#define CMP_CR1_AC1_INV_negative_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Negative of 8bit */
N
N#define CMP_CR1_AC1_NMUX_mask_w                     ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_NMUX_mask_h0                    ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_NMUX_mask_b1                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_NMUX_ivref2_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF2 of 32bit */
N#define CMP_CR1_AC1_NMUX_ivref2_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF2 of 16bit */
N#define CMP_CR1_AC1_NMUX_ivref2_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF2 of 8bit */
N#define CMP_CR1_AC1_NMUX_cmp1_i0_w                  ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):CMP1_I0 of 32bit */
N#define CMP_CR1_AC1_NMUX_cmp1_i0_h0                 ((uint16_t)0x1000)      /*!< Bit Value =(0x1):CMP1_I0 of 16bit */
N#define CMP_CR1_AC1_NMUX_cmp1_i0_b1                 ((uint8_t )0x10)        /*!< Bit Value =(0x1):CMP1_I0 of 8bit */
N#define CMP_CR1_AC1_NMUX_cmp1_i1_w                  ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):CMP1_I1 of 32bit */
N#define CMP_CR1_AC1_NMUX_cmp1_i1_h0                 ((uint16_t)0x2000)      /*!< Bit Value =(0x2):CMP1_I1 of 16bit */
N#define CMP_CR1_AC1_NMUX_cmp1_i1_b1                 ((uint8_t )0x20)        /*!< Bit Value =(0x2):CMP1_I1 of 8bit */
N#define CMP_CR1_AC1_NMUX_cmp_c0_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR1_AC1_NMUX_cmp_c0_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR1_AC1_NMUX_cmp_c0_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR1_AC1_NMUX_cmp_c1_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR1_AC1_NMUX_cmp_c1_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR1_AC1_NMUX_cmp_c1_b1                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR1_AC1_NMUX_ldo_core_w                 ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR1_AC1_NMUX_ldo_core_h0                ((uint16_t)0x5000)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR1_AC1_NMUX_ldo_core_b1                ((uint8_t )0x50)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR1_AC1_PMUX_mask_w                     ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_PMUX_mask_h0                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_PMUX_mask_b1                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_PMUX_ivref2_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF2 of 32bit */
N#define CMP_CR1_AC1_PMUX_ivref2_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF2 of 16bit */
N#define CMP_CR1_AC1_PMUX_ivref2_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF2 of 8bit */
N#define CMP_CR1_AC1_PMUX_cmp1_i0_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CMP1_I0 of 32bit */
N#define CMP_CR1_AC1_PMUX_cmp1_i0_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CMP1_I0 of 16bit */
N#define CMP_CR1_AC1_PMUX_cmp1_i0_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CMP1_I0 of 8bit */
N#define CMP_CR1_AC1_PMUX_cmp1_i1_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CMP1_I1 of 32bit */
N#define CMP_CR1_AC1_PMUX_cmp1_i1_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CMP1_I1 of 16bit */
N#define CMP_CR1_AC1_PMUX_cmp1_i1_b1                 ((uint8_t )0x02)        /*!< Bit Value =(0x2):CMP1_I1 of 8bit */
N#define CMP_CR1_AC1_PMUX_cmp_c0_w                   ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR1_AC1_PMUX_cmp_c0_h0                  ((uint16_t)0x0300)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR1_AC1_PMUX_cmp_c0_b1                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR1_AC1_PMUX_cmp_c1_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR1_AC1_PMUX_cmp_c1_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR1_AC1_PMUX_cmp_c1_b1                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR1_AC1_PMUX_ldo_core_w                 ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR1_AC1_PMUX_ldo_core_h0                ((uint16_t)0x0500)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR1_AC1_PMUX_ldo_core_b1                ((uint8_t )0x05)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR1_AC1_RES_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_RES_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_RES_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_RES_200ns_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):200ns of 32bit */
N#define CMP_CR1_AC1_RES_200ns_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):200ns of 16bit */
N#define CMP_CR1_AC1_RES_200ns_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):200ns of 8bit */
N#define CMP_CR1_AC1_RES_10us_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):10us of 32bit */
N#define CMP_CR1_AC1_RES_10us_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(0x1):10us of 16bit */
N#define CMP_CR1_AC1_RES_10us_b0                     ((uint8_t )0x08)        /*!< Bit Value =(0x1):10us of 8bit */
N
N#define CMP_CR1_AC1_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_CR1_AC1_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR1_AC1_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR1_AC1_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR1_AC1_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR1_AC1_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR1_AC1_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR1_AC1_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR1_AC1_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CMP_CR2  [register's definitions]
N *              Offset[0x18]  CMP Analog comparator-2 control register (0x5C000018)
N ******************************************************************************
N */
N///@{
N#define CMP_CR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_CR2 */
N#define CMP_CR2_AC2_FDIV_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_FDIV_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_FDIV_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_FDIV_div1_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CMP_CR2_AC2_FDIV_div1_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CMP_CR2_AC2_FDIV_div1_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CMP_CR2_AC2_FDIV_div2_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CMP_CR2_AC2_FDIV_div2_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CMP_CR2_AC2_FDIV_div2_b2                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CMP_CR2_AC2_FDIV_div4_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CMP_CR2_AC2_FDIV_div4_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CMP_CR2_AC2_FDIV_div4_b2                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CMP_CR2_AC2_FDIV_div8_w                     ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CMP_CR2_AC2_FDIV_div8_h1                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CMP_CR2_AC2_FDIV_div8_b2                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define CMP_CR2_AC2_FSEL_mask_w                     ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_FSEL_mask_h1                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_FSEL_mask_b2                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_FSEL_bypass_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Bypass of 32bit */
N#define CMP_CR2_AC2_FSEL_bypass_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Bypass of 16bit */
N#define CMP_CR2_AC2_FSEL_bypass_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Bypass of 8bit */
N#define CMP_CR2_AC2_FSEL_cmp_ck_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):CMP_CK of 32bit */
N#define CMP_CR2_AC2_FSEL_cmp_ck_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CMP_CK of 16bit */
N#define CMP_CR2_AC2_FSEL_cmp_ck_b2                  ((uint8_t )0x04)        /*!< Bit Value =(0x1):CMP_CK of 8bit */
N#define CMP_CR2_AC2_FSEL_tm00_trgo_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define CMP_CR2_AC2_FSEL_tm00_trgo_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define CMP_CR2_AC2_FSEL_tm00_trgo_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N#define CMP_CR2_AC2_FSEL_tm01_trgo_w                ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define CMP_CR2_AC2_FSEL_tm01_trgo_h1               ((uint16_t)0x000C)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define CMP_CR2_AC2_FSEL_tm01_trgo_b2               ((uint8_t )0x0C)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N#define CMP_CR2_AC2_PINV_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_PINV_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_PINV_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_PINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR2_AC2_PINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR2_AC2_PINV_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR2_AC2_PINV_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR2_AC2_PINV_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR2_AC2_PINV_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_CR2_AC2_INV_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_INV_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_INV_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_INV_positive_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Positive of 32bit */
N#define CMP_CR2_AC2_INV_positive_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Positive of 16bit */
N#define CMP_CR2_AC2_INV_positive_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Positive of 8bit */
N#define CMP_CR2_AC2_INV_negative_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Negative of 32bit */
N#define CMP_CR2_AC2_INV_negative_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Negative of 16bit */
N#define CMP_CR2_AC2_INV_negative_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Negative of 8bit */
N
N#define CMP_CR2_AC2_NMUX_mask_w                     ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_NMUX_mask_h0                    ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_NMUX_mask_b1                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_NMUX_ivref2_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF2 of 32bit */
N#define CMP_CR2_AC2_NMUX_ivref2_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF2 of 16bit */
N#define CMP_CR2_AC2_NMUX_ivref2_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF2 of 8bit */
N#define CMP_CR2_AC2_NMUX_cmp2_i0_w                  ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):CMP2_I0 of 32bit */
N#define CMP_CR2_AC2_NMUX_cmp2_i0_h0                 ((uint16_t)0x1000)      /*!< Bit Value =(0x1):CMP2_I0 of 16bit */
N#define CMP_CR2_AC2_NMUX_cmp2_i0_b1                 ((uint8_t )0x10)        /*!< Bit Value =(0x1):CMP2_I0 of 8bit */
N#define CMP_CR2_AC2_NMUX_cmp2_i1_w                  ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):CMP2_I1 of 32bit */
N#define CMP_CR2_AC2_NMUX_cmp2_i1_h0                 ((uint16_t)0x2000)      /*!< Bit Value =(0x2):CMP2_I1 of 16bit */
N#define CMP_CR2_AC2_NMUX_cmp2_i1_b1                 ((uint8_t )0x20)        /*!< Bit Value =(0x2):CMP2_I1 of 8bit */
N#define CMP_CR2_AC2_NMUX_cmp_c0_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR2_AC2_NMUX_cmp_c0_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR2_AC2_NMUX_cmp_c0_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR2_AC2_NMUX_cmp_c1_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR2_AC2_NMUX_cmp_c1_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR2_AC2_NMUX_cmp_c1_b1                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR2_AC2_NMUX_ldo_core_w                 ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR2_AC2_NMUX_ldo_core_h0                ((uint16_t)0x5000)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR2_AC2_NMUX_ldo_core_b1                ((uint8_t )0x50)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR2_AC2_PMUX_mask_w                     ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_PMUX_mask_h0                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_PMUX_mask_b1                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_PMUX_ivref2_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF2 of 32bit */
N#define CMP_CR2_AC2_PMUX_ivref2_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF2 of 16bit */
N#define CMP_CR2_AC2_PMUX_ivref2_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF2 of 8bit */
N#define CMP_CR2_AC2_PMUX_cmp2_i0_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CMP2_I0 of 32bit */
N#define CMP_CR2_AC2_PMUX_cmp2_i0_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CMP2_I0 of 16bit */
N#define CMP_CR2_AC2_PMUX_cmp2_i0_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CMP2_I0 of 8bit */
N#define CMP_CR2_AC2_PMUX_cmp2_i1_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CMP2_I1 of 32bit */
N#define CMP_CR2_AC2_PMUX_cmp2_i1_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CMP2_I1 of 16bit */
N#define CMP_CR2_AC2_PMUX_cmp2_i1_b1                 ((uint8_t )0x02)        /*!< Bit Value =(0x2):CMP2_I1 of 8bit */
N#define CMP_CR2_AC2_PMUX_cmp_c0_w                   ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR2_AC2_PMUX_cmp_c0_h0                  ((uint16_t)0x0300)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR2_AC2_PMUX_cmp_c0_b1                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR2_AC2_PMUX_cmp_c1_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR2_AC2_PMUX_cmp_c1_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR2_AC2_PMUX_cmp_c1_b1                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR2_AC2_PMUX_ldo_core_w                 ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR2_AC2_PMUX_ldo_core_h0                ((uint16_t)0x0500)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR2_AC2_PMUX_ldo_core_b1                ((uint8_t )0x05)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR2_AC2_RES_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_RES_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_RES_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_RES_200ns_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):200ns of 32bit */
N#define CMP_CR2_AC2_RES_200ns_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):200ns of 16bit */
N#define CMP_CR2_AC2_RES_200ns_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):200ns of 8bit */
N#define CMP_CR2_AC2_RES_10us_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):10us of 32bit */
N#define CMP_CR2_AC2_RES_10us_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(0x1):10us of 16bit */
N#define CMP_CR2_AC2_RES_10us_b0                     ((uint8_t )0x08)        /*!< Bit Value =(0x1):10us of 8bit */
N
N#define CMP_CR2_AC2_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_CR2_AC2_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR2_AC2_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR2_AC2_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR2_AC2_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR2_AC2_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR2_AC2_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR2_AC2_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR2_AC2_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CMP_CR3  [register's definitions]
N *              Offset[0x1C]  CMP Analog comparator-3 control register (0x5C00001C)
N ******************************************************************************
N */
N///@{
N#define CMP_CR3_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CMP_CR3 */
N#define CMP_CR3_AC3_FDIV_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_FDIV_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_FDIV_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_FDIV_div1_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CMP_CR3_AC3_FDIV_div1_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CMP_CR3_AC3_FDIV_div1_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CMP_CR3_AC3_FDIV_div2_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CMP_CR3_AC3_FDIV_div2_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CMP_CR3_AC3_FDIV_div2_b2                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CMP_CR3_AC3_FDIV_div4_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CMP_CR3_AC3_FDIV_div4_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CMP_CR3_AC3_FDIV_div4_b2                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CMP_CR3_AC3_FDIV_div8_w                     ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CMP_CR3_AC3_FDIV_div8_h1                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CMP_CR3_AC3_FDIV_div8_b2                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define CMP_CR3_AC3_FSEL_mask_w                     ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_FSEL_mask_h1                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_FSEL_mask_b2                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_FSEL_bypass_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Bypass of 32bit */
N#define CMP_CR3_AC3_FSEL_bypass_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Bypass of 16bit */
N#define CMP_CR3_AC3_FSEL_bypass_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Bypass of 8bit */
N#define CMP_CR3_AC3_FSEL_cmp_ck_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):CMP_CK of 32bit */
N#define CMP_CR3_AC3_FSEL_cmp_ck_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CMP_CK of 16bit */
N#define CMP_CR3_AC3_FSEL_cmp_ck_b2                  ((uint8_t )0x04)        /*!< Bit Value =(0x1):CMP_CK of 8bit */
N#define CMP_CR3_AC3_FSEL_tm00_trgo_w                ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define CMP_CR3_AC3_FSEL_tm00_trgo_h1               ((uint16_t)0x0008)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define CMP_CR3_AC3_FSEL_tm00_trgo_b2               ((uint8_t )0x08)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N#define CMP_CR3_AC3_FSEL_tm01_trgo_w                ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define CMP_CR3_AC3_FSEL_tm01_trgo_h1               ((uint16_t)0x000C)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define CMP_CR3_AC3_FSEL_tm01_trgo_b2               ((uint8_t )0x0C)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N#define CMP_CR3_AC3_PINV_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_PINV_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_PINV_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_PINV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR3_AC3_PINV_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR3_AC3_PINV_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR3_AC3_PINV_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR3_AC3_PINV_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR3_AC3_PINV_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CMP_CR3_AC3_INV_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_INV_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_INV_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_INV_positive_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Positive of 32bit */
N#define CMP_CR3_AC3_INV_positive_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Positive of 16bit */
N#define CMP_CR3_AC3_INV_positive_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Positive of 8bit */
N#define CMP_CR3_AC3_INV_negative_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Negative of 32bit */
N#define CMP_CR3_AC3_INV_negative_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Negative of 16bit */
N#define CMP_CR3_AC3_INV_negative_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Negative of 8bit */
N
N#define CMP_CR3_AC3_NMUX_mask_w                     ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_NMUX_mask_h0                    ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_NMUX_mask_b1                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_NMUX_ivref2_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF2 of 32bit */
N#define CMP_CR3_AC3_NMUX_ivref2_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF2 of 16bit */
N#define CMP_CR3_AC3_NMUX_ivref2_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF2 of 8bit */
N#define CMP_CR3_AC3_NMUX_cmp3_i0_w                  ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):CMP3_I0 of 32bit */
N#define CMP_CR3_AC3_NMUX_cmp3_i0_h0                 ((uint16_t)0x1000)      /*!< Bit Value =(0x1):CMP3_I0 of 16bit */
N#define CMP_CR3_AC3_NMUX_cmp3_i0_b1                 ((uint8_t )0x10)        /*!< Bit Value =(0x1):CMP3_I0 of 8bit */
N#define CMP_CR3_AC3_NMUX_cmp3_i1_w                  ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):CMP3_I1 of 32bit */
N#define CMP_CR3_AC3_NMUX_cmp3_i1_h0                 ((uint16_t)0x2000)      /*!< Bit Value =(0x2):CMP3_I1 of 16bit */
N#define CMP_CR3_AC3_NMUX_cmp3_i1_b1                 ((uint8_t )0x20)        /*!< Bit Value =(0x2):CMP3_I1 of 8bit */
N#define CMP_CR3_AC3_NMUX_cmp_c0_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR3_AC3_NMUX_cmp_c0_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR3_AC3_NMUX_cmp_c0_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR3_AC3_NMUX_cmp_c1_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR3_AC3_NMUX_cmp_c1_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR3_AC3_NMUX_cmp_c1_b1                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR3_AC3_NMUX_ldo_core_w                 ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR3_AC3_NMUX_ldo_core_h0                ((uint16_t)0x5000)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR3_AC3_NMUX_ldo_core_b1                ((uint8_t )0x50)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR3_AC3_PMUX_mask_w                     ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_PMUX_mask_h0                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_PMUX_mask_b1                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_PMUX_ivref2_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IVREF2 of 32bit */
N#define CMP_CR3_AC3_PMUX_ivref2_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IVREF2 of 16bit */
N#define CMP_CR3_AC3_PMUX_ivref2_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):IVREF2 of 8bit */
N#define CMP_CR3_AC3_PMUX_cmp3_i0_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CMP3_I0 of 32bit */
N#define CMP_CR3_AC3_PMUX_cmp3_i0_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CMP3_I0 of 16bit */
N#define CMP_CR3_AC3_PMUX_cmp3_i0_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):CMP3_I0 of 8bit */
N#define CMP_CR3_AC3_PMUX_cmp3_i1_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CMP3_I1 of 32bit */
N#define CMP_CR3_AC3_PMUX_cmp3_i1_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CMP3_I1 of 16bit */
N#define CMP_CR3_AC3_PMUX_cmp3_i1_b1                 ((uint8_t )0x02)        /*!< Bit Value =(0x2):CMP3_I1 of 8bit */
N#define CMP_CR3_AC3_PMUX_cmp_c0_w                   ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):CMP_C0 of 32bit */
N#define CMP_CR3_AC3_PMUX_cmp_c0_h0                  ((uint16_t)0x0300)      /*!< Bit Value =(0x3):CMP_C0 of 16bit */
N#define CMP_CR3_AC3_PMUX_cmp_c0_b1                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):CMP_C0 of 8bit */
N#define CMP_CR3_AC3_PMUX_cmp_c1_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):CMP_C1 of 32bit */
N#define CMP_CR3_AC3_PMUX_cmp_c1_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(0x4):CMP_C1 of 16bit */
N#define CMP_CR3_AC3_PMUX_cmp_c1_b1                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):CMP_C1 of 8bit */
N#define CMP_CR3_AC3_PMUX_ldo_core_w                 ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):LDO_Core of 32bit */
N#define CMP_CR3_AC3_PMUX_ldo_core_h0                ((uint16_t)0x0500)      /*!< Bit Value =(0x5):LDO_Core of 16bit */
N#define CMP_CR3_AC3_PMUX_ldo_core_b1                ((uint8_t )0x05)        /*!< Bit Value =(0x5):LDO_Core of 8bit */
N
N#define CMP_CR3_AC3_RES_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_RES_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_RES_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_RES_200ns_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):200ns of 32bit */
N#define CMP_CR3_AC3_RES_200ns_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):200ns of 16bit */
N#define CMP_CR3_AC3_RES_200ns_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):200ns of 8bit */
N#define CMP_CR3_AC3_RES_10us_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):10us of 32bit */
N#define CMP_CR3_AC3_RES_10us_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(0x1):10us of 16bit */
N#define CMP_CR3_AC3_RES_10us_b0                     ((uint8_t )0x08)        /*!< Bit Value =(0x1):10us of 8bit */
N
N#define CMP_CR3_AC3_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CMP_CR3_AC3_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CMP_CR3_AC3_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CMP_CR3_AC3_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CMP_CR3_AC3_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CMP_CR3_AC3_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CMP_CR3_AC3_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CMP_CR3_AC3_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CMP_CR3_AC3_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_CMP_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_CMP.h                         */
N/*----------------------------------------------------------------------------*/
L 41 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CMP_DRV.h" 2
N#include "MG32x02z__ExtraStruct.H"
N
N
N/** @brief AC0 RisingEdge_IE Rising edge interrupt Enable */
N#define AC0_RisingEdge_IE       CMP_INT_AC0_RIE_enable_w   
N/** @brief AC0 FallingEdge_IE Falling edge interrupt Enable */
N#define AC0_FallingEdge_IE      CMP_INT_AC0_FIE_enable_w     
N
N/** @brief AC1 RisingEdge_IE Rising edge interrupt Enable */
N#define AC1_RisingEdge_IE       CMP_INT_AC1_RIE_enable_w   
N/** @brief AC1 FallingEdge_IE Falling edge interrupt Enable */
N#define AC1_FallingEdge_IE      CMP_INT_AC1_FIE_enable_w     
N
N#if defined(MG32_1ST)
X#if 1L
N/** @brief AC2 RisingEdge_IE Rising edge interrupt Enable */
N#define AC2_RisingEdge_IE       CMP_INT_AC2_RIE_enable_w   
N/** @brief AC2 FallingEdge_IE Falling edge interrupt Enable */
N#define AC2_FallingEdge_IE      CMP_INT_AC2_FIE_enable_w     
N
N/** @brief AC3 RisingEdge_IE Rising edge interrupt Enable */
N#define AC3_RisingEdge_IE       CMP_INT_AC3_RIE_enable_w   
N/** @brief AC3 FallingEdge_IE Falling edge interrupt Enable */
N#define AC3_FallingEdge_IE      CMP_INT_AC3_FIE_enable_w   
N#endif  
N
N/** @brief RisingEdge_Flag Rising edge flag */
N#define AC0_RisingEdge_Flag     CMP_STA_AC0_RF_happened_w    
N/** @brief FallingEdge_Flag  Falling edge flag */
N#define AC0_FallingEdge_Flag    CMP_STA_AC0_FF_happened_w    
N
N/** @brief RisingEdge_Flag Rising edge flag */
N#define AC1_RisingEdge_Flag      CMP_STA_AC1_RF_happened_w    
N/** @brief FallingEdge_Flag  Falling edge flag */
N#define AC1_FallingEdge_Flag    CMP_STA_AC1_FF_happened_w    
N
N#if defined(MG32_1ST)
X#if 1L
N/** @brief RisingEdge_Flag Rising edge flag */
N#define AC2_RisingEdge_Flag      CMP_STA_AC2_RF_happened_w    
N/** @brief FallingEdge_Flag  Falling edge flag */
N#define AC2_FallingEdge_Flag    CMP_STA_AC2_FF_happened_w    
N
N/** @brief RisingEdge_Flag Rising edge flag */
N#define AC3_RisingEdge_Flag      CMP_STA_AC3_RF_happened_w    
N/** @brief FallingEdge_Flag  Falling edge flag */
N#define AC3_FallingEdge_Flag    CMP_STA_AC3_FF_happened_w    
N#endif  
N
N
N
N/** 
N * @enum		CMP_PowerLevelDef
N * @brief		declare comparator response ability 
N */        
Ntypedef enum 
N{ 
N    CMP_Normal,             /*!< response time ~ 200ns */
N    CMP_Slow,               /*!< response time 5~10us */
N} CMP_PowerLevelDef;
N
N/** 
N * @enum		CMP_SynchClockSrcDef
N * @brief		declare comparator synchronized clock source 
N */        
Ntypedef enum 
N{ 
N    CMP_ByPass,             /*!< bypass (no schronized)*/
N    CMP_CMPCK,              /*!< synchronized clock from CMP_PROC */
N    CMP_TM00_TRGO,          /*!< synchronized clock from TM00 TRGO */
N    CMP_TM01_TRGO,          /*!< synchronized clock from TM01 TRGO */
N} CMP_SynchClockSrcDef;
N
N
N/** 
N * @enum		CMP_SYNCHClockDivDef
N * @brief		declare CMP synchronized filter clock divided 
N */        
Ntypedef enum 
N{ 
N    CMP_SFDIV1=0,           /*!< CMP synchronized filter clock divider (DIV1) */
N    CMP_SFDIV2,             /*!< CMP synchronized filter clock divider (DIV2) */
N    CMP_SFDIV4,             /*!< CMP synchronized filter clock divider (DIV4) */
N    CMP_SFDIV8,             /*!< CMP synchronized filter clock divider (DIV8) */
N} CMP_SYNCHClockDivDef;
N
N
N/** 
N * @enum		CMP_OutputPolarityDef
N * @brief		declare CMP output polarity (inverse) 
N */        
Ntypedef enum 
N{ 
N    CMP_PositivePolarity,   /*!< PI > NI => Out='+' */
N    CMP_NegativePolarity,   /*!< PI > NI => Out='-' */
N} CMP_OutputPolarityDef;
N
N
N
N#if defined(MG32_1ST) || defined(MG32_2ND)
X#if 1L || 0L
N/** 
N * @enum		CMP_ACPinInputDef
N * @brief		declare ACz input property 
N */        
Ntypedef enum 
N{ 
N    CMP_ACzIVREF,           /*!< select internal reference be input */
N    CMP_ACz_I0,             /*!< select AC0 input0 be input */
N    CMP_ACz_I1,             /*!< select AC0 input1  be input */
N    CMP_ACz_CMPC0,          /*!< select CMP common input0 be input */
N    CMP_ACz_CMPC1,          /*!< select CMP common input1 be input */
N    CMP_ACzLDO,             /*!< select LDO be input */
N} CMP_ACPinInputDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		CMP_ACPinInputDef
S * @brief		declare ACz input property 
S */        
Stypedef enum 
S{ 
S    CMP_ACzIVREF,           /*!< select internal reference be input */
S    CMP_ACz_I0,             /*!< select AC0 input0 be input */
S    CMP_ACz_I1,             /*!< select AC0 input1  be input */
S    CMP_ACz_CMPC0,          /*!< select CMP common input0 be input */
S    CMP_ACz_CMPC1,          /*!< select CMP common input1 be input */
S    CMP_ACzDAC,             /*!< select DAC output be input */
S} CMP_ACPinInputDef;
N#endif
N
N/** 
N * @enum		CMP_HysteresisLevel
N * @brief		declare hysteresis window level
N */        
Ntypedef enum 
N{ 
N    CMP_DisableHysteresis,  /*!< Disable comparator hysteresis window */
N    CMP_HysteresisLevel1,   /*!< Config Hysteresis window level1 */
N} CMP_HysteresisLevel;
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		CMP_VrefTopSourceSel
S * @brief		Comparator Vref top source select
S */        
Stypedef enum 
S{ 
S    CMP_VrefTop_VDD,        /*!< Disable comparator hysteresis window */
S    CMP_VrefTop_VR0,        /*!< Config Hysteresis window level1 */
S} CMP_VrefTopSourceSel;
N#endif
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
Nvoid CMP_DeInit(void);
N///@}
N
N///@{  
Nvoid CMP_Cmd(CMPAC_Struct* CMPACx, FunctionalState NewState);
Nvoid CMP_Power_Select(CMPAC_Struct* CMPACx, CMP_PowerLevelDef PowerLevelSel);
N///@}
N
N///@{  
Nvoid CMP_FilterClock_Select(CMPAC_Struct* CMPACx, CMP_SynchClockSrcDef SYNCHClockSrc);
Nvoid CMP_FilterClockDivider_Select(CMPAC_Struct* CMPACx, CMP_SYNCHClockDivDef SYNCHClockDiv);
Nvoid CMP_InverseOutputPin(CMPAC_Struct* CMPACx, FunctionalState NewState);
Nvoid CMP_OutputPolarity_Select(CMPAC_Struct* CMPACx, CMP_OutputPolarityDef OutPorSel);
N///@}
N
N///@{  
Nvoid CMP_IVREF_Cmd(CMP_Struct* CMPx, FunctionalState NewState);
Nvoid CMP_IVREF2_Cmd(CMP_Struct* CMPx, FunctionalState NewState);
NDRV_Return CMP_IVREF_Select(CMP_Struct* CMPx, uint8_t RefSel);
NDRV_Return CMP_IVREF2_Select(CMP_Struct* CMPx, uint8_t RefSel);
N#if defined(MG32_3RD)
X#if 0L
Svoid CMP_IVREFTopSource_Select(CMP_Struct* CMPx, CMP_VrefTopSourceSel RefTopSel);
Svoid CMP_IVREF2TopSource_Select(CMP_Struct* CMPx, CMP_VrefTopSourceSel RefTopSel);
N#endif
N///@}
N
N#if defined(MG32_3RD)
X#if 0L
S///@{  
Svoid CMP_AC0IVREFOuput_Cmd(CMPAC_Struct* CMPACx, FunctionalState NewState);
Svoid CMP_AC1IVREFOuput_Cmd(CMPAC_Struct* CMPACx, FunctionalState NewState);
N#endif
N///@}
N
N///@{  
Nvoid CMP_PositivePin_Select(CMPAC_Struct* CMPACx, CMP_ACPinInputDef ACzPPin);
Nvoid CMP_NegativePin_Select(CMPAC_Struct* CMPACx, CMP_ACPinInputDef ACzNPin);
N///@}
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S///@{  
Svoid CMP_SetHysteresisWindow(CMPAC_Struct* CMPACx, CMP_HysteresisLevel ACzPPin);
S///@}
N#endif
N///@{  
Nvoid CMP_IT_Config(CMP_Struct* CMPx, uint32_t CMP_ITSrc, FunctionalState NewState);
Nvoid CMP_ITEA_Cmd(CMP_Struct* CMPx, FunctionalState NewState);
NDRV_Return CMP_GetSingleFlagStatus(CMP_Struct* CMPx, uint32_t CMP_ITSrc);
Nuint32_t CMP_GetAllFlagStatus(CMP_Struct* CMPx);
Nvoid CMP_ClearFlag(CMP_Struct* CMPx, uint32_t CMP_ITSrc);
N///@}
N
N///@{  
NDRV_Return CMP_GetOutput (CMPAC_Struct* CMPACx);
N///@}
N
N#endif
N#endif
L 41 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_CSC_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CSC_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_CSC_DRV.H
N *
N * @brief       This is the C code format driver head file for CSC module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.25
N * @date        2021/04/28
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_GPIO_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_GPIO_DRV.h" 1
N
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_GPIO_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the GPIO
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.11
N * @date        2019/05/15
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N 
N#ifndef __MG32x02z_GPIO_DRV_H
N#define __MG32x02z_GPIO_DRV_H 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_GPIO.h" 
N 
N 
N/*! @name 
N*/
N/* @{ */
N#define PX_Pin_0                ((uint16_t)0x0001)  /*!< Pin 0 selected    */
N#define PX_Pin_1                ((uint16_t)0x0002)  /*!< Pin 1 selected    */
N#define PX_Pin_2                ((uint16_t)0x0004)  /*!< Pin 2 selected    */
N#define PX_Pin_3                ((uint16_t)0x0008)  /*!< Pin 3 selected    */
N#define PX_Pin_4                ((uint16_t)0x0010)  /*!< Pin 4 selected    */
N#define PX_Pin_5                ((uint16_t)0x0020)  /*!< Pin 5 selected    */
N#define PX_Pin_6                ((uint16_t)0x0040)  /*!< Pin 6 selected    */
N#define PX_Pin_7                ((uint16_t)0x0080)  /*!< Pin 7 selected    */
N#define PX_Pin_8                ((uint16_t)0x0100)  /*!< Pin 8 selected    */
N#define PX_Pin_9                ((uint16_t)0x0200)  /*!< Pin 9 selected    */
N#define PX_Pin_10               ((uint16_t)0x0400)  /*!< Pin 10 selected   */
N#define PX_Pin_11               ((uint16_t)0x0800)  /*!< Pin 11 selected   */
N#define PX_Pin_12               ((uint16_t)0x1000)  /*!< Pin 12 selected   */
N#define PX_Pin_13               ((uint16_t)0x2000)  /*!< Pin 13 selected   */
N#define PX_Pin_14               ((uint16_t)0x4000)  /*!< Pin 14 selected   */
N#define PX_Pin_15               ((uint16_t)0x8000)  /*!< Pin 15 selected   */
N#define PX_Pin_All              ((uint16_t)0xFFFF)  /*!< All pins selected */
N/* @} */
N
N/*! @name 
N*/
N/* @{ */ 
N#define PX(GPIOX,PinNum)        *((volatile uint8_t*)((uint32_t)GPIOX + PinNum + 0x10))    /*!< GPIOX pin (PinNum) read /write */
N
N
N#if defined(GPIOA_Base)
X#if 1L
N    #if defined(PA_CR0_default)
X    #if 1L
N        #define PA0                     PX(GPIOA_Base,0)            /*!< PA0 read / write */
N    #endif
N    #if defined(PA_CR1_default)
X    #if 1L
N        #define PA1                     PX(GPIOA_Base,1)            /*!< PA1 read / write */
N    #endif
N    #if defined(PA_CR2_default)
X    #if 1L
N        #define PA2                     PX(GPIOA_Base,2)            /*!< PA2 read / write */
N    #endif
N    #if defined(PA_CR3_default)
X    #if 1L
N        #define PA3                     PX(GPIOA_Base,3)            /*!< PA3 read / write */
N    #endif
N    #if defined(PA_CR4_default)
X    #if 1L
N        #define PA4                     PX(GPIOA_Base,4)            /*!< PA4 read / write */
N    #endif
N    #if defined(PA_CR5_default)
X    #if 1L
N        #define PA5                     PX(GPIOA_Base,5)            /*!< PA5 read / write */
N    #endif
N    #if defined(PA_CR6_default)
X    #if 1L
N        #define PA6                     PX(GPIOA_Base,6)            /*!< PA6 read / write */
N    #endif
N    #if defined(PA_CR7_default)
X    #if 1L
N        #define PA7                     PX(GPIOA_Base,7)            /*!< PA7 read / write */
N    #endif
N    #if defined(PA_CR8_default)
X    #if 1L
N        #define PA8                     PX(GPIOA_Base,8)            /*!< PA8 read / write */
N    #endif
N    #if defined(PA_CR9_default)
X    #if 1L
N        #define PA9                     PX(GPIOA_Base,9)            /*!< PA9 read / write */
N    #endif
N    #if defined(PA_CR10_default)
X    #if 1L
N        #define PA10                    PX(GPIOA_Base,10)           /*!< PA10 read / write */
N    #endif
N    #if defined(PA_CR11_default)
X    #if 1L
N        #define PA11                    PX(GPIOA_Base,11)           /*!< PA11 read / write */
N    #endif
N    #if defined(PA_CR12_default)
X    #if 1L
N        #define PA12                    PX(GPIOA_Base,12)           /*!< PA12 read / write */
N    #endif
N    #if defined(PA_CR13_default)
X    #if 1L
N        #define PA13                    PX(GPIOA_Base,13)           /*!< PA13 read / write */
N    #endif
N    #if defined(PA_CR14_default)
X    #if 1L
N        #define PA14                    PX(GPIOA_Base,14)           /*!< PA14 read / write */
N    #endif
N    #if defined(PA_CR15_default)
X    #if 1L
N        #define PA15                    PX(GPIOA_Base,15)           /*!< PA15 read / write */
N    #endif
N#endif
N
N#if defined(GPIOB_Base)
X#if 1L
N    #if defined(PB_CR0_default)
X    #if 1L
N        #define PB0                     PX(GPIOB_Base,0)            /*!< PB0 read / write */
N    #endif
N    #if defined(PB_CR1_default)
X    #if 1L
N        #define PB1                     PX(GPIOB_Base,1)            /*!< PB1 read / write */
N    #endif    
N    #if defined(PB_CR2_default)
X    #if 1L
N        #define PB2                     PX(GPIOB_Base,2)            /*!< PB2 read / write */
N    #endif
N    #if defined(PB_CR3_default)
X    #if 1L
N        #define PB3                     PX(GPIOB_Base,3)            /*!< PB3 read / write */
N    #endif
N    #if defined(PB_CR4_default)
X    #if 1L
N        #define PB4                     PX(GPIOB_Base,4)            /*!< PB4 read / write */
N    #endif
N    #if defined(PB_CR5_default)
X    #if 1L
N        #define PB5                     PX(GPIOB_Base,5)            /*!< PB5 read / write */
N    #endif
N    #if defined(PB_CR6_default)
X    #if 1L
N        #define PB6                     PX(GPIOB_Base,6)            /*!< PB6 read / write */
N    #endif
N    #if defined(PB_CR7_default)
X    #if 1L
N        #define PB7                     PX(GPIOB_Base,7)            /*!< PB7 read / write */
N    #endif
N    #if defined(PB_CR8_default)
X    #if 1L
N        #define PB8                     PX(GPIOB_Base,8)            /*!< PB8 read / write */
N    #endif
N    #if defined(PB_CR9_default)
X    #if 1L
N        #define PB9                     PX(GPIOB_Base,9)            /*!< PB9 read / write */
N    #endif
N    #if defined(PB_CR10_default)
X    #if 1L
N        #define PB10                    PX(GPIOB_Base,10)           /*!< PB10 read / write */
N    #endif
N    #if defined(PB_CR11_default)
X    #if 1L
N        #define PB11                    PX(GPIOB_Base,11)           /*!< PB11 read / write */
N    #endif
N    #if defined(PB_CR12_default)
X    #if 1L
N        #define PB12                    PX(GPIOB_Base,12)           /*!< PB12 read / write */
N    #endif
N    #if defined(PB_CR13_default)
X    #if 1L
N        #define PB13                    PX(GPIOB_Base,13)           /*!< PB13 read / write */
N    #endif
N    #if defined(PB_CR14_default)
X    #if 1L
N        #define PB14                    PX(GPIOB_Base,14)           /*!< PB14 read / write */
N    #endif
N    #if defined(PB_CR15_default)
X    #if 1L
N        #define PB15                    PX(GPIOB_Base,15)           /*!< PB15 read / write */
N    #endif
N#endif
N
N#if defined(GPIOC_Base)
X#if 1L
N    #if defined(PC_CR0_default)
X    #if 1L
N        #define PC0                     PX(GPIOC_Base,0)            /*!< PC0 read / write */
N    #endif
N    #if defined(PC_CR1_default)
X    #if 1L
N        #define PC1                     PX(GPIOC_Base,1)            /*!< PC1 read / write */
N    #endif
N    #if defined(PC_CR2_default)
X    #if 1L
N        #define PC2                     PX(GPIOC_Base,2)            /*!< PC2 read / write */
N    #endif
N    #if defined(PC_CR3_default)
X    #if 1L
N        #define PC3                     PX(GPIOC_Base,3)            /*!< PC3 read / write */
N    #endif
N    #if defined(PC_CR4_default)
X    #if 1L
N        #define PC4                     PX(GPIOC_Base,4)            /*!< PC4 read / write */
N    #endif
N    #if defined(PC_CR5_default)
X    #if 1L
N        #define PC5                     PX(GPIOC_Base,5)            /*!< PC5 read / write */
N    #endif
N    #if defined(PC_CR6_default)
X    #if 1L
N        #define PC6                     PX(GPIOC_Base,6)            /*!< PC6 read / write */
N    #endif
N    #if defined(PC_CR7_default)
X    #if 1L
N        #define PC7                     PX(GPIOC_Base,7)            /*!< PC7 read / write */
N    #endif
N    #if defined(PC_CR8_default)
X    #if 1L
N        #define PC8                     PX(GPIOC_Base,8)            /*!< PC8 read / write */
N    #endif
N    #if defined(PC_CR9_default)
X    #if 1L
N        #define PC9                     PX(GPIOC_Base,9)            /*!< PC9 read / write */
N    #endif
N    #if defined(PC_CR10_default)
X    #if 1L
N        #define PC10                    PX(GPIOC_Base,10)           /*!< PC10 read / write */
N    #endif
N    #if defined(PC_CR11_default)
X    #if 1L
N        #define PC11                    PX(GPIOC_Base,11)           /*!< PC11 read / write */
N    #endif
N    #if defined(PC_CR12_default)
X    #if 1L
N        #define PC12                    PX(GPIOC_Base,12)           /*!< PC12 read / write */
N    #endif
N    #if defined(PC_CR13_default)
X    #if 1L
N        #define PC13                    PX(GPIOC_Base,13)           /*!< PC13 read / write */
N    #endif
N    #if defined(PC_CR14_default)
X    #if 1L
N        #define PC14                    PX(GPIOC_Base,14)           /*!< PC14 read / write */
N    #endif
N    #if defined(PC_CR15_default)
X    #if 0L
S        #define PC15                    PX(GPIOC_Base,15)           /*!< PC15 read / write */
N    #endif
N#endif
N
N#if defined(GPIOD_Base)
X#if 1L
N    #if defined(PD_CR0_default)
X    #if 1L
N        #define PD0                     PX(GPIOD_Base,0)            /*!< PD0 read / write */
N    #endif
N    #if defined(PD_CR1_default)
X    #if 1L
N        #define PD1                     PX(GPIOD_Base,1)            /*!< PD1 read / write */
N    #endif
N    #if defined(PD_CR2_default)
X    #if 1L
N        #define PD2                     PX(GPIOD_Base,2)            /*!< PD2 read / write */
N    #endif
N    #if defined(PD_CR3_default)
X    #if 1L
N        #define PD3                     PX(GPIOD_Base,3)            /*!< PD3 read / write */
N    #endif
N    #if defined(PD_CR4_default)
X    #if 1L
N        #define PD4                     PX(GPIOD_Base,4)            /*!< PD4 read / write */
N    #endif
N    #if defined(PD_CR5_default)
X    #if 1L
N        #define PD5                     PX(GPIOD_Base,5)            /*!< PD5 read / write */
N    #endif
N    #if defined(PD_CR6_default)
X    #if 1L
N        #define PD6                     PX(GPIOD_Base,6)            /*!< PD6 read / write */
N    #endif
N    #if defined(PD_CR7_default)
X    #if 1L
N        #define PD7                     PX(GPIOD_Base,7)            /*!< PD7 read / write */
N    #endif
N    #if defined(PD_CR8_default)
X    #if 1L
N        #define PD8                     PX(GPIOD_Base,8)            /*!< PD8 read / write */
N    #endif
N    #if defined(PD_CR9_default)
X    #if 1L
N        #define PD9                     PX(GPIOD_Base,9)            /*!< PD9 read / write */
N    #endif
N    #if defined(PD_CR10_default)
X    #if 1L
N        #define PD10                    PX(GPIOD_Base,10)           /*!< PD10 read / write */
N    #endif
N    #if defined(PD_CR11_default)
X    #if 1L
N        #define PD11                    PX(GPIOD_Base,11)           /*!< PD11 read / write */
N    #endif
N    #if defined(PD_CR12_default)
X    #if 1L
N        #define PD12                    PX(GPIOD_Base,12)           /*!< PD12 read / write */
N    #endif
N    #if defined(PD_CR13_default)
X    #if 1L
N        #define PD13                    PX(GPIOD_Base,13)           /*!< PD13 read / write */
N    #endif
N    #if defined(PD_CR14_default)
X    #if 1L
N        #define PD14                    PX(GPIOD_Base,14)           /*!< PD14 read / write */
N    #endif
N    #if defined(PD_CR15_default)
X    #if 1L
N        #define PD15                    PX(GPIOD_Base,15)           /*!< PD15 read / write */
N    #endif
N#endif
N
N#if defined(GPIOE_Base)
X#if 1L
N    #if defined(PE_CR0_default)
X    #if 1L
N        #define PE0                     PX(GPIOE_Base,0)            /*!< PE0 read / write */
N    #endif
N    #if defined(PE_CR1_default)
X    #if 1L
N        #define PE1                     PX(GPIOE_Base,1)            /*!< PE1 read / write */
N    #endif
N    #if defined(PE_CR2_default)
X    #if 1L
N        #define PE2                     PX(GPIOE_Base,2)            /*!< PE2 read / write */
N    #endif
N    #if defined(PE_CR3_default)
X    #if 1L
N        #define PE3                     PX(GPIOE_Base,3)            /*!< PE3 read / write */
N    #endif
N    #if defined(PE_CR4_default)
X    #if 0L
S        #define PE4                     PX(GPIOE_Base,4)            /*!< PE4 read / write */
N    #endif
N    #if defined(PE_CR5_default)
X    #if 0L
S        #define PE5                     PX(GPIOE_Base,5)            /*!< PE5 read / write */
N    #endif
N    #if defined(PE_CR6_default)
X    #if 0L
S        #define PE6                     PX(GPIOE_Base,6)            /*!< PE6 read / write */
N    #endif
N    #if defined(PE_CR7_default)
X    #if 0L
S        #define PE7                     PX(GPIOE_Base,7)            /*!< PE7 read / write */
N    #endif
N    #if defined(PE_CR8_default)
X    #if 1L
N        #define PE8                     PX(GPIOE_Base,8)            /*!< PE8 read / write */
N    #endif
N    #if defined(PE_CR9_default)
X    #if 1L
N        #define PE9                     PX(GPIOE_Base,9)            /*!< PE9 read / write */
N    #endif
N    #if defined(PE_CR10_default)
X    #if 0L
S        #define PE10                    PX(GPIOE_Base,10)           /*!< PE10 read / write */
N    #endif
N    #if defined(PE_CR11_default)
X    #if 0L
S        #define PE11                    PX(GPIOE_Base,11)           /*!< PE11 read / write */
N    #endif
N    #if defined(PE_CR12_default)
X    #if 1L
N        #define PE12                    PX(GPIOE_Base,12)           /*!< PE12 read / write */
N    #endif
N    #if defined(PE_CR13_default)
X    #if 1L
N        #define PE13                    PX(GPIOE_Base,13)           /*!< PE13 read / write */
N    #endif
N    #if defined(PE_CR14_default)
X    #if 1L
N        #define PE14                    PX(GPIOE_Base,14)           /*!< PE14 read / write */
N    #endif
N    #if defined(PE_CR15_default)
X    #if 1L
N        #define PE15                    PX(GPIOE_Base,15)           /*!< PE15 read / write */
N    #endif
N#endif
N
N/* @} */ 
N 
N 
N 
N/*! @enum   PINX_Mode_TypeDef
N    @brief  Pin IO mode control options .
N*/ 
Ntypedef enum
N{
N	PINX_Mode_Analog_IO     = 0x00000000,               /*!< Analog IO */
N	PINX_Mode_OpenDrain_O   = 0x00000001,               /*!< Open drain output */
N	PINX_Mode_PushPull_O    = 0x00000002,               /*!< Push pull output */
N	PINX_Mode_Digital_I     = 0x00000003,               /*!< Digital input */
N	PINX_Mode_Quasi_IO      = 0x00000004,               /*!< Quasi-bidirection output*/
N}PINX_Mode_TypeDef;
N
N
N/*! @enum   PINX_Speed_Typedef
N    @brief  Pin output high speed control options .
N*/
Ntypedef enum
N{
N	PINX_Speed_Low     = 0,                             /*!< Output high speed mode disable*/
N	PINX_Speed_High    = 0x00000008,                    /*!< Output high speed mode enable*/
N}PINX_Speed_Typedef;
N
N
N/*! @enum   PINX_PUResistant_Typedef
N    @brief  Pin pull up resister control options .
N*/
Ntypedef enum
N{
N	PINX_PUResistant_Disable = 0,                       /*!< Pull up resister disable*/
N	PINX_PUResistant_Enable  = 0x00000020,              /*!< Pull up resister enable*/
N}PINX_PUResistant_Typedef;
N
N
N/*! @enum   PINX_Inverse_Typedef
N    @brief  Pin input inverse control options .
N*/
Ntypedef enum
N{
N	PINX_Inverse_Disable  = 0,                          /*!< input inverse disable*/
N	PINX_Inverse_Enable   = 0x00000080,                 /*!< input inverse enable*/
N}PINX_Inverse_Typedef;
N
N
N/*! @enum   PINX_OUTDrive_Typedef
N    @brief  Pin output drive strength control options .
N*/
Ntypedef enum
N{
N	PINX_OUTDrive_Level0 = 0x00000000,                  /*!< Drive strength-Full*/
N    PINX_OUTDrive_Level1 = 0x00000100,                  /*!< Drive strength-1/2*/
N	PINX_OUTDrive_Level2 = 0x00000200,                  /*!< Drive strength 1/4*/
N    PINX_OUTDrive_Level3 = 0x00000300                   /*!< Drive strength-1/8*/   
N}PINX_OUTDrive_Typedef;
N
N
N/*! @enum   PINX_FilterDiver_Typedef
N    @brief  Pin input deglitch filter clock divider control options .
N*/
Ntypedef enum
N{
N	PINX_FilterDivider_Bypass = 0x00000000,             /*!< input bypass filter*/
N	PINX_FilterDivider_1      = 0x00000400,             /*!< input filter clock divided by 1*/
N	PINX_FilterDivider_4      = 0x00000800,             /*!< input filter clock divided by 4*/
N	PINX_FilterDivider_16     = 0x00000C00,	            /*!< input filter clock divided by 16*/
N}PINX_FilterDiver_Typedef;
N
N
N/*! @enum   PortFilterCLK_Typedef
N    @brief  Port input deglitch filter clock source control options .
N*/
Ntypedef enum
N{
N    GPIO_FT_CLK_AHB         =   0,                   /*!< Filter clock source from AHB*/         
N    GPIO_FT_CLK_AHB_DIV8    =   1,                   /*!< Filter clock source from AHB/8*/
N    GPIO_FT_CLK_ILRCO       =   2,                   /*!< Filter clock source from ILRCO*/
N    GPIO_FT_TM00_TRGO       =   3,                   /*!< Filter clock source from TM00_TRGO*/
N    GPIO_FT_CK_UT           =   4                    /*!< Filter clock source from CK_UT*/
N}PortFilterCLK_Typedef; 
N
N
N/** 
N * @struct	PIN_InitTypeDef
N * @brief	Pin relationship control member.
N */
Ntypedef struct	
N{
N	uint32_t                  	PINX_Pin;                       /*!<Configuration Pin. */ 
N	PINX_Mode_TypeDef			PINX_Mode;                      /*!<Pin mode select. */ 
N    PINX_Speed_Typedef 		  	PINX_Speed;                     /*!<Pin output high speed mode control. */ 
N	PINX_PUResistant_Typedef    PINX_PUResistant;               /*!<Pin pull up resistant control. */ 
N	PINX_Inverse_Typedef        PINX_Inverse;                   /*!<Pin input inverse control. */ 
N    PINX_OUTDrive_Typedef       PINX_OUTDrive;                  /*!<Pin output drive strength control. */ 
N	PINX_FilterDiver_Typedef    PINX_FilterDivider;             /*!<Pin input filter divider control. */ 
N	uint32_t  				  	PINX_Alternate_Function;        /*!<Pin alternate function select. */ 
N}PIN_InitTypeDef;
N 
N 
N 
N
Nvoid GPIO_PinMode_Config(Pin_Struct* PINX , PIN_InitTypeDef* PINX_InitStruct);
Nvoid GPIO_PortMode_Config(IOM_Struct* IOMX, PIN_InitTypeDef* PINX_InitStruct);
Nvoid GPIO_PinMode_Select(Pin_Struct* PINX , PINX_Mode_TypeDef Pin_Mode);
Nvoid GPIO_PinHighSpeedMode_Cmd(Pin_Struct* PINX , FunctionalState Pin_HSMode);
Nvoid GPIO_PinPUResister_Cmd(Pin_Struct* PINX , FunctionalState Pin_PUR);
Nvoid GPIO_PinInverse_Cmd(Pin_Struct* PINX, FunctionalState Pin_INV);
Nvoid GPIO_PinOutputDrive_Select(Pin_Struct* PINX , PINX_OUTDrive_Typedef Pin_ODC);
Nvoid GPIO_PinInFilterDivider_Select(Pin_Struct* PINX , PINX_FilterDiver_Typedef Pin_FDIV);
Nvoid GPIO_PinFunction_Select(Pin_Struct* PINX , uint8_t Pin_Func);
Nvoid GPIO_PortFilterClockSource_Select(IOM_Struct* IOMX , PortFilterCLK_Typedef FCKS);
Nvoid GPIO_WritePort(GPIO_Struct* GPIOX, uint16_t Port_Status);
Nuint16_t GPIO_ReadPort(GPIO_Struct* GPIOX);
Nvoid GPIO_SetPortBit(GPIO_Struct* GPIOX , uint16_t Set_Pin);
Nvoid GPIO_ClearPortBit(GPIO_Struct* GPIOX , uint16_t Clear_Pin);
Nvoid GPIO_SetClearPortBit(GPIO_Struct* GPIOX, uint16_t Set_Pin , uint16_t Clr_Pin);
N#endif
N
N
N
N
N
N 
L 31 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CSC_DRV.h" 2
N#include "MG32x02z_CSC.h"
N
N
N#ifndef _MG32x02z_CSC_DRV_H
N/*!< _MG32x02z_CSC_DRV_H */ 
N#define _MG32x02z_CSC_DRV_H
N
N/*! @name 
N*/
N/* @{ */ 
N#define CSC_XOSCF       CSC_STA_XOSCF_mask_w                                            /*!< XOSC clock stable and ready detect flag */
N#define CSC_ILRCOF      CSC_STA_ILRCOF_mask_w                                           /*!< ILRCO clock stable and ready detect flag */
N#define CSC_IHRCOF      CSC_STA_IHRCOF_mask_w                                           /*!< IHRCO clock stable and ready detect flag */
N#define CSC_PLLF        CSC_STA_PLLF_mask_w                                             /*!< PLL clock stable and ready detect flag */
N#define CSC_MCDF        CSC_STA_MCDF_mask_w                                             /*!< XOSC missing clock detect failure event flag */
N#define CSC_ALLF        CSC_XOSCF | CSC_ILRCOF | CSC_IHRCOF | CSC_PLLF | CSC_MCDF       /*!< All event and interrupt flag */
N
N#define CSC_PLL_STA         CSC_STA_PLL_STA_mask_w      /*!< Select clock source PLL */
N#define CSC_IHRCO_STA       CSC_STA_IHRCO_STA_mask_w    /*!< Select clock source IHRCO */
N#define CSC_ILRCO_STA       CSC_STA_ILRCO_STA_mask_w    /*!< Select clock source ILRCO */
N#define CSC_XOSC_STA        CSC_STA_XOSC_STA_mask_w     /*!< Select clock source XOSC */
N#if defined(MG32_3RD)
X#if 0L
S#define CSC_PLL_LOCKF       CSC_STA_PLL_LOCKF_mask_w    /*!< Select clock source PLL lock */
N#endif
N
N#define CSC_INT_XOSC        CSC_INT_XOSC_IE_mask_w      /*!< XOSC clock stable interrupt */
N#define CSC_INT_ILRCO       CSC_INT_ILRCO_IE_mask_w     /*!< ILRCO clock stable interrupt */
N#define CSC_INT_IHRCO       CSC_INT_IHRCO_IE_mask_w     /*!< IHRCO clock stable interrupt */
N#define CSC_INT_PLL         CSC_INT_PLL_IE_mask_w       /*!< PLL clock stable interrupt */
N#define CSC_INT_MCD         CSC_INT_MCD_IE_mask_w       /*!< XOSC missing clock detect failure event interrupt */
N/* @} */
N
N
N/*! @enum   CSC_PeriphOnMode_TypeDef
N    @brief  peripheral on mode configuration.
N*/
N#if defined(MG32_1ST)
X#if 1L
Ntypedef enum
N{   
N    CSC_ON_PortA    = 0,    /*!< IO Port A clock source */
N    CSC_ON_PortB    = 1,    /*!< IO Port B clock source */
N    CSC_ON_PortC    = 2,    /*!< IO Port C clock source */
N    CSC_ON_PortD    = 3,    /*!< IO Port D clock source */
N    CSC_ON_PortE    = 4,    /*!< IO Port E clock source */
N    CSC_ON_GPL      = 8,    /*!< GPL clock source */
N    CSC_ON_EMB      = 12,   /*!< External memory bus clock source */
N    CSC_ON_DMA      = 15,   /*!< DMA clock source */
N    CSC_ON_ADC0     = 32,   /*!< ADC module clock source */
N    CSC_ON_CMP      = 34,   /*!< CMP module clock source */
N    CSC_ON_DAC      = 35,   /*!< DAC module clock source */
N    CSC_ON_RTC      = 37,   /*!< RTC module clock source */
N    CSC_ON_IWDT     = 38,   /*!< IWDT module clock source */
N    CSC_ON_WWDT     = 39,   /*!< WWDT module clock source */
N    CSC_ON_I2C0     = 40,   /*!< I2C0 module clock source */
N    CSC_ON_I2C1     = 41,   /*!< I2C1 module clock source */
N    CSC_ON_SPI0     = 44,   /*!< SPI0 module clock source */
N    CSC_ON_UART0    = 48,   /*!< UART0 module clock source */
N    CSC_ON_UART1    = 49,   /*!< UART1 module clock source */
N    CSC_ON_UART2    = 50,   /*!< UART2 module clock source */
N    CSC_ON_UART3    = 51,   /*!< UART3 module clock source */
N    CSC_ON_TM00     = 64,   /*!< TM00 module clock source */
N    CSC_ON_TM01     = 65,   /*!< TM01 module clock source */
N    CSC_ON_TM10     = 68,   /*!< TM10 module clock source */
N    CSC_ON_TM16     = 71,   /*!< TM16 module clock source */
N    CSC_ON_TM20     = 72,   /*!< TM20 module clock source */
N    CSC_ON_TM26     = 75,   /*!< TM26 module clock source */
N    CSC_ON_TM36     = 79    /*!< TM36 module clock source */
N}CSC_PeriphOnMode_TypeDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
Stypedef enum
S{   
S    CSC_ON_PortA    = 0,    /*!< IO Port A clock source */
S    CSC_ON_PortB    = 1,    /*!< IO Port B clock source */
S    CSC_ON_PortC    = 2,    /*!< IO Port C clock source */
S    CSC_ON_PortD    = 3,    /*!< IO Port D clock source */
S    CSC_ON_GPL      = 8,    /*!< GPL clock source */
S    CSC_ON_DMA      = 15,   /*!< DMA clock source */
S    CSC_ON_ADC0     = 32,   /*!< ADC module clock source */
S    CSC_ON_CMP      = 34,   /*!< CMP module clock source */
S    CSC_ON_RTC      = 37,   /*!< RTC module clock source */
S    CSC_ON_IWDT     = 38,   /*!< IWDT module clock source */
S    CSC_ON_WWDT     = 39,   /*!< WWDT module clock source */
S    CSC_ON_I2C0     = 40,   /*!< I2C0 module clock source */
S    CSC_ON_SPI0     = 44,   /*!< SPI0 module clock source */
S    CSC_ON_UART0    = 48,   /*!< UART0 module clock source */
S    CSC_ON_UART1    = 49,   /*!< UART1 module clock source */
S    CSC_ON_TM00     = 64,   /*!< TM00 module clock source */
S    CSC_ON_TM01     = 65,   /*!< TM01 module clock source */
S    CSC_ON_TM10     = 68,   /*!< TM10 module clock source */
S    CSC_ON_TM16     = 71,   /*!< TM16 module clock source */
S    CSC_ON_TM36     = 79    /*!< TM36 module clock source */
S}CSC_PeriphOnMode_TypeDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
Stypedef enum
S{   
S    CSC_ON_PortA    = 0,    /*!< IO Port A clock source */
S    CSC_ON_PortB    = 1,    /*!< IO Port B clock source */
S    CSC_ON_PortC    = 2,    /*!< IO Port C clock source */
S    CSC_ON_PortD    = 3,    /*!< IO Port D clock source */
S    CSC_ON_PortE    = 4,    /*!< IO Port E clock source */
S    CSC_ON_GPL      = 8,    /*!< GPL clock source */
S    CSC_ON_EMB      = 12,   /*!< External memory bus clock source */
S    CSC_ON_DMA      = 15,   /*!< DMA clock source */
S    CSC_ON_ADC0     = 32,   /*!< ADC module clock source */
S    CSC_ON_CMP      = 34,   /*!< CMP module clock source */
S    CSC_ON_DAC      = 35,   /*!< DAC module clock source */
S    CSC_ON_RTC      = 37,   /*!< RTC module clock source */
S    CSC_ON_IWDT     = 38,   /*!< IWDT module clock source */
S    CSC_ON_WWDT     = 39,   /*!< WWDT module clock source */
S    CSC_ON_I2C0     = 40,   /*!< I2C0 module clock source */
S    CSC_ON_I2C1     = 41,   /*!< I2C1 module clock source */
S    CSC_ON_SPI0     = 44,   /*!< SPI0 module clock source */
S    CSC_ON_UART0    = 48,   /*!< UART0 module clock source */
S    CSC_ON_UART1    = 49,   /*!< UART1 module clock source */
S    CSC_ON_UART2    = 50,   /*!< UART2 module clock source */
S    CSC_ON_UART4    = 52,   /*!< UART4 module clock source */
S    CSC_ON_UART5    = 53,   /*!< UART5 module clock source */
S    CSC_ON_UART6    = 54,   /*!< UART6 module clock source */
S    CSC_ON_UART7    = 55,   /*!< UART7 module clock source */
S    CSC_ON_USB      = 60,   /*!< USB module clock source */
S    CSC_ON_APX      = 61,   /*!< APX module clock source */
S    CSC_ON_TM00     = 64,   /*!< TM00 module clock source */
S    CSC_ON_TM01     = 65,   /*!< TM01 module clock source */
S    CSC_ON_TM10     = 68,   /*!< TM10 module clock source */
S    CSC_ON_TM16     = 71,   /*!< TM16 module clock source */
S    CSC_ON_TM20     = 72,   /*!< TM20 module clock source */
S    CSC_ON_TM26     = 75,   /*!< TM26 module clock source */
S    CSC_ON_TM36     = 79    /*!< TM36 module clock source */
S}CSC_PeriphOnMode_TypeDef;
N#endif
N
N
N
N/*! @enum   CSC_PeriphSleepMode_TypeDef
N    @brief  peripheral sleep mode configuration.
N*/
N#if defined(MG32_1ST)
X#if 1L
Ntypedef enum
N{   
N    CSC_SLP_ADC0    = 32,   /*!< ADC module clock in SLEEP mode */
N    CSC_SLP_CMP     = 34,   /*!< CMP module clock in SLEEP mode */
N    CSC_SLP_DAC     = 35,   /*!< DAC module clock in SLEEP mode */
N    CSC_SLP_RTC     = 37,   /*!< RTC module clock in SLEEP mode */
N    CSC_SLP_IWDT    = 38,   /*!< IWDT module clock in SLEEP mode */
N    CSC_SLP_WWDT    = 39,   /*!< WWDT module clock in SLEEP mode */
N    CSC_SLP_I2C0    = 40,   /*!< I2C0 module clock in SLEEP mode */
N    CSC_SLP_I2C1    = 41,   /*!< I2C1 module clock in SLEEP mode */
N    CSC_SLP_SPI0    = 44,   /*!< SPI0 module clock in SLEEP mode */
N    CSC_SLP_UART0   = 48,   /*!< UART0 module clock in SLEEP mode */
N    CSC_SLP_UART1   = 49,   /*!< UART1 module clock in SLEEP mode */
N    CSC_SLP_UART2   = 50,   /*!< UART2 module clock in SLEEP mode */
N    CSC_SLP_UART3   = 51,   /*!< UART3 module clock in SLEEP mode */
N    CSC_SLP_TM00    = 64,   /*!< TM00 module clock in SLEEP mode */
N    CSC_SLP_TM01    = 65,   /*!< TM01 module clock in SLEEP mode */
N    CSC_SLP_TM10    = 68,   /*!< TM10 module clock in SLEEP mode */
N    CSC_SLP_TM16    = 71,   /*!< TM16 module clock in SLEEP mode */
N    CSC_SLP_TM20    = 72,   /*!< TM20 module clock in SLEEP mode */
N    CSC_SLP_TM26    = 75,   /*!< TM26 module clock in SLEEP mode */
N    CSC_SLP_TM36    = 79,   /*!< TM36 module clock in SLEEP mode */
N    CSC_SLP_EMB     = 94,   /*!< EMB module clock in SLEEP mode */
N}CSC_PeriphSleepMode_TypeDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
Stypedef enum
S{   
S    CSC_SLP_ADC0    = 32,   /*!< ADC module clock in SLEEP mode */
S    CSC_SLP_CMP     = 34,   /*!< CMP module clock in SLEEP mode */
S    CSC_SLP_RTC     = 37,   /*!< RTC module clock in SLEEP mode */
S    CSC_SLP_IWDT    = 38,   /*!< IWDT module clock in SLEEP mode */
S    CSC_SLP_WWDT    = 39,   /*!< WWDT module clock in SLEEP mode */
S    CSC_SLP_I2C0    = 40,   /*!< I2C0 module clock in SLEEP mode */
S    CSC_SLP_SPI0    = 44,   /*!< SPI0 module clock in SLEEP mode */
S    CSC_SLP_UART0   = 48,   /*!< UART0 module clock in SLEEP mode */
S    CSC_SLP_UART1   = 49,   /*!< UART1 module clock in SLEEP mode */
S    CSC_SLP_TM00    = 64,   /*!< TM00 module clock in SLEEP mode */
S    CSC_SLP_TM01    = 65,   /*!< TM01 module clock in SLEEP mode */
S    CSC_SLP_TM10    = 68,   /*!< TM10 module clock in SLEEP mode */
S    CSC_SLP_TM16    = 71,   /*!< TM16 module clock in SLEEP mode */
S    CSC_SLP_TM36    = 79,   /*!< TM36 module clock in SLEEP mode */
S}CSC_PeriphSleepMode_TypeDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
Stypedef enum
S{   
S    CSC_SLP_ADC0    = 32,   /*!< ADC module clock in SLEEP mode */
S    CSC_SLP_CMP     = 34,   /*!< CMP module clock in SLEEP mode */
S    CSC_SLP_DAC     = 35,   /*!< DAC module clock in SLEEP mode */
S    CSC_SLP_RTC     = 37,   /*!< RTC module clock in SLEEP mode */
S    CSC_SLP_IWDT    = 38,   /*!< IWDT module clock in SLEEP mode */
S    CSC_SLP_WWDT    = 39,   /*!< WWDT module clock in SLEEP mode */
S    CSC_SLP_I2C0    = 40,   /*!< I2C0 module clock in SLEEP mode */
S    CSC_SLP_I2C1    = 41,   /*!< I2C1 module clock in SLEEP mode */
S    CSC_SLP_SPI0    = 44,   /*!< SPI0 module clock in SLEEP mode */
S    CSC_SLP_UART0   = 48,   /*!< UART0 module clock in SLEEP mode */
S    CSC_SLP_UART1   = 49,   /*!< UART1 module clock in SLEEP mode */
S    CSC_SLP_UART2   = 50,   /*!< UART2 module clock in SLEEP mode */
S    CSC_SLP_UART4   = 52,   /*!< UART4 module clock in SLEEP mode */
S    CSC_SLP_UART5   = 53,   /*!< UART5 module clock in SLEEP mode */
S    CSC_SLP_UART6   = 54,   /*!< UART6 module clock in SLEEP mode */
S    CSC_SLP_UART7   = 55,   /*!< UART7 module clock in SLEEP mode */
S    CSC_SLP_USB     = 60,   /*!< USB module clock in SLEEP mode */
S    CSC_SLP_APX     = 61,   /*!< APX module clock in SLEEP mode */
S    CSC_SLP_TM00    = 64,   /*!< TM00 module clock in SLEEP mode */
S    CSC_SLP_TM01    = 65,   /*!< TM01 module clock in SLEEP mode */
S    CSC_SLP_TM10    = 68,   /*!< TM10 module clock in SLEEP mode */
S    CSC_SLP_TM16    = 71,   /*!< TM16 module clock in SLEEP mode */
S    CSC_SLP_TM20    = 72,   /*!< TM20 module clock in SLEEP mode */
S    CSC_SLP_TM26    = 75,   /*!< TM26 module clock in SLEEP mode */
S    CSC_SLP_TM36    = 79,   /*!< TM36 module clock in SLEEP mode */
S    CSC_SLP_SRAM    = 88,   /*!< SRAM module clock in SLEEP mode */
S    CSC_SLP_FLASH   = 89,   /*!< FLASH module clock in SLEEP mode */
S    CSC_SLP_DMA     = 93,   /*!< DMA module clock in SLEEP mode */
S    CSC_SLP_EMB     = 94,   /*!< EMB module clock in SLEEP mode */
S}CSC_PeriphSleepMode_TypeDef;
N#endif
N
N
N
N/*! @enum   CSC_PeriphStopMode_TypeDef
N    @brief  peripheral stop mode configuration.
N*/
Ntypedef enum
N{   
N    CSC_STP_RTC     = 37,   /*!< RTC module clock in STOP mode */
N    CSC_STP_IWDT    = 38,   /*!< IWDT module clock in STOP mode */
N}CSC_PeriphStopMode_TypeDef;
N
N
N/*! @enum   CSC_CKS_TypeDef
N    @brief  CSC peripheral selection.
N*/
N#if defined(MG32_1ST)
X#if 1L
Ntypedef enum
N{
N    CSC_ADC0_CKS    = 0,    /*!< ADC0 process clock source */
N    CSC_CMP_CKS     = 4,    /*!< CMP process clock source */
N    CSC_DAC_CKS     = 5,    /*!< DAC process clock source */
N    CSC_I2C0_CKS    = 32,   /*!< I2C0 process clock source */
N    CSC_I2C1_CKS    = 34,   /*!< I2C1 process clock source */
N    CSC_SPI0_CKS    = 40,   /*!< SPI0 process clock source */
N    CSC_UART0_CKS   = 48,   /*!< UART0 process clock source */
N    CSC_UART1_CKS   = 50,   /*!< UART1 process clock source */
N    CSC_UART2_CKS   = 52,   /*!< UART2 process clock source */
N    CSC_UART3_CKS   = 54,   /*!< UART3 process clock source */
N    CSC_TM00_CKS    = 64,   /*!< TM01 process clock source */
N    CSC_TM01_CKS    = 66,   /*!< TM10 process clock source */
N    CSC_TM10_CKS    = 72,   /*!< TM16 process clock source */
N    CSC_TM16_CKS    = 78,   /*!< TM20 process clock source */
N    CSC_TM20_CKS    = 80,   /*!< TM26 process clock source */
N    CSC_TM26_CKS    = 86,   /*!< TM36 process clock source */
N    CSC_TM36_CKS    = 94,   /*!< ADC0 process clock source */
N}CSC_CKS_TypeDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
Stypedef enum
S{
S    CSC_ADC0_CKS    = 0,    /*!< ADC0 process clock source */
S    CSC_CMP_CKS     = 4,    /*!< CMP process clock source */
S    CSC_I2C0_CKS    = 32,   /*!< I2C0 process clock source */
S    CSC_SPI0_CKS    = 40,   /*!< SPI0 process clock source */
S    CSC_UART0_CKS   = 48,   /*!< UART0 process clock source */
S    CSC_UART1_CKS   = 50,   /*!< UART1 process clock source */
S    CSC_TM00_CKS    = 64,   /*!< TM01 process clock source */
S    CSC_TM01_CKS    = 66,   /*!< TM10 process clock source */
S    CSC_TM10_CKS    = 72,   /*!< TM16 process clock source */
S    CSC_TM16_CKS    = 78,   /*!< TM20 process clock source */
S    CSC_TM36_CKS    = 94,   /*!< ADC0 process clock source */
S}CSC_CKS_TypeDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
Stypedef enum
S{
S    CSC_ADC0_CKS    = 0,    /*!< ADC0 process clock source */
S    CSC_CMP_CKS     = 4,    /*!< CMP process clock source */
S    CSC_DAC_CKS     = 5,    /*!< DAC process clock source */
S    CSC_APX_CKS     = 10,   /*!< APX process clock source */
S    CSC_I2C0_CKS    = 32,   /*!< I2C0 process clock source */
S    CSC_I2C1_CKS    = 34,   /*!< I2C1 process clock source */
S    CSC_SPI0_CKS    = 40,   /*!< SPI0 process clock source */
S    CSC_UART0_CKS   = 48,   /*!< UART0 process clock source */
S    CSC_UART1_CKS   = 50,   /*!< UART1 process clock source */
S    CSC_UART2_CKS   = 52,   /*!< UART2 process clock source */
S    CSC_UART4_CKS   = 56,   /*!< UART4 process clock source */
S    CSC_UART5_CKS   = 58,   /*!< UART5 process clock source */
S    CSC_UART6_CKS   = 60,   /*!< UART6 process clock source */
S    CSC_UART7_CKS   = 62,   /*!< UART7 process clock source */
S    CSC_TM00_CKS    = 64,   /*!< TM01 process clock source */
S    CSC_TM01_CKS    = 66,   /*!< TM10 process clock source */
S    CSC_TM10_CKS    = 72,   /*!< TM16 process clock source */
S    CSC_TM16_CKS    = 78,   /*!< TM20 process clock source */
S    CSC_TM20_CKS    = 80,   /*!< TM26 process clock source */
S    CSC_TM26_CKS    = 86,   /*!< TM36 process clock source */
S    CSC_TM36_CKS    = 94,   /*!< ADC0 process clock source */
S}CSC_CKS_TypeDef;
N#endif
N
N
N
N/*! @enum   CSC_CKSS_TypeDef
N    @brief  CSC peripheral clock source selection.
N*/
Ntypedef enum
N{
N    CK_APB      = 0,    /*!< Peripheral clock source select CK_APB */
N    CK_AHB      = 1     /*!< Peripheral clock source select CK_AHB */
N}CSC_CKSS_TypeDef;
N
N
N#if defined(MG32_3RD)
X#if 0L
S/*! @enum   CSC_USB_CKSS_TypeDef
S    @brief  CSC USB clock source selection.
S*/
Stypedef enum
S{
S    CK_PLL      = CSC_CKS0_USB_CKS_ck_pll_b1,   /*!< Peripheral clock source select CK_PLL */
S    CK_SYS      = CSC_CKS0_USB_CKS_ck_sys_b1    /*!< Peripheral clock source select CK_SYS */
S}CSC_USB_CKSS_TypeDef;
N#endif
N
N
N/*! @enum   CSC_IHRCO_TypeDef
N    @brief  CSC IHRCO clock source selection.
N*/
Ntypedef enum
N{
N    IHRCO_12MHz     = 0,    /*!< Select IHECO clock select 12MHz */
N    IHRCO_11M0592Hz = 1     /*!< Select IHECO clock select 11.0952MHz */
N}CSC_IHRCO_TypeDef;
N
N
N/*! @enum   CSC_XOSC_GN_TypeDef
N    @brief  CSC XTAL gain selection.
N*/
Ntypedef enum
N{
N    Gain_Low            = 0x00,     /*!< Select XOSC gain low for 32.768K */
N    Gain_Medium         = 0x01,     /*!< Select XOSC gain medium */
N    Gain_Lowest         = 0x02,     /*!< Select XOSC gain lowest for 32.768K */
N}CSC_XOSC_GN_TypeDef;
N
N
N/*! @enum   CSC_MCD_SEL_TypeDef
N    @brief  CSC MCD duration time selection.
N*/
Ntypedef enum
N{
N    MCD_Duration_125us      = 0x00,     /*!< Select MCD Duration 125us */
N    MCD_Duration_250us      = 0x40,     /*!< Select MCD Duration 250us */
N    MCD_Duration_500us      = 0x80,     /*!< Select MCD Duration 500us */
N    MCD_Duration_1ms        = 0xC0      /*!< Select MCD Duration 1ms */
N}CSC_MCD_SEL_TypeDef;
N  
N  
N/*! @enum   CSC_PLL_MUL_TypeDef
N    @brief  CSC PLL Multiplication selection.
N*/
Ntypedef enum
N{
N    PLLIx16         = 0x0000,   /*!< Select PLL input clock x 16 */
N    PLLIx24         = 0x0100,   /*!< Select PLL input clock x 24 */
N#if defined(MG32_3RD) 
X#if 0L 
S    PLLI_CLKx4      = 0x0600,   /*!< Select PLL input clock x 04 */
S    PLLI_CLKx5      = 0x0800,   /*!< Select PLL input clock x 05 */
S    PLLI_CLKx6      = 0x0A00,   /*!< Select PLL input clock x 06 */
S    PLLI_CLKx7      = 0x0C00,   /*!< Select PLL input clock x 07 */
S    PLLI_CLKx8      = 0x0E00,   /*!< Select PLL input clock x 08 */
S    PLLI_CLKx9      = 0x1000,   /*!< Select PLL input clock x 09 */
S    PLLI_CLKx10     = 0x1200,   /*!< Select PLL input clock x 10 */
S    PLLI_CLKx11     = 0x1400,   /*!< Select PLL input clock x 11 */
S    PLLI_CLKx12     = 0x1600,   /*!< Select PLL input clock x 12 */
S    PLLI_CLKx13     = 0x1800,   /*!< Select PLL input clock x 13 */
S    PLLI_CLKx14     = 0x1A00,   /*!< Select PLL input clock x 14 */
S    PLLI_CLKx15     = 0x1C00,   /*!< Select PLL input clock x 15 */
S    PLLI_CLKx16     = 0x1E00,   /*!< Select PLL input clock x 16 */
S    PLLI_CLKx17     = 0x2000,   /*!< Select PLL input clock x 17 */
S    PLLI_CLKx18     = 0x2200,   /*!< Select PLL input clock x 18 */
S    PLLI_CLKx19     = 0x2400,   /*!< Select PLL input clock x 19 */
S    PLLI_CLKx20     = 0x2600,   /*!< Select PLL input clock x 20 */
S    PLLI_CLKx21     = 0x2800,   /*!< Select PLL input clock x 21 */
S    PLLI_CLKx22     = 0x2A00,   /*!< Select PLL input clock x 22 */
S    PLLI_CLKx23     = 0x2C00,   /*!< Select PLL input clock x 23 */
S    PLLI_CLKx24     = 0x2E00,   /*!< Select PLL input clock x 24 */
S    PLLI_CLKx25     = 0x3000,   /*!< Select PLL input clock x 25 */
S    PLLI_CLKx26     = 0x3200,   /*!< Select PLL input clock x 26 */
S    PLLI_CLKx27     = 0x3400,   /*!< Select PLL input clock x 27 */
S    PLLI_CLKx28     = 0x3600,   /*!< Select PLL input clock x 28 */
S    PLLI_CLKx29     = 0x3800,   /*!< Select PLL input clock x 29 */
S    PLLI_CLKx30     = 0x3A00,   /*!< Select PLL input clock x 30 */
S    PLLI_CLKx31     = 0x3C00,   /*!< Select PLL input clock x 31 */
S    PLLI_CLKx32     = 0x3E00,   /*!< Select PLL input clock x 32 */
N#endif
N}CSC_PLL_MUL_TypeDef;
N      
N  
N/*! @enum   CSC_PLLI_DIV_TypeDef
N    @brief  CSC PLL input divider selection.
N*/      
Ntypedef enum
N{
N    PLLI_DIV_1      = 0x00,     /*!< Select PLL input clock divided by 1 */
N    PLLI_DIV_2      = 0x01,     /*!< Select PLL input clock divided by 2 */
N    PLLI_DIV_4      = 0x02,     /*!< Select PLL input clock divided by 4 */
N    PLLI_DIV_6      = 0x03      /*!< Select PLL input clock divided by 6 */
N}CSC_PLLI_DIV_TypeDef;
N
N
N/*! @enum   CSC_PLLO_DIV_TypeDef
N    @brief  CSC PLL output divider selection.
N*/     
Ntypedef enum
N{
N    PLLO_DIV_1      = 0x30,     /*!< Select PLL output clock divided by 1 */
N    PLLO_DIV_2      = 0x20,     /*!< Select PLL output clock divided by 2 */
N    PLLO_DIV_3      = 0x10,     /*!< Select PLL output clock divided by 3 */
N    PLLO_DIV_4      = 0x00      /*!< Select PLL output clock divided by 4 */
N}CSC_PLLO_DIV_TypeDef;
N
N
N
N
N
N
N/*! @enum   CSC_PLLI_SEL_TypeDef
N    @brief  CSC PLL input clock source select
N*/
Ntypedef enum
N{
N    PLLI_SEL_HS         = 0x0000,   /*!<Select PLL input CK_HS */
N    PLLI_SEL_HS2        = 0x0002    /*!<Select PLL input CK_HS2 */
N}CSC_PLLI_SEL_TypeDef;
N
N
N
N/*! @enum   CSC_ST_SEL_TypeDef
N    @brief  CSC CK_ST clock source selection.
N*/  
Ntypedef enum
N{
N    ST_HCLK_DIV_8       = 0x00,     /*!< Select clock source HCLK divided by 8 */
N    ST_CK_LS_DIV_2      = 0x01      /*!< Select clock source CK_LS divided by 2 */
N}CSC_ST_SEL_TypeDef;
N
N
N/*! @enum   CSC_MAIN_SEL_TypeDef
N    @brief  CSC CK_MAIN clock sourcr selection.
N*/  
Ntypedef enum
N{
N    MAIN_CK_HS       = 0x00,     /*!< Select clock source CK_HS */
N    MAIN_CK_PLLI     = 0x40,     /*!< Select clock source CK_HS */
N    MAIN_CK_PLLO     = 0x80      /*!< Select clock source CK_HS */
N}CSC_MAIN_SEL_TypeDef;
N
N
N/*! @enum   CSC_HS_SEL_TypeDef
N    @brief  CSC CK_HS clock sourcr selection.
N*/ 
Ntypedef enum
N{
N    HS_CK_IHRCO     = 0x00,     /*!< Select clock source CK_IHRCO */
N    HS_CK_XOSC      = 0x04,     /*!< Select clock source CK_XOSC */
N    HS_CK_ILRCO     = 0x08,     /*!< Select clock source CK_ILRCO */
N    HS_CK_EXT       = 0x0C      /*!< Select clock source CK_EXT */
N}CSC_HS_SEL_TypeDef;
N
N
N/*! @enum   CSC_LS_SEL_TypeDef
N    @brief  CSC CK_LS clock sourcr selection.
N*/ 
Ntypedef enum
N{
N    LS_CK_XOSC      = 0x01,     /*!< Select clock source CK_ILECO */
N    LS_CK_ILRCO     = 0x02,     /*!< Select clock source CK_ILECO */
N    LS_CK_EXT       = 0x03      /*!< Select clock source  */
N}CSC_LS_SEL_TypeDef;
N
N
N/*! @enum   CSC_APB_DIV_TypeDef
N    @brief  CSC CK_APV clock divider selection.
N*/ 
Ntypedef enum
N{
N    APB_DIV_1       = 0x00,     /*!< Select clock source divided by 1 */
N    APB_DIV_2       = 0x01,     /*!< Select clock source divided by 2 */
N    APB_DIV_4       = 0x02,     /*!< Select clock source divided by 4 */
N    APB_DIV_8       = 0x03,     /*!< Select clock source divided by 8 */
N    APB_DIV_16      = 0x04      /*!< Select clock source divided by 16 */
N}CSC_APB_DIV_TypeDef;
N
N
N/*! @enum   CSC_UT_DIV_TypeDef
N    @brief  CSC CK_UT clock divider selection.
N*/ 
Ntypedef enum
N{
N    UT_DIV_8        = 0x04,     /*!< Select clock source divided by 8 */
N    UT_DIV_16       = 0x08,     /*!< Select clock source divided by 16 */
N    UT_DIV_32       = 0x00,     /*!< Select clock source divided by 32 */
N    UT_DIV_128      = 0x0C      /*!< Select clock source divided by 128 */
N}CSC_UT_DIV_TypeDef;
N
N
N/*! @enum   CSC_AHB_DIV_TypeDef
N    @brief  CSC CK_AHB clock divider selection. 
N*/ 
Ntypedef enum
N{
N    AHB_DIV_1       = 0x00,     /*!< Select clock source divided by 1 */
N    AHB_DIV_2       = 0x01,     /*!< Select clock source divided by 2 */
N    AHB_DIV_4       = 0x02,     /*!< Select clock source divided by 4 */
N    AHB_DIV_8       = 0x03,     /*!< Select clock source divided by 8 */
N    AHB_DIV_16      = 0x04,     /*!< Select clock source divided by 16 */
N    AHB_DIV_32      = 0x05,     /*!< Select clock source divided by 32 */
N    AHB_DIV_64      = 0x06,     /*!< Select clock source divided by 64 */
N    AHB_DIV_128     = 0x07,     /*!< Select clock source divided by 128 */
N    AHB_DIV_256     = 0x08,     /*!< Select clock source divided by 256 */
N    AHB_DIV_512     = 0x09,     /*!< Select clock source divided by 512 */
N}CSC_AHB_DIV_TypeDef;
N
N
N#if defined(MG32_3RD) 
X#if 0L 
S/*! @enum   CSC_USB_SIE_DIV_TypeDef
S    @brief  CSC CK_APV clock divider selection.
S*/ 
Stypedef enum
S{
S    USB_SIE_DIV_1       = 0x00,     /*!< Select USB SIE divided by 1 */
S    USB_SIE_DIV_2       = 0x10,     /*!< Select USB SIE divided by 2 */
S    USB_SIE_DIV_3       = 0x20,     /*!< Select USB SIE divided by 3 */
S    USB_SIE_DIV_4       = 0x30      /*!< Select USB SIE divided by 4 */
S}CSC_USB_SIE_DIV_TypeDef;
N#endif
N
N
N/*! @enum   CSC_CKO_SEL_TypeDef
N    @brief  CSC ICKO clock source selection.
N*/ 
Ntypedef enum
N{
N    ICKO_CK_MAIN    = 0x00,     /*!< Select clock source CK_MAIN */
N    ICKO_CK_AHB     = 0x10,     /*!< Select clock source CK_AHB */
N    ICKO_CK_APB     = 0x20,     /*!< Select clock source CK_APB */
N    ICKO_CK_HS      = 0x30,     /*!< Select clock source CK_HS */
N    ICKO_CK_LS      = 0x40,     /*!< Select clock source CK_LS */
N    ICKO_CK_XOSC    = 0x50      /*!< Select clock source CK_XOSC */
N}CSC_CKO_SEL_TypeDef;
N
N
N/*! @enum   CSC_CKO_DIV_TypeDef
N    @brief  CSC ICKO clock divider selection.
N*/ 
Ntypedef enum
N{
N    ICKO_DIV_1      = 0x00,     /*!< Select clock source divided by 1 */
N    ICKO_DIV_2      = 0x04,     /*!< Select clock source divided by 2 */
N    ICKO_DIV_4      = 0x08,     /*!< Select clock source divided by 4 */
N    ICKO_DIV_8      = 0x0C      /*!< Select clock source divided by 8 */
N}CSC_CKO_DIV_TypeDef;
N
N
N/*! @enum   CSC_MAIN_MUX_STA_TypeDef
N    @brief  CSC clock MAIN MUX state
N*/ 
Ntypedef enum
N{
N    MAIN_MUX_HS     = 0x01,     /*!< MAIN MUX check HS */
N    MAIN_MUX_PLLI   = 0x02,     /*!< MAIN MUX check PLLI */
N    MAIN_MUX_PLLO   = 0x04      /*!< MAIN MUX check PLLO */
N}CSC_MAIN_MUX_STA_TypeDef;
N
N
N/*! @enum   CSC_HS_MUX_STA_TypeDef
N    @brief  CSC clock HS MUX state
N*/ 
Ntypedef enum
N{
N    HS_MUX_IHRCO    = 0x01,     /*!< HS MUX check IHRCO */
N    HS_MUX_XOSC     = 0x02,     /*!< HS MUX check XOSC */
N    HS_MUX_ILRCO    = 0x04,     /*!< HS MUX check ILRCO */
N    HS_MUX_CK_EXT   = 0x08      /*!< HS MUX check CK_EXT */
N}CSC_HS_MUX_STA_TypeDef;
N
N
N/*! @enum   CSC_LS_MUX_STA_TypeDef
N    @brief  CSC clock LS MUX state
N*/ 
Ntypedef enum
N{
N    LS_MUX_XOSC     = 0x02,     /*!< LS MUX check XOSC */
N    LS_MUX_ILRCO    = 0x04,     /*!< LS MUX check ILRCO */
N    LS_MUX_CK_EXT   = 0x08      /*!< LS MUX check CK_EXT */
N}CSC_LS_MUX_STA_TypeDef;
N
N
N/*! @enum   CSC_PLLI_MUX_STA_TypeDef
N    @brief  CSC PLLI MUX state
N*/ 
Ntypedef enum
N{
N    PLLI_MUX_HS     = 0x00,     /*!< LS MUX check HS */
N    PLLI_MUX_HS2    = 0x01,     /*!< LS MUX check HS2 */
N
N}CSC_PLLI_MUX_STA_TypeDef;
N
N
N
N/** 
N * @struct  CSC_PLL_TypeDef
N * @brief   CSC PLL initial structure.
N */
N#if defined(MG32_1ST) || defined(MG32_2ND)
X#if 1L || 0L
Ntypedef struct
N{
N    CSC_PLLI_DIV_TypeDef    InputDivider;               /*!< PLL input divider: PLLI_DIV_1/2/4/6 */
N    CSC_PLL_MUL_TypeDef     Multiplication;             /*!< PLL Multiplication */
N    CSC_PLLO_DIV_TypeDef    OutputDivider;              /*!< PLL input divider: PLLO_DIV_1/2/3/4 */
N}CSC_PLL_TypeDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
Stypedef struct
S{
S    CSC_PLLI_DIV_TypeDef    InputDivider;               /*!< PLL input divider: PLLI_DIV_1/2/4/6 */
S    CSC_PLL_MUL_TypeDef     Multiplication;             /*!< PLL Multiplication */
S    CSC_PLLO_DIV_TypeDef    OutputDivider;              /*!< PLL input divider: PLLO_DIV_1/2/3/4 */
S    CSC_PLLI_SEL_TypeDef    PLLInputClockSelect;        /*!< PLL input clock source select */
S}CSC_PLL_TypeDef;
N#endif
N
N
N/*! @name
N*/       
N/* @{ */ 
N#define CSC_PeriphOnModeClock_Config      CSC_PeriphONModeClock_Config
N#define CSC_PeriphSleepModeClock_Config   CSC_PeriphSLEEPModeClock_Config
N#define CSC_PeriphStopModeClock_Config    CSC_PeriphSTOPModeClock_Config
N
N/**
N * @name    Function announce
N *
N */ 
Nvoid CSC_IHRCO_Cmd (FunctionalState NewState);
Nvoid CSC_IHRCO_Select (CSC_IHRCO_TypeDef Freq);
Nvoid CSC_XOSC_Cmd (FunctionalState NewState);
Nvoid CSC_XOSCGain_Select (CSC_XOSC_GN_TypeDef CSC_XoscGain);
Nvoid CSC_CK_ST_Select (CSC_ST_SEL_TypeDef CSC_CK_ST_SEL);
Nvoid CSC_CK_MAIN_Select (CSC_MAIN_SEL_TypeDef CSC_CK_MAIN_SEL);
Nvoid CSC_CK_HS_Select (CSC_HS_SEL_TypeDef CSC_CK_HS_SEL);
Nvoid CSC_CK_HS2_Select (CSC_HS_SEL_TypeDef CSC_CK_HS2_SEL);
Nvoid CSC_CK_LS_Select (CSC_LS_SEL_TypeDef CSC_CK_LS_SEL);
N
Nvoid CSC_PLL_Config (CSC_PLL_TypeDef* CSC_PLL_CFG);
Nvoid CSC_PLL_Cmd (FunctionalState NewState);
N
Nvoid CSC_CK_APB_Divider_Select (CSC_APB_DIV_TypeDef CSC_CK_APB_DIVS);
Nvoid CSC_CK_UT_Divider_Select (CSC_UT_DIV_TypeDef CSC_CK_UT_DIVS);
Nvoid CSC_CK_AHB_Divider_Select (CSC_AHB_DIV_TypeDef CSC_CK_AHB_DIVS);
N
Nvoid CSC_ICKO_ClockSource_Select (CSC_CKO_SEL_TypeDef ICKO_CKS_SEL);
Nvoid CSC_ICKO_Divider_Select (CSC_CKO_DIV_TypeDef CSC_ICKO_DIVS);
Nvoid CSC_ICKO_Cmd (FunctionalState NewState);
N
Nvoid CSC_MissingClockDetectionDuration_Select (CSC_MCD_SEL_TypeDef CSC_MCDDuration);
Nvoid CSC_MissingClockDetection_Cmd (FunctionalState NewState);
N
Nvoid CSC_PeriphProcessClockSource_Config (CSC_CKS_TypeDef CSC_Periph, CSC_CKSS_TypeDef CSC_CKS);
Nvoid CSC_PeriphONModeClock_Config (CSC_PeriphOnMode_TypeDef CSC_Periph, FunctionalState NewState);
Nvoid CSC_PeriphSLEEPModeClock_Config (CSC_PeriphSleepMode_TypeDef CSC_Periph, FunctionalState NewState);
Nvoid CSC_PeriphSTOPModeClock_Config (CSC_PeriphStopMode_TypeDef CSC_Periph, FunctionalState NewState);
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
SDRV_Return CSC_GetClockSourceState (uint32_t CLK_SEL);
SDRV_Return CSC_GetMainSwitchState (CSC_MAIN_MUX_STA_TypeDef MAIN_MUX_STA);
SDRV_Return CSC_GetHsSwitchState (CSC_HS_MUX_STA_TypeDef HS_MUX_STA);
SDRV_Return CSC_GetLsSwitchState (CSC_LS_MUX_STA_TypeDef LS_MUX_STA);
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
SDRV_Return CSC_GetHS2SwitchState (CSC_HS_MUX_STA_TypeDef HS2_MUX_STA);
SDRV_Return CSC_GetPLLISwitchState (CSC_PLLI_MUX_STA_TypeDef PLLI_MUX_STA);
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
Svoid CSC_CK_USB_Divider_Select (CSC_USB_SIE_DIV_TypeDef CSC_USB_SIE_DIVS);
Svoid CSC_CK_USB_ClockSource_Select (CSC_USB_CKSS_TypeDef CSC_USB_CKS);
N#endif
N
Nuint32_t CSC_GetAllFlagStatus (void);
NDRV_Return CSC_GetSingleFlagStatus (uint32_t CSC_ITSrc);
Nvoid CSC_ClearFlag (uint32_t CSC_ITSrc);
Nvoid CSC_IT_Config (uint32_t CSC_ITSrc, FunctionalState NewState);
Nvoid CSC_ITEA_Cmd (FunctionalState NewState);
N
N
N#endif  // _MG32x02z_CSC_DRV_H
N
L 42 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_EXIC_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_EXIC_DRV.h" 1
N
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EXIC_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the EXIC
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.12
N * @date        2021/04/21
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */
N
N#ifndef __MG32x02z_EXIC_DRV_H
N#define __MG32x02z_EXIC_DRV_H
N
N
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z__ExtraStruct.h"
N#include "MG32x02z_EXIC.h" 
N
N
N
N///@{
N
N#define EXIC_PA_IT          EXIC_INT_PA_IEA_mask_w                                      /*!< External trigger interrupt flag Control Definitions */
N#define EXIC_PB_IT          EXIC_INT_PB_IEA_mask_w                                      /*!< External trigger interrupt flag Control Definitions */
N#define EXIC_PC_IT          EXIC_INT_PC_IEA_mask_w                                      /*!< External trigger interrupt flag Control Definitions */
N#define EXIC_PD_IT          EXIC_INT_PD_IEA_mask_w                                      /*!< External trigger interrupt flag Control Definitions */
N#if defined(EXIC_PE_Base)
X#if 0L
S#define EXIC_PE_IT          EXIC_INT_PE_IEA_mask_w                                      /*!< External trigger interrupt flag Control Definitions */ 
N#endif
N
N#define EXIC_PX_AF          EXIC_STA_PA_AF_mask_b0              /*!< Byte of PX_AF mask */                
N#define EXIC_PX_OF          EXIC_STA_PA_OF_mask_b0              /*!< Byte of PX_OF mask */                  
N#define EXIC_PX_ITF_Mask    EXIC_PX_AF | EXIC_PX_OF             /*!< Byte of EXIC PX interrupt flag mask */
N#define EXIC_PX_ITF_Shift   4
N
N#define EXIC_TRGS_PIN0      0x00000001      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN1      0x00000004      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN2      0x00000010      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN3      0x00000040      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN4      0x00000100      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN5      0x00000400      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN6      0x00001000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN7      0x00004000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN8      0x00010000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN9      0x00040000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN10     0x00100000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN11     0x00400000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN12     0x01000000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN13     0x04000000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN14     0x10000000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_PIN15     0x40000000      /*!< External trigger mode of pin Control Definitions */
N#define EXIC_TRGS_ALL       0x55555555      /*!< External trigger mode of pin Control Definitions */
N                              
N#define EXIC_PX_PIN0        0x0001          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN1        0x0002          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN2        0x0004          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN3        0x0008          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN4        0x0010          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN5        0x0020          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN6        0x0040          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN7        0x0080          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN8        0x0100          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN9        0x0200          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN10       0x0400          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN11       0x0800          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN12       0x1000          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN13       0x2000          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN14       0x4000          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_PIN15       0x8000          /*!< External trigger Pin Control Definitions */
N#define EXIC_PX_AllPIN      0xFFFF          /*!< External trigger Pin Control Definitions */
N
N#define EXIC_ID_ADR_Base    0x50000060
N#define EXIC_ID_MAX         32
N
N
N
N/**
N *******************************************************************************
N * @brief  Read interrupt source-0 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID0_SOURCE()           (EXIC->SRC0.B[0])      /*!< Get Interrupt 0  identity.*/    
N/**
N *******************************************************************************
N * @brief  Read interrupt source-1 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID1_SOURCE()           (EXIC->SRC0.B[1])      /*!< Get Interrupt 1  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-2 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID2_SOURCE()           (EXIC->SRC0.B[2])      /*!< Get Interrupt 2  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-3 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID3_SOURCE()           (EXIC->SRC0.B[3])      /*!< Get Interrupt 3  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-4 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID4_SOURCE()           (EXIC->SRC1.B[0])      /*!< Get Interrupt 4  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-5 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID5_SOURCE()           (EXIC->SRC1.B[1])      /*!< Get Interrupt 5  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-6 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID6_SOURCE()           (EXIC->SRC1.B[2])      /*!< Get Interrupt 6  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-7 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID7_SOURCE()           (EXIC->SRC1.B[3])      /*!< Get Interrupt 7  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-8 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID8_SOURCE()           (EXIC->SRC2.B[0])      /*!< Get Interrupt 8  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-9 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID9_SOURCE()           (EXIC->SRC2.B[1])      /*!< Get Interrupt 9  identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-10 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID10_SOURCE()          (EXIC->SRC2.B[2])      /*!< Get Interrupt 10 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-11 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID11_SOURCE()          (EXIC->SRC2.B[3])      /*!< Get Interrupt 11 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-12 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID12_SOURCE()          (EXIC->SRC3.B[0])      /*!< Get Interrupt 12 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-13 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID13_SOURCE()          (EXIC->SRC3.B[1])      /*!< Get Interrupt 13 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-14 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID14_SOURCE()          (EXIC->SRC3.B[2])      /*!< Get Interrupt 14 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-15 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID15_SOURCE()          (EXIC->SRC3.B[3])      /*!< Get Interrupt 15 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-16 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID16_SOURCE()          (EXIC->SRC4.B[0])      /*!< Get Interrupt 16 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-17 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID17_SOURCE()          (EXIC->SRC4.B[1])      /*!< Get Interrupt 17 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-18 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID18_SOURCE()          (EXIC->SRC4.B[2])      /*!< Get Interrupt 18 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-19 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID19_SOURCE()          (EXIC->SRC4.B[3])      /*!< Get Interrupt 19 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-20 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID20_SOURCE()          (EXIC->SRC5.B[0])      /*!< Get Interrupt 20 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-21 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID21_SOURCE()          (EXIC->SRC5.B[1])      /*!< Get Interrupt 21 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-22 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID22_SOURCE()          (EXIC->SRC5.B[2])      /*!< Get Interrupt 22 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-23 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID23_SOURCE()          (EXIC->SRC5.B[3])      /*!< Get Interrupt 23 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-24 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID24_SOURCE()          (EXIC->SRC6.B[0])      /*!< Get Interrupt 24 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-25 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID25_SOURCE()          (EXIC->SRC6.B[1])      /*!< Get Interrupt 25 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-26 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID26_SOURCE()          (EXIC->SRC6.B[2])      /*!< Get Interrupt 26 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-27 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID27_SOURCE()          (EXIC->SRC6.B[3])      /*!< Get Interrupt 27 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-28 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID28_SOURCE()          (EXIC->SRC7.B[0])      /*!< Get Interrupt 28 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-29 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID29_SOURCE()          (EXIC->SRC7.B[1])      /*!< Get Interrupt 29 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-30 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID30_SOURCE()          (EXIC->SRC7.B[2])      /*!< Get Interrupt 30 identity.*/
N/**
N *******************************************************************************
N * @brief  Read interrupt source-31 identity.
N * @return No
N *******************************************************************************
N */
N#define __DRV_EXIC_GET_ID31_SOURCE()          (EXIC->SRC7.B[3])      /*!< Get Interrupt 31 identity.*/
N
N
N
N
N///@}
N
N
N/*! @enum   EXIC_TRGSMode_Typedef
N    @brief  External pin edge / level trigger event select definitions.
N*/
Ntypedef enum
N{
N	No_UpData_Flag  =   0,                  /*!< No external trgger function */
N    Level           =   1,                  /*!< External trigger event is level*/ 
N    Edge            =   2,                  /*!< External trigger event is edge*/
N    Dual_edge       =   3                   /*!< External trigger event is dual edge*/
N}EXIC_TRGSMode_Typedef;                              
N
N
N/*! @enum   EXIC_ITFlag_Typdef
N    @brief  Read / Clear interrupt flag of Port select definitions.
N*/
Ntypedef enum
N{
N    EXIC_PA_ITF    = 0,                     /*!< PortA*/                                               
N    EXIC_PB_ITF    = 1,                     /*!< PortB*/
N    EXIC_PC_ITF    = 2,                     /*!< PortC*/                    
N    EXIC_PD_ITF    = 3,                     /*!< PortD*/
N    #if defined(EXIC_PE_Base)
X    #if 0L
S        EXIC_PE_ITF    = 4,                 /*!< PortE*/
N    #endif
N}EXIC_ITFlag_Typdef;
N
N
N#if defined(EXIC_CR0_NMI_SEL_mask_w) && defined(EXIC_CR0_NMI_MUX_mask_w)
X#if 0L && 0L
S/** 
S * @enum	EXIC_NMIMUX_Typedef
S * @brief	Control NIM trigger source select.
S */
Stypedef enum
S{
S    EXIC_NMI_WWDT       = 0x00000000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from WWDT */
S    EXIC_NMI_SYS        = 0x00000400 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from SYS */
S    EXIC_NMI_EXIN0      = 0x00000C00 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from EXINT0 */
S    EXIC_NMI_EXIN1      = 0x00001000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from EXINT1 */
S    EXIC_NMI_EXIN2      = 0x00001400 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from EXINT2 */
S    EXIC_NMI_EXIN3      = 0x00001800 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from EXINT3 */
S    EXIC_NMI_COMP       = 0x00001C00 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from COMP */
S    EXIC_NMI_DMA        = 0x00002000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from DMA */
S    EXIC_NMI_ADC        = 0x00002800 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from ADC */
S    EXIC_NMI_DAC        = 0x00002C00 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from DAC */
S    EXIC_NMI_TM00       = 0x00003000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from TM00 */
S    EXIC_NMI_TM10       = 0x00003400 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from TM10 */
S    EXIC_NMI_TM16       = 0x00003800 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from TM16 */
S    EXIC_NMI_TM20       = 0x00003C00 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from TM20 */
S    EXIC_NMI_TM26       = 0x00004000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from TM26 */
S    EXIC_NMI_TM36       = 0x00004400 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from TM36 */
S    EXIC_NMI_URT0       = 0x00005000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from URT0 */
S    EXIC_NMI_URT123     = 0x00005400 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from URT123 */
S    EXIC_NMI_SPI0       = 0x00006000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from SPI0 */
S    EXIC_NMI_I2C0       = 0x00007000 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from I2C0 */
S    EXIC_NMI_I2Cx       = 0x00007400 | EXIC_CR0_NMI_SEL_mask_w,    /*!< Trigger NMI source from I2Cx */
S    EXIC_NMI_NMI        = 0x00000000,
S}EXIC_NMIMUX_Typedef;
N#endif
N
N/** 
N * @struct	EXIC_TRGSTypeDef
N * @brief	Control external pin event flag.
N */
Ntypedef struct	
N{
N	uint32_t                  	EXIC_Pin;           /*!< Select external trigger pin.*/
N	EXIC_TRGSMode_Typedef       EXIC_TRGS_Mode;     /*!< Select external trigger mode.*/
N}EXIC_TRGSTypeDef;
N
N
N
N
N
Nvoid EXIC_PxTriggerITEA_Cmd(uint32_t EXIC_PX_IT, FunctionalState EXIC_IT_State);
Nuint16_t EXIC_GetPxAllTriggerEventFlagStatus(EXIC_PX_Struct* EXIC_PX);
Nuint8_t EXIC_GetPxAllTriggerITFlagStatus( EXIC_ITFlag_Typdef EXIC_PX_ITFlag);
NDRV_Return EXIC_GetPinxTriggerEventSingleFlagStatus(EXIC_PX_Struct* EXIC_PX , uint16_t EXIC_Pin_PF);
NDRV_Return EXIC_GetPxTriggerAndITFlagStatus( EXIC_ITFlag_Typdef EXIC_PX_ITFlag);
NDRV_Return EXIC_GetPxTriggerOrITFlagStatus( EXIC_ITFlag_Typdef EXIC_PX_ITFlag);
Nvoid EXIC_ClearPxTriggerEventFlag(EXIC_PX_Struct* EXIC_PX , uint16_t EXIC_Pin_PF);
Nvoid EXIC_ClearPxTriggerITFlag( EXIC_ITFlag_Typdef EXIC_PX , uint8_t EXIC_PX_ITFlag);
NDRV_Return EXIC_PxTriggerMode_Select(EXIC_PX_Struct* EXIC_PX ,EXIC_TRGSTypeDef* EXIC_PX_TRGS );
Nvoid EXIC_PxTriggerAndMask_Select(EXIC_PX_Struct* EXIC_PX , uint16_t  EXIC_MSK_PIN);
Nvoid EXIC_PxTriggerOrMask_Select(EXIC_PX_Struct* EXIC_PX , uint16_t  EXIC_MSK_PIN);
Nvoid EXIC_PxTriggerAndUnmatch_Cmd(uint32_t EXIC_PX_IT, FunctionalState PX_unMatch_Cmd);
Nuint8_t EXIC_GetITSourceID(IRQn_Type ITSourceNum);
Nvoid EXIC_RXEV_Cmd(FunctionalState RXEV_State);
Nvoid EXIC_NMI_Cmd(FunctionalState NMI_State);
Nvoid EXIC_NMITrigger_SW(void);
N#if defined(EXIC_CR0_NMI_SEL_mask_w) && defined(EXIC_CR0_NMI_MUX_mask_w)
X#if 0L && 0L
S    void EXIC_NMI_Select(EXIC_NMIMUX_Typedef);
N#endif
N
N
N#endif
N
N
N
N
N
N
N
N
L 43 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_GPIO_DRV.h"
N#include "MG32x02z_GPL_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_GPL_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_GPL_DRV.h
N *
N * @brief       This is the C code format driver head file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.15
N * @date        2019/05/13
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer 
N *      The Demo software is provided "AS IS"  without any warranty, either 
N *      expressed or implied, including, but not limited to, the implied warranties 
N *      of merchantability and fitness for a particular purpose.  The author will 
N *      not be liable for any special, incidental, consequential or indirect 
N *      damages due to loss of data or any other reason. 
N *      These statements agree with the world wide and local dictated laws about 
N *      authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N
N#ifndef __MG32x02z_GPL_DRV_H
N#define __MG32x02z_GPL_DRV_H
N//#define _MG32x02z_GPL_DRV_H_VER                            0.01
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_GPL.h" 
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_GPL.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_GPL.h
N *
N * @brief       MG32x02z GPL Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_GPL_H
N#define _MG32x02z_GPL_H
N#define _MG32x02z_GPL_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_GPL_H_VER)
S    #error "MG32x02z_GPL_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      GPL_Struct
N *              GPL  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t  PAR8_OUT      :4;     //[11..8] GPL 8-bit data parity check output.
X            volatile const  uint8_t  PAR8_OUT      :4;     
N            __I  uint8_t  PAR16_OUT     :2;     //[13..12] GPL 16-bit data parity check output.
X            volatile const  uint8_t  PAR16_OUT     :2;     
N            __I  uint8_t  PAR32_OUT     :1;     //[14] GPL 32-bit data parity check output.
X            volatile const  uint8_t  PAR32_OUT     :1;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  GPL status register */
N
N    __I uint32_t  RESERVED0[3];         /*!< RESERVED0  ~ Offset[0x04]  Reserved */
X    volatile const uint32_t  RESERVED0[3];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BEND_EN       :1;     //[1] Data byte big/little endian change mode enable
X            volatile uint8_t  BEND_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BREV_MDS      :2;     //[3..2] Data bit order reverse change mode select
X            volatile uint8_t  BREV_MDS      :2;     
N                                        //0x0 = Disable
N                                        //0x1 = 8bit : 8-bit range bit order reverse
N                                        //0x2 = 16bit : 16-bit range bit order reverse
N                                        //0x3 = 32bit : 32-bit range bit order reverse
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IN_INV        :1;     //[6] Inverse input data enable.
X            volatile uint8_t  IN_INV        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  PAR_POL       :1;     //[10] Data parity check polarity select.
X            volatile uint8_t  PAR_POL       :1;     
N                                        //0 = Even
N                                        //1 = Odd
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :1;     //[30] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  DMA_EN        :1;     //[31] Direct memory access enable bit
X            volatile uint8_t  DMA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  GPL control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CRC_EN        :1;     //[0] CRC function enable bit.
X            volatile uint8_t  CRC_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CRC_MDS       :2;     //[3..2] CRC mode select.
X            volatile uint8_t  CRC_MDS       :2;     
N                                        //0x0 = CCITT16 : polynomial 0x1021
N                                        //0x1 = CRC8 : polynomial 0x07
N                                        //0x2 = CRC16 : polynomial 0x8005
N                                        //0x3 = CRC32 : polynomial 0x4C11DB7
N            __IO uint8_t  CRC_DSIZE     :2;     //[5..4] CRC operation data size
X            volatile uint8_t  CRC_DSIZE     :2;     
N                                        //0x0 = 8bit
N                                        //0x1 = 16bit
N                                        //0x2 = 32bit
N                                        //0x3 = Reserved
N            __IO uint8_t  CRC_BREV      :2;     //[7..6] CRC data output bit order reverse change mode select.
X            volatile uint8_t  CRC_BREV      :2;     
N                                        //0x0 = Disable
N                                        //0x1 = 8bit : 8-bit range bit order reverse
N                                        //0x2 = 16bit : 16-bit range bit order reverse
N                                        //0x3 = 32bit : 32-bit range bit order reverse
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  GPL control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t DIN           :32;    //[31..0] GPL data input register
X            volatile uint32_t DIN           :32;    
N        }MBIT;
N    }DIN;                               /*!< DIN        ~ Offset[0x18]  GPL data input register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t DOUT          :32;    //[31..0] GPL data output register.
X            volatile const  uint32_t DOUT          :32;    
N        }MBIT;
N    }DOUT;                              /*!< DOUT       ~ Offset[0x1C]  GPL data output register */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x20]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CRC_INIT      :32;    //[31..0] Programmable initial CRC value
X            volatile uint32_t CRC_INIT      :32;    
N        }MBIT;
N    }CRCINIT;                           /*!< CRCINIT    ~ Offset[0x24]  GPL CRC initial register */
N
N} GPL_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        GPL  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define GPL_Base                        ((uint32_t)0x4B000000)              /*!< General Purpose Logic Control */
N#define GPL                             ((GPL_Struct*) GPL_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        GPL  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        GPL_STA  [register's definitions]
N *              Offset[0x00]  GPL status register (0x4B000000)
N ******************************************************************************
N */
N///@{
N#define GPL_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of GPL_STA */
N#define GPL_STA_PAR32_OUT_mask_w                    ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define GPL_STA_PAR32_OUT_mask_h0                   ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define GPL_STA_PAR32_OUT_mask_b1                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define GPL_STA_PAR32_OUT_shift_w                   (14)                    /*!< Bit Shift of 32bit */
N#define GPL_STA_PAR32_OUT_shift_h0                  (14)                    /*!< Bit Shift of 16bit */
N#define GPL_STA_PAR32_OUT_shift_b1                  (6)                     /*!< Bit Shift of 8bit */
N
N#define GPL_STA_PAR16_OUT_mask_w                    ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define GPL_STA_PAR16_OUT_mask_h0                   ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define GPL_STA_PAR16_OUT_mask_b1                   ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define GPL_STA_PAR16_OUT_shift_w                   (12)                    /*!< Bit Shift of 32bit */
N#define GPL_STA_PAR16_OUT_shift_h0                  (12)                    /*!< Bit Shift of 16bit */
N#define GPL_STA_PAR16_OUT_shift_b1                  (4)                     /*!< Bit Shift of 8bit */
N
N#define GPL_STA_PAR8_OUT_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define GPL_STA_PAR8_OUT_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define GPL_STA_PAR8_OUT_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define GPL_STA_PAR8_OUT_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define GPL_STA_PAR8_OUT_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define GPL_STA_PAR8_OUT_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        GPL_CR0  [register's definitions]
N *              Offset[0x10]  GPL control register 0 (0x4B000010)
N ******************************************************************************
N */
N///@{
N#define GPL_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of GPL_CR0 */
N#define GPL_CR0_DMA_EN_mask_w                       ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define GPL_CR0_DMA_EN_mask_h1                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define GPL_CR0_DMA_EN_mask_b3                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define GPL_CR0_DMA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define GPL_CR0_DMA_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define GPL_CR0_DMA_EN_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define GPL_CR0_DMA_EN_enable_w                     ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define GPL_CR0_DMA_EN_enable_h1                    ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define GPL_CR0_DMA_EN_enable_b3                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define GPL_CR0_PAR_POL_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define GPL_CR0_PAR_POL_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define GPL_CR0_PAR_POL_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define GPL_CR0_PAR_POL_even_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Even of 32bit */
N#define GPL_CR0_PAR_POL_even_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Even of 16bit */
N#define GPL_CR0_PAR_POL_even_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Even of 8bit */
N#define GPL_CR0_PAR_POL_odd_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(1):Odd of 32bit */
N#define GPL_CR0_PAR_POL_odd_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(1):Odd of 16bit */
N#define GPL_CR0_PAR_POL_odd_b1                      ((uint8_t )0x04)        /*!< Bit Value =(1):Odd of 8bit */
N
N#define GPL_CR0_IN_INV_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define GPL_CR0_IN_INV_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define GPL_CR0_IN_INV_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define GPL_CR0_IN_INV_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define GPL_CR0_IN_INV_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define GPL_CR0_IN_INV_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define GPL_CR0_IN_INV_enable_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define GPL_CR0_IN_INV_enable_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define GPL_CR0_IN_INV_enable_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define GPL_CR0_BREV_MDS_mask_w                     ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define GPL_CR0_BREV_MDS_mask_h0                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define GPL_CR0_BREV_MDS_mask_b0                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define GPL_CR0_BREV_MDS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define GPL_CR0_BREV_MDS_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define GPL_CR0_BREV_MDS_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define GPL_CR0_BREV_MDS_8bit_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):8bit of 32bit */
N#define GPL_CR0_BREV_MDS_8bit_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(0x1):8bit of 16bit */
N#define GPL_CR0_BREV_MDS_8bit_b0                    ((uint8_t )0x04)        /*!< Bit Value =(0x1):8bit of 8bit */
N#define GPL_CR0_BREV_MDS_16bit_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):16bit of 32bit */
N#define GPL_CR0_BREV_MDS_16bit_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(0x2):16bit of 16bit */
N#define GPL_CR0_BREV_MDS_16bit_b0                   ((uint8_t )0x08)        /*!< Bit Value =(0x2):16bit of 8bit */
N#define GPL_CR0_BREV_MDS_32bit_w                    ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):32bit of 32bit */
N#define GPL_CR0_BREV_MDS_32bit_h0                   ((uint16_t)0x000C)      /*!< Bit Value =(0x3):32bit of 16bit */
N#define GPL_CR0_BREV_MDS_32bit_b0                   ((uint8_t )0x0C)        /*!< Bit Value =(0x3):32bit of 8bit */
N
N#define GPL_CR0_BEND_EN_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define GPL_CR0_BEND_EN_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define GPL_CR0_BEND_EN_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define GPL_CR0_BEND_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define GPL_CR0_BEND_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define GPL_CR0_BEND_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define GPL_CR0_BEND_EN_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define GPL_CR0_BEND_EN_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define GPL_CR0_BEND_EN_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        GPL_CR1  [register's definitions]
N *              Offset[0x14]  GPL control register 1 (0x4B000014)
N ******************************************************************************
N */
N///@{
N#define GPL_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of GPL_CR1 */
N#define GPL_CR1_CRC_BREV_mask_w                     ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define GPL_CR1_CRC_BREV_mask_h0                    ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define GPL_CR1_CRC_BREV_mask_b0                    ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define GPL_CR1_CRC_BREV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define GPL_CR1_CRC_BREV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define GPL_CR1_CRC_BREV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define GPL_CR1_CRC_BREV_8bit_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):8bit of 32bit */
N#define GPL_CR1_CRC_BREV_8bit_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(0x1):8bit of 16bit */
N#define GPL_CR1_CRC_BREV_8bit_b0                    ((uint8_t )0x40)        /*!< Bit Value =(0x1):8bit of 8bit */
N#define GPL_CR1_CRC_BREV_16bit_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):16bit of 32bit */
N#define GPL_CR1_CRC_BREV_16bit_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(0x2):16bit of 16bit */
N#define GPL_CR1_CRC_BREV_16bit_b0                   ((uint8_t )0x80)        /*!< Bit Value =(0x2):16bit of 8bit */
N#define GPL_CR1_CRC_BREV_32bit_w                    ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):32bit of 32bit */
N#define GPL_CR1_CRC_BREV_32bit_h0                   ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):32bit of 16bit */
N#define GPL_CR1_CRC_BREV_32bit_b0                   ((uint8_t )0xC0)        /*!< Bit Value =(0x3):32bit of 8bit */
N
N#define GPL_CR1_CRC_DSIZE_mask_w                    ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define GPL_CR1_CRC_DSIZE_mask_h0                   ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define GPL_CR1_CRC_DSIZE_mask_b0                   ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define GPL_CR1_CRC_DSIZE_8bit_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):8bit of 32bit */
N#define GPL_CR1_CRC_DSIZE_8bit_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):8bit of 16bit */
N#define GPL_CR1_CRC_DSIZE_8bit_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):8bit of 8bit */
N#define GPL_CR1_CRC_DSIZE_16bit_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):16bit of 32bit */
N#define GPL_CR1_CRC_DSIZE_16bit_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(0x1):16bit of 16bit */
N#define GPL_CR1_CRC_DSIZE_16bit_b0                  ((uint8_t )0x10)        /*!< Bit Value =(0x1):16bit of 8bit */
N#define GPL_CR1_CRC_DSIZE_32bit_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):32bit of 32bit */
N#define GPL_CR1_CRC_DSIZE_32bit_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(0x2):32bit of 16bit */
N#define GPL_CR1_CRC_DSIZE_32bit_b0                  ((uint8_t )0x20)        /*!< Bit Value =(0x2):32bit of 8bit */
N
N#define GPL_CR1_CRC_MDS_mask_w                      ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define GPL_CR1_CRC_MDS_mask_h0                     ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define GPL_CR1_CRC_MDS_mask_b0                     ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define GPL_CR1_CRC_MDS_ccitt16_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CCITT16 of 32bit */
N#define GPL_CR1_CRC_MDS_ccitt16_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CCITT16 of 16bit */
N#define GPL_CR1_CRC_MDS_ccitt16_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):CCITT16 of 8bit */
N#define GPL_CR1_CRC_MDS_crc8_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):CRC8 of 32bit */
N#define GPL_CR1_CRC_MDS_crc8_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CRC8 of 16bit */
N#define GPL_CR1_CRC_MDS_crc8_b0                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):CRC8 of 8bit */
N#define GPL_CR1_CRC_MDS_crc16_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):CRC16 of 32bit */
N#define GPL_CR1_CRC_MDS_crc16_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(0x2):CRC16 of 16bit */
N#define GPL_CR1_CRC_MDS_crc16_b0                    ((uint8_t )0x08)        /*!< Bit Value =(0x2):CRC16 of 8bit */
N#define GPL_CR1_CRC_MDS_crc32_w                     ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):CRC32 of 32bit */
N#define GPL_CR1_CRC_MDS_crc32_h0                    ((uint16_t)0x000C)      /*!< Bit Value =(0x3):CRC32 of 16bit */
N#define GPL_CR1_CRC_MDS_crc32_b0                    ((uint8_t )0x0C)        /*!< Bit Value =(0x3):CRC32 of 8bit */
N
N#define GPL_CR1_CRC_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define GPL_CR1_CRC_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define GPL_CR1_CRC_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define GPL_CR1_CRC_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define GPL_CR1_CRC_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define GPL_CR1_CRC_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define GPL_CR1_CRC_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define GPL_CR1_CRC_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define GPL_CR1_CRC_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        GPL_DIN  [register's definitions]
N *              Offset[0x18]  GPL data input register (0x4B000018)
N ******************************************************************************
N */
N///@{
N#define GPL_DIN_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of GPL_DIN */
N#define GPL_DIN_DIN_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define GPL_DIN_DIN_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define GPL_DIN_DIN_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define GPL_DIN_DIN_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        GPL_DOUT  [register's definitions]
N *              Offset[0x1C]  GPL data output register (0x4B00001C)
N ******************************************************************************
N */
N///@{
N#define GPL_DOUT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of GPL_DOUT */
N#define GPL_DOUT_DOUT_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define GPL_DOUT_DOUT_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define GPL_DOUT_DOUT_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define GPL_DOUT_DOUT_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        GPL_CRCINIT  [register's definitions]
N *              Offset[0x24]  GPL CRC initial register (0x4B000024)
N ******************************************************************************
N */
N///@{
N#define GPL_CRCINIT_default                         ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of GPL_CRCINIT */
N#define GPL_CRCINIT_CRC_INIT_mask_w                 ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define GPL_CRCINIT_CRC_INIT_shift_w                (0)                     /*!< Bit Shift of 32bit */
N#define GPL_CRCINIT_CRC_INIT_shift_h0               (0)                     /*!< Bit Shift of 16bit */
N#define GPL_CRCINIT_CRC_INIT_shift_b0               (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_GPL_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_GPL.h                         */
N/*----------------------------------------------------------------------------*/
L 42 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_GPL_DRV.h" 2
N
N/** 
N * @name    Parity
N *
N */ 
N///@{ 
N
N/**
N  * @brief  Parity Setting
N  */
N
N#define GPL_PARITY_MASK          GPL_CR0_PAR_POL_mask_b1
N#define GPL_PARITY_EVEN          GPL_CR0_PAR_POL_even_b1
N#define GPL_PARITY_ODD           GPL_CR0_PAR_POL_odd_b1
N#define IS_GPL_PARITY(SELECT) (((SELECT) == GPL_PARITY_MASK) || \
N                               ((SELECT) == GPL_PARITY_EVEN) || \
N                               ((SELECT) == GPL_PARITY_ODD))
X#define IS_GPL_PARITY(SELECT) (((SELECT) == GPL_PARITY_MASK) ||                                ((SELECT) == GPL_PARITY_EVEN) ||                                ((SELECT) == GPL_PARITY_ODD))
N
N
N
N/** @brief  Parity Output
N  */
N
N#define GPL_FLAG_MASK               (GPL_STA_PAR32_OUT_mask_w | GPL_STA_PAR16_OUT_mask_w | GPL_STA_PAR8_OUT_mask_w)
N#define GPL_FLAG_PARITY32           GPL_STA_PAR32_OUT_mask_w
N#define GPL_FLAG_PARITY16_ALL       GPL_STA_PAR16_OUT_mask_w
N#define GPL_FLAG_PARITY16_LOW       0x00010000 
N#define GPL_FLAG_PARITY16_HIGH      0x00020000
N#define GPL_FLAG_PARITY8_ALL        GPL_STA_PAR8_OUT_mask_w
N#define GPL_FLAG_PARITY8_BYTE_0     0x00000100
N#define GPL_FLAG_PARITY8_BYTE_1     0x00000200
N#define GPL_FLAG_PARITY8_BYTE_2     0x00000400
N#define GPL_FLAG_PARITY8_BYTE_3     0x00000800
N#define IS_GPL_FLAG(FLAG) (((FLAG) == GPL_FLAG_MASK) || \
N                           ((FLAG) == GPL_FLAG_PARITY32) || \
N                           ((FLAG) == GPL_FLAG_PARITY16_ALL) || \
N                           ((FLAG) == GPL_FLAG_PARITY16_LOW) || \
N                           ((FLAG) == GPL_FLAG_PARITY16_HIGH) || \
N                           ((FLAG) == GPL_FLAG_PARITY8_ALL) || \
N                           ((FLAG) == GPL_FLAG_PARITY8_BYTE_0) || \
N                           ((FLAG) == GPL_FLAG_PARITY8_BYTE_1) || \
N                           ((FLAG) == GPL_FLAG_PARITY8_BYTE_2) || \
N                           ((FLAG) == GPL_FLAG_PARITY8_BYTE_3))
X#define IS_GPL_FLAG(FLAG) (((FLAG) == GPL_FLAG_MASK) ||                            ((FLAG) == GPL_FLAG_PARITY32) ||                            ((FLAG) == GPL_FLAG_PARITY16_ALL) ||                            ((FLAG) == GPL_FLAG_PARITY16_LOW) ||                            ((FLAG) == GPL_FLAG_PARITY16_HIGH) ||                            ((FLAG) == GPL_FLAG_PARITY8_ALL) ||                            ((FLAG) == GPL_FLAG_PARITY8_BYTE_0) ||                            ((FLAG) == GPL_FLAG_PARITY8_BYTE_1) ||                            ((FLAG) == GPL_FLAG_PARITY8_BYTE_2) ||                            ((FLAG) == GPL_FLAG_PARITY8_BYTE_3))
N///@}
N
N
N/** 
N * @name    INVERSE Data
N *
N */ 
N///@{
N
N/**
N  * @brief  Data INVERSE
N  */
N#define GPL_INVERSE_MASK            GPL_CR0_IN_INV_mask_b0
N#define GPL_INVERSE_DISABLE         GPL_CR0_IN_INV_disable_b0
N#define GPL_INVERSE_ENABLE          GPL_CR0_IN_INV_enable_b0
N#define IS_GPL_INVERSE(INVERSE) (((INVERSE) == GPL_INVERSE_MASK) || \
N                                 ((INVERSE) == GPL_INVERSE_DISABLE) || \
N                                 ((INVERSE) == GPL_INVERSE_ENABLE))
X#define IS_GPL_INVERSE(INVERSE) (((INVERSE) == GPL_INVERSE_MASK) ||                                  ((INVERSE) == GPL_INVERSE_DISABLE) ||                                  ((INVERSE) == GPL_INVERSE_ENABLE))
N///@}
N
N
N
N/** 
N * @name    Order for Byte
N *
N */ 
N///@{
N
N/**
N  * @brief  Byte Order
N  */
N#define GPL_BYTE_ORDER_CHANGE_MASK       GPL_CR0_BEND_EN_mask_b0
N#define GPL_BYTE_ORDER_CHANGE_DISABLE    GPL_CR0_BEND_EN_disable_b0
N#define GPL_BYTE_ORDER_CHANGE_ENABLE     GPL_CR0_BEND_EN_enable_b0
N#define IS_GPL_BYTE_ORDER_CHANGE(BYTE_ORDER) (((BYTE_ORDER) == GPL_BYTE_ORDER_CHANGE_MASK) || \
N                                              ((BYTE_ORDER) == GPL_BYTE_ORDER_CHANGE_DISABLE) || \
N                                              ((BYTE_ORDER) == GPL_BYTE_ORDER_CHANGE_ENABLE))
X#define IS_GPL_BYTE_ORDER_CHANGE(BYTE_ORDER) (((BYTE_ORDER) == GPL_BYTE_ORDER_CHANGE_MASK) ||                                               ((BYTE_ORDER) == GPL_BYTE_ORDER_CHANGE_DISABLE) ||                                               ((BYTE_ORDER) == GPL_BYTE_ORDER_CHANGE_ENABLE))
N
N/**
N  * @brief  16-Bits Byte Order
N  */
N#define GPL_16Bits_BYTE_ORDER_CHANGE_MASK       GPL_CR0_BEND16_EN_mask_b0
N#define GPL_16Bits_BYTE_ORDER_CHANGE_DISABLE    GPL_CR0_BEND16_EN_disable_b0
N#define GPL_16Bits_BYTE_ORDER_CHANGE_ENABLE     GPL_CR0_BEND16_EN_enable_b0
N#define IS_GPL_16Bits_BYTE_ORDER_CHANGE(BYTE_ORDER) (((BYTE_ORDER) == GPL_16Bits_BYTE_ORDER_CHANGE_MASK) || \
N                                                     ((BYTE_ORDER) == GPL_16Bits_BYTE_ORDER_CHANGE_DISABLE) || \
N                                                     ((BYTE_ORDER) == GPL_16Bits_BYTE_ORDER_CHANGE_ENABLE))
X#define IS_GPL_16Bits_BYTE_ORDER_CHANGE(BYTE_ORDER) (((BYTE_ORDER) == GPL_16Bits_BYTE_ORDER_CHANGE_MASK) ||                                                      ((BYTE_ORDER) == GPL_16Bits_BYTE_ORDER_CHANGE_DISABLE) ||                                                      ((BYTE_ORDER) == GPL_16Bits_BYTE_ORDER_CHANGE_ENABLE))
N
N/**
N  * @brief  Before Bit Order
N  */
N#define GPL_BEFORE_BIT_ORDER_MASK         GPL_CR0_BREV_MDS_mask_b0
N#define GPL_BEFORE_BIT_ORDER_DISABLE      GPL_CR0_BREV_MDS_disable_b0
N#define GPL_BEFORE_BIT_ORDER_8BITS        GPL_CR0_BREV_MDS_8bit_b0
N#define GPL_BEFORE_BIT_ORDER_16BITS       GPL_CR0_BREV_MDS_16bit_b0
N#define GPL_BEFORE_BIT_ORDER_32BITS       GPL_CR0_BREV_MDS_32bit_b0
N#define IS_GPL_BEFORE_BIT_ORDER(SELECT) (((SELECT) == GPL_BEFORE_BIT_ORDER_MASK) || \
N                                         ((SELECT) == GPL_BEFORE_BIT_ORDER_DISABLE) || \
N                                         ((SELECT) == GPL_BEFORE_BIT_ORDER_8BITS) || \
N                                         ((SELECT) == GPL_BEFORE_BIT_ORDER_16BITS) || \
N                                         ((SELECT) == GPL_BEFORE_BIT_ORDER_32BITS))
X#define IS_GPL_BEFORE_BIT_ORDER(SELECT) (((SELECT) == GPL_BEFORE_BIT_ORDER_MASK) ||                                          ((SELECT) == GPL_BEFORE_BIT_ORDER_DISABLE) ||                                          ((SELECT) == GPL_BEFORE_BIT_ORDER_8BITS) ||                                          ((SELECT) == GPL_BEFORE_BIT_ORDER_16BITS) ||                                          ((SELECT) == GPL_BEFORE_BIT_ORDER_32BITS))
N/**
N  * @brief  After Bit Order
N  */
N#define GPL_AFTER_BIT_ORDER_MASK         GPL_CR1_CRC_BREV_mask_b0
N#define GPL_AFTER_BIT_ORDER_DISABLE      GPL_CR1_CRC_BREV_disable_b0
N#define GPL_AFTER_BIT_ORDER_8BITS        GPL_CR1_CRC_BREV_8bit_b0
N#define GPL_AFTER_BIT_ORDER_16BITS       GPL_CR1_CRC_BREV_16bit_b0
N#define GPL_AFTER_BIT_ORDER_32BITS       GPL_CR1_CRC_BREV_32bit_b0
N#define IS_GPL_AFTER_BIT_ORDER(SELECT) (((SELECT) == AFTER_BIT_ORDER_MASK) || \
N                                        ((SELECT) == GPL_AFTER_BIT_ORDER_DISABLE) || \
N                                        ((SELECT) == GPL_AFTER_BIT_ORDER_8BITS) || \
N                                        ((SELECT) == GPL_AFTER_BIT_ORDER_16BITS) || \
N                                        ((SELECT) == GPL_AFTER_BIT_ORDER_32BITS))
X#define IS_GPL_AFTER_BIT_ORDER(SELECT) (((SELECT) == AFTER_BIT_ORDER_MASK) ||                                         ((SELECT) == GPL_AFTER_BIT_ORDER_DISABLE) ||                                         ((SELECT) == GPL_AFTER_BIT_ORDER_8BITS) ||                                         ((SELECT) == GPL_AFTER_BIT_ORDER_16BITS) ||                                         ((SELECT) == GPL_AFTER_BIT_ORDER_32BITS))
N
N///@}
N
N
N/** 
N * @name    CRC
N *
N */ 
N///@{
N
N/**
N  * @brief  CRC Mode
N  */
N#define GPL_CRC_MODE_MASK        GPL_CR1_CRC_MDS_mask_b0
N#define GPL_CRC_MODE_CCITT16     GPL_CR1_CRC_MDS_ccitt16_b0 /* 0x1021 */
N#define GPL_CRC_MODE_CRC8        GPL_CR1_CRC_MDS_crc8_b0    /* 0x07 */
N#define GPL_CRC_MODE_CRC16       GPL_CR1_CRC_MDS_crc16_b0   /* 0x8005 */
N#define GPL_CRC_MODE_CRC32       GPL_CR1_CRC_MDS_crc32_b0   /* 0x04C11DB7 */
N#define IS_GPL_CRC_MODE(SELECT) (((SELECT) == GPL_CRC_MODE_MASK) || \
N                                 ((SELECT) == GPL_CRC_MODE_CCITT16) || \
N                                 ((SELECT) == GPL_CRC_MODE_CRC8) || \
N                                 ((SELECT) == GPL_CRC_MODE_CRC16) || \
N                                 ((SELECT) == GPL_CRC_MODE_CRC32))
X#define IS_GPL_CRC_MODE(SELECT) (((SELECT) == GPL_CRC_MODE_MASK) ||                                  ((SELECT) == GPL_CRC_MODE_CCITT16) ||                                  ((SELECT) == GPL_CRC_MODE_CRC8) ||                                  ((SELECT) == GPL_CRC_MODE_CRC16) ||                                  ((SELECT) == GPL_CRC_MODE_CRC32))
N
N
N
N/**
N  * @brief  CRC Data Size
N  */
N#define GPL_CRC_DATA_SIZE_MASK       GPL_CR1_CRC_DSIZE_mask_b0
N#define GPL_CRC_DATA_SIZE_8BITS      GPL_CR1_CRC_DSIZE_8bit_b0
N#define GPL_CRC_DATA_SIZE_16BITS     GPL_CR1_CRC_DSIZE_16bit_b0
N#define GPL_CRC_DATA_SIZE_32BITS     GPL_CR1_CRC_DSIZE_32bit_b0
N#define IS_GPL_CRC_DATA_SIZE_SELECT(SELECT) (((SELECT) == GPL_CRC_DATA_SIZE_MASK) || \
N                                             ((SELECT) == GPL_CRC_DATA_SIZE_8BITS) || \
N                                             ((SELECT) == GPL_CRC_DATA_SIZE_16BITS) || \
N                                             ((SELECT) == GPL_CRC_DATA_SIZE_32BITS))
X#define IS_GPL_CRC_DATA_SIZE_SELECT(SELECT) (((SELECT) == GPL_CRC_DATA_SIZE_MASK) ||                                              ((SELECT) == GPL_CRC_DATA_SIZE_8BITS) ||                                              ((SELECT) == GPL_CRC_DATA_SIZE_16BITS) ||                                              ((SELECT) == GPL_CRC_DATA_SIZE_32BITS))
N
N/**
N  * @brief  CRC Enable / Disable
N  */
N#define GPL_CRC_MASK       GPL_CR1_CRC_EN_mask_b0
N#define GPL_CRC_DISABLE    GPL_CR1_CRC_EN_disable_b0
N#define GPL_CRC_ENABLE     GPL_CR1_CRC_EN_enable_b0
N#define IS_GPL_CRC(CRC) (((CRC) == GPL_CRC_MASK) || \
N                         ((CRC) == GPL_CRC_DISABLE) || \
N                         ((CRC) == GPL_CRC_ENABLE))
X#define IS_GPL_CRC(CRC) (((CRC) == GPL_CRC_MASK) ||                          ((CRC) == GPL_CRC_DISABLE) ||                          ((CRC) == GPL_CRC_ENABLE))
N
N///@}
N
N
N
N/**
N * @name    GPL DMA
N *          
N */ 
N///@{
N
N/**
N  * @brief  DMA Enable / Disable
N  */
N#define GPL_DMA_MASK       GPL_CR0_DMA_EN_mask_b3
N#define GPL_DMA_DISABLE    GPL_CR0_DMA_EN_disable_b3
N#define GPL_DMA_ENABLE     GPL_CR0_DMA_EN_enable_b3
N#define IS_GPL_DMA(CRC) (((CRC) == GPL_DMA_MASK) || \
N                         ((CRC) == GPL_DMA_DISABLE) || \
N                         ((CRC) == GPL_DMA_ENABLE))
X#define IS_GPL_DMA(CRC) (((CRC) == GPL_DMA_MASK) ||                          ((CRC) == GPL_DMA_DISABLE) ||                          ((CRC) == GPL_DMA_ENABLE))
N
N///@}
N
N
N
N/**
N * @name    Inverse
N *          Inverse Enable / Disable
N */ 
N///@{
N#define __GPL_Inverse_Enable()                                  (GPL->CR0.B[0] |= GPL_INVERSE_ENABLE)
N#define __GPL_Inverse_Disable()                                 (GPL->CR0.B[0] &= (~GPL_INVERSE_MASK))
Nvoid GPL_Inverse_Cmd(FunctionalState State);
N///@}
N
N/** 
N * @name    Parity
N *          Parity Setting 
N */ 
N///@{
N
N#define __GPL_ParityCheck_Select(Parity__)                      (GPL->CR0.B[1] = (GPL->CR0.B[1] & (~GPL_PARITY_MASK)) | (Parity__))
N#define __GPL_ParityCheck_Odd()                                 (GPL->CR0.B[1] |= GPL_PARITY_ODD)
N#define __GPL_ParityCheck_Even()                                (GPL->CR0.B[1] &= (~GPL_PARITY_MASK))
Nvoid GPL_ParityCheck_Select(uint32_t Parity);
N
N#define __GPL_GetParityCheckWord(Data__)                        (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR32)?1:0)
Nuint8_t GPL_GetParityCheckWord(uint32_t Data);
N
N#define __GPL_GetParityCheckHalfWord_High(Data__)               (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR_HighHalfWord)?1:0)
Nuint8_t GPL_GetParityCheckHalfWord_High(uint32_t Data);
N
N#define __GPL_GetParityCheckHalfWord_Low(Data__)                (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR_LowHalfWord)?1:0)
Nuint8_t GPL_GetParityCheckHalfWord_Low(uint32_t Data);
N
N#define __GPL_GetParityCheckHalfWord(Data__, HighLow__)         (GPL->DIN.W = (Data__); (HighLow__)?((GPL->STA.W & GPL_Flag_PAR_HighHalfWord)?1:0) : ((GPL->STA.W & GPL_Flag_PAR_LowHalfWord)?1:0))
Nuint8_t GPL_GetParityCheckHalfWord(uint32_t Data, uint16_t HalfWordX);
N
N#define __GPL_GetParityCheckByte_0(Data__)                      (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR_Byte0)?1:0)
Nuint8_t GPL_GetParityCheckByte_0(uint32_t Data);
N
N#define __GPL_GetParityCheckByte_1(Data__)                      (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR_Byte1)?1:0)
Nuint8_t GPL_GetParityCheckByte_1(uint32_t Data);
N
N#define __GPL_GetParityCheckByte_2(Data__)                      (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR_Byte2)?1:0)
Nuint8_t GPL_GetParityCheckByte_2(uint32_t Data);
N
N#define __GPL_GetParityCheckByte_3(Data__)                      (GPL->DIN.W = (Data__); (GPL->STA.W & GPL_Flag_PAR_Byte3)?1:0)
Nuint8_t GPL_GetParityCheckByte_3(uint32_t Data);
N
Nuint8_t GPL_GetParityCheckByte(uint32_t Data, uint8_t ByteX);
N
N///@}
N
N
N
N/**
N * @name    Inverse
N *          Inverse Enable / Disable
N */ 
N///@{
N#define __GPL_Inverse_Enable()                                  (GPL->CR0.B[0] |= GPL_INVERSE_ENABLE)
N#define __GPL_Inverse_Disable()                                 (GPL->CR0.B[0] &= (~GPL_INVERSE_MASK))
Nvoid GPL_Inverse_Cmd(FunctionalState State);
N///@}
N
N
N
N/**
N * @name    Order
N *          Order Setting
N */ 
N///@{
N#define __GPL_ByteOrderChange_Enable()                          (GPL->CR0.B[0] |= GPL_BYTE_ORDER_CHANGE_MASK)
N#define __GPL_ByteOrderChange_Disable()                         (GPL->CR0.B[0] &= (~GPL_BYTE_ORDER_CHANGE_MASK))
Nvoid GPL_ByteOrderChange_Cmd(FunctionalState State);
N
N#if !defined(MG32_1ST)
X#if !1L
S  #define __GPL_16BitsByteOrderChange_Enable()                  (GPL->CR0.B[0] |= GPL_16Bits_BYTE_ORDER_CHANGE_MASK)
S  #define __GPL_16BitsByteOrderChange_Disable()                 (GPL->CR0.B[0] &= (~GPL_16Bits_BYTE_ORDER_CHANGE_MASK))
S  void GPL_16BitsByteOrderChange_Cmd(FunctionalState State);
N#endif
N
N#define __GPL_BeforeBitOrderChange_Select(SELECT__)             (GPL->CR0.B[0] = (GPL->CR0.B[0] & (~GPL_BEFORE_BIT_ORDER_MASK)) | (SELECT__))
Nvoid GPL_BeforeBitOrderChange_Select(uint32_t Select);
N
N#define __GPL_AfterBitOrderChange_Select(SELECT__)              (GPL->CR1.B[0] = (GPL->CR1.W & (~GPL_AFTER_BIT_ORDER_MASK)) | (SELECT__))
Nvoid GPL_AfterBitOrderChange_Select(uint32_t Select);
N///@}
N
N
N
N/**
N * @name    CRC
N *          CRC Setting
N */ 
N///@{
N#define __GPL_CRC_Mode_Select(SELECT__)                         (GPL->CR1.B[0] = (GPL->CR1.B[0] & (~GPL_CRC_MODE_MASK)) | (SELECT__))
Nvoid GPL_CRC_Mode_Select(uint32_t Select);
N
N#define __GPL_CRC_Data_Size_Select(SELECT__)                    (GPL->CR1.B[0] = (GPL->CR1.W & (~GPL_CRC_DATA_SIZE_MASK)) | (SELECT__))
Nvoid GPL_CRC_Data_Size_Select(uint32_t Select);
N
N#define __GPL_CRC_SetInitialValue(VALUE__)                      (GPL->CRCINIT.W = (VALUE__))
Nvoid GPL_CRC_SetInitValue(uint32_t InitialValue);
N
N#define __GPL_CRC_Enable()                                      (GPL->CR1.B[0] |= GPL_CRC_MASK)
N#define __GPL_CRC_Disable()                                     (GPL->CR1.B[0] &= ~GPL_CRC_MASK)
Nvoid GPL_CRC_Cmd(FunctionalState State);
N///@}
N
N
N
N/**
N * @name    Data Input and Calculation Results Output.
N *          
N */ 
N///@{
N#define __GPL_DataInput(DATA__)                                 (GPL->DIN.W = (uint32_t)(DATA__))
Nvoid GPL_DataInput(uint32_t Data);
N
N#define __GPL_GetOutputData()                                   (GPL->DOUT.W)
Nuint32_t GPL_GetOutputData(void);
N///@}
N
N
N
N/**
N * @name    GPL DMA
N *          DMA Enable / Disable
N */ 
N///@{
N#define __GPL_DMA_Enable()                                      GPL->CR0.B[3] |= GPL_CR0_DMA_EN_mask_b3
N#define __GPL_DMA_Disable()                                     GPL->CR0.B[3] &= ~GPL_CR0_DMA_EN_mask_b3
Nvoid GPL_DMA_Cmd(FunctionalState State);
N///@}
N
N
N
N/**
N * @name    Flag
N *          Get and Clear Results Flag 
N */ 
N///@{
N#define __GPL_GetAllFlagStatus()                                (GPL->STA.W)
Nuint32_t GPL_GetAllFlagStatus(void);
N
N#define __GPL_GetFlagStatus(GPL_FLAG)                           ((GPL->STA.W & (GPL_FLAG)) == (GPL_FLAG))
NDRV_Return GPL_GetFlagStatus(uint32_t GPL_FLAG);
N
N#define __GPL_ClearFlag(GPL_FLAG)                               (GPL->STA.W = (GPL_FLAG))
Nvoid GPL_ClearFlag(uint32_t GPL_FLAG);
N///@}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 45 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_I2C_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_I2C_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_I2C_DRV.h
N *
N * @brief       This is the C code format driver head file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V2.21
N * @date        2019/11/25
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer 
N *      The Demo software is provided "AS IS"  without any warranty, either 
N *      expressed or implied, including, but not limited to, the implied warranties 
N *      of merchantability and fitness for a particular purpose.  The author will 
N *      not be liable for any special, incidental, consequential or indirect 
N *      damages due to loss of data or any other reason. 
N *      These statements agree with the world wide and local dictated laws about 
N *      authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */
N
N
N
N#ifndef __MG32x02z_I2C_DRV_H
N#define __MG32x02z_I2C_DRV_H
N//#define _MG32x02z_I2C_DRV_H_VER                            2.21
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_I2C.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_I2C.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_I2C.h
N *
N * @brief       MG32x02z I2C Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_I2C_H
N#define _MG32x02z_I2C_H
N#define _MG32x02z_I2C_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_I2C_H_VER)
S    #error "MG32x02z_I2C_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      I2C_Struct
N *              I2C  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  BUSYF         :1;     //[0] I2C busy flag. (set and clear by hardware)
X            volatile const  uint8_t  BUSYF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Busy (Event happened)
N            __IO uint8_t  EVENTF        :1;     //[1] I2C status event interrupt Flag
X            volatile uint8_t  EVENTF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  BUFF          :1;     //[2] I2C buffer mode event flag. (set by hardware , clear by software setting 1)
X            volatile uint8_t  BUFF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  ERRF          :1;     //[3] I2C error interrupt flag for invalid no ack, bus arbitration lost bus error or data o
X            volatile uint8_t  ERRF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TMOUTF        :1;     //[4] I2C time-out detect flag. (set and clear by hardware)
X            volatile uint8_t  TMOUTF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RXF           :1;     //[6] I2C Receive data register not empty
X            volatile uint8_t  RXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TXF           :1;     //[7] I2C Transmit data register empty
X            volatile uint8_t  TXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  RSTRF         :1;     //[8] I2C repeat start asserted flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  RSTRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  STOPF         :1;     //[9] I2C stop detection flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  STOPF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CNTF          :1;     //[10] I2C buffer count I2C_BUF_CNT empty status
X            volatile uint8_t  CNTF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  ERRCF         :1;     //[11] I2C master mode NACK error flag and state control bit
X            volatile uint8_t  ERRCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SADRF         :1;     //[12] I2C slave mode slave address matched flag
X            volatile uint8_t  SADRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  SLAF          :1;     //[13] I2C slave mode detection status.
X            volatile const  uint8_t  SLAF          :1;     
N            __I  uint8_t  MSTF          :1;     //[14] I2C master mode detection status. It set by Start command and clear by Stop state.
X            volatile const  uint8_t  MSTF          :1;     
N            __I  uint8_t  RWF           :1;     //[15] I2C read or write transfer direction status
X            volatile const  uint8_t  RWF           :1;     
N                                        //0 = Write
N                                        //1 = Read
N            __IO uint8_t  TSCF          :1;     //[16] I2C shadow buffer transfer complete flag
X            volatile uint8_t  TSCF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  STPSTRF       :1;     //[17] I2C Stop or Start detection flag.  (set by hardware and clear by software writing 1)
X            volatile uint8_t  STPSTRF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TXRF          :1;     //[18] I2C  transmit data register remained status
X            volatile uint8_t  TXRF          :1;     
N                                        //0 = No data
N                                        //1 = Remained data
N            __IO uint8_t  ROVRF         :1;     //[19] I2C data buffer receive overrun error flag
X            volatile uint8_t  ROVRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TOVRF         :1;     //[20] I2C data buffer transmit underrun error flag
X            volatile uint8_t  TOVRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  NACKF         :1;     //[21] I2C Not Acknowledge received error flag
X            volatile uint8_t  NACKF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  ALOSF         :1;     //[22] I2C bus arbitration lost error flag
X            volatile uint8_t  ALOSF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  BERRF         :1;     //[23] I2C bus error flag for invalid Stop/Start state
X            volatile uint8_t  BERRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  I2C status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] I2C interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EVENT_IE      :1;     //[1] I2C status event interrupt enable.
X            volatile uint8_t  EVENT_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BUF_IE        :1;     //[2] I2C buffer mode event Interrupt enable
X            volatile uint8_t  BUF_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ERR_IE        :1;     //[3] I2C no ack error, bus arbitration lost, bus error or data overrun interrupt enable.
X            volatile uint8_t  ERR_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TMOUT_IE      :1;     //[4] I2C timeout error interrupt enable.
X            volatile uint8_t  TMOUT_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[29..25] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  SCLF          :1;     //[30] I2C SCL line status bit.
X            volatile const  uint8_t  SCLF          :1;     
N            __I  uint8_t  SDAF          :1;     //[31] I2C SDA line status bit.
X            volatile const  uint8_t  SDAF          :1;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  I2C interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_SEL        :2;     //[3..2] I2C internal clock CK_I2C source select
X            volatile uint8_t  CK_SEL        :2;     
N                                        //0x0 = PROC : CK_I2C_PR process clock from CSC
N                                        //0x1 = Reserved
N                                        //0x2 = TM00_TRGO
N                                        //0x3 = Reserved
N            __IO uint8_t  CK_DIV        :3;     //[6..4] I2C internal clock CK_I2C_INT input divider
X            volatile uint8_t  CK_DIV        :3;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N                                        //0x5 = DIV32 : divided by 32
N                                        //0x6 = DIV64 : divided by 64
N                                        //0x7 = DIV128 : divided by 128
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CK_PSC        :3;     //[10..8] I2C internal clock CK_I2C_INT prescaler
X            volatile uint8_t  CK_PSC        :3;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TMO_CKS       :1;     //[12] I2C timeout clock source select.
X            volatile uint8_t  TMO_CKS       :1;     
N                                        //0 = CK_UT
N                                        //1 = DIV64 (CK_I2C_PSC divided by 64)
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  I2C clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  SA_RW         :1;     //[0] I2C slave mode grabbed read/write bit.
X            volatile const  uint8_t  SA_RW         :1;     
N            __I  uint8_t  SA_CODE       :7;     //[7..1] I2C slave mode grabbed slave address code
X            volatile const  uint8_t  SA_CODE       :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }SAC;                               /*!< SAC        ~ Offset[0x0C]  I2C slave mode slave address code register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] I2C function enable bit
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SADR_EN       :1;     //[1] I2C slave mode main slave address detect enable
X            volatile uint8_t  SADR_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SADR2_EN      :1;     //[2] I2C slave mode 2nd slave address detect enable
X            volatile uint8_t  SADR2_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MDS           :2;     //[5..4] I2C operation mode select. The monitor mode is only support for Buffer mode.
X            volatile uint8_t  MDS           :2;     
N                                        //0x0 = I2C : Single/Multi-Master/ Slave mode
N                                        //0x1 = Monitor : Monitor-Slave mode
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __IO uint8_t  BUF_EN        :1;     //[6] I2C data buffer enable bit
X            volatile uint8_t  BUF_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  GC_EN         :1;     //[7] I2C general call address 0x00 recognized enable bit.
X            volatile uint8_t  GC_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SFBD_EN       :1;     //[11] I2C SDA first bit drive high enable when data transmitted
X            volatile uint8_t  SFBD_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SCLS_DIS      :1;     //[12] I2C slave mode clock SCL stretching low control disable
X            volatile uint8_t  SCLS_DIS      :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PDRV_SEL      :2;     //[15..14] I2C pre-drive time select for both SCL and SDA by CK_I2C clock time.
X            volatile uint8_t  PDRV_SEL      :2;     
N                                        //0x0 = 0T (disable pre-drive)
N                                        //0x1 = 1T
N                                        //0x2 = 2T
N                                        //0x3 = 3T
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  DMA_RXEN      :1;     //[30] Direct memory access enable to receive
X            volatile uint8_t  DMA_RXEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_TXEN      :1;     //[31] Direct memory access enable to transmit
X            volatile uint8_t  DMA_TXEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  I2C control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  LT            :5;     //[4..0] I2C SCL low cycle time by CK_I2C_INT clock time
X            volatile uint8_t  LT            :5;     
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  HT            :4;     //[11..8] I2C SCL high cycle time by CK_I2C_INT clock time
X            volatile uint8_t  HT            :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  I2C control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  STA           :1;     //[0] I2C START enable bit.
X            volatile uint8_t  STA           :1;     
N            __IO uint8_t  STO           :1;     //[1] I2C STOP enable bit.
X            volatile uint8_t  STO           :1;     
N            __IO uint8_t  AA            :1;     //[2] I2C assert Acknowledge enable bit.
X            volatile uint8_t  AA            :1;     
N            __IO uint8_t  CMD_TC        :1;     //[3] I2C command preload enable control bit
X            volatile uint8_t  CMD_TC        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  STA_LCK       :1;     //[4] I2C_STA bit write access protected control
X            volatile uint8_t  STA_LCK       :1;     
N                                        //0 = Locked
N                                        //1 = un-Locked
N            __IO uint8_t  STO_LCK       :1;     //[5] I2C_STO bit write access protected control
X            volatile uint8_t  STO_LCK       :1;     
N                                        //0 = Locked
N                                        //1 = un-Locked
N            __IO uint8_t  AA_LCK        :1;     //[6] I2C_AA bit write access protected control
X            volatile uint8_t  AA_LCK        :1;     
N                                        //0 = Locked
N                                        //1 = un-Locked
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BUF_CNT       :3;     //[10..8] I2C transmitted or received data byte count threshold
X            volatile uint8_t  BUF_CNT       :3;     
N                                        //0x0 = Reserved
N                                        //0x1 = 1-byte
N                                        //0x2 = 2-byte
N                                        //0x3 = 3-byte
N                                        //0x4 = 4-byte
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  ACNT          :3;     //[18..16] I2C transmitted or received data actual byte count value
X            volatile const  uint8_t  ACNT          :3;     
N                                        //0x0 = 0-byte
N                                        //0x1 = 1-byte
N                                        //0x2 = 2-byte
N                                        //0x3 = 3-byte
N                                        //0x4 = 4-byte
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[26] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[31..27] 
X            volatile const  uint8_t                :5;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  I2C control register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SADR          :7;     //[7..1] I2C slave mode main slave address detection request address value.
X            volatile uint8_t  SADR          :7;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SADR2         :7;     //[15..9] I2C slave mode 2nd slave address detection request address value.
X            volatile uint8_t  SADR2         :7;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }SADR;                              /*!< SADR       ~ Offset[0x1C]  I2C slave address detect register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TMO_EN        :1;     //[0] I2C timeout detect enable.
X            volatile uint8_t  TMO_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TMO_MDS       :2;     //[3..2] I2C timeout detection mode select
X            volatile uint8_t  TMO_MDS       :2;     
N                                        //0x0 = SCL-low (SCL low timeout)
N                                        //0x1 = SCL-SDA-high (both SCL and SDA high timeout for bus idle condition)
N                                        //0x2 = General (general counter)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  TMO_CNT       :8;     //[15..8] I2C timeout setting value.
X            volatile uint8_t  TMO_CNT       :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }TMOUT;                             /*!< TMOUT      ~ Offset[0x20]  I2C timeout control register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x24]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  EVENT         :8;     //[7..0] I2C status event code
X            volatile const  uint8_t  EVENT         :8;     
N            __IO uint8_t  EVENTF2       :1;     //[8] I2C status event interrupt Flag
X            volatile uint8_t  EVENTF2       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA2;                              /*!< STA2       ~ Offset[0x28]  I2C status register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SBUF          :8;     //[7..0] I2C data shift buffer register
X            volatile uint8_t  SBUF          :8;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }SBUF;                              /*!< SBUF       ~ Offset[0x2C]  I2C data shift buffer register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t DAT           :32;    //[31..0] I2C data byte register
X            volatile uint32_t DAT           :32;    
N        }MBIT;
N    }DAT;                               /*!< DAT        ~ Offset[0x30]  I2C data register */
N
N} I2C_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        I2C  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define I2C0_Base                       ((uint32_t)0x51000000)              /*!< I2C Control Module-0 */
N#define I2C1_Base                       ((uint32_t)0x51010000)              /*!< I2C Control Module-1 */
N#define I2C0                            ((I2C_Struct*) I2C0_Base)
N#define I2C1                            ((I2C_Struct*) I2C1_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        I2C  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        I2C_STA  [register's definitions]
N *              Offset[0x00]  I2C status register
N ******************************************************************************
N */
N///@{
N#define I2C_STA_default                             ((uint32_t)0x00000080)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_STA */
N#define I2C_STA_BERRF_mask_w                        ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_BERRF_mask_h1                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define I2C_STA_BERRF_mask_b2                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define I2C_STA_BERRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_BERRF_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_BERRF_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_BERRF_happened_w                    ((uint32_t)0x00800000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_BERRF_happened_h1                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_BERRF_happened_b2                   ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_ALOSF_mask_w                        ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_ALOSF_mask_h1                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define I2C_STA_ALOSF_mask_b2                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_STA_ALOSF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_ALOSF_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_ALOSF_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_ALOSF_happened_w                    ((uint32_t)0x00400000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_ALOSF_happened_h1                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_ALOSF_happened_b2                   ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_NACKF_mask_w                        ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_NACKF_mask_h1                       ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define I2C_STA_NACKF_mask_b2                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define I2C_STA_NACKF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_NACKF_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_NACKF_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_NACKF_happened_w                    ((uint32_t)0x00200000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_NACKF_happened_h1                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_NACKF_happened_b2                   ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_TOVRF_mask_w                        ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_TOVRF_mask_h1                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define I2C_STA_TOVRF_mask_b2                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_STA_TOVRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_TOVRF_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_TOVRF_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_TOVRF_happened_w                    ((uint32_t)0x00100000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_TOVRF_happened_h1                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_TOVRF_happened_b2                   ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_ROVRF_mask_w                        ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_ROVRF_mask_h1                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define I2C_STA_ROVRF_mask_b2                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define I2C_STA_ROVRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_ROVRF_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_ROVRF_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_ROVRF_happened_w                    ((uint32_t)0x00080000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_ROVRF_happened_h1                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_ROVRF_happened_b2                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_TXRF_mask_w                         ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_TXRF_mask_h1                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define I2C_STA_TXRF_mask_b2                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define I2C_STA_TXRF_no_data_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):No data of 32bit */
N#define I2C_STA_TXRF_no_data_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):No data of 16bit */
N#define I2C_STA_TXRF_no_data_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):No data of 8bit */
N#define I2C_STA_TXRF_remained_data_w                ((uint32_t)0x00040000)  /*!< Bit Value =(1):Remained data of 32bit */
N#define I2C_STA_TXRF_remained_data_h1               ((uint16_t)0x0004)      /*!< Bit Value =(1):Remained data of 16bit */
N#define I2C_STA_TXRF_remained_data_b2               ((uint8_t )0x04)        /*!< Bit Value =(1):Remained data of 8bit */
N
N#define I2C_STA_STPSTRF_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_STPSTRF_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define I2C_STA_STPSTRF_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define I2C_STA_STPSTRF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_STPSTRF_normal_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_STPSTRF_normal_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_STPSTRF_happened_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_STPSTRF_happened_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_STPSTRF_happened_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_TSCF_mask_w                         ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_TSCF_mask_h1                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_STA_TSCF_mask_b2                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_STA_TSCF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_TSCF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_TSCF_normal_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_TSCF_happened_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_TSCF_happened_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_TSCF_happened_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_RWF_mask_w                          ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_RWF_mask_h0                         ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define I2C_STA_RWF_mask_b1                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define I2C_STA_RWF_write_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Write of 32bit */
N#define I2C_STA_RWF_write_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Write of 16bit */
N#define I2C_STA_RWF_write_b1                        ((uint8_t )0x00)        /*!< Bit Value =(0):Write of 8bit */
N#define I2C_STA_RWF_read_w                          ((uint32_t)0x00008000)  /*!< Bit Value =(1):Read of 32bit */
N#define I2C_STA_RWF_read_h0                         ((uint16_t)0x8000)      /*!< Bit Value =(1):Read of 16bit */
N#define I2C_STA_RWF_read_b1                         ((uint8_t )0x80)        /*!< Bit Value =(1):Read of 8bit */
N
N#define I2C_STA_MSTF_mask_w                         ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_MSTF_mask_h0                        ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define I2C_STA_MSTF_mask_b1                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_STA_MSTF_shift_w                        (14)                    /*!< Bit Shift of 32bit */
N#define I2C_STA_MSTF_shift_h0                       (14)                    /*!< Bit Shift of 16bit */
N#define I2C_STA_MSTF_shift_b1                       (6)                     /*!< Bit Shift of 8bit */
N
N#define I2C_STA_SLAF_mask_w                         ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_SLAF_mask_h0                        ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define I2C_STA_SLAF_mask_b1                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define I2C_STA_SLAF_shift_w                        (13)                    /*!< Bit Shift of 32bit */
N#define I2C_STA_SLAF_shift_h0                       (13)                    /*!< Bit Shift of 16bit */
N#define I2C_STA_SLAF_shift_b1                       (5)                     /*!< Bit Shift of 8bit */
N
N#define I2C_STA_SADRF_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define I2C_STA_SADRF_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define I2C_STA_SADRF_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_STA_SADRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_SADRF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_SADRF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_SADRF_happened_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_SADRF_happened_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_SADRF_happened_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_ERRCF_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define I2C_STA_ERRCF_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define I2C_STA_ERRCF_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define I2C_STA_ERRCF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_ERRCF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_ERRCF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_ERRCF_happened_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_ERRCF_happened_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_ERRCF_happened_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_CNTF_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define I2C_STA_CNTF_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define I2C_STA_CNTF_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define I2C_STA_CNTF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_CNTF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_CNTF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_CNTF_happened_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_CNTF_happened_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_CNTF_happened_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_STOPF_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define I2C_STA_STOPF_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define I2C_STA_STOPF_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define I2C_STA_STOPF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_STOPF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_STOPF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_STOPF_happened_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_STOPF_happened_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_STOPF_happened_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_RSTRF_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define I2C_STA_RSTRF_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define I2C_STA_RSTRF_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_STA_RSTRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_RSTRF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_RSTRF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_RSTRF_happened_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_RSTRF_happened_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_RSTRF_happened_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_TXF_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define I2C_STA_TXF_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define I2C_STA_TXF_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define I2C_STA_TXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_TXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_TXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_TXF_happened_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_TXF_happened_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_TXF_happened_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_RXF_mask_w                          ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define I2C_STA_RXF_mask_h0                         ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define I2C_STA_RXF_mask_b0                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_STA_RXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_RXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_RXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_RXF_happened_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_RXF_happened_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_RXF_happened_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_TMOUTF_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define I2C_STA_TMOUTF_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define I2C_STA_TMOUTF_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_STA_TMOUTF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_TMOUTF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_TMOUTF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_TMOUTF_happened_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_TMOUTF_happened_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_TMOUTF_happened_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_ERRF_mask_w                         ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define I2C_STA_ERRF_mask_h0                        ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define I2C_STA_ERRF_mask_b0                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define I2C_STA_ERRF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_ERRF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_ERRF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_ERRF_happened_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_ERRF_happened_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_ERRF_happened_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_BUFF_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define I2C_STA_BUFF_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define I2C_STA_BUFF_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define I2C_STA_BUFF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_BUFF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_BUFF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_BUFF_happened_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_BUFF_happened_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_BUFF_happened_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_EVENTF_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define I2C_STA_EVENTF_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define I2C_STA_EVENTF_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define I2C_STA_EVENTF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_EVENTF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_EVENTF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_EVENTF_happened_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA_EVENTF_happened_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA_EVENTF_happened_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA_BUSYF_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define I2C_STA_BUSYF_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_STA_BUSYF_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_STA_BUSYF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA_BUSYF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA_BUSYF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA_BUSYF_busy_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Busy of 32bit */
N#define I2C_STA_BUSYF_busy_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Busy of 16bit */
N#define I2C_STA_BUSYF_busy_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Busy of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_INT  [register's definitions]
N *              Offset[0x04]  I2C interrupt enable register
N ******************************************************************************
N */
N///@{
N#define I2C_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_INT */
N#define I2C_INT_SDAF_mask_w                         ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define I2C_INT_SDAF_mask_h1                        ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define I2C_INT_SDAF_mask_b3                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define I2C_INT_SDAF_shift_w                        (31)                    /*!< Bit Shift of 32bit */
N#define I2C_INT_SDAF_shift_h1                       (15)                    /*!< Bit Shift of 16bit */
N#define I2C_INT_SDAF_shift_b3                       (7)                     /*!< Bit Shift of 8bit */
N
N#define I2C_INT_SCLF_mask_w                         ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define I2C_INT_SCLF_mask_h1                        ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define I2C_INT_SCLF_mask_b3                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_INT_SCLF_shift_w                        (30)                    /*!< Bit Shift of 32bit */
N#define I2C_INT_SCLF_shift_h1                       (14)                    /*!< Bit Shift of 16bit */
N#define I2C_INT_SCLF_shift_b3                       (6)                     /*!< Bit Shift of 8bit */
N
N#define I2C_INT_TMOUT_IE_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define I2C_INT_TMOUT_IE_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define I2C_INT_TMOUT_IE_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_INT_TMOUT_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_INT_TMOUT_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_INT_TMOUT_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_INT_TMOUT_IE_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_INT_TMOUT_IE_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_INT_TMOUT_IE_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_INT_ERR_IE_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define I2C_INT_ERR_IE_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define I2C_INT_ERR_IE_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define I2C_INT_ERR_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_INT_ERR_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_INT_ERR_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_INT_ERR_IE_enable_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_INT_ERR_IE_enable_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_INT_ERR_IE_enable_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_INT_BUF_IE_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define I2C_INT_BUF_IE_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define I2C_INT_BUF_IE_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define I2C_INT_BUF_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_INT_BUF_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_INT_BUF_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_INT_BUF_IE_enable_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_INT_BUF_IE_enable_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_INT_BUF_IE_enable_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_INT_EVENT_IE_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define I2C_INT_EVENT_IE_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define I2C_INT_EVENT_IE_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define I2C_INT_EVENT_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_INT_EVENT_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_INT_EVENT_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_INT_EVENT_IE_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_INT_EVENT_IE_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_INT_EVENT_IE_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define I2C_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_CLK  [register's definitions]
N *              Offset[0x08]  I2C clock source register
N ******************************************************************************
N */
N///@{
N#define I2C_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_CLK */
N#define I2C_CLK_TMO_CKS_mask_w                      ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define I2C_CLK_TMO_CKS_mask_h0                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define I2C_CLK_TMO_CKS_mask_b1                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_CLK_TMO_CKS_ck_ut_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):CK_UT of 32bit */
N#define I2C_CLK_TMO_CKS_ck_ut_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):CK_UT of 16bit */
N#define I2C_CLK_TMO_CKS_ck_ut_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):CK_UT of 8bit */
N#define I2C_CLK_TMO_CKS_div64_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(1):DIV64 of 32bit */
N#define I2C_CLK_TMO_CKS_div64_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(1):DIV64 of 16bit */
N#define I2C_CLK_TMO_CKS_div64_b1                    ((uint8_t )0x10)        /*!< Bit Value =(1):DIV64 of 8bit */
N
N#define I2C_CLK_CK_PSC_mask_w                       ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define I2C_CLK_CK_PSC_mask_h0                      ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define I2C_CLK_CK_PSC_mask_b1                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define I2C_CLK_CK_PSC_shift_w                      (8)                     /*!< Bit Shift of 32bit */
N#define I2C_CLK_CK_PSC_shift_h0                     (8)                     /*!< Bit Shift of 16bit */
N#define I2C_CLK_CK_PSC_shift_b1                     (0)                     /*!< Bit Shift of 8bit */
N
N#define I2C_CLK_CK_DIV_mask_w                       ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define I2C_CLK_CK_DIV_mask_h0                      ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define I2C_CLK_CK_DIV_mask_b0                      ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define I2C_CLK_CK_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define I2C_CLK_CK_DIV_div1_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define I2C_CLK_CK_DIV_div1_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define I2C_CLK_CK_DIV_div2_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define I2C_CLK_CK_DIV_div2_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define I2C_CLK_CK_DIV_div2_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define I2C_CLK_CK_DIV_div4_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define I2C_CLK_CK_DIV_div4_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define I2C_CLK_CK_DIV_div4_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define I2C_CLK_CK_DIV_div8_w                       ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define I2C_CLK_CK_DIV_div8_h0                      ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define I2C_CLK_CK_DIV_div8_b0                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define I2C_CLK_CK_DIV_div16_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define I2C_CLK_CK_DIV_div16_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define I2C_CLK_CK_DIV_div16_b0                     ((uint8_t )0x40)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N#define I2C_CLK_CK_DIV_div32_w                      ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):DIV32 of 32bit */
N#define I2C_CLK_CK_DIV_div32_h0                     ((uint16_t)0x0050)      /*!< Bit Value =(0x5):DIV32 of 16bit */
N#define I2C_CLK_CK_DIV_div32_b0                     ((uint8_t )0x50)        /*!< Bit Value =(0x5):DIV32 of 8bit */
N#define I2C_CLK_CK_DIV_div64_w                      ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):DIV64 of 32bit */
N#define I2C_CLK_CK_DIV_div64_h0                     ((uint16_t)0x0060)      /*!< Bit Value =(0x6):DIV64 of 16bit */
N#define I2C_CLK_CK_DIV_div64_b0                     ((uint8_t )0x60)        /*!< Bit Value =(0x6):DIV64 of 8bit */
N#define I2C_CLK_CK_DIV_div128_w                     ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):DIV128 of 32bit */
N#define I2C_CLK_CK_DIV_div128_h0                    ((uint16_t)0x0070)      /*!< Bit Value =(0x7):DIV128 of 16bit */
N#define I2C_CLK_CK_DIV_div128_b0                    ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIV128 of 8bit */
N
N#define I2C_CLK_CK_SEL_mask_w                       ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define I2C_CLK_CK_SEL_mask_h0                      ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define I2C_CLK_CK_SEL_mask_b0                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define I2C_CLK_CK_SEL_proc_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):PROC of 32bit */
N#define I2C_CLK_CK_SEL_proc_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):PROC of 16bit */
N#define I2C_CLK_CK_SEL_proc_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):PROC of 8bit */
N#define I2C_CLK_CK_SEL_tm00_trgo_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define I2C_CLK_CK_SEL_tm00_trgo_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define I2C_CLK_CK_SEL_tm00_trgo_b0                 ((uint8_t )0x08)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_SAC  [register's definitions]
N *              Offset[0x0C]  I2C slave mode slave address code register
N ******************************************************************************
N */
N///@{
N#define I2C_SAC_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_SAC */
N#define I2C_SAC_SA_CODE_mask_w                      ((uint32_t)0x000000FE)  /*!< Bit Mask of 32bit */
N#define I2C_SAC_SA_CODE_mask_h0                     ((uint16_t)0x00FE)      /*!< Bit Mask of 16bit */
N#define I2C_SAC_SA_CODE_mask_b0                     ((uint8_t )0xFE)        /*!< Bit Mask of 8bit */
N#define I2C_SAC_SA_CODE_shift_w                     (1)                     /*!< Bit Shift of 32bit */
N#define I2C_SAC_SA_CODE_shift_h0                    (1)                     /*!< Bit Shift of 16bit */
N#define I2C_SAC_SA_CODE_shift_b0                    (1)                     /*!< Bit Shift of 8bit */
N
N#define I2C_SAC_SA_RW_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define I2C_SAC_SA_RW_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_SAC_SA_RW_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_SAC_SA_RW_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define I2C_SAC_SA_RW_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define I2C_SAC_SA_RW_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_CR0  [register's definitions]
N *              Offset[0x10]  I2C control register 0
N ******************************************************************************
N */
N///@{
N#define I2C_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_CR0 */
N#define I2C_CR0_DMA_TXEN_mask_w                     ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_DMA_TXEN_mask_h1                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_DMA_TXEN_mask_b3                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_DMA_TXEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_DMA_TXEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_DMA_TXEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_DMA_TXEN_enable_w                   ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_DMA_TXEN_enable_h1                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_DMA_TXEN_enable_b3                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_DMA_RXEN_mask_w                     ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_DMA_RXEN_mask_h1                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_DMA_RXEN_mask_b3                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_DMA_RXEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_DMA_RXEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_DMA_RXEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_DMA_RXEN_enable_w                   ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_DMA_RXEN_enable_h1                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_DMA_RXEN_enable_b3                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_PDRV_SEL_mask_w                     ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_PDRV_SEL_mask_h0                    ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_PDRV_SEL_mask_b1                    ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_PDRV_SEL_0t_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0T of 32bit */
N#define I2C_CR0_PDRV_SEL_0t_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0T of 16bit */
N#define I2C_CR0_PDRV_SEL_0t_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):0T of 8bit */
N#define I2C_CR0_PDRV_SEL_1t_w                       ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):1T of 32bit */
N#define I2C_CR0_PDRV_SEL_1t_h0                      ((uint16_t)0x4000)      /*!< Bit Value =(0x1):1T of 16bit */
N#define I2C_CR0_PDRV_SEL_1t_b1                      ((uint8_t )0x40)        /*!< Bit Value =(0x1):1T of 8bit */
N#define I2C_CR0_PDRV_SEL_2t_w                       ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):2T of 32bit */
N#define I2C_CR0_PDRV_SEL_2t_h0                      ((uint16_t)0x8000)      /*!< Bit Value =(0x2):2T of 16bit */
N#define I2C_CR0_PDRV_SEL_2t_b1                      ((uint8_t )0x80)        /*!< Bit Value =(0x2):2T of 8bit */
N#define I2C_CR0_PDRV_SEL_3t_w                       ((uint32_t)0x0000C000)  /*!< Bit Value =(0x3):3T of 32bit */
N#define I2C_CR0_PDRV_SEL_3t_h0                      ((uint16_t)0xC000)      /*!< Bit Value =(0x3):3T of 16bit */
N#define I2C_CR0_PDRV_SEL_3t_b1                      ((uint8_t )0xC0)        /*!< Bit Value =(0x3):3T of 8bit */
N
N#define I2C_CR0_SCLS_DIS_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_SCLS_DIS_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_SCLS_DIS_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_SCLS_DIS_enable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define I2C_CR0_SCLS_DIS_enable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define I2C_CR0_SCLS_DIS_enable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define I2C_CR0_SCLS_DIS_disable_w                  ((uint32_t)0x00001000)  /*!< Bit Value =(1):Disable of 32bit */
N#define I2C_CR0_SCLS_DIS_disable_h0                 ((uint16_t)0x1000)      /*!< Bit Value =(1):Disable of 16bit */
N#define I2C_CR0_SCLS_DIS_disable_b1                 ((uint8_t )0x10)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define I2C_CR0_SFBD_EN_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_SFBD_EN_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_SFBD_EN_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_SFBD_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_SFBD_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_SFBD_EN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_SFBD_EN_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_SFBD_EN_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_SFBD_EN_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_GC_EN_mask_w                        ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_GC_EN_mask_h0                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_GC_EN_mask_b0                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_GC_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_GC_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_GC_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_GC_EN_enable_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_GC_EN_enable_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_GC_EN_enable_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_BUF_EN_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_BUF_EN_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_BUF_EN_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_BUF_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_BUF_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_BUF_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_BUF_EN_enable_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_BUF_EN_enable_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_BUF_EN_enable_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_MDS_mask_w                          ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_MDS_mask_h0                         ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_MDS_mask_b0                         ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_MDS_i2c_w                           ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):I2C of 32bit */
N#define I2C_CR0_MDS_i2c_h0                          ((uint16_t)0x0000)      /*!< Bit Value =(0x0):I2C of 16bit */
N#define I2C_CR0_MDS_i2c_b0                          ((uint8_t )0x00)        /*!< Bit Value =(0x0):I2C of 8bit */
N#define I2C_CR0_MDS_monitor_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Monitor of 32bit */
N#define I2C_CR0_MDS_monitor_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Monitor of 16bit */
N#define I2C_CR0_MDS_monitor_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):Monitor of 8bit */
N
N#define I2C_CR0_SADR2_EN_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_SADR2_EN_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_SADR2_EN_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_SADR2_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_SADR2_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_SADR2_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_SADR2_EN_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_SADR2_EN_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_SADR2_EN_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_SADR_EN_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_SADR_EN_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_SADR_EN_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_SADR_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_SADR_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_SADR_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_SADR_EN_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_SADR_EN_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_SADR_EN_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define I2C_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_CR1  [register's definitions]
N *              Offset[0x14]  I2C control register 1
N ******************************************************************************
N */
N///@{
N#define I2C_CR1_default                             ((uint32_t)0x00000504)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_CR1 */
N#define I2C_CR1_HT_mask_w                           ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define I2C_CR1_HT_mask_h0                          ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define I2C_CR1_HT_mask_b1                          ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N
N#define I2C_CR1_LT_mask_w                           ((uint32_t)0x0000001F)  /*!< Bit Mask of 32bit */
N#define I2C_CR1_LT_mask_h0                          ((uint16_t)0x001F)      /*!< Bit Mask of 16bit */
N#define I2C_CR1_LT_mask_b0                          ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_CR2  [register's definitions]
N *              Offset[0x18]  I2C control register 2
N ******************************************************************************
N */
N///@{
N#define I2C_CR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_CR2 */
N#define I2C_CR2_ACNT_mask_w                         ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_ACNT_mask_h1                        ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_ACNT_mask_b2                        ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_ACNT_0_byte_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0-byte of 32bit */
N#define I2C_CR2_ACNT_0_byte_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0-byte of 16bit */
N#define I2C_CR2_ACNT_0_byte_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):0-byte of 8bit */
N#define I2C_CR2_ACNT_1_byte_w                       ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):1-byte of 32bit */
N#define I2C_CR2_ACNT_1_byte_h1                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):1-byte of 16bit */
N#define I2C_CR2_ACNT_1_byte_b2                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):1-byte of 8bit */
N#define I2C_CR2_ACNT_2_byte_w                       ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):2-byte of 32bit */
N#define I2C_CR2_ACNT_2_byte_h1                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):2-byte of 16bit */
N#define I2C_CR2_ACNT_2_byte_b2                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):2-byte of 8bit */
N#define I2C_CR2_ACNT_3_byte_w                       ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):3-byte of 32bit */
N#define I2C_CR2_ACNT_3_byte_h1                      ((uint16_t)0x0003)      /*!< Bit Value =(0x3):3-byte of 16bit */
N#define I2C_CR2_ACNT_3_byte_b2                      ((uint8_t )0x03)        /*!< Bit Value =(0x3):3-byte of 8bit */
N#define I2C_CR2_ACNT_4_byte_w                       ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):4-byte of 32bit */
N#define I2C_CR2_ACNT_4_byte_h1                      ((uint16_t)0x0004)      /*!< Bit Value =(0x4):4-byte of 16bit */
N#define I2C_CR2_ACNT_4_byte_b2                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):4-byte of 8bit */
N
N#define I2C_CR2_BUF_CNT_mask_w                      ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_BUF_CNT_mask_h0                     ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_BUF_CNT_mask_b1                     ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_BUF_CNT_1_byte_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):1-byte of 32bit */
N#define I2C_CR2_BUF_CNT_1_byte_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):1-byte of 16bit */
N#define I2C_CR2_BUF_CNT_1_byte_b1                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):1-byte of 8bit */
N#define I2C_CR2_BUF_CNT_2_byte_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):2-byte of 32bit */
N#define I2C_CR2_BUF_CNT_2_byte_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(0x2):2-byte of 16bit */
N#define I2C_CR2_BUF_CNT_2_byte_b1                   ((uint8_t )0x02)        /*!< Bit Value =(0x2):2-byte of 8bit */
N#define I2C_CR2_BUF_CNT_3_byte_w                    ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):3-byte of 32bit */
N#define I2C_CR2_BUF_CNT_3_byte_h0                   ((uint16_t)0x0300)      /*!< Bit Value =(0x3):3-byte of 16bit */
N#define I2C_CR2_BUF_CNT_3_byte_b1                   ((uint8_t )0x03)        /*!< Bit Value =(0x3):3-byte of 8bit */
N#define I2C_CR2_BUF_CNT_4_byte_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):4-byte of 32bit */
N#define I2C_CR2_BUF_CNT_4_byte_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(0x4):4-byte of 16bit */
N#define I2C_CR2_BUF_CNT_4_byte_b1                   ((uint8_t )0x04)        /*!< Bit Value =(0x4):4-byte of 8bit */
N
N#define I2C_CR2_AA_LCK_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_AA_LCK_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_AA_LCK_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_AA_LCK_locked_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define I2C_CR2_AA_LCK_locked_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define I2C_CR2_AA_LCK_locked_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define I2C_CR2_AA_LCK_un_locked_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):un-Locked of 32bit */
N#define I2C_CR2_AA_LCK_un_locked_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):un-Locked of 16bit */
N#define I2C_CR2_AA_LCK_un_locked_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):un-Locked of 8bit */
N
N#define I2C_CR2_STO_LCK_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_STO_LCK_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_STO_LCK_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_STO_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define I2C_CR2_STO_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define I2C_CR2_STO_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define I2C_CR2_STO_LCK_un_locked_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):un-Locked of 32bit */
N#define I2C_CR2_STO_LCK_un_locked_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):un-Locked of 16bit */
N#define I2C_CR2_STO_LCK_un_locked_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):un-Locked of 8bit */
N
N#define I2C_CR2_STA_LCK_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_STA_LCK_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_STA_LCK_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_STA_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define I2C_CR2_STA_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define I2C_CR2_STA_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define I2C_CR2_STA_LCK_un_locked_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):un-Locked of 32bit */
N#define I2C_CR2_STA_LCK_un_locked_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):un-Locked of 16bit */
N#define I2C_CR2_STA_LCK_un_locked_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):un-Locked of 8bit */
N
N#define I2C_CR2_CMD_TC_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_CMD_TC_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_CMD_TC_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_CMD_TC_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_CR2_CMD_TC_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_CR2_CMD_TC_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_CR2_CMD_TC_enable_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_CR2_CMD_TC_enable_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_CR2_CMD_TC_enable_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define I2C_CR2_AA_mask_w                           ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_AA_mask_h0                          ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_AA_mask_b0                          ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_AA_shift_w                          (2)                     /*!< Bit Shift of 32bit */
N#define I2C_CR2_AA_shift_h0                         (2)                     /*!< Bit Shift of 16bit */
N#define I2C_CR2_AA_shift_b0                         (2)                     /*!< Bit Shift of 8bit */
N
N#define I2C_CR2_STO_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_STO_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_STO_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_STO_shift_w                         (1)                     /*!< Bit Shift of 32bit */
N#define I2C_CR2_STO_shift_h0                        (1)                     /*!< Bit Shift of 16bit */
N#define I2C_CR2_STO_shift_b0                        (1)                     /*!< Bit Shift of 8bit */
N
N#define I2C_CR2_STA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define I2C_CR2_STA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_CR2_STA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_CR2_STA_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define I2C_CR2_STA_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define I2C_CR2_STA_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_SADR  [register's definitions]
N *              Offset[0x1C]  I2C slave address detect register
N ******************************************************************************
N */
N///@{
N#define I2C_SADR_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_SADR */
N#define I2C_SADR_SADR2_mask_w                       ((uint32_t)0x0000FE00)  /*!< Bit Mask of 32bit */
N#define I2C_SADR_SADR2_mask_h0                      ((uint16_t)0xFE00)      /*!< Bit Mask of 16bit */
N#define I2C_SADR_SADR2_mask_b1                      ((uint8_t )0xFE)        /*!< Bit Mask of 8bit */
N#define I2C_SADR_SADR2_shift_w                      (9)                     /*!< Bit Shift of 32bit */
N#define I2C_SADR_SADR2_shift_h0                     (9)                     /*!< Bit Shift of 16bit */
N#define I2C_SADR_SADR2_shift_b1                     (1)                     /*!< Bit Shift of 8bit */
N
N#define I2C_SADR_SADR_mask_w                        ((uint32_t)0x000000FE)  /*!< Bit Mask of 32bit */
N#define I2C_SADR_SADR_mask_h0                       ((uint16_t)0x00FE)      /*!< Bit Mask of 16bit */
N#define I2C_SADR_SADR_mask_b0                       ((uint8_t )0xFE)        /*!< Bit Mask of 8bit */
N#define I2C_SADR_SADR_shift_w                       (1)                     /*!< Bit Shift of 32bit */
N#define I2C_SADR_SADR_shift_h0                      (1)                     /*!< Bit Shift of 16bit */
N#define I2C_SADR_SADR_shift_b0                      (1)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_TMOUT  [register's definitions]
N *              Offset[0x20]  I2C timeout control register
N ******************************************************************************
N */
N///@{
N#define I2C_TMOUT_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_TMOUT */
N#define I2C_TMOUT_TMO_CNT_mask_w                    ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define I2C_TMOUT_TMO_CNT_mask_h0                   ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define I2C_TMOUT_TMO_CNT_mask_b1                   ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define I2C_TMOUT_TMO_CNT_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define I2C_TMOUT_TMO_CNT_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define I2C_TMOUT_TMO_CNT_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N#define I2C_TMOUT_TMO_MDS_mask_w                    ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define I2C_TMOUT_TMO_MDS_mask_h0                   ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define I2C_TMOUT_TMO_MDS_mask_b0                   ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define I2C_TMOUT_TMO_MDS_scl_low_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SCL-low of 32bit */
N#define I2C_TMOUT_TMO_MDS_scl_low_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SCL-low of 16bit */
N#define I2C_TMOUT_TMO_MDS_scl_low_b0                ((uint8_t )0x00)        /*!< Bit Value =(0x0):SCL-low of 8bit */
N#define I2C_TMOUT_TMO_MDS_scl_sda_high_w            ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):SCL-SDA-high of 32bit */
N#define I2C_TMOUT_TMO_MDS_scl_sda_high_h0           ((uint16_t)0x0004)      /*!< Bit Value =(0x1):SCL-SDA-high of 16bit */
N#define I2C_TMOUT_TMO_MDS_scl_sda_high_b0           ((uint8_t )0x04)        /*!< Bit Value =(0x1):SCL-SDA-high of 8bit */
N#define I2C_TMOUT_TMO_MDS_general_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):General of 32bit */
N#define I2C_TMOUT_TMO_MDS_general_h0                ((uint16_t)0x0008)      /*!< Bit Value =(0x2):General of 16bit */
N#define I2C_TMOUT_TMO_MDS_general_b0                ((uint8_t )0x08)        /*!< Bit Value =(0x2):General of 8bit */
N
N#define I2C_TMOUT_TMO_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define I2C_TMOUT_TMO_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define I2C_TMOUT_TMO_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_TMOUT_TMO_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define I2C_TMOUT_TMO_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define I2C_TMOUT_TMO_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define I2C_TMOUT_TMO_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define I2C_TMOUT_TMO_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define I2C_TMOUT_TMO_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_STA2  [register's definitions]
N *              Offset[0x28]  I2C status register 2
N ******************************************************************************
N */
N///@{
N#define I2C_STA2_default                            ((uint32_t)0x000000F8)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_STA2 */
N#define I2C_STA2_EVENTF2_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define I2C_STA2_EVENTF2_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define I2C_STA2_EVENTF2_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define I2C_STA2_EVENTF2_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define I2C_STA2_EVENTF2_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define I2C_STA2_EVENTF2_normal_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define I2C_STA2_EVENTF2_happened_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define I2C_STA2_EVENTF2_happened_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define I2C_STA2_EVENTF2_happened_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define I2C_STA2_EVENT_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define I2C_STA2_EVENT_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define I2C_STA2_EVENT_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define I2C_STA2_EVENT_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define I2C_STA2_EVENT_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define I2C_STA2_EVENT_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_SBUF  [register's definitions]
N *              Offset[0x2C]  I2C data shift buffer register
N ******************************************************************************
N */
N///@{
N#define I2C_SBUF_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_SBUF */
N#define I2C_SBUF_SBUF_mask_w                        ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define I2C_SBUF_SBUF_mask_h0                       ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define I2C_SBUF_SBUF_mask_b0                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define I2C_SBUF_SBUF_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define I2C_SBUF_SBUF_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define I2C_SBUF_SBUF_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        I2C_DAT  [register's definitions]
N *              Offset[0x30]  I2C data register
N ******************************************************************************
N */
N///@{
N#define I2C_DAT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of I2C_DAT */
N#define I2C_DAT_DAT_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define I2C_DAT_DAT_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define I2C_DAT_DAT_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define I2C_DAT_DAT_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_I2C_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_I2C.h                         */
N/*----------------------------------------------------------------------------*/
L 41 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_I2C_DRV.h" 2
N
N
N
N/**
N * @name    Clock 
N *          Clock Definition
N */
N///@{
N
N/** @brief  I2C internal clock CK_I2C source select.
N  */
N#define I2C_CLK_SRC_MASK                I2C_CLK_CK_SEL_mask_b0
N#define I2C_CLK_SRC_PROC                I2C_CLK_CK_SEL_proc_b0          /* CK_I2C0_PR process clock from CSC */
N#define I2C_CLK_SRC_TM00_TROG           I2C_CLK_CK_SEL_tm00_trgo_b0
N
N
N
N/** @brief  I2C internal clock CK_I2C_INT prescaler. The value range 0~7 is indicated divider 1~8.
N  */
N#define I2C_CLK_PSC_MASK                I2C_CLK_CK_PSC_mask_b1
N#define I2C_CLK_PSC_1                   0x00U
N#define I2C_CLK_PSC_2                   0x01U
N#define I2C_CLK_PSC_3                   0x02U
N#define I2C_CLK_PSC_4                   0x03U
N#define I2C_CLK_PSC_5                   0x04U
N#define I2C_CLK_PSC_6                   0x05U
N#define I2C_CLK_PSC_7                   0x06U
N#define I2C_CLK_PSC_8                   0x07U
N
N
N
N/** @brief  I2C internal clock CK_I2C_INT input divider.
N  */
N#define I2C_CLK_DIV_MASK                I2C_CLK_CK_DIV_mask_b0
N#define I2C_CLK_DIV_SHIFT               0x04U
N#define I2C_CLK_DIV_1                   I2C_CLK_CK_DIV_div1_b0
N#define I2C_CLK_DIV_2                   I2C_CLK_CK_DIV_div2_b0
N#define I2C_CLK_DIV_4                   I2C_CLK_CK_DIV_div4_b0
N#define I2C_CLK_DIV_8                   I2C_CLK_CK_DIV_div8_b0
N#define I2C_CLK_DIV_16                  I2C_CLK_CK_DIV_div16_b0
N#define I2C_CLK_DIV_32                  I2C_CLK_CK_DIV_div32_b0
N#define I2C_CLK_DIV_64                  I2C_CLK_CK_DIV_div64_b0
N#define I2C_CLK_DIV_128                 I2C_CLK_CK_DIV_div128_b0
N
N
N
N/** @brief  I2C SCL high cycle time by CK_I2C_INT clock time.
N            It write setting value for master mode. 
N            (SCL High time = START hold time = STOP setup time)
N  */
N#define I2C_SCL_HT_MASK                 I2C_CR1_HT_mask_w
N#define I2C_SCL_HT_SHIFT                8
N
N
N
N/** @brief  I2C SCL low cycle time by CK_I2C_INT clock time.
N            It write setting value for master mode. 
N            (SCL Low time = START setup time = Bus free time between STOP and START)
N  */
N#define I2C_SCL_LT_MASK                 I2C_CR1_LT_mask_w
N#define I2C_SCL_LT_SHIFT                0
N
N
N
N/** @brief  I2C pre-drive time select for both SCL and SDA by CK_I2C clock time.
N  */
N#define I2C_PDRV_MASK                   I2C_CR0_PDRV_SEL_mask_w
N#define I2C_PDRV_0T                     I2C_CR0_PDRV_SEL_0t_w
N#define I2C_PDRV_1T                     I2C_CR0_PDRV_SEL_1t_w
N#define I2C_PDRV_2T                     I2C_CR0_PDRV_SEL_2t_w
N#define I2C_PDRV_3T                     I2C_CR0_PDRV_SEL_3t_w
N
N///@}
N
N
N
N/**
N * @name    I2C Operation.
N *          I2C Operation Mode.
N */
N///@{
N
N/** @brief  I2C Operation mode select.
N  */
N#define I2C_MDS_MASK                    I2C_CR0_MDS_mask_b0
N#define I2C_MDS_I2C                     I2C_CR0_MDS_i2c_b0                      /* I2C : Single/Multi-Master/ Slave mode */
N
N
N
N/** @brief  I2C Slave Address
N  */
N#define I2C_SADR_0                      I2C_CR0_GC_EN_mask_w                    /* I2C general call address 0x00 recognized */
N#define I2C_SADR_1                      I2C_CR0_SADR_EN_mask_w                  /* I2C slave mode main slave address detect. */
N#define I2C_SADR_2                      I2C_CR0_SADR2_EN_mask_w                 /* I2C slave mode 2nd slave address detect. */
N
N///@}
N
N
N
N/**
N * @name    Interript & Flag
N *          Interript & Flag definition
N */
N///@{
N
N/** @brief  Flag definition 
N  */
N#define I2C_FLAG_BUSYF                  I2C_STA_BUSYF_mask_w                    /* I2C busy flag. (set and clear by hardware) */
N#define I2C_FLAG_EVENTF                 I2C_STA_EVENTF_mask_w                   /* I2C status event interrupt Flag. (set by hardware , clear by software setting 1)*/
N#define I2C_FLAG_BUFF                   I2C_STA_BUFF_mask_w                     /* I2C buffer mode event flag. (set by hardware , clear by software setting 1)*/
N#define I2C_FLAG_ERRF                   I2C_STA_ERRF_mask_w                     /* I2C error interrupt flag. for invalid no ack, bus arbitration lost, bus error or data overrun error. */
N#define I2C_FLAG_TMOUTF                 I2C_STA_TMOUTF_mask_w                   /* I2C time-out detect flag. (set and clear by hardware)*/
N#define I2C_FLAG_RXF                    I2C_STA_RXF_mask_w                      /* I2C Receive data register not empty. (set by hardware and clear by hardware or software writing 1) This bit is cleared when I2C_DAT is read or this flag set to 1 by software.*/
N#define I2C_FLAG_TXF                    I2C_STA_TXF_mask_w                      /* I2C Transmit data register empty.  (set by hardware and clear by hardware or software writing 1) This bit is cleared when I2C_DAT is written or this flag set to 1 by software. The flag is set after I2C reset or Idle state.*/
N#define I2C_FLAG_RSTRF                  I2C_STA_RSTRF_mask_w                    /* I2C repeat start asserted flag. (set by hardware and clear by software writing 1)*/
N#define I2C_FLAG_STOPF                  I2C_STA_STOPF_mask_w                    /* I2C stop detection flag. (set by hardware and clear by software writing 1)*/
N#define I2C_FLAG_CNTF                   I2C_STA_CNTF_mask_w                     /* I2C buffer count I2C0_BUF_CNT empty status.  (set by hardware and clear by software writing 1 or I2C_BUF_CNT written)*/
N#define I2C_FLAG_ERRCF                  I2C_STA_ERRCF_mask_w                    /* I2C master mode NACK error flag and state control bit. (set by hardware and clear by software writing 1 or hardware auto clear during START/STOP state) This bit is asserted if occurs NACK during slave-address cycle or data cycle of receive access.*/
N#define I2C_FLAG_SADRF                  I2C_STA_SADRF_mask_w                    /* I2C slave mode slave address matched flag. This flag is also asserted for master mode if transmit mode slave address unmatched or received mode slave address asserted. When wakeup from STOP mode by detection matched slave address, user needs to clear this bit to disable the clock stretching and releases clock signal for external master. (set by hardware and clear by software writing 1)*/
N#define I2C_FLAG_SLAF                   I2C_STA_SLAF_mask_w                     /* I2C slave mode detection status. It set by Slave address matched condition and clear by Start/Stop conditions.*/
N#define I2C_FLAG_MSTF                   I2C_STA_MSTF_mask_w                     /* I2C master mode detection status. It set by Start command and clear by Stop state.*/
N#define I2C_FLAG_RWF                    I2C_STA_RWF_mask_w                      /* I2C read or write transfer direction status. It always update at slave address r/w state.*/
N#define I2C_FLAG_TSCF                   I2C_STA_TSCF_mask_w                     /* I2C shadow buffer transfer complete flag. (set by hardware and clear by hardware or software writing 1)*/
N#define I2C_FLAG_TXRF                   I2C_STA_TXRF_mask_w                     /* I2C transmit data register remained status.  (set and clear by hardware) When occurs bus NACK error and I2C_NACKF is asserted, this bit is used to check the data register contain whether has remain data when master STOP and calculate the corrected total transfer count by I2C_ACNT. It is cleared in slave address matched state and updated after last byte NACK state.*/
N#define I2C_FLAG_ROVRF                  I2C_STA_ROVRF_mask_w                    /* I2C data buffer receive overrun error flag. Under the conditions, slave mode enables data buffer mode and clock stretching is disabled. When the data buffer is overrun, this bit is set and interrupt is generated if I2C_ERR_IE is enabled. Also, the I2C_ERRF is set. (set by hardware and clear by software writing 1)*/
N#define I2C_FLAG_TOVRF                  I2C_STA_TOVRF_mask_w                    /* I2C data buffer transmit underrun error flag. Under the conditions, slave mode enables data buffer mode and clock stretching is disabled. When the data buffer is underrun, this bit is set and interrupt is generated if I2C_ERR_IE is enabled. Also, the I2C_ERRF is set. (set by hardware and clear by software writing 1)*/
N#define I2C_FLAG_NACKF                  I2C_STA_NACKF_mask_w                    /* I2C Not Acknowledge received error flag. (set by hardware and clear by software writing 1)*/ 
N#define I2C_FLAG_ALOSF                  I2C_STA_ALOSF_mask_w                    /* I2C bus arbitration lost error flag. (set by hardware and clear by software writing 1)*/
N#define I2C_FLAG_BERRF                  I2C_STA_BERRF_mask_w                    /* I2C bus error flag for invalid Stop/Start state. (set by hardware and clear by software writing 1)*/
N#if defined(MG32_1ST)
X#if 1L
N  #define I2C_FLAG_STPSTRF              0                                       /* I2C Bus Stop or Bus Start detection flag. (set by hardware and clear by software writing 1)*/
N  #define I2C_FLAG_WUPF                 0                                       /* I2C wakeup from STOP mode flag. set by hardware and clear by software writing 1)*/ 
N#else
S  #define I2C_FLAG_STPSTRF              I2C_STA_STPSTRF_mask_w                  /* I2C Bus Stop or Bus Start detection flag. (set by hardware and clear by software writing 1)*/
S  #define I2C_FLAG_WUPF                 I2C_STA_WUPF_mask_w                     /* I2C wakeup from STOP mode flag. set by hardware and clear by software writing 1)*/ 
N#endif
N
N
N
N/** @brief  Interrup Enable Definition
N  */
N#define I2C_IT_IEA                      I2C_INT_IEA_mask_w                      /* I2C interrupt all enable. When disables, the I2C global all interrupt event are disabled. When enables, the related event interrupt enable bit is to enable or disable the interrupt. */
N#define I2C_IT_TMOUT                    I2C_INT_TMOUT_IE_mask_w                 /* I2C timeout error interrupt enable. */
N#define I2C_IT_EVENT                    I2C_INT_EVENT_IE_mask_w                 /* I2C status event interrupt enable. */
N#define I2C_IT_ERR                      I2C_INT_ERR_IE_mask_w                   /* I2C no ack error, bus arbitration lost, bus error or data overrun interrupt enable. */
N#define I2C_IT_BUF                      I2C_INT_BUF_IE_mask_w                   /* I2C buffer mode event Interrupt enable. When enables, it will generate the interrupt if the flag of I2C_RXF, I2C_TXF, I2C_RSTRF, I2C_STOPF or I2C_SADRF is set. */
N#if defined(MG32_1ST)
X#if 1L
N  #define I2C_IT_STPSTR                 0                                       /* I2C Stop or Start detection interrupt enable. */
N  #define I2C_IT_WUP                    0                                       /* I2C wakeup from STOP mode interrupt enable on slave address matched. */
N#else
S  #define I2C_IT_STPSTR                 I2C_INT_STPSTR_IE_mask_w                /* I2C Stop or Start detection interrupt enable. */
S  #define I2C_IT_WUP                    I2C_INT_WUP_IE_mask_w                   /* I2C wakeup from STOP mode interrupt enable on slave address matched. */
N#endif
N///@}
N
N
N
N/**
N * @name    TimeOut Config
N *          TimeOut Config
N */
N///@{
N
N/** @brief  TimeOut Count Clock Source
N  */
N
N#define I2C_TMO_CKS_MASK                I2C_CLK_TMO_CKS_mask_w
N#define I2C_TMO_CKS_CK_UT               I2C_CLK_TMO_CKS_ck_ut_w
N#define I2C_TMO_CKS_DIV64               I2C_CLK_TMO_CKS_div64_w
N
N
N/** @brief  TimeOut Mode sELECT
N  */
N
N#define I2C_TMO_MDS_MASK                I2C_TMOUT_TMO_MDS_mask_w
N#define I2C_TMO_MDS_SCL_LOW             I2C_TMOUT_TMO_MDS_scl_low_w
N#define I2C_TMO_MDS_SDA_SCL_HIGH        I2C_TMOUT_TMO_MDS_scl_sda_high_w
N#define I2C_TMO_MDS_GENERAL             I2C_TMOUT_TMO_MDS_general_w
N
N///@}
N
N
N
N/**
N * @name    Start / Stop / Acknowledge Enable / Disable.
N *          Start / Stop / Acknowledge Enable / Disable.
N */
N///@{
N
N/** @brief  Start / Stop / Acknowledge Enable / Disable.
N    @retval None
N  */
N#define __I2C_PreSet_ASSERT_ACKNOWLEDGE_CLR(I2Cx__)   (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_AA_mask_b0) | (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N#define __I2C_PreSet_ASSERT_ACKNOWLEDGE_SET(I2Cx__)   (I2Cx__)->CR2.B[0] = ((I2Cx__)->CR2.B[0] | (I2C_CR2_AA_mask_b0 | I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N#define __I2C_Set_ASSERT_ACKNOWLEDGE_CLR(I2Cx__)      (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~(I2C_CR2_AA_mask_b0 | I2C_CR2_CMD_TC_mask_b0)) | I2C_CR2_AA_LCK_mask_b0)
N#define __I2C_Set_ASSERT_ACKNOWLEDGE_SET(I2Cx__)      (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_CMD_TC_mask_b0) | (I2C_CR2_AA_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N#define __I2C_PAA_0                             __I2C_PreSet_ASSERT_ACKNOWLEDGE_CLR 
N#define __I2C_PAA_1                             __I2C_PreSet_ASSERT_ACKNOWLEDGE_SET
N#define __I2C_AA_0                              __I2C_Set_ASSERT_ACKNOWLEDGE_CLR
N#define __I2C_AA_1                              __I2C_Set_ASSERT_ACKNOWLEDGE_SET
N#define PreSet_ASSERT_ACKNOWLEDGE_CLR(I2Cx__)   (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_AA_mask_b0) | (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N#define PreSet_ASSERT_ACKNOWLEDGE_SET(I2Cx__)   (I2Cx__)->CR2.B[0] = ((I2Cx__)->CR2.B[0] | (I2C_CR2_AA_mask_b0 | I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N#define Set_ASSERT_ACKNOWLEDGE_CLR(I2Cx__)      (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~(I2C_CR2_AA_mask_b0 | I2C_CR2_CMD_TC_mask_b0)) | I2C_CR2_AA_LCK_mask_b0)
N#define Set_ASSERT_ACKNOWLEDGE_SET(I2Cx__)      (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_CMD_TC_mask_b0) | (I2C_CR2_AA_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N#define PAA_0                                   PreSet_ASSERT_ACKNOWLEDGE_CLR 
N#define PAA_1                                   PreSet_ASSERT_ACKNOWLEDGE_SET
N#define AA_0                                    Set_ASSERT_ACKNOWLEDGE_CLR
N#define AA_1                                    Set_ASSERT_ACKNOWLEDGE_SET
N
N#define __I2C_PreSet_START_CLR(I2Cx__)          (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_STA_mask_b0) | (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0))
N#define __I2C_PreSet_START_SET(I2Cx__)          (I2Cx__)->CR2.B[0] = ((I2Cx__)->CR2.B[0] | (I2C_CR2_STA_mask_b0 | I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0))
N#define __I2C_Set_START_CLR(I2Cx__)             (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~(I2C_CR2_STA_mask_b0 | I2C_CR2_CMD_TC_mask_b0)) | I2C_CR2_STA_LCK_mask_b0)
N#define __I2C_Set_START_SET(I2Cx__)             (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_CMD_TC_mask_b0) | (I2C_CR2_STA_mask_b0 | I2C_CR2_STA_LCK_mask_b0))
N#define __I2C_PSTA_0                            __I2C_PreSet_START_CLR
N#define __I2C_PSTA_1                            __I2C_PreSet_START_SET
N#define __I2C_STA_0                             __I2C_Set_START_CLR
N#define __I2C_STA_1                             __I2C_Set_START_SET
N#define PreSet_START_CLR(I2Cx__)                (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_STA_mask_b0) | (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0))
N#define PreSet_START_SET(I2Cx__)                (I2Cx__)->CR2.B[0] = ((I2Cx__)->CR2.B[0] | (I2C_CR2_STA_mask_b0 | I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0))
N#define Set_START_CLR(I2Cx__)                   (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~(I2C_CR2_STA_mask_b0 | I2C_CR2_CMD_TC_mask_b0)) | I2C_CR2_STA_LCK_mask_b0)
N#define Set_START_SET(I2Cx__)                   (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_CMD_TC_mask_b0) | (I2C_CR2_STA_mask_b0 | I2C_CR2_STA_LCK_mask_b0))
N#define PSTA_0                                  PreSet_START_CLR
N#define PSTA_1                                  PreSet_START_SET
N#define STA_0                                   Set_START_CLR
N#define STA_1                                   Set_START_SET
N
N#define __I2C_PreSet_STOP_CLR(I2Cx__)           (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_STO_mask_b0) | (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STO_LCK_mask_b0))
N#define __I2C_PreSet_STOP_SET(I2Cx__)           (I2Cx__)->CR2.B[0] = ((I2Cx__)->CR2.B[0] | (I2C_CR2_STO_mask_b0 | I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STO_LCK_mask_b0))
N#define __I2C_Set_STOP_CLR(I2Cx__)              (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~(I2C_CR2_STO_mask_b0 | I2C_CR2_CMD_TC_mask_b0)) | I2C_CR2_STO_LCK_mask_b0)
N#define __I2C_Set_STOP_SET(I2Cx__)              (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_CMD_TC_mask_b0) | (I2C_CR2_STO_mask_b0 | I2C_CR2_STO_LCK_mask_b0))
N#define __I2C_PSTO_0                            __I2C_PreSet_STOP_CLR
N#define __I2C_PSTO_1                            __I2C_PreSet_STOP_SET
N#define __I2C_STO_0                             __I2C_Set_STOP_CLR
N#define __I2C_STO_1                             __I2C_Set_STOP_SET
N#define PreSet_STOP_CLR(I2Cx__)                 (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_STO_mask_b0) | (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STO_LCK_mask_b0))
N#define PreSet_STOP_SET(I2Cx__)                 (I2Cx__)->CR2.B[0] = ((I2Cx__)->CR2.B[0] | (I2C_CR2_STO_mask_b0 | I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STO_LCK_mask_b0))
N#define Set_STOP_CLR(I2Cx__)                    (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~(I2C_CR2_STO_mask_b0 | I2C_CR2_CMD_TC_mask_b0)) | I2C_CR2_STO_LCK_mask_b0)
N#define Set_STOP_SET(I2Cx__)                    (I2Cx__)->CR2.B[0] = (((I2Cx__)->CR2.B[0]& ~I2C_CR2_CMD_TC_mask_b0) | (I2C_CR2_STO_mask_b0 | I2C_CR2_STO_LCK_mask_b0))
N#define PSTO_0                                  PreSet_STOP_CLR
N#define PSTO_1                                  PreSet_STOP_SET
N#define STO_0                                   Set_STOP_CLR
N#define STO_1                                   Set_STOP_SET
N
N#define __I2C_PreSet_STA_STO_AA_111(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_110(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_101(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_100(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_011(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_010(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_001(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_PreSet_STA_STO_AA_000(I2Cx__)     ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N
N#define PreSet_STA_STO_AA_111(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define PreSet_STA_STO_AA_110(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0))
N#define PreSet_STA_STO_AA_101(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_AA_mask_b0))
N#define PreSet_STA_STO_AA_100(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0))
N#define PreSet_STA_STO_AA_011(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define PreSet_STA_STO_AA_010(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0))
N#define PreSet_STA_STO_AA_001(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_AA_mask_b0))
N#define PreSet_STA_STO_AA_000(I2Cx__)           ((I2Cx__)->CR2.B[0] = (I2C_CR2_CMD_TC_mask_b0 | I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N
N#define PAction_111                             PreSet_STA_STO_AA_111
N#define PAction_110                             PreSet_STA_STO_AA_110
N#define PAction_101                             PreSet_STA_STO_AA_101
N#define PAction_100                             PreSet_STA_STO_AA_100
N#define PAction_011                             PreSet_STA_STO_AA_011
N#define PAction_010                             PreSet_STA_STO_AA_010
N#define PAction_001                             PreSet_STA_STO_AA_001
N#define PAction_000                             PreSet_STA_STO_AA_000
N
N#define __I2C_Set_STA_STO_AA_111(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_Set_STA_STO_AA_110(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0))
N#define __I2C_Set_STA_STO_AA_101(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_Set_STA_STO_AA_100(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0))
N#define __I2C_Set_STA_STO_AA_011(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_Set_STA_STO_AA_010(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0))
N#define __I2C_Set_STA_STO_AA_001(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_AA_mask_b0))
N#define __I2C_Set_STA_STO_AA_000(I2Cx__)        ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N
N#define Set_STA_STO_AA_111(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define Set_STA_STO_AA_110(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_STO_mask_b0))
N#define Set_STA_STO_AA_101(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0 | I2C_CR2_AA_mask_b0))
N#define Set_STA_STO_AA_100(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STA_mask_b0))
N#define Set_STA_STO_AA_011(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0 | I2C_CR2_AA_mask_b0))
N#define Set_STA_STO_AA_010(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_STO_mask_b0))
N#define Set_STA_STO_AA_001(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0 | I2C_CR2_AA_mask_b0))
N#define Set_STA_STO_AA_000(I2Cx__)              ((I2Cx__)->CR2.B[0] = (I2C_CR2_STA_LCK_mask_b0 | I2C_CR2_STO_LCK_mask_b0 | I2C_CR2_AA_LCK_mask_b0))
N
N#define Action_111                              Set_STA_STO_AA_111
N#define Action_110                              Set_STA_STO_AA_110
N#define Action_101                              Set_STA_STO_AA_101
N#define Action_100                              Set_STA_STO_AA_100
N#define Action_011                              Set_STA_STO_AA_011
N#define Action_010                              Set_STA_STO_AA_010
N#define Action_001                              Set_STA_STO_AA_001
N#define Action_000                              Set_STA_STO_AA_000
N
N#define __I2C_WaitSTOClear(I2Cx__)              while(((I2Cx__)->CR2.B[0] & I2C_CR2_STO_mask_b0) != 0)
N///@}
N
N
N
N/**
N * @name    Clcok Control
N *          Operation Clock Setting
N */
N///@{
N
N#define __I2C_SetClockSource(I2Cx__, I2C_CLK_SRC)   ((I2Cx__)->CLK.W = ((((I2Cx__)->CLK.W) & (~I2C_CLK_SRC_MASK)) | (I2C_CLK_SRC)))
Nvoid I2C_SetClockSource(I2C_Struct* I2Cx, uint8_t Select);
N
N#define __I2C_SetClockPrescaler(I2Cx__, I2C_CLK_PSC__)    ((I2Cx__)->CLK.B[1] = (((I2Cx__)->CLK.B[1] & (~I2C_CLK_PSC_MASK)) | I2C_CLK_PSC__))
Nvoid I2C_SetClockPrescaler(I2C_Struct* I2Cx, uint8_t Select);
N
N#define __I2C_SetClockDivider(I2Cx__, I2C_CLK_DIV)  ((I2Cx__)->CLK.W = ((((I2Cx__)->CLK.W) & (~I2C_CLK_DIV_MASK)) | (I2C_CLK_DIV)))
Nvoid I2C_SetClockDivider(I2C_Struct* I2Cx, uint8_t Select);
N
N#define __I2C_SetSCLHighTime(I2Cx__, HighTime__)    ((I2Cx__)->CR1.B[1] = (HighTime__))
Nvoid I2C_SetSCLHighTime(I2C_Struct* I2Cx, uint8_t HighTime);
N
N#define __I2C_SetSCLLowTime(I2Cx__, LowTime__)     ((I2Cx__)->CR1.B[0] = (LowTime__))
Nvoid I2C_SetSCLLowTime(I2C_Struct* I2Cx, uint8_t LowTime);
N
N#define __I2C_SetPreDriveTime(I2Cx__, I2C_PDRV)     ((I2Cx__)->CR0.W) = (((I2Cx__)->CR0.W & I2C_PDRV_MASK) | I2C_PDRV)
Nvoid I2C_SetPreDriveTime(I2C_Struct* I2Cx, uint32_t Select);
N///@}
N
N
N
N/**
N * @name    Mode
N *          Operation Mode Setting
N */
N///@{
N#define __I2C_GeneralCallAddress_Enable(I2Cx__)     (I2Cx__)->CR0.W |= I2C_CR0_GC_EN_mask_w
N#define __I2C_GeneralCallAddress_Disable(I2Cx__)    (I2Cx__)->CR0.W &= (~I2C_CR0_GC_EN_mask_w)
Nvoid I2C_GeneralCallAddress_Cmd(I2C_Struct* I2Cx, FunctionalState State);
N
N#define __I2C_SlaveAddressDetect_Enable(I2Cx__, SADRx__)    (I2Cx__)->CR0.W |= (SADRx__)
N#define __I2C_SlaveAddressDetect_Disable(I2Cx__, SADRx__)   (I2Cx__)->CR0.W &= (~(SADRx__))
Nvoid I2C_SlaveAddressDetect_Cmd(I2C_Struct* I2Cx, uint8_t I2C_SADRx, FunctionalState State);
N
N#define __I2C_SetSlaveAddress(I2Cx__, SADR__)   (I2Cx__)->SADR.W = (SADR__)
N#define __I2C_SetSlaveAddress1(I2Cx__, SADR__)  (I2Cx__)->SADR.B[0] = (SADR__)
N#define __I2C_SetSlaveAddress2(I2Cx__, SADR__)  (I2Cx__)->SADR.B[1] = (SADR__)
Nvoid I2C_SetSlaveAddress(I2C_Struct* I2Cx, uint8_t I2C_SADRx, uint8_t Address);
N
N#if !defined(MG32_1ST)
X#if !1L
S  #define __I2C_SetSlaveAddress1Mask(__I2Cx__, __MASK__)    (__I2Cx__)->MASK.B[0] = (__MASK__)
S  void I2C_SetSlaveAddress1Mask(I2C_Struct* I2Cx, uint8_t I2C_SlaveAddress1Mask);
N#endif
N
Nuint8_t I2C_GetSlaveAddress(I2C_Struct* I2Cx, uint8_t I2C_SADRx);
N
N#define __I2C_Enable(I2Cx__)                    ((I2Cx__)->CR0.B[0] |= I2C_CR0_EN_mask_b0)
N#define __I2C_Disable(I2Cx__)                   ((I2Cx__)->CR0.B[0] &= (~I2C_CR0_EN_mask_b0))
N#define __I2C_GetEnableStatus(I2Cx__)           (((I2Cx__)->CR0.B[0] & I2C_CR0_EN_mask_b0)?ENABLE:DISABLE)
Nvoid I2C_Cmd(I2C_Struct* I2Cx, FunctionalState State);
N///@}
N
N
N
N/**
N * @name    DMA
N *          Operation Mode Setting
N */
N///@{
N#define __I2C_TXDMA_Enable(I2Cx__)              ((I2Cx__)->CR0.B[3] |= I2C_CR0_DMA_TXEN_mask_b3)
N#define __I2C_TXDMA_Disable(I2Cx__)             ((I2Cx__)->CR0.B[3] &= ~I2C_CR0_DMA_TXEN_mask_b3)
Nvoid I2C_TXDMA_Cmd( I2C_Struct* I2Cx, FunctionalState State);
N
N
N#define __I2C_RXDMA_Enable(I2Cx__)              ((I2Cx__)->CR0.B[3] |= I2C_CR0_DMA_RXEN_mask_b3)
N#define __I2C_RXDMA_Disable(I2Cx__)             ((I2Cx__)->CR0.B[3] &= ~I2C_CR0_DMA_RXEN_mask_b3)
Nvoid I2C_RXDMA_Cmd(I2C_Struct* I2Cx, FunctionalState State);
N///@}
N
N
N
N/**
N * @name    Interript & Event
N *          Interript and Event
N */
N///@{
N#define __I2C_IT_Enable(I2Cx__, I2C_ITSrc__)    ((I2Cx__)->INT.W |= (I2C_ITSrc__))
N#define __I2C_IT_Disable(I2Cx__, I2C_ITSrc__)   ((I2Cx__)->INT.W &= (~(I2C_ITSrc__)))
Nvoid I2C_IT_Config(I2C_Struct* I2Cx, uint32_t I2C_ITSrc, FunctionalState State);
N#define  I2C_IT_Cmd     I2C_IT_Config
N
N#define __I2C_ITEA_Enable(I2Cx__)               ((I2Cx__)->INT.B[0] |= I2C_CR0_EN_enable_b0)
N#define __I2C_ITEA_Disable(I2Cx__)              ((I2Cx__)->INT.B[0] &= (~I2C_CR0_EN_enable_b0))
Nvoid I2C_ITEA_Cmd(I2C_Struct* I2Cx, FunctionalState State);
N
N#define __I2C_GetITSource(I2Cx__)               ((I2Cx__)->INT.W)
Nuint32_t I2C_GetITSource(I2C_Struct* I2Cx);
N
N#define __I2C_GetAllFlagStatus(I2Cx__)          ((I2Cx__)->STA.W)
Nuint32_t I2C_GetAllFlagStatus(I2C_Struct* I2Cx);
N
N#define __I2C_GetFlagStatus(I2Cx__, I2C_FLAG__) ((((I2Cx__)->STA.W & (I2C_FLAG__)) == (I2C_FLAG__))? SET : CLR)
NDRV_Return I2C_GetFlagStatus(I2C_Struct* I2Cx, uint32_t I2C_FLAG);
N
N#define __I2C_ClearFlag(I2Cx__, I2C_FLAG__)     ((I2Cx__)->STA.W = (I2C_FLAG__))
Nvoid I2C_ClearFlag(I2C_Struct* I2Cx, uint32_t I2C_FLAG);
N
N
N
N#define __I2C_GetEventCode(I2Cx__)              ((I2Cx__)->STA2.B[0] & 0xF8)
N#define __I2C_GetStatusCode(I2Cx__)             ((I2Cx__)->STA2.B[0] & 0xF8)
Nuint8_t I2C_GetEventCode(I2C_Struct* I2Cx);
N#define I2C_GetStatusCode                       I2C_GetEventCode
N
N#define __I2C_GetEventFlag(I2Cx__)              ((I2Cx__)->STA2.B[1] & I2C_STA2_EVENTF2_mask_b1)
N#define __I2C_GetStateFlag(I2Cx__)              ((I2Cx__)->STA2.B[1] & I2C_STA2_EVENTF2_mask_b1)
NDRV_Return I2C_GetEventFlag(I2C_Struct* I2Cx);
N
N#define __I2C_ClearEventFlag(I2Cx__)            ((I2Cx__)->STA2.B[1] = I2C_STA2_EVENTF2_mask_b1)
N#define __I2C_ClearStateFlag(I2Cx__)            ((I2Cx__)->STA2.B[1] = I2C_STA2_EVENTF2_mask_b1)
Nvoid I2C_ClearEventFlag(I2C_Struct* I2Cx);
N
N#define __I2C_WaitEventFlag(I2Cx__)             while(((I2Cx__)->STA2.B[1] & I2C_STA2_EVENTF2_mask_b1) == 0)
N
N///@}
N
N
N
N/**
N * @name    Data transmission
N *          Data transmission
N */
N///@{
N
N#define __I2C_GetSlaveMatchAddress(I2Cx__)      ((I2Cx__)->SAC.B[0])
Nuint8_t I2C_GetSlaveMatchAddress(I2C_Struct* I2Cx);
N
N//#define __I2C_WriteTxData(I2C__, TxData__, TxDataLenth__)   ((I2Cx__)->CR2.B[1] = (TxDataLenth__)); ((I2Cx__)->DAT.W = (TxData__))
N//#define __I2C_SendData(I2Cx__, TxData__, TxDataLenth__)     ((I2Cx__)->CR2.B[1] = (TxDataLenth__)); ((I2Cx__)->DAT.W = (TxData__))
N#define __I2C_WriteTxSBUF(I2Cx__, TxData__)     ((I2Cx__)->SBUF.B[0] = (TxData__))
N#define __I2C_SendSBUF(I2Cx__, TxData__)        ((I2Cx__)->SBUF.B[0] = (TxData__))
Nvoid I2C_SendSBUF(I2C_Struct* I2Cx, uint8_t TxData);
N#define I2C_SendTxData                          I2C_SendSBUF
N
N//#define __I2C_ReadRxData(I2C__)                 ((I2Cx__)->DAT.W)
N//#define __I2C_ReceiveData(I2Cx__)               ((I2Cx__)->DAT.W)
N#define __I2C_ReadRxSBUF(I2Cx__)                ((I2Cx__)->SBUF.B[0])
N#define __I2C_ReceiveSBUF(I2Cx__)               ((I2Cx__)->SBUF.B[0])
Nuint8_t I2C_ReceiveSBUF(I2C_Struct* I2Cx);
N#define I2C_ReceiveRxData                       I2C_ReceiveSBUF
N
N///@}
N
N
N
N/**
N * @name    TimeOut
N *          TimeOut
N */
N///@{
N
N#define __I2C_SetTimeOutClockSource(I2Cx__, I2C_TMO_CKS__)      ((I2Cx__)->CLK.W = ((((I2Cx__)->CLK.W) & (~I2C_TMO_CKS_MASK)) | (I2C_TMO_CKS__)))
N
N#define __I2C_SetTimeOutCount(I2Cx__, I2C_TMO_CNT__)            ((I2Cx__)->TMOUT.B[1] = (I2C_TMO_CNT__))
N
N#define __I2C_SetTimeOutDetectionMode(I2Cx__, I2C_TMO_MDS__)    ((I2Cx__)->TMOUT.W = ((((I2Cx__)->TMOUT.W) & (~I2C_TMO_MDS_MASK)) | (I2C_TMO_MDS__)))
N
N#define __I2C_TMO_Enable(I2Cx__)                                ((I2Cx__)->TMOUT.W |= I2C_TMOUT_TMO_EN_mask_w)
N#define __I2C_TMO_Disable(I2Cx__)                               ((I2Cx__)->TMOUT.W &= (~I2C_TMOUT_TMO_EN_mask_w))
N
N///@}
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 46 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_IWDT_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_IWDT_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_IWDT_DRV.H
N *
N * @brief       This is the C code format driver head file for the IWDT module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.10
N * @date        2018/01/31
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2018 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par 		Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_IWDT.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_IWDT.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_IWDT.h
N *
N * @brief       MG32x02z IWDT Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_IWDT_H
N#define _MG32x02z_IWDT_H
N#define _MG32x02z_IWDT_H_VER                        3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_IWDT_H_VER)
S    #error "MG32x02z_IWDT_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      IWDT_Struct
N *              IWDT  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TF            :1;     //[1] IWDT timer timeout interrupt flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TF            :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  EW0F          :1;     //[2] IWDT early wakeup-0 flag
X            volatile uint8_t  EW0F          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  EW1F          :1;     //[3] IWDT early wakeup-1 flag
X            volatile uint8_t  EW1F          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  IWDT status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TIE           :1;     //[1] IWDT timer timeout interrupt enable.
X            volatile uint8_t  TIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EW0_IE        :1;     //[2] IWDT early wakeup-0 interrupt enable.
X            volatile uint8_t  EW0_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EW1_IE        :1;     //[3] IWDT early wakeup-1 interrupt enable.
X            volatile uint8_t  EW1_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  IWDT interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_DIV        :4;     //[7..4] IWDT internal clock CK_IWDT_INT input divider
X            volatile uint8_t  CK_DIV        :4;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N                                        //0x5 = DIV32 : divided by 32
N                                        //0x6 = DIV64 : divided by 64
N                                        //0x7 = DIV128 : divided by 128
N                                        //0x8 = DIV256 : divided by 256 
N                                        //0x9 = DIV512 : divided by 512
N                                        //0xA = DIV1024 : divided by 1024
N                                        //0xB = DIV2048 : divided by 2048
N                                        //0xC = DIV4096 : divided by 4096
N                                        //0xD = Reserved
N                                        //0xE = Reserved
N                                        //0xF = Reserved
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  IWDT clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] IWDT key register and counter reload enable control
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __IO uint16_t LOCK          :16;    //[31..16] IWDT lock register
X            volatile uint16_t LOCK          :16;    
N                                        //0 = Unlocked
N                                        //1 = Locked
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  IWDT write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] IWDT function enable bit
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  TF_WPEN       :1;     //[8] IWDT detect IWDT_TF flag wakeup from STOP mode enable bit.
X            volatile uint8_t  TF_WPEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  EW0_WPEN      :1;     //[10] IWDT detect IWDT_EW0F flag wakeup from STOP mode enable bit.
X            volatile uint8_t  EW0_WPEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EW1_WPEN      :1;     //[11] IWDT detect IWDT_EW1F flag wakeup from STOP mode enable bit.
X            volatile uint8_t  EW1_WPEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  IWDT control register 0 */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x14]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  CNT           :8;     //[7..0] IWDT counter value register.
X            volatile const  uint8_t  CNT           :8;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x18]  IWDT counter register */
N
N} IWDT_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        IWDT  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define IWDT_Base                       ((uint32_t)0x5D000000)              /*!< Independent Watch Dog Timer Control */
N#define IWDT                            ((IWDT_Struct*) IWDT_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        IWDT  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        IWDT_STA  [register's definitions]
N *              Offset[0x00]  IWDT status register (0x5D000000)
N ******************************************************************************
N */
N///@{
N#define IWDT_STA_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of IWDT_STA */
N#define IWDT_STA_EW1F_mask_w                        ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define IWDT_STA_EW1F_mask_h0                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define IWDT_STA_EW1F_mask_b0                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define IWDT_STA_EW1F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define IWDT_STA_EW1F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define IWDT_STA_EW1F_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define IWDT_STA_EW1F_happened_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define IWDT_STA_EW1F_happened_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define IWDT_STA_EW1F_happened_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define IWDT_STA_EW0F_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define IWDT_STA_EW0F_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define IWDT_STA_EW0F_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define IWDT_STA_EW0F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define IWDT_STA_EW0F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define IWDT_STA_EW0F_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define IWDT_STA_EW0F_happened_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define IWDT_STA_EW0F_happened_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define IWDT_STA_EW0F_happened_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define IWDT_STA_TF_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define IWDT_STA_TF_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define IWDT_STA_TF_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define IWDT_STA_TF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define IWDT_STA_TF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define IWDT_STA_TF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define IWDT_STA_TF_happened_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define IWDT_STA_TF_happened_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define IWDT_STA_TF_happened_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        IWDT_INT  [register's definitions]
N *              Offset[0x04]  IWDT interrupt enable register (0x5D000004)
N ******************************************************************************
N */
N///@{
N#define IWDT_INT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of IWDT_INT */
N#define IWDT_INT_EW1_IE_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define IWDT_INT_EW1_IE_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define IWDT_INT_EW1_IE_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define IWDT_INT_EW1_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_INT_EW1_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_INT_EW1_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_INT_EW1_IE_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_INT_EW1_IE_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_INT_EW1_IE_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define IWDT_INT_EW0_IE_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define IWDT_INT_EW0_IE_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define IWDT_INT_EW0_IE_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define IWDT_INT_EW0_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_INT_EW0_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_INT_EW0_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_INT_EW0_IE_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_INT_EW0_IE_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_INT_EW0_IE_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define IWDT_INT_TIE_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define IWDT_INT_TIE_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define IWDT_INT_TIE_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define IWDT_INT_TIE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_INT_TIE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_INT_TIE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_INT_TIE_enable_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_INT_TIE_enable_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_INT_TIE_enable_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        IWDT_CLK  [register's definitions]
N *              Offset[0x08]  IWDT clock source register (0x5D000008)
N ******************************************************************************
N */
N///@{
N#define IWDT_CLK_default                            ((uint32_t)0x000000C0)  /*!< Reg Reset Default Value */
N
N/* Bit fields of IWDT_CLK */
N#define IWDT_CLK_CK_DIV_mask_w                      ((uint32_t)0x000000F0)  /*!< Bit Mask of 32bit */
N#define IWDT_CLK_CK_DIV_mask_h0                     ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define IWDT_CLK_CK_DIV_mask_b0                     ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define IWDT_CLK_CK_DIV_div1_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define IWDT_CLK_CK_DIV_div1_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define IWDT_CLK_CK_DIV_div1_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define IWDT_CLK_CK_DIV_div2_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define IWDT_CLK_CK_DIV_div2_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define IWDT_CLK_CK_DIV_div2_b0                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define IWDT_CLK_CK_DIV_div4_w                      ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define IWDT_CLK_CK_DIV_div4_h0                     ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define IWDT_CLK_CK_DIV_div4_b0                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define IWDT_CLK_CK_DIV_div8_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define IWDT_CLK_CK_DIV_div8_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define IWDT_CLK_CK_DIV_div8_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define IWDT_CLK_CK_DIV_div16_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define IWDT_CLK_CK_DIV_div16_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define IWDT_CLK_CK_DIV_div16_b0                    ((uint8_t )0x40)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N#define IWDT_CLK_CK_DIV_div32_w                     ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):DIV32 of 32bit */
N#define IWDT_CLK_CK_DIV_div32_h0                    ((uint16_t)0x0050)      /*!< Bit Value =(0x5):DIV32 of 16bit */
N#define IWDT_CLK_CK_DIV_div32_b0                    ((uint8_t )0x50)        /*!< Bit Value =(0x5):DIV32 of 8bit */
N#define IWDT_CLK_CK_DIV_div64_w                     ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):DIV64 of 32bit */
N#define IWDT_CLK_CK_DIV_div64_h0                    ((uint16_t)0x0060)      /*!< Bit Value =(0x6):DIV64 of 16bit */
N#define IWDT_CLK_CK_DIV_div64_b0                    ((uint8_t )0x60)        /*!< Bit Value =(0x6):DIV64 of 8bit */
N#define IWDT_CLK_CK_DIV_div128_w                    ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):DIV128 of 32bit */
N#define IWDT_CLK_CK_DIV_div128_h0                   ((uint16_t)0x0070)      /*!< Bit Value =(0x7):DIV128 of 16bit */
N#define IWDT_CLK_CK_DIV_div128_b0                   ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIV128 of 8bit */
N#define IWDT_CLK_CK_DIV_div256_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(0x8):DIV256 of 32bit */
N#define IWDT_CLK_CK_DIV_div256_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(0x8):DIV256 of 16bit */
N#define IWDT_CLK_CK_DIV_div256_b0                   ((uint8_t )0x80)        /*!< Bit Value =(0x8):DIV256 of 8bit */
N#define IWDT_CLK_CK_DIV_div512_w                    ((uint32_t)0x00000090)  /*!< Bit Value =(0x9):DIV512 of 32bit */
N#define IWDT_CLK_CK_DIV_div512_h0                   ((uint16_t)0x0090)      /*!< Bit Value =(0x9):DIV512 of 16bit */
N#define IWDT_CLK_CK_DIV_div512_b0                   ((uint8_t )0x90)        /*!< Bit Value =(0x9):DIV512 of 8bit */
N#define IWDT_CLK_CK_DIV_div1024_w                   ((uint32_t)0x000000A0)  /*!< Bit Value =(0xA):DIV1024 of 32bit */
N#define IWDT_CLK_CK_DIV_div1024_h0                  ((uint16_t)0x00A0)      /*!< Bit Value =(0xA):DIV1024 of 16bit */
N#define IWDT_CLK_CK_DIV_div1024_b0                  ((uint8_t )0xA0)        /*!< Bit Value =(0xA):DIV1024 of 8bit */
N#define IWDT_CLK_CK_DIV_div2048_w                   ((uint32_t)0x000000B0)  /*!< Bit Value =(0xB):DIV2048 of 32bit */
N#define IWDT_CLK_CK_DIV_div2048_h0                  ((uint16_t)0x00B0)      /*!< Bit Value =(0xB):DIV2048 of 16bit */
N#define IWDT_CLK_CK_DIV_div2048_b0                  ((uint8_t )0xB0)        /*!< Bit Value =(0xB):DIV2048 of 8bit */
N#define IWDT_CLK_CK_DIV_div4096_w                   ((uint32_t)0x000000C0)  /*!< Bit Value =(0xC):DIV4096 of 32bit */
N#define IWDT_CLK_CK_DIV_div4096_h0                  ((uint16_t)0x00C0)      /*!< Bit Value =(0xC):DIV4096 of 16bit */
N#define IWDT_CLK_CK_DIV_div4096_b0                  ((uint8_t )0xC0)        /*!< Bit Value =(0xC):DIV4096 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        IWDT_KEY  [register's definitions]
N *              Offset[0x0C]  IWDT write protected Key register (0x5D00000C)
N ******************************************************************************
N */
N///@{
N#define IWDT_KEY_default                            ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of IWDT_KEY */
N#define IWDT_KEY_LOCK_mask_w                        ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define IWDT_KEY_LOCK_mask_h1                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define IWDT_KEY_LOCK_unlocked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unlocked of 32bit */
N#define IWDT_KEY_LOCK_unlocked_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Unlocked of 16bit */
N#define IWDT_KEY_LOCK_unlocked_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Unlocked of 8bit */
N#define IWDT_KEY_LOCK_locked_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Locked of 32bit */
N#define IWDT_KEY_LOCK_locked_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Locked of 16bit */
N#define IWDT_KEY_LOCK_locked_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Locked of 8bit */
N
N#define IWDT_KEY_KEY_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define IWDT_KEY_KEY_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define IWDT_KEY_KEY_unprotected_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define IWDT_KEY_KEY_unprotected_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define IWDT_KEY_KEY_unprotected_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define IWDT_KEY_KEY_protected_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define IWDT_KEY_KEY_protected_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define IWDT_KEY_KEY_protected_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        IWDT_CR0  [register's definitions]
N *              Offset[0x10]  IWDT control register 0 (0x5D000010)
N ******************************************************************************
N */
N///@{
N#define IWDT_CR0_default                            ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of IWDT_CR0 */
N#define IWDT_CR0_EW1_WPEN_mask_w                    ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define IWDT_CR0_EW1_WPEN_mask_h0                   ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define IWDT_CR0_EW1_WPEN_mask_b1                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define IWDT_CR0_EW1_WPEN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_CR0_EW1_WPEN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_CR0_EW1_WPEN_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_CR0_EW1_WPEN_enable_w                  ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_CR0_EW1_WPEN_enable_h0                 ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_CR0_EW1_WPEN_enable_b1                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define IWDT_CR0_EW0_WPEN_mask_w                    ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define IWDT_CR0_EW0_WPEN_mask_h0                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define IWDT_CR0_EW0_WPEN_mask_b1                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define IWDT_CR0_EW0_WPEN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_CR0_EW0_WPEN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_CR0_EW0_WPEN_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_CR0_EW0_WPEN_enable_w                  ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_CR0_EW0_WPEN_enable_h0                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_CR0_EW0_WPEN_enable_b1                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define IWDT_CR0_TF_WPEN_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define IWDT_CR0_TF_WPEN_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define IWDT_CR0_TF_WPEN_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define IWDT_CR0_TF_WPEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_CR0_TF_WPEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_CR0_TF_WPEN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_CR0_TF_WPEN_enable_w                   ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_CR0_TF_WPEN_enable_h0                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_CR0_TF_WPEN_enable_b1                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define IWDT_CR0_EN_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define IWDT_CR0_EN_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define IWDT_CR0_EN_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define IWDT_CR0_EN_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define IWDT_CR0_EN_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define IWDT_CR0_EN_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define IWDT_CR0_EN_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define IWDT_CR0_EN_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define IWDT_CR0_EN_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        IWDT_CNT  [register's definitions]
N *              Offset[0x18]  IWDT counter register (0x5D000018)
N ******************************************************************************
N */
N///@{
N#define IWDT_CNT_default                            ((uint32_t)0x000000FF)  /*!< Reg Reset Default Value */
N
N/* Bit fields of IWDT_CNT */
N#define IWDT_CNT_CNT_mask_w                         ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define IWDT_CNT_CNT_mask_h0                        ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define IWDT_CNT_CNT_mask_b0                        ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define IWDT_CNT_CNT_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define IWDT_CNT_CNT_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define IWDT_CNT_CNT_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_IWDT_H
N
N/*----------------------------------------------------------------------------*/
N/*                        End of file MG32x02z_IWDT.h                         */
N/*----------------------------------------------------------------------------*/
L 31 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_IWDT_DRV.h" 2
N
N#ifndef _MG32x02z_IWDT_DRV_H
N/*!< _MG32x02z_IWDT_DRV_H */ 
N#define _MG32x02z_IWDT_DRV_H
N
N 
N/*! @name 
N*/
N/* @{ */ 
N#define IWDT_EW1_WPEN    IWDT_CR0_EW1_WPEN_mask_w   /*!< IWDT detect IWDT_EW1F flag wakeup from STOP mode enable bit */
N#define IWDT_EW0_WPEN    IWDT_CR0_EW0_WPEN_mask_w   /*!< IWDT detect IWDT_EW0F flag wakeup from STOP mode enable bit */
N#define IWDT_TF_WPEN     IWDT_CR0_TF_WPEN_mask_w    /*!< IWDT detect IWDT_TF flag wakeup from STOP mode enable bit */
N
N                
N#define IWDT_EW1F   IWDT_STA_EW1F_mask_w                /*!< IWDT early wakeup-1 flag */
N#define IWDT_EW0F   IWDT_STA_EW0F_mask_w                /*!< IWDT early wakeup-0 flag */
N#define IWDT_TF     IWDT_STA_TF_mask_w                  /*!< IWDT timer timeout interrupt flag */
N#define IWDT_ALLF   (IWDT_EW1F | IWDT_EW0F | IWDT_TF)   /*!< IWDT all flag */
N
N#define IWDT_INT_EW1    IWDT_INT_EW1_IE_mask_w  /*!< IWDT early wakeup-1 interrupt enable */
N#define IWDT_INT_EW0    IWDT_INT_EW0_IE_mask_w  /*!< IWDT early wakeup-0 interrupt enable */
N#define IWDT_INT_TF     IWDT_INT_TIE_mask_w     /*!< IWDT timer timeout interrupt enable */
N/* @} */
N
N
N/*! @enum   IWDT_DIVS_TypeDef
N    @brief  IWDT clcok divider selection.
N*/
Ntypedef enum   
N{
N    IWDT_DIV_1       = 0,   /*!< Select clock divided by 1 */
N    IWDT_DIV_2       = 1,   /*!< Select clock divided by 2 */
N    IWDT_DIV_4       = 2,   /*!< Select clock divided by 4 */
N    IWDT_DIV_8       = 3,   /*!< Select clock divided by 8 */
N    IWDT_DIV_16      = 4,   /*!< Select clock divided by 16 */
N    IWDT_DIV_32      = 5,   /*!< Select clock divided by 32 */
N    IWDT_DIV_64      = 6,   /*!< Select clock divided by 64 */
N    IWDT_DIV_128     = 7,   /*!< Select clock divided by 128 */
N    IWDT_DIV_256     = 8,   /*!< Select clock divided by 256 */
N    IWDT_DIV_512     = 9,   /*!< Select clock divided by 512 */
N    IWDT_DIV_1024    = 10,  /*!< Select clock divided by 1024 */
N    IWDT_DIV_2048    = 11,  /*!< Select clock divided by 2048 */
N    IWDT_DIV_4096    = 12   /*!< Select clock divided by 4096 */
N}IWDT_DIVS_TypeDef;
N                
N
N/**
N * @name	Function announce
N *
N */ 
Nvoid IWDT_Divider_Select (IWDT_DIVS_TypeDef IWDT_DIVS);
N
Nuint8_t IWDT_GetCounter (void);
Nvoid IWDT_RefreshCounter (void);
N
Nvoid IWDT_StopModeWakeUpEvent_Config (uint32_t IWDT_WK, FunctionalState NewState);
N
Nvoid IWDT_Cmd (FunctionalState NewState);
N
Nuint32_t IWDT_GetAllFlagStatus (void);
NDRV_Return IWDT_GetSingleFlagStatus (uint32_t IWDT_ITSrc);
Nvoid IWDT_ClearFlag (uint32_t IWDT_ITSrc);
Nvoid IWDT_IT_Config (uint32_t IWDT_ITSrc, FunctionalState NewState);
N
N 
N#endif  //_MG32x02z_IWDT_DRV_H
N
N
L 47 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_MEM_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_MEM_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_MEM_DRV.h
N *
N * @brief       This is the C code format driver head file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.16
N * @date        2020/10/20
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N
N#ifndef __MG32x02z_MEM_DRV_H
N#define __MG32x02z_MEM_DRV_H
N//#define __MG32x02z_MEM_DRV_H_VER                            0.01
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_MEM.h"
N#include "MG32x02z_CFG.h"
N
N/*===============================================================
N *	By MEM Define
N *==============================================================*/
N/**
N * @name	Flash Memory Reset Enable
N *   		Flash Memory Reset Enable
N */ 
N///@{ 
N#define MEM_RST_RPRE            MEM_INT_RPE_RE_mask_w   /*!<    */
N#define MEM_RST_WPRE            MEM_INT_WPE_RE_mask_w   /*!<    */
N#define MEM_RST_IARE            MEM_INT_IAE_RE_mask_w   /*!<    */
N///@}
N
N/**
N * @name	Flash Memory Interrupt Enable
N *   		Flash Memory Interrupt Enable
N */ 
N///@{ 
N#define MEM_IT_RPIE             MEM_INT_RPE_IE_mask_w   /*!<    */
N#define MEM_IT_WPIE             MEM_INT_WPE_IE_mask_w   /*!<    */
N#define MEM_IT_IAIE             MEM_INT_IAE_IE_mask_w   /*!<    */
N#define MEM_IT_EOPIE            MEM_INT_EOP_IE_mask_w   /*!<    */
N#define MEM_IT_IEA              MEM_INT_IEA_mask_w      /*!<    */
N///@}
N
N/**
N * @name    StateFlag
N *          Flag State 
N */ 
N///@{  
N#define MEM_FLAG_IAPSEF         MEM_STA_IAPSEF_mask_w   /*!<    */
N#define MEM_FLAG_RPEF           MEM_STA_RPEF_mask_w     /*!<    */
N#define MEM_FLAG_WPEF           MEM_STA_WPEF_mask_w     /*!<    */
N#define MEM_FLAG_IAEF           MEM_STA_IAEF_mask_w     /*!<    */
N#define MEM_FLAG_EOPF           MEM_STA_EOPF_mask_w     /*!<    */
N#define MEM_FLAG_FBUSYF         MEM_STA_FBUSYF_mask_w   /*!<    */
N///@}
N
N/**
N * @name	MEM_CMD
N *   		Flash Read Write Enable
N */ 
N///@{  
N#define MEM_ACCESS_AP_WRITE         MEM_CR1_AP_WEN_mask_w   /*!<    */
N#define MEM_ACCESS_IAP_EXECUTE      MEM_CR1_IAP_EXEC_mask_w /*!<    */
N#define MEM_ACCESS_IAP_WRITE        MEM_CR1_IAP_WEN_mask_w  /*!<    */
N#define MEM_ACCESS_ISPD_READ        MEM_CR1_ISPD_REN_mask_w /*!<    */
N#define MEM_ACCESS_ISPD_WRITE       MEM_CR1_ISPD_WEN_mask_w /*!<    */
N#define MEM_ACCESS_ISP_READ         MEM_CR1_ISP_REN_mask_w  /*!<    */
N#define MEM_ACCESS_ISP_WRITE        MEM_CR1_ISP_WEN_mask_w  /*!<    */
N
N///@}
N
N/**
N * @name	Flash Wait Time
N *   		Flash Access Time, Flash Wait State
N */ 
N///@{ 
N#define MEM_FWAIT_ZERO   MEM_CR0_FWAIT_zero_w    /*!< 0Hz > Sysclk >= 25MHz */
N#define MEM_FWAIT_ONE    MEM_CR0_FWAIT_one_w     /*!< 25MHz > Sysclk >= 50MHz */
N#define MEM_FWAIT_TWO    MEM_CR0_FWAIT_two_w     /*!< 50MHz > Sysclk >= 75MHz */
N
N///@}
N
N/**
N * @name	Boot Select
N *   		Flash Access Time, Flash Wait State
N */ 
N///@{ 
N#define MEM_BOOT_MASK   MEM_CR0_BOOT_MS_mask_w
N#define MEM_BOOT_AP     MEM_CR0_BOOT_MS_application_flash_w     /*!<    */
N#define MEM_BOOT_ISP    MEM_CR0_BOOT_MS_boot_flash_w            /*!<    */
N#define MEM_BOOT_SRAM   MEM_CR0_BOOT_MS_embedded_sram_w         /*!<    */
N
N///@}
N
N
N/**
N * @name	Flash Write Mode
N *   		Flash Access Time, Flash Wait State
N */ 
N///@{ 
N#define MEM_MODE_NONE           0x00000000  /*!<    */
N#define MEM_MODE_STANDBY        0x00000000  /*!<    */
N#define MEM_MODE_ERASE          0x00000020  /*!<    */
N#define MEM_MODE_PROGRAM        0x00000010  /*!<    */
N#define MEM_MODE_APERASE        0x00000020  /*!<    */
N#define MEM_MODE_APPROGRAM      0x00000010  /*!<    */
N#define MEM_MODE_IAPERASE       0x00000020  /*!<    */
N#define MEM_MODE_IAPPROGRAM     0x00000010  /*!<    */
N#define MEM_MODE_ISPDERASE      0x00000020  /*!<    */
N#define MEM_MODE_ISPDPROGRAM    0x00000010  /*!<    */
N#define MEM_MODE_ISPERASE       0x00000060  /*!<    */
N#define MEM_MODE_ISPPROGRAM     0x00000050  /*!<    */
N
N///@}
N
N
N
N/******************************************************************************
N*   Enum
N******************************************************************************/ 
N
N
N
N/**
N * @enum	BootSelect
N *   		Flash Access Time, Flash Wait State
N */ 
N///@{ 
Ntypedef enum {
N    AP_Space = MEM_CR0_BOOT_MS_application_flash_w,     // 0Hz > Sysclk >= 25MHz
X    AP_Space = ((uint32_t)0x00000000),     
N    ISP_Space = MEM_CR0_BOOT_MS_boot_flash_w,           // 25MHz > Sysclk >= 50MHz
X    ISP_Space = ((uint32_t)0x00010000),           
N    SRAM_Space = MEM_CR0_BOOT_MS_embedded_sram_w        // 50MHz > Sysclk >= 75MHz
X    SRAM_Space = ((uint32_t)0x00020000)        
N}BootSelect;
N///@}
N
N/** 
N * @enum		MEMAccessMode
N * @brief		Flash Write Access Mode.
N * 				Some details about the Test class.
N */       
Ntypedef enum {
N    None = 0x00000000,
N    StandBy = 0x00000000,
N    Erase = 0x00000020,
N    Program = 0x00000010,
N    APErase = 0x00000020,
N    APProgram = 0x00000010,
N    IAPErase = 0x00000020,
N    IAPProgram = 0x00000010,
N    ISPDErase = 0x00000020,
N    ISPDProgram = 0x00000010,
N    ISPErase = 0x00000060,
N    ISPProgram = 0x00000050
N}MEMAccessMode;
N
N/** 
N * @enum		UnProtectSKey
N * @brief		Single Write Access or Multiple Write sequential key
N *
N */
Ntypedef enum {
N    NoneSKey = 0x0000,
N    APSingleSKey = 0x46B9,
N    APMultipleSKey = 0x46BE,
N    IAPSingleSKey = 0x46B9,
N    IAPMultipleSKey = 0x46BE,
N    ISPDSingleSKey = 0x46B9,
N    ISPDMultipleSKey = 0x46BE,
N    ISPSingleSKey = 0xB955,
N    ISPMultipleSKey = 0xBEAA,
N}UnProtectSKey;
N
N
N
N/******************************************************************************
N*   Struct
N******************************************************************************/
N
N
N
N/******************************************************************************
N*   Function
N******************************************************************************/ 
N
N
N/** 
N * @name    Memory Register Protect and UnProtect
N *
N */ 
N///@{
N
N#define __MEM_UnProtect()                       (MEM->KEY.MBIT.KEY = 0xA217)
N#define __MEM_Protect()                         (MEM->KEY.MBIT.KEY = 0x0000)
N#define __MEM_GetProtectStatus()                (MEM->KEY.MBIT.KEY)
N
N
N
N#define __MEM_UnProtect2()                      (MEM->KEY.MBIT.KEY2 = 0xA217)
N#define __MEM_Protect2()                        (MEM->KEY.MBIT.KEY2 = 0x0000)
N#define __MEM_GetProtect2Status()               (MEM->KEY.MBIT.KEY2)
N
N///@}
N
N
N
N/** 
N * @name    Memory Access Status Flag 
N *
N */ 
N///@{
N
N#define __MEM_GetAllFlagStatus()                (MEM->STA.W)
Nuint32_t MEM_GetAllFlagStatus(void);
N
N#define __MEM_GetFlagStatus(MEM_FLAG)           ((((MEM->STA.W) & (MEM_FLAG)) == (MEM_FLAG)) ? SET : CLR)
NDRV_Return MEM_GetFlagStatus(uint32_t MEM_FLAG);
N
N#define __MEM_ClearFlag(MEM_FLAG)               (MEM->STA.W = (MEM_FLAG))
Nvoid MEM_ClearFlag(uint32_t MEM_FLAG);
N
N///@}
N
N
N
N/** 
N * @name    Memory controller enable.
N *
N */ 
N///@{
N
N#define __MEM_Enable()                          (MEM->CR0.W |= MEM_CR0_EN_mask_w)
N#define __MEM_Disable()                         (MEM->CR0.W &= (~MEM_CR0_EN_mask_w))
Nvoid MEM_Cmd(FunctionalState State);
N
N///@}
N
N
N
N/** 
N * @name    Flash Read Wait Time
N *
N */ 
N///@{
N
N#define __MEM_GetFlashWaitState()               (MEM->CR0.W & MEM_CR0_FWAIT_mask_w)
N#define __MEM_SetFlashWaitState(MEM_FWAIT)      (MEM->CR0.W = (MEM->CR0.W & (~MEM_CR0_FWAIT_mask_w)) | (MEM_FWAIT))
Nvoid MEM_SetFlashWaitState(uint32_t MEM_FWAIT);
N
N///@}
N
N
N
N/** 
N * @name    System Boot Memory
N *
N */ 
N///@{
N
N#define __MEM_SetBootSelect(MEM_BOOT)           (MEM->CR0.W = (MEM->CR0.W & (~MEM_BOOT_MASK)) | (MEM_BOOT))
N#define __MEM_GetBootSelectState()              (MEM->CR0.W & MEM_CR0_BOOT_MS_mask_w)
N
N///@}
N
N
N
N/** 
N * @name    Memory Access Interrupt
N *
N */ 
N///@{
N
N#define __MEM_IT_Enable(MEM_IT)                 (MEM->INT.W |= (MEM_IT))
N#define __MEM_IT_Disable(MEM_IT)                (MEM->INT.W &= (~(MEM_IT)))
Nvoid MEM_IT_Cmd(uint32_t MEM_IT, FunctionalState State);
N
N#define __MEM_ITEA_Enable()                     (MEM->INT.W |= MEM_IT_IEA)
N#define __MEM_ITEA_Disable()                    (MEM->INT.W &= (~MEM_IT_IEA))
Nvoid MEM_ITEA_Cmd(FunctionalState State);
N
N///@}
N
N
N
N/**
N * @name	Error Reset
N *        Enable or Disable Access Error Reset
N */ 
N///@{
N
N#define __MEM_GetAllResetSource()               (MEM->INT.W & MEM_RST_MASK)
N#define __MEM_GetResetSource(MEM_RST)           (MEM->INT.W & (MEM_RST))
N#define __MEM_ErrorReset_Enable(MEM_RST)        (MEM->INT.W |= (MEM_RST))
N#define __MEM_ErrorReset_Disable(MEM_RST)       (MEM->INT.W &= (~(MEM_RST)))
Nvoid MEM_ErrorReset_Cmd(uint32_t Reset, FunctionalState State);
N
N///@}
N
N
N
N/** 
N * @name    Memory Access Error Hard Fault
N *
N */ 
N///@{
N
N#define __MEM_GetHardFaultState()               (((MEM->CR0.W & MEM_CR0_HF_EN_mask_w) != 0)? SET : CLR)
N#define __MEM_ErrorHardFault_Enable()           (MEM->CR0.W |= MEM_CR0_HF_EN_mask_w)
N#define __MEM_ErrorHardFault_Disable()          (MEM->CR0.W &= (~MEM_CR0_HF_EN_mask_w))
Nvoid MEM_ErrorHardFault_Cmd(FunctionalState State);
N
N///@}
N
N
N
N/** 
N * @name    Flash Write of CPU Hold
N *
N */ 
N///@{
N
N#define __MEM_WriteFlashHold_Enable()           (MEM->CR0.W &= (~MEM_CR0_HOLD_mask_w))
N#define __MEM_WriteFlashHold_Disable()          (MEM->CR0.W |= MEM_CR0_HOLD_mask_w)
Nvoid MEM_WriteFlashHold_Cmd(FunctionalState State);
N
N///@}
N
N
N
N/** 
N * @name    MEM Flash Read, Write and Execute Access
N *
N */ 
N///@{
N
N#define __MEM_GetAllAccessState                 (MEM->CR1.W & (MEM_ACCESS_AP_WRITE | MEM_ACCESS_IAP_WRITE | MEM_ACCESS_ISPD_READ |  MEM_ACCESS_ISPD_WRITE | MEM_ACCESS_ISP_READ | MEM_ACCESS_ISP_WRITE | MEM_ACCESS_IAP_EXECUTE))
Nuint32_t MEM_GetAllAccessState(void);
N
N#define __MEM_GetAccessState(MEM_ACCESS)        (((MEM->CR1.W & (MEM_ACCESS)) == (MEM_ACCESS)) ? SET : CLR)
NDRV_Return MEM_GetAccessState(uint32_t MEM_ACCESS);
N
N#define __MEM_Access_Enable(MEM_ACCESS)         (MEM->CR1.W |= (MEM_ACCESS))
N#define __MEM_Access_Disable(MEM_ACCESS)        (MEM->CR1.W &= (~(MEM_ACCESS)))
Nvoid MEM_Access_Cmd(uint32_t MEM_ACCESS, FunctionalState State);
N
N#define __MEM_SetWriteMode(AccessMode)            (MEM->CR0.W = (MEM->CR0.W & (~MEM_CR0_MDS_mask_w)) | (AccessMode))
Nvoid MEM_SetWriteMode(MEMAccessMode AccessMode);            
N
N///@}
N
N
N
N/** 
N * @name    AP / IAP / ISPD Write 
N *
N */ 
N///@{
N
N#define __MEM_GetSequentialKeyStatus()          (MEM->SKEY.B[0])
N#define __MEM_SingleWriteUnProtect()            MEM->SKEY.B[0] = 0x46; MEM->SKEY.H[0] = 0xB9
N#define __MEM_MultipleWriteUnProtect()          MEM->SKEY.B[0] = 0x46; MEM->SKEY.H[0] = 0xBE
N#define __MEM_MultipleWriteProtect()            (MEM->SKEY.B[0] = 0)
Nvoid MEM_SetWriteUnProtect(UnProtectSKey SKEY);
N
Nvoid MEM_SetSinglePageEraseUnProtect(void);
Nvoid MEM_SetMultiplePageEraseUnProtect(void);
Nvoid MEM_SetSingleProgramUnProtect(void);
Nvoid MEM_SetMultipleProgramUnProtect(void);
Nvoid MEM_SetMultipleWriteProtect(void);
N
N///@}
N
N
N
N/** 
N * @name    AP Write
N *
N */ 
N///@{
N
N#define __MEM_APWrite_Enable()                  (MEM->CR1.W |= MEM_ACCESS_AP_WRITE)
N#define __MEM_APWrite_Disable()                 (MEM->CR1.W &= (~MEM_ACCESS_AP_WRITE))
NDRV_Return MEM_APWrite_Cmd(FunctionalState State);
N
N#define MEM_SetAPSinglePageEraseUnProtect       MEM_SetSinglePageEraseUnProtect    /*!< ____ */
N#define MEM_SetAPMultiplePageEraseUnProtect     MEM_SetMultiplePageEraseUnProtect  /*!< ____ */
N#define MEM_SetAPSingleProgramUnProtect         MEM_SetSingleProgramUnProtect      /*!< ____ */
N#define MEM_SetAPMultipleProgramUnProtect       MEM_SetMultipleProgramUnProtect    /*!< ____ */
N
N///@}
N
N
N
N/** 
N * @name    IAP Memory Size
N *
N */ 
N///@{
N
N#define __MEM_GetIAPSize()                      (MEM->IAPSZ.H[0] << 2)
Nuint32_t MEM_GetIAPSize(void);
N
N#define __MEM_SetIAPSize(IAPSize)               (MEM->IAPSZ.H[0] = (IAPSize >> 2))
NDRV_Return MEM_SetIAPSize(uint32_t IAPSize);
N
N#define __MEM_GetIAPSizeLockState()             (((MEM->CR0.W & MEM_CR0_IAP_AEN_mask_w) != 0) ? SET : CLR)
N#define __MEM_SetIAPSizeLock()                  (MEM->CR0.W &= (~MEM_CR0_IAP_AEN_mask_w))
NDRV_Return MEM_SetIAPSizeLock(void);
N
N///@}
N
N
N
N/** 
N * @name    IAP Code Execute
N *
N */ 
N///@{
N
N#define __MEM_GetIAPExecuteCodeState()          (MEM->CR1.W & MEM_CR1_IAP_EXEC_mask_w)
N#define __MEM_IAPExecuteCode_Enable()           (MEM->CR1.W |= MEM_CR1_IAP_EXEC_mask_w)   
N#define __MEM_IAPExecuteCode_Disable()          (MEM->CR1.W &= ~ MEM_CR1_IAP_EXEC_mask_w)
NDRV_Return MEM_IAPExecuteCode_Cmd(FunctionalState State);
N
N///@}
N
N
N
N/** 
N * @name    IAP Write
N *
N */ 
N///@{
N
N#define __MEM_IAPWrite_Enable()                 (MEM->CR1.W |= MEM_ACCESS_IAP_WRITE)
N#define __MEM_IAPWrite_Disable()                (MEM->CR1.W &= (~MEM_ACCESS_IAP_WRITE))
NDRV_Return MEM_IAPWrite_Cmd(FunctionalState State);
N
N#define MEM_SetIAPSinglePageEraseUnProtect      MEM_SetSinglePageEraseUnProtect    /*!< ____ */
N#define MEM_SetIAPMultiplePageEraseUnProtect    MEM_SetMultiplePageEraseUnProtect  /*!< ____ */
N#define MEM_SetIAPSingleProgramUnProtect        MEM_SetSingleProgramUnProtect      /*!< ____ */
N#define MEM_SetIAPMultipleProgramUnProtect      MEM_SetMultipleProgramUnProtect    /*!< ____ */
N
N///@}
N
N
N
N/** 
N * @name    ISPD Read and Write
N *
N */ 
N///@{
N
N#define __MEM_ISPDRead_Enable()                 (MEM->CR1.W |= MEM_ACCESS_ISPD_READ)
N#define __MEM_ISPDRead_Disable()                (MEM->CR1.W &= (~MEM_ACCESS_ISPD_READ))
NDRV_Return MEM_ISPDRead_Cmd(FunctionalState State);
N
N#define __MEM_ISPDWrite_Enable()                (MEM->CR1.W |= MEM_ACCESS_ISPD_WRITE)
N#define __MEM_ISPDWrite_Disable()               (MEM->CR1.W &= (~MEM_ACCESS_ISPD_WRITE))
NDRV_Return MEM_ISPDWrite_Cmd(FunctionalState State);
N
N#define MEM_SetISPDSinglePageEraseUnProtect     MEM_SetSinglePageEraseUnProtect    /*!< ____ */
N#define MEM_SetISPDMultiplePageEraseUnProtect   MEM_SetMultiplePageEraseUnProtect  /*!< ____ */
N#define MEM_SetISPDSingleProgramUnProtect       MEM_SetSingleProgramUnProtect      /*!< ____ */
N#define MEM_SetISPDMultipleProgramUnProtect     MEM_SetMultipleProgramUnProtect    /*!< ____ */
N
N///@}
N
N
N
N/** 
N * @name    ISP Read and Write
N *
N */ 
N///@{
N
N#define __MEM_GetISPSize()                      (CFG->OR02.B[1])
Nuint32_t MEM_GetISPSize(void);
N
N#define __MEM_ISPRead_Enable()                  (MEM->CR1.W |= MEM_ACCESS_ISP_READ)
N#define __MEM_ISPRead_Disable()                 (MEM->CR1.W &= (~MEM_ACCESS_ISP_READ))
NDRV_Return MEM_ISPRead_Cmd(FunctionalState State);
N
N#define __MEM_ISPWrite_Enable()                 (MEM->CR1.W |= MEM_ACCESS_ISP_WRITE)
N#define __MEM_ISPWrite_Disable()                (MEM->CR1.W &= (~MEM_ACCESS_ISP_WRITE))
NDRV_Return MEM_ISPWrite_Cmd(FunctionalState State);
N
N#define __MEM_GetSequentialKey2Status()         (MEM->SKEY.H[1])
N#define __MEM_ISPSingleWriteUnProtect()         MEM->SKEY.H[1] = 0x9867; MEM->SKEY.H[1] = 0xB955
N#define __MEM_ISPMultipleWriteUnProtect()       MEM->SKEY.H[1] = 0x9867; MEM->SKEY.H[1] = 0xBEAA
N#define __MEM_ISPMultipleWriteProtect()         MEM->SKEY.H[1] = 0x0000
N
Nvoid MEM_SetISPSinglePageEraseUnProtect(void);
Nvoid MEM_SetISPMultiplePageEraseUnProtect(void);
Nvoid MEM_SetISPSingleProgramUnProtect(void);
Nvoid MEM_SetISPMultipleProgramUnProtect(void);
Nvoid MEM_SetISPMultipleWriteProtect(void);
N
N///@}
N
N
N
N/**
N  *****************************************************************************
N  * @brief      Memory Write 
N  * @param      ADDR__ Write Address, alignment 4-Bytes.
N  * @param      VALUE__ Write on 32bits Any Value.
N  *
N  * @retval     none
N  *****************************************************************************
N  */
N#define MEM_Write(ADDR__, VALUE__)              (*(uint32_t *)((ADDR__) & 0xFFFFFFFC) = ((uint32_t)(VALUE__)))
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 48 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_PW_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_PW_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_PW_DRV.H
N *
N * @brief       This is the C code format driver head file for PW module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.22
N * @date        2021/04/28
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_PW.h"
N
N
N#ifndef _MG32x02z_PW_DRV_H
S/*!< _MG32x02z_PW_DRV_H */ 
S#define _MG32x02z_PW_DRV_H
S
S
S/*! @name 
S*/
S/* @{ */ 
S#define PW_PORF     PW_STA_PORF_mask_w                          /*!< Power-On reset status flag */
S#define PW_BOD0F    PW_STA_BOD0F_mask_w                         /*!< Brown-Out detect BOD0 status flag  */
S#define PW_BOD1F    PW_STA_BOD1F_mask_w                         /*!< Brown-Out detect BOD1 interrupt flag */
S#if (defined(MG32_3RD))
S#define PW_BOD2F    PW_STA_BOD2F_mask_w                         /*!< Brown-Out detect BOD2 interrupt flag */
S#endif
S#define PW_WKF      PW_STA_WKF_mask_w                           /*!< System received wakeup event flag */
S#if (defined(MG32_1ST) || defined(MG32_2ND))
S#define PW_ALLF     PW_PORF | PW_BOD0F | PW_BOD1F | PW_WKF              /*!< All event and interrupt flag */
S#endif
S#if (defined(MG32_3RD))
S#define PW_ALLF     PW_PORF | PW_BOD0F | PW_BOD1F | PW_BOD2F | PW_WKF   /*!< All event and interrupt flag */
S#endif
S
S#define PW_INT_WK       PW_INT_WK_IE_mask_w         /*!< System received wakeup event interrupt enable bit */
S#if (defined(MG32_3RD))
S#define PW_INT_BOD2     PW_INT_BOD2_IE_mask_w       /*!< BOD2 interrupt enable */
S#endif
S#define PW_INT_BOD1     PW_INT_BOD1_IE_mask_w       /*!< BOD1 interrupt enable */
S#define PW_INT_BOD0     PW_INT_BOD0_IE_mask_w       /*!< BOD0 interrupt enable */
S/* @} */
S
S
S/*! @enum   PW_WakeUpDly_TypeDef
S    @brief  MCU wake up delay selection
S*/ 
Stypedef enum
S{   
S    PW_WK_15us      = 0,    /*!< Wakeup delay time 15us */
S    PW_WK_45us      = 1,    /*!< Wakeup delay time 45us */
S    PW_WK_75us      = 2,    /*!< Wakeup delay time 65us */
S    PW_WK_135us     = 3     /*!< Wakeup delay time 135us */
S}PW_WakeUpDly_TypeDef;
S
S
S
S/*! @enum   PW_WakeUpMode_TypeDef
S    @brief  MCU wakeup mode selection
S*/
Stypedef enum
S{
S    PW_Normal_SleepMode = 0,    /*!< Wakeup from normal SLEEP mode */
S    PW_LowPower_SleepMode = 1,  /*!< Wakeup from low power SLEEP mode */
S}PW_WakeUpMode_TypeDef;
S
S
S/*! @enum   PW_BOD1_TH_TypeDef
S    @brief  BOD1 detect voltage threshold select
S*/ 
Stypedef enum
S{   
S    PW_BOD1_2V0     = 0,    /*!< BOD1 detect voltage is 2.0V */
S    PW_BOD1_2V4     = 1,    /*!< BOD1 detect voltage is 2.4V */
S    PW_BOD1_3V7     = 2,    /*!< BOD1 detect voltage is 3.7V */
S    PW_BOD1_4V2     = 3,    /*!< BOD1 detect voltage is 4.2V */
S}PW_BOD1_TH_TypeDef;
S
S
S/*! @enum   PW_BODx_TRGS_TypeDef
S    @brief  BODx Interrupt trigger selection.
S*/
Stypedef enum
S{   
S    PW_BODx_Reserved    = 0,    /*!< BODx not interrupt trigger */
S    PW_BODx_RisingEdge  = 1,    /*!< BODx interrupt trigger at rising edge */
S    PW_BODx_FallingEdge = 2,    /*!< BODx interrupt trigger at falling edge */
S    PW_BODx_DualEdge    = 3     /*!< BODx interrupt trigger at rising edge and falling edge  */
S}PW_BODx_TRGS_TypeDef;
S
S
S/*! @enum   PW_LowPowerLdo_TypeDef
S    @brief  Low power LDO level selection
S*/
Stypedef enum
S{   
S    PW_LV0      = 0,    /*!< Low power LDO is Lowest level */
S    PW_LV1      = 1,    /*!< Low power LDO is the same PW_LV2 */
S    PW_LV2      = 2,    /*!< Low power LDO is the same PW_LV1 */
S    PW_LV3      = 3     /*!< Low power LDO is highest level */
S}PW_LowPowerLdo_TypeDef;
S
S
S/*! @enum   PW_LDOMode_TypeDef
S    @brief  Core voltage LDO mode selection.
S*/
Stypedef enum
S{   
S    PW_Normal_LDO   = 0,    /*!< Core voltage LDO mode select normal LDO */
S    PW_LowPower_LDO = 1     /*!< Core voltage LDO mode select low power LDO */
S}PW_LDOMode_TypeDef;
S
S
S/*! @enum   PW_WKSTP_Periph_TypeDef
S    @brief  Peripheral event wakeup from STOP mode configure.
S*/
S#if (defined(MG32_1ST))
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP2   = 18,   /*!< CMP2 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP3   = 19,   /*!< CMP3 voltage detection wakeup from STOP mode */
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
S#endif
S
S#if (defined(MG32_2ND))
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
S#endif
S
S#if (defined(MG32_3RD))
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD2   = 6,    /*!< BOD2 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S#if (USB_TYPE)
S    PW_WKSTP_USB    = 24,   /*!< USB module event wakeup from STOP mode */
S#endif
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
S#endif
S
S
S
S/*! @enum   PW_STP_Periph_TypeDef
S    @brief  Peripheral stop mode continuous run configure.
S*/
S#if (defined(MG32_1ST))
Stypedef enum
S{
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP2   = PW_CR1_STP_CMP2_mask_w,   /*!< CMP2 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP3   = PW_CR1_STP_CMP3_mask_w,   /*!< CMP3 power-on configuration after enter STOP mode */
S}PW_STP_Periph_TypeDef;
S#endif
S
S#if (defined(MG32_2ND))
Stypedef enum
S{   
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S}PW_STP_Periph_TypeDef;
S#endif
S
S#if (defined(MG32_3RD))
Stypedef enum
S{
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD2   = PW_CR1_STP_BOD2_mask_w,   /*!< BOD2 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S#if (USB_TYPE)
S    PW_STPPO_USB    = PW_CR1_STP_USB_mask_w     /*!< USB power-on configuration after enter STOP mode */
S#endif
S}PW_STP_Periph_TypeDef;
S#endif
S
S
S
S
S/*! @enum   PW_SLP_Periph_TypeDef
S    @brief  Peripheral sleep mode continuous run configure.
S*/
S#if (defined(MG32_1ST))
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP2   = PW_CR1_SLP_CMP2_mask_w,   /*!< CMP2 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP3   = PW_CR1_SLP_CMP3_mask_w,   /*!< CMP3 power-on configuration after enter SLEEP mode */
S}PW_SLP_Periph_TypeDef;
S#endif
S
S#if (defined(MG32_2ND))
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S}PW_SLP_Periph_TypeDef;
S#endif
S
S#if (defined(MG32_3RD))
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S#if (USB_TYPE)
S    PW_SLPPO_USB    = PW_CR1_SLP_USB_mask_w     /*!< USB power-on configuration after enter SLEEP mode */
S#endif
S}PW_SLP_Periph_TypeDef;
S#endif
S
S/** @name   Function rename
S *       
S */ 
S#define PW_PeriphStopModeWakeUp_Config      PW_PeriphSTOPModeWakeUp_Config
S#define PW_StopModeLDO_Select               PW_STOPModeLDO_Select
S#define PW_OnModeLDO_Select                 PW_ONModeLDO_Select
S#define PW_PeriphStopModeContinuous_Config  PW_PeriphSTOPModeContinuous_Config
S#define PW_PeriphSleepModeContinuous_Config PW_PeriphSLEEPModeContinuous_Config
S
S/**
S * @name	Function announce
S *
S */ 
S///@{  
Suint32_t PW_GetAllFlagStatus (void);
SDRV_Return PW_GetSingleFlagStatus (uint32_t PW_ITSrc);
Svoid PW_ClearFlag (uint32_t PW_ITSrc);
Svoid PW_IT_Config (uint32_t PW_ITSrc, FunctionalState NewState);
Svoid PW_ITEA_Cmd (FunctionalState NewState);
S
Svoid PW_PeriphSTOPModeWakeUp_Config (PW_WKSTP_Periph_TypeDef WKSTP_Periph, FunctionalState NewState);
Svoid PW_WakeUpDelay_Select (PW_WakeUpDly_TypeDef WakeUpDly);
S#if (defined(MG32_3RD))
Svoid PW_WakeUpMode_Select (PW_WakeUpMode_TypeDef WakeUpModeSelect);
S#endif
SDRV_Return PW_GetWakeUpMode (void);;
S
Svoid PW_BOD1Threshold_Select (PW_BOD1_TH_TypeDef BOD1_TH);
Svoid PW_BOD1Trigger_Select (PW_BODx_TRGS_TypeDef BOD1_TRGS);
Svoid PW_BOD1_Cmd (FunctionalState NewState);
Svoid PW_BOD0_Cmd (FunctionalState NewState);
SDRV_Return PW_GetBod1Status (void);
S#if (defined(MG32_3RD))
Svoid PW_BOD2Trigger_Select (PW_BODx_TRGS_TypeDef BOD2_TRGS);
Svoid PW_BOD2_Cmd (FunctionalState NewState);
SDRV_Return PW_GetBod2Status (void);
S#endif
S
Svoid PW_VoltageBuffer (FunctionalState NewState);
Svoid PW_STOPModeLDO_Select (PW_LDOMode_TypeDef LdoSelect);
Svoid PW_ONModeLDO_Select (PW_LDOMode_TypeDef LdoSelect);
S
Svoid PW_PeriphSTOPModeContinuous_Config (PW_STP_Periph_TypeDef STP_Periph,FunctionalState NewState);
S#if (defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD))
Svoid PW_PeriphSLEEPModeContinuous_Config (PW_SLP_Periph_TypeDef SLP_Periph, FunctionalState NewState);
S#endif
S///@}
S
S
N#endif  //_MG32x02z_PW_DRV_H
N
L 49 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_RST_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_RST_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_RST_DRV.H
N *
N * @brief       This is the C code format driver head file for RST module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.17
N * @date        2021/03/26
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par     Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_RST.h"
N
N
N#ifndef _MG32x02z_RST_DRV_H
N/*!< _MG32x02z_RST_DRV_H */ 
N#define _MG32x02z_RST_DRV_H
N
N
N/*! @name   RST module 
N*/
N/* @{ */ 
N#define RST_PORF        RST_STA_PORF_mask_w     /*!< Power-on reset flag */
N#define RST_SWF         RST_STA_SWF_mask_w      /*!< Software forced reset flag */
N#define RST_EXF         RST_STA_EXF_mask_w      /*!< External input reset flag */
N#define RST_CPUF        RST_STA_CPUF_mask_w     /*!< CPU SYSRESETREQ bit system reset flag */
N#define RST_BOD0F       RST_STA_BOD0F_mask_w    /*!< BOD0 reset flag */
N#define RST_BOD1F       RST_STA_BOD1F_mask_w    /*!< BOD1 reset flag */
N#if defined(MG32_3RD)
X#if 0L
S#define RST_BOD2F       RST_STA_BOD2F_mask_w    /*!< BOD2 reset flag */
N#endif
N#define RST_LPMF        RST_STA_LPMF_mask_w     /*!< Low power mode reset flag */
N#define RST_CSCF        RST_STA_CSCF_mask_w     /*!< CSC missing clock detect reset flag */
N#define RST_MEMF        RST_STA_MEMF_mask_w     /*!< Flash memory read/write/erase error reset flag */
N#define RST_IWDTF       RST_STA_IWDTF_mask_w    /*!< IWDT reset flag */
N#define RST_WWDTF       RST_STA_WWDTF_mask_w    /*!< WWDT reset flag */
N#define RST_ADCF        RST_STA_ADCF_mask_w     /*!< ADC analog voltage watch-dog reset flag */
N#if defined(MG32_1ST)
X#if 1L
N#define RST_CMP2F       RST_STA_CMP2F_mask_w    /*!< Comparator CMP2 threshold comparison reset flag */
N#define RST_CMP3F       RST_STA_CMP3F_mask_w    /*!< Comparator CMP3 threshold comparison reset flag */
N#endif
N#define RST_WRF         RST_STA_WRF_mask_w      /*!< Warm reset flag */
N#define RST_CRF         RST_STA_CRF_mask_w      /*!< Cold reset flag */
N#define RST_ALLF        0xC00F3D7F
N/* @} */
N
N
N/*! @name 
N*/
N/* @{ */ 
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N#define RST_PE_DIS1     RST_CR0_PE_DIS1_mask_w  /*!< Warm reset disable for PE[9:8] pins */
N#define RST_PE_DIS0     RST_CR0_PE_DIS0_mask_w  /*!< Warm reset disable for PE[3:0] pins */
N#endif
N#define RST_PD_DIS1     RST_CR0_PD_DIS1_mask_w  /*!< Warm reset disable for PD[11:8] pins */
N#define RST_PD_DIS0     RST_CR0_PD_DIS0_mask_w  /*!< Warm reset disable for PD[3:0] pins */
N#define RST_PC_DIS1     RST_CR0_PC_DIS1_mask_w  /*!< Warm reset disable for PC[11:8] pins */
N#define RST_PC_DIS0     RST_CR0_PC_DIS0_mask_w  /*!< Warm reset disable for PC[3:0] pins */
N#define RST_PB_DIS1     RST_CR0_PB_DIS1_mask_w  /*!< Warm reset disable for PB[11:8] pins */
N#define RST_PB_DIS0     RST_CR0_PB_DIS0_mask_w  /*!< Warm reset disable for PB[3:0] pins */
N#define RST_PA_DIS1     RST_CR0_PA_DIS1_mask_w  /*!< Warm reset disable for PA[11:8] pins */
N#define RST_PA_DIS0     RST_CR0_PA_DIS0_mask_w  /*!< Warm reset disable for PA[3:0] pins */
N/* @} */
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define RST_SW_CE       RST_CE_SW_CE_mask_w     /*!< Software forced cold reset enable */
N#define RST_EX_CE       RST_CE_EX_CE_mask_w     /*!< External input cold reset enable */
N#define RST_CPU_CE      RST_CE_CPU_CE_mask_w    /*!< CPU SYSRESETREQ bit forced cold reset enable */
N#define RST_BOD0_CE     RST_CE_BOD0_CE_mask_w   /*!< BOD0 cold reset enable */
N#define RST_BOD1_CE     RST_CE_BOD1_CE_mask_w   /*!< BOD1 cold reset enable */
N#if defined(MG32_3RD)
X#if 0L
S#define RST_BOD2_CE     RST_CE_BOD2_CE_mask_w   /*!< BOD2 cold reset enable */
N#endif
N#define RST_LPM_CE      RST_CE_LPM_CE_mask_w    /*!< Low power STOP mode cold reset enable */
N#define RST_CSC_CE      RST_CE_CSC_CE_mask_w    /*!< CSC missing clock detect cold reset enable */
N#define RST_MEM_CE      RST_CE_MEM_CE_mask_w    /*!< Flash memory read/write/erase error cold reset enable */
N#define RST_IWDT_CE     RST_CE_IWDT_CE_mask_w   /*!< IWDT cold reset enable */
N#define RST_WWDT_CE     RST_CE_WWDT_CE_mask_w   /*!< WWDT cold reset enable */
N#define RST_ADC_CE      RST_CE_ADC_CE_mask_w    /*!< ADC analog voltage watch-dog cold reset enable */
N#if defined(MG32_1ST)
X#if 1L
N#define RST_CMP2_CE     RST_CE_CMP2_CE_mask_w   /*!< Comparator CMP2 threshold comparison cold reset enable */
N#define RST_CMP3_CE     RST_CE_CMP3_CE_mask_w   /*!< Comparator CMP3 threshold comparison cold reset enable */
N#endif
N/* @} */
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define RST_SW_WE       RST_WE_SW_WE_mask_w     /*!< Software forced warm reset enable */
N#define RST_EX_WE       RST_WE_EX_WE_mask_w     /*!< External input warm reset enable */
N#define RST_CPU_WE      RST_WE_CPU_WE_mask_w    /*!< CPU SYSRESETREQ bit forced warm reset enable */
N#define RST_BOD0_WE     RST_WE_BOD0_WE_mask_w   /*!< BOD0 warm reset enable */
N#define RST_BOD1_WE     RST_WE_BOD1_WE_mask_w   /*!< BOD1 warm reset enable */
N#if defined(MG32_3RD)
X#if 0L
S#define RST_BOD2_WE     RST_WE_BOD2_WE_mask_w   /*!< BOD2 warm reset enable */ 
N    #endif
N#define RST_LPM_WE      RST_WE_LPM_WE_mask_w    /*!< Low power STOP mode warm reset enable */
N#define RST_CSC_WE      RST_WE_CSC_WE_mask_w    /*!< CSC missing clock detect warm reset enable */
N#define RST_MEM_WE      RST_WE_MEM_WE_mask_w    /*!< Flash memory read/write/erase error warm reset enable */
N#define RST_IWDT_WE     RST_WE_IWDT_WE_mask_w   /*!< IWDT warm reset enable */
N#define RST_WWDT_WE     RST_WE_WWDT_WE_mask_w   /*!< WWDT warm reset enable */
N#define RST_ADC_WE      RST_WE_ADC_WE_mask_w    /*!< ADC analog voltage watch-dog warm reset enable */
N#if defined(MG32_1ST)
X#if 1L
N#define RST_CMP2_WE     RST_WE_CMP2_WE_mask_w   /*!< Comparator CMP2 threshold comparison warm reset enable */
N#define RST_CMP3_WE     RST_WE_CMP3_WE_mask_w   /*!< Comparator CMP3 threshold comparison warm reset enable */
N#endif
N/* @} */
N
N
N/*! @enum   RST_SoftForceReset_Type
N    @brief  RST software force reset
N*/ 
N#if defined(MG32_1ST)
X#if 1L
Ntypedef enum
N{
N    RST_FR_IOPA     = 0,    /*!< System software forced reset enable for IO Port-A */
N    RST_FR_IOPB     = 1,    /*!< System software forced reset enable for IO Port-B */
N    RST_FR_IOPC     = 2,    /*!< System software forced reset enable for IO Port-C */
N    RST_FR_IOPD     = 3,    /*!< System software forced reset enable for IO Port-D */
N    RST_FR_IOPE     = 4,    /*!< System software forced reset enable for IO Port-E */
N    RST_FR_GPL      = 8,    /*!< System software forced reset enable for GPL module */
N    RST_FR_EMB      = 12,   /*!< System software forced reset enable for EMB module */
N    RST_FR_ADC0     = 32,   /*!< System software forced reset enable for ADC0 module */
N    RST_FR_CMP      = 34,   /*!< System software forced reset enable for CMP module */
N    RST_FR_DAC      = 35,   /*!< System software forced reset enable for DAC module */
N    RST_FR_RTC      = 37,   /*!< System software forced reset enable for RTC module */
N    RST_FR_IWDT     = 38,   /*!< System software forced reset enable for IWDT module  */
N    RST_FR_WWDT     = 39,   /*!< System software forced reset enable for WWDT module  */
N    RST_FR_I2C0     = 40,   /*!< System software forced reset enable for I2C0 module  */
N    RST_FR_I2C1     = 41,   /*!< System software forced reset enable for I2C1 module  */
N    RST_FR_SPI0     = 44,   /*!< System software forced reset enable for SPI0 module  */
N    RST_FR_URT0     = 48,   /*!< System software forced reset enable for URT0 module  */
N    RST_FR_URT1     = 49,   /*!< System software forced reset enable for URT1 module  */
N    RST_FR_URT2     = 50,   /*!< System software forced reset enable for URT2 module  */
N    RST_FR_URT3     = 51,   /*!< System software forced reset enable for URT3 module  */
N    RST_FR_TM00     = 64,   /*!< System software forced reset enable for TM00 module  */
N    RST_FR_TM01     = 65,   /*!< System software forced reset enable for TM01 module  */
N    RST_FR_TM10     = 68,   /*!< System software forced reset enable for TM10 module  */
N    RST_FR_TM16     = 71,   /*!< System software forced reset enable for TM16 module  */
N    RST_FR_TM20     = 72,   /*!< System software forced reset enable for TM20 module  */
N    RST_FR_TM26     = 75,   /*!< System software forced reset enable for TM26 module  */
N    RST_FR_TM36     = 79    /*!< System software forced reset enable for TM36 module  */
N}RST_SoftForceReset_Type;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
Stypedef enum
S{
S    RST_FR_IOPA     = 0,    /*!< System software forced reset enable for IO Port-A */
S    RST_FR_IOPB     = 1,    /*!< System software forced reset enable for IO Port-B */
S    RST_FR_IOPC     = 2,    /*!< System software forced reset enable for IO Port-C */
S    RST_FR_IOPD     = 3,    /*!< System software forced reset enable for IO Port-D */
S    RST_FR_GPL      = 8,    /*!< System software forced reset enable for GPL module */
S    RST_FR_ADC0     = 32,   /*!< System software forced reset enable for ADC0 module */
S    RST_FR_CMP      = 34,   /*!< System software forced reset enable for CMP module */
S    RST_FR_RTC      = 37,   /*!< System software forced reset enable for RTC module */
S    RST_FR_IWDT     = 38,   /*!< System software forced reset enable for IWDT module  */
S    RST_FR_WWDT     = 39,   /*!< System software forced reset enable for WWDT module  */
S    RST_FR_I2C0     = 40,   /*!< System software forced reset enable for I2C0 module  */
S    RST_FR_SPI0     = 44,   /*!< System software forced reset enable for SPI0 module  */
S    RST_FR_URT0     = 48,   /*!< System software forced reset enable for URT0 module  */
S    RST_FR_URT1     = 49,   /*!< System software forced reset enable for URT1 module  */
S    RST_FR_TM00     = 64,   /*!< System software forced reset enable for TM00 module  */
S    RST_FR_TM01     = 65,   /*!< System software forced reset enable for TM01 module  */
S    RST_FR_TM10     = 68,   /*!< System software forced reset enable for TM10 module  */
S    RST_FR_TM16     = 71,   /*!< System software forced reset enable for TM16 module  */
S    RST_FR_TM36     = 79    /*!< System software forced reset enable for TM36 module  */
S}RST_SoftForceReset_Type;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
Stypedef enum
S{
S    RST_FR_IOPA     = 0,    /*!< System software forced reset enable for IO Port-A */
S    RST_FR_IOPB     = 1,    /*!< System software forced reset enable for IO Port-B */
S    RST_FR_IOPC     = 2,    /*!< System software forced reset enable for IO Port-C */
S    RST_FR_IOPD     = 3,    /*!< System software forced reset enable for IO Port-D */
S    RST_FR_IOPE     = 4,    /*!< System software forced reset enable for IO Port-E */
S    RST_FR_GPL      = 8,    /*!< System software forced reset enable for GPL module */
S    RST_FR_EMB      = 12,   /*!< System software forced reset enable for EMB module */
S    RST_FR_ADC0     = 32,   /*!< System software forced reset enable for ADC0 module */
S    RST_FR_CMP      = 34,   /*!< System software forced reset enable for CMP module */
S    RST_FR_DAC      = 35,   /*!< System software forced reset enable for DAC module */
S    RST_FR_RTC      = 37,   /*!< System software forced reset enable for RTC module */
S    RST_FR_IWDT     = 38,   /*!< System software forced reset enable for IWDT module  */
S    RST_FR_WWDT     = 39,   /*!< System software forced reset enable for WWDT module  */
S    RST_FR_I2C0     = 40,   /*!< System software forced reset enable for I2C0 module  */
S    RST_FR_I2C1     = 41,   /*!< System software forced reset enable for I2C1 module  */
S    RST_FR_SPI0     = 44,   /*!< System software forced reset enable for SPI0 module  */
S    RST_FR_URT0     = 48,   /*!< System software forced reset enable for URT0 module  */
S    RST_FR_URT1     = 49,   /*!< System software forced reset enable for URT1 module  */
S    RST_FR_URT2     = 50,   /*!< System software forced reset enable for URT2 module  */
S    RST_FR_URT4     = 52,   /*!< System software forced reset enable for URT4 module  */
S    RST_FR_URT5     = 53,   /*!< System software forced reset enable for URT5 module  */
S    RST_FR_URT6     = 54,   /*!< System software forced reset enable for URT6 module  */
S    RST_FR_URT7     = 55,   /*!< System software forced reset enable for URT7 module  */
S#if (USB_TYPE)
S    RST_FR_USB      = 60,   /*!< System software forced reset enable for USB module  */
S#endif
S    RST_FR_APX      = 61,   /*!< System software forced reset enable for APX module  */
S    RST_FR_TM00     = 64,   /*!< System software forced reset enable for TM00 module  */
S    RST_FR_TM01     = 65,   /*!< System software forced reset enable for TM01 module  */
S    RST_FR_TM10     = 68,   /*!< System software forced reset enable for TM10 module  */
S    RST_FR_TM16     = 71,   /*!< System software forced reset enable for TM16 module  */
S    RST_FR_TM20     = 72,   /*!< System software forced reset enable for TM20 module  */
S    RST_FR_TM26     = 75,   /*!< System software forced reset enable for TM26 module  */
S    RST_FR_TM36     = 79    /*!< System software forced reset enable for TM36 module  */
S}RST_SoftForceReset_Type;
N#endif
N
N
N
N#if defined(MG32_3RD)
X#if 0L
S/*! @enum   RST_USBResetMode_Type
S    @brief  
S*/ 
Stypedef enum
S{
S    RST_USB_ResetMode_All   = 0,    /*!< Chip will auto reset USB all blocks and registers */
S    RST_USB_ResetMode_LV1   = 1,    /*!< chip will reset all blocks and and registers except 
S                                         USB_EN, USB_XTR_EN, USB_V33_EN (V33 LDO) and USB_DPU_EN 
S                                         (DP 1.5k pull-up) contro */
S}RST_USBResetMode_Type;
N#endif
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
Nuint32_t RST_GetAllFlagStatus (void);
NDRV_Return RST_GetSingleFlagStatus (uint32_t RST_FLAG) ;
Nvoid RST_ClearFlag (uint32_t RST_FLAG);
N
Nvoid RST_CRstSource_Config (uint32_t RST_CRS, FunctionalState NewState);
Nvoid RST_WRstSource_Config (uint32_t RST_WRS, FunctionalState NewState) ;
N
Nvoid RST_WRstGPIOLock_Config (uint32_t RST_Px_DISx, FunctionalState NewState);
N
Nvoid RST_ForceRstPeriph_SW (RST_SoftForceReset_Type ForceReset, FunctionalState NewState);
N
Nvoid RST_TriggerSystemRst_SW (FunctionalState NewState);
Nvoid RST_WWDTWRstMask_Cmd (FunctionalState NewState);
N#if defined(MG32_3RD)
X#if 0L
Svoid RST_USBRstMode_Select (RST_USBResetMode_Type RST_USBResetMode);
N#endif
N///@}
N
N
N#endif  //_MG32x02z_RST_DRV_H
N
L 50 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_SPI_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_SPI_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_SPI_DRV.H
N *
N * @brief       This is the C code format driver head file for SPI module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.19
N * @date        2021/05/04
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_SPI.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_SPI.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_SPI.h
N *
N * @brief       MG32x02z SPI Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_SPI_H
N#define _MG32x02z_SPI_H
N#define _MG32x02z_SPI_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_SPI_H_VER)
S    #error "MG32x02z_SPI_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      SPI_Struct
N *              SPI  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  BUSYF         :1;     //[0] SPI data transfer busy flag.
X            volatile const  uint8_t  BUSYF         :1;     
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IDLF          :1;     //[3] SPI slave mode NSS idle detect flag
X            volatile uint8_t  IDLF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TCF           :1;     //[4] SPI transmission complete flag
X            volatile uint8_t  TCF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  RXDF          :1;     //[5] SPI received data byte number is different from previous received data byte number fo
X            volatile const  uint8_t  RXDF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  RXF           :1;     //[6] SPI receive data register not empty
X            volatile uint8_t  RXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TXF           :1;     //[7] SPI transmit data register empty flag 
X            volatile uint8_t  TXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  MODF          :1;     //[8] SPI mode detect fault flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  MODF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WEF           :1;     //[9] SPI slave mode write error flag
X            volatile uint8_t  WEF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  ROVRF         :1;     //[10] SPI receive overrun flag
X            volatile uint8_t  ROVRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TUDRF         :1;     //[11] SPI slave mode transmit underrun flag
X            volatile uint8_t  TUDRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[12] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  RX_LVL        :3;     //[18..16] SPI data buffer received level indications.
X            volatile const  uint8_t  RX_LVL        :3;     
N                                        //0x0 = 0 (0-byte,empty)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  TX_LVL        :3;     //[22..20] SPI data buffer transmission remained level indications.
X            volatile const  uint8_t  TX_LVL        :3;     
N                                        //0x0 = 0 (0-byte,empty)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RNUM          :3;     //[26..24] SPI received data byte number when data shadow buffer last transfer to SPI_RDAT regi
X            volatile uint8_t  RNUM          :3;     
N                                        //0x0 = 0 (0-byte)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :5;     //[31..27] 
X            volatile const  uint8_t                :5;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  SPI status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] SPI interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IDL_IE        :1;     //[3] SPI slave mode NSS idle detect interrupt enable
X            volatile uint8_t  IDL_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TC_IE         :1;     //[4] SPI transmission complete interrupt enable
X            volatile uint8_t  TC_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RX_IE         :1;     //[6] SPI Receive data register not empty interrupt enable.
X            volatile uint8_t  RX_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TX_IE         :1;     //[7] SPI TX buffer underflow the threshold SPI_TX_TH Interrupt enable.
X            volatile uint8_t  TX_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MODF_IE       :1;     //[8] SPI mode detect fault interrupt enable.
X            volatile uint8_t  MODF_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WE_IE         :1;     //[9] SPI slave mode write error interrupt enable.
X            volatile uint8_t  WE_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ROVR_IE       :1;     //[10] SPI RX buffer receive overrun interrupt enable.
X            volatile uint8_t  ROVR_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TUDR_IE       :1;     //[11] SPI TX buffer transmit underrun interrupt enable.
X            volatile uint8_t  TUDR_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[12] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  SPI interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_SEL        :2;     //[3..2] SPI internal clock CK_SPI source select.
X            volatile uint8_t  CK_SEL        :2;     
N                                        //0x0 = PROC : CK_SPI_PR process clock from CSC
N                                        //0x1 = Reserved
N                                        //0x2 = TM00_TRGO
N                                        //0x3 = Reserved
N            __IO uint8_t  CK_DIV        :2;     //[5..4] SPI internal clock CK_SPI_INT input divider.
X            volatile uint8_t  CK_DIV        :2;     
N                                        //0x0 = DIV2 : divided by 2
N                                        //0x1 = DIV4 : divided by 4
N                                        //0x2 = DIV8 : divided by 8
N                                        //0x3 = DIV16 : divided by 16
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_PSC        :3;     //[10..8] SPI internal clock CK_SPI_INT prescaler
X            volatile uint8_t  CK_PSC        :3;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CK_PDIV       :2;     //[13..12] SPI process clock CK_SPI_PR input divider. 
X            volatile uint8_t  CK_PDIV       :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  SPI clock source register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x0C]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] SPI function enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CPOL          :1;     //[1] SPI clock polarity select. It is used to select the SPI clock level in idle state.
X            volatile uint8_t  CPOL          :1;     
N                                        //0 = Low
N                                        //1 = High
N            __IO uint8_t  CPHA          :1;     //[2] SPI clock phase select
X            volatile uint8_t  CPHA          :1;     
N                                        //0 = Leading edge
N                                        //1 = Trailing edge
N            __IO uint8_t  LSB_EN        :1;     //[3] SPI data order Lsb first enable. When disables , the Msb bit will be the first bit.
X            volatile uint8_t  LSB_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MDS           :2;     //[5..4] SPI operation mode select.
X            volatile uint8_t  MDS           :2;     
N                                        //0x0 = Slave
N                                        //0x1 = Master
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IO_SWP        :1;     //[7] SPI I/O SPI_MOSI,SPI_MISO signals swap enable.
X            volatile uint8_t  IO_SWP        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSSO_EN       :1;     //[8] SPI_NSS signal output function enable.
X            volatile uint8_t  NSSO_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSSI_EN       :1;     //[9] SPI_NSS signal input function enable
X            volatile uint8_t  NSSI_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSSI_SEL      :1;     //[10] SPI pin select for NSS input signal
X            volatile uint8_t  NSSI_SEL      :1;     
N                                        //0 = NSS (SPI_NSS pin)
N                                        //1 = NSSI (SPI_NSSI pin)
N            __IO uint8_t  NSS_SWEN      :1;     //[11] SPI NSS signal input/output use software control bit enable
X            volatile uint8_t  NSS_SWEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSSO_INV      :1;     //[12] SPI NSS output signal inverse enable
X            volatile uint8_t  NSSO_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSSI_INV      :1;     //[13] SPI NSS input signal inverse enable.
X            volatile uint8_t  NSSI_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSS_PEN       :1;     //[14] SPI single master mode NSS pulse enable
X            volatile uint8_t  NSS_PEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MODF_SEL      :1;     //[15] SPI function select when master mode fault detect.
X            volatile uint8_t  MODF_SEL      :1;     
N                                        //0 = SPI disable
N                                        //1 = Switch to slave
N            __I  uint8_t                :2;     //[17..16] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[18] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  LBM_EN        :1;     //[19] Loop back mode enable bit
X            volatile uint8_t  LBM_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :6;     //[29..24] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  DMA_RXEN      :1;     //[30] Direct memory access enable to receive
X            volatile uint8_t  DMA_RXEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_TXEN      :1;     //[31] Direct memory access enable to transmit
X            volatile uint8_t  DMA_TXEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  SPI control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __O  uint8_t  RDAT_CLR      :1;     //[0] SPI received data clear enable
X            volatile  uint8_t  RDAT_CLR      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __O  uint8_t  TDAT_CLR      :1;     //[1] SPI transmitted data clear enable
X            volatile  uint8_t  TDAT_CLR      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :4;     //[11..8] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :3;     //[14..12] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[17..16] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[25..24] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  SPI control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BDIR_OE       :1;     //[2] SPI data line Bidirectional output enable
X            volatile uint8_t  BDIR_OE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  COPY_EN       :1;     //[3] SPI data transfer copy mode enable
X            volatile uint8_t  COPY_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DAT_LINE      :3;     //[6..4] SPI data line number select
X            volatile uint8_t  DAT_LINE      :3;     
N                                        //0x0 = SPI : 2-lines separated~ standard SPI mode)
N                                        //0x1 = 1 : 1-line Bidirectional~ SPI_MOSI
N                                        //0x2 = 2 : 2-lines Bidirectional~ SPI_D0(MOSI), SPI_D1(MISO)
N                                        //0x3 = 4 : 4-lines Bidirectional~ SPI_D0 ~ SPI_D3
N                                        //0x4 = Reserved
N                                        //0x5 = 8 : 8-lines Bidirectional~ SPI_D0 ~ SPI_D7
N            __IO uint8_t  TX_DIS        :1;     //[7] SPI data line output disable
X            volatile uint8_t  TX_DIS        :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  RX_TH         :2;     //[9..8] SPI received data buffer high threshold for slave mode
X            volatile uint8_t  RX_TH         :2;     
N                                        //0x0 = 1-byte
N                                        //0x1 = 2-byte (default)
N                                        //0x2 = 3-byte
N                                        //0x3 = 4-byte
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[13..12] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  DSIZE         :5;     //[20..16] SPI transfer data frame bit size from 4-bit to 32-bit
X            volatile uint8_t  DSIZE         :5;     
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  NSS_SWO       :1;     //[24] SPI NSS signal software output control bit when SPI_NSS_SWEN is enable
X            volatile uint8_t  NSS_SWO       :1;     
N            __IO uint8_t  NSS_SWI       :1;     //[25] SPI NSS signal input control and status bit
X            volatile uint8_t  NSS_SWI       :1;     
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CKO_MUX       :3;     //[30..28] SPI_CLK output signal select.
X            volatile uint8_t  CKO_MUX       :3;     
N                                        //0x0 = SPI : SPI clock
N                                        //0x1 = WE : EMB MWE signal
N                                        //0x2 = OE : EMB MOE signal
N                                        //0x3 = TM10 : TM10_CKO
N                                        //0x4 = TM16 : TM16_CKO
N                                        //0x5 = TM20 : TM20_CKO
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  SPI control register 2 */
N
N    __I uint32_t  RESERVED1[5];         /*!< RESERVED1  ~ Offset[0x1C]  Reserved */
X    volatile const uint32_t  RESERVED1[5];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t RDAT          :32;    //[31..0] SPI received data register
X            volatile const  uint32_t RDAT          :32;    
N        }MBIT;
N    }RDAT;                              /*!< RDAT       ~ Offset[0x30]  SPI data receive register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t TDAT          :32;    //[31..0] SPI transmitted data register
X            volatile uint32_t TDAT          :32;    
N        }MBIT;
N    }TDAT;                              /*!< TDAT       ~ Offset[0x34]  SPI data transmit register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __O  uint32_t TDAT3         :24;    //[23..0] SPI transmitted data register for 3-byte data write only
X            volatile  uint32_t TDAT3         :24;    
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }TDAT3;                             /*!< TDAT3      ~ Offset[0x38]  SPI TX data 3-byte register */
N
N} SPI_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        SPI  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define SPI0_Base                       ((uint32_t)0x53000000)              /*!< SPI Control  Module-0 */
N#define SPI0                            ((SPI_Struct*) SPI0_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        SPI  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        SPI_STA  [register's definitions]
N *              Offset[0x00]  SPI status register
N ******************************************************************************
N */
N///@{
N#define SPI_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_STA */
N#define SPI_STA_RNUM_mask_w                         ((uint32_t)0x07000000)  /*!< Bit Mask of 32bit */
N#define SPI_STA_RNUM_mask_h1                        ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define SPI_STA_RNUM_mask_b3                        ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define SPI_STA_RNUM_0_w                            ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define SPI_STA_RNUM_0_h1                           ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define SPI_STA_RNUM_0_b3                           ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define SPI_STA_RNUM_1_w                            ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):1 of 32bit */
N#define SPI_STA_RNUM_1_h1                           ((uint16_t)0x0100)      /*!< Bit Value =(0x1):1 of 16bit */
N#define SPI_STA_RNUM_1_b3                           ((uint8_t )0x01)        /*!< Bit Value =(0x1):1 of 8bit */
N#define SPI_STA_RNUM_2_w                            ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):2 of 32bit */
N#define SPI_STA_RNUM_2_h1                           ((uint16_t)0x0200)      /*!< Bit Value =(0x2):2 of 16bit */
N#define SPI_STA_RNUM_2_b3                           ((uint8_t )0x02)        /*!< Bit Value =(0x2):2 of 8bit */
N#define SPI_STA_RNUM_3_w                            ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):3 of 32bit */
N#define SPI_STA_RNUM_3_h1                           ((uint16_t)0x0300)      /*!< Bit Value =(0x3):3 of 16bit */
N#define SPI_STA_RNUM_3_b3                           ((uint8_t )0x03)        /*!< Bit Value =(0x3):3 of 8bit */
N#define SPI_STA_RNUM_4_w                            ((uint32_t)0x04000000)  /*!< Bit Value =(0x4):4 of 32bit */
N#define SPI_STA_RNUM_4_h1                           ((uint16_t)0x0400)      /*!< Bit Value =(0x4):4 of 16bit */
N#define SPI_STA_RNUM_4_b3                           ((uint8_t )0x04)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define SPI_STA_TX_LVL_mask_w                       ((uint32_t)0x00700000)  /*!< Bit Mask of 32bit */
N#define SPI_STA_TX_LVL_mask_h1                      ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define SPI_STA_TX_LVL_mask_b2                      ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define SPI_STA_TX_LVL_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define SPI_STA_TX_LVL_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define SPI_STA_TX_LVL_0_b2                         ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define SPI_STA_TX_LVL_1_w                          ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):1 of 32bit */
N#define SPI_STA_TX_LVL_1_h1                         ((uint16_t)0x0010)      /*!< Bit Value =(0x1):1 of 16bit */
N#define SPI_STA_TX_LVL_1_b2                         ((uint8_t )0x10)        /*!< Bit Value =(0x1):1 of 8bit */
N#define SPI_STA_TX_LVL_2_w                          ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):2 of 32bit */
N#define SPI_STA_TX_LVL_2_h1                         ((uint16_t)0x0020)      /*!< Bit Value =(0x2):2 of 16bit */
N#define SPI_STA_TX_LVL_2_b2                         ((uint8_t )0x20)        /*!< Bit Value =(0x2):2 of 8bit */
N#define SPI_STA_TX_LVL_3_w                          ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):3 of 32bit */
N#define SPI_STA_TX_LVL_3_h1                         ((uint16_t)0x0030)      /*!< Bit Value =(0x3):3 of 16bit */
N#define SPI_STA_TX_LVL_3_b2                         ((uint8_t )0x30)        /*!< Bit Value =(0x3):3 of 8bit */
N#define SPI_STA_TX_LVL_4_w                          ((uint32_t)0x00400000)  /*!< Bit Value =(0x4):4 of 32bit */
N#define SPI_STA_TX_LVL_4_h1                         ((uint16_t)0x0040)      /*!< Bit Value =(0x4):4 of 16bit */
N#define SPI_STA_TX_LVL_4_b2                         ((uint8_t )0x40)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define SPI_STA_RX_LVL_mask_w                       ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define SPI_STA_RX_LVL_mask_h1                      ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define SPI_STA_RX_LVL_mask_b2                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define SPI_STA_RX_LVL_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define SPI_STA_RX_LVL_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define SPI_STA_RX_LVL_0_b2                         ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define SPI_STA_RX_LVL_1_w                          ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):1 of 32bit */
N#define SPI_STA_RX_LVL_1_h1                         ((uint16_t)0x0001)      /*!< Bit Value =(0x1):1 of 16bit */
N#define SPI_STA_RX_LVL_1_b2                         ((uint8_t )0x01)        /*!< Bit Value =(0x1):1 of 8bit */
N#define SPI_STA_RX_LVL_2_w                          ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):2 of 32bit */
N#define SPI_STA_RX_LVL_2_h1                         ((uint16_t)0x0002)      /*!< Bit Value =(0x2):2 of 16bit */
N#define SPI_STA_RX_LVL_2_b2                         ((uint8_t )0x02)        /*!< Bit Value =(0x2):2 of 8bit */
N#define SPI_STA_RX_LVL_3_w                          ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):3 of 32bit */
N#define SPI_STA_RX_LVL_3_h1                         ((uint16_t)0x0003)      /*!< Bit Value =(0x3):3 of 16bit */
N#define SPI_STA_RX_LVL_3_b2                         ((uint8_t )0x03)        /*!< Bit Value =(0x3):3 of 8bit */
N#define SPI_STA_RX_LVL_4_w                          ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):4 of 32bit */
N#define SPI_STA_RX_LVL_4_h1                         ((uint16_t)0x0004)      /*!< Bit Value =(0x4):4 of 16bit */
N#define SPI_STA_RX_LVL_4_b2                         ((uint8_t )0x04)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define SPI_STA_TUDRF_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define SPI_STA_TUDRF_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define SPI_STA_TUDRF_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_STA_TUDRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_TUDRF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_TUDRF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_TUDRF_happened_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_TUDRF_happened_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_TUDRF_happened_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_ROVRF_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define SPI_STA_ROVRF_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define SPI_STA_ROVRF_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SPI_STA_ROVRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_ROVRF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_ROVRF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_ROVRF_happened_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_ROVRF_happened_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_ROVRF_happened_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_WEF_mask_w                          ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define SPI_STA_WEF_mask_h0                         ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define SPI_STA_WEF_mask_b1                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SPI_STA_WEF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_WEF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_WEF_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_WEF_happened_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_WEF_happened_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_WEF_happened_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_MODF_mask_w                         ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define SPI_STA_MODF_mask_h0                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define SPI_STA_MODF_mask_b1                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_STA_MODF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_MODF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_MODF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_MODF_happened_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_MODF_happened_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_MODF_happened_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_TXF_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define SPI_STA_TXF_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define SPI_STA_TXF_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define SPI_STA_TXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_TXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_TXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_TXF_happened_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_TXF_happened_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_TXF_happened_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_RXF_mask_w                          ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define SPI_STA_RXF_mask_h0                         ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define SPI_STA_RXF_mask_b0                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define SPI_STA_RXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_RXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_RXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_RXF_happened_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_RXF_happened_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_RXF_happened_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_RXDF_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define SPI_STA_RXDF_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define SPI_STA_RXDF_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define SPI_STA_RXDF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_RXDF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_RXDF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_RXDF_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_RXDF_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_RXDF_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_TCF_mask_w                          ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define SPI_STA_TCF_mask_h0                         ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define SPI_STA_TCF_mask_b0                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define SPI_STA_TCF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_TCF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_TCF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_TCF_happened_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_TCF_happened_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_TCF_happened_b0                     ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_IDLF_mask_w                         ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define SPI_STA_IDLF_mask_h0                        ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define SPI_STA_IDLF_mask_b0                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_STA_IDLF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define SPI_STA_IDLF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define SPI_STA_IDLF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define SPI_STA_IDLF_happened_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define SPI_STA_IDLF_happened_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define SPI_STA_IDLF_happened_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define SPI_STA_BUSYF_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define SPI_STA_BUSYF_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SPI_STA_BUSYF_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_STA_BUSYF_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define SPI_STA_BUSYF_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define SPI_STA_BUSYF_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_INT  [register's definitions]
N *              Offset[0x04]  SPI interrupt enable register
N ******************************************************************************
N */
N///@{
N#define SPI_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_INT */
N#define SPI_INT_TUDR_IE_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define SPI_INT_TUDR_IE_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define SPI_INT_TUDR_IE_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_INT_TUDR_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_TUDR_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_TUDR_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_TUDR_IE_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_TUDR_IE_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_TUDR_IE_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_ROVR_IE_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define SPI_INT_ROVR_IE_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define SPI_INT_ROVR_IE_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SPI_INT_ROVR_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_ROVR_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_ROVR_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_ROVR_IE_enable_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_ROVR_IE_enable_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_ROVR_IE_enable_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_WE_IE_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define SPI_INT_WE_IE_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define SPI_INT_WE_IE_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SPI_INT_WE_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_WE_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_WE_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_WE_IE_enable_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_WE_IE_enable_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_WE_IE_enable_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_MODF_IE_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define SPI_INT_MODF_IE_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define SPI_INT_MODF_IE_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_INT_MODF_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_MODF_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_MODF_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_MODF_IE_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_MODF_IE_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_MODF_IE_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_TX_IE_mask_w                        ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define SPI_INT_TX_IE_mask_h0                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define SPI_INT_TX_IE_mask_b0                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define SPI_INT_TX_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_TX_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_TX_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_TX_IE_enable_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_TX_IE_enable_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_TX_IE_enable_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_RX_IE_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define SPI_INT_RX_IE_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define SPI_INT_RX_IE_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define SPI_INT_RX_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_RX_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_RX_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_RX_IE_enable_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_RX_IE_enable_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_RX_IE_enable_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_TC_IE_mask_w                        ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define SPI_INT_TC_IE_mask_h0                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define SPI_INT_TC_IE_mask_b0                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define SPI_INT_TC_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_TC_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_TC_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_TC_IE_enable_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_TC_IE_enable_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_TC_IE_enable_b0                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_IDL_IE_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define SPI_INT_IDL_IE_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define SPI_INT_IDL_IE_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_INT_IDL_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_IDL_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_IDL_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_IDL_IE_enable_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_IDL_IE_enable_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_IDL_IE_enable_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define SPI_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SPI_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_CLK  [register's definitions]
N *              Offset[0x08]  SPI clock source register
N ******************************************************************************
N */
N///@{
N#define SPI_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_CLK */
N#define SPI_CLK_CK_PDIV_mask_w                      ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define SPI_CLK_CK_PDIV_mask_h0                     ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define SPI_CLK_CK_PDIV_mask_b1                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define SPI_CLK_CK_PDIV_div1_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define SPI_CLK_CK_PDIV_div1_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define SPI_CLK_CK_PDIV_div1_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define SPI_CLK_CK_PDIV_div2_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define SPI_CLK_CK_PDIV_div2_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define SPI_CLK_CK_PDIV_div2_b1                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define SPI_CLK_CK_PDIV_div4_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define SPI_CLK_CK_PDIV_div4_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define SPI_CLK_CK_PDIV_div4_b1                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define SPI_CLK_CK_PDIV_div8_w                      ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define SPI_CLK_CK_PDIV_div8_h0                     ((uint16_t)0x3000)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define SPI_CLK_CK_PDIV_div8_b1                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define SPI_CLK_CK_PSC_mask_w                       ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define SPI_CLK_CK_PSC_mask_h0                      ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define SPI_CLK_CK_PSC_mask_b1                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define SPI_CLK_CK_PSC_shift_w                      (8)                     /*!< Bit Shift of 32bit */
N#define SPI_CLK_CK_PSC_shift_h0                     (8)                     /*!< Bit Shift of 16bit */
N#define SPI_CLK_CK_PSC_shift_b1                     (0)                     /*!< Bit Shift of 8bit */
N
N#define SPI_CLK_CK_DIV_mask_w                       ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define SPI_CLK_CK_DIV_mask_h0                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define SPI_CLK_CK_DIV_mask_b0                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define SPI_CLK_CK_DIV_div2_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV2 of 32bit */
N#define SPI_CLK_CK_DIV_div2_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV2 of 16bit */
N#define SPI_CLK_CK_DIV_div2_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV2 of 8bit */
N#define SPI_CLK_CK_DIV_div4_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV4 of 32bit */
N#define SPI_CLK_CK_DIV_div4_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV4 of 16bit */
N#define SPI_CLK_CK_DIV_div4_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV4 of 8bit */
N#define SPI_CLK_CK_DIV_div8_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV8 of 32bit */
N#define SPI_CLK_CK_DIV_div8_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV8 of 16bit */
N#define SPI_CLK_CK_DIV_div8_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV8 of 8bit */
N#define SPI_CLK_CK_DIV_div16_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV16 of 32bit */
N#define SPI_CLK_CK_DIV_div16_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV16 of 16bit */
N#define SPI_CLK_CK_DIV_div16_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV16 of 8bit */
N
N#define SPI_CLK_CK_SEL_mask_w                       ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define SPI_CLK_CK_SEL_mask_h0                      ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define SPI_CLK_CK_SEL_mask_b0                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define SPI_CLK_CK_SEL_proc_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):PROC of 32bit */
N#define SPI_CLK_CK_SEL_proc_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):PROC of 16bit */
N#define SPI_CLK_CK_SEL_proc_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):PROC of 8bit */
N#define SPI_CLK_CK_SEL_tm00_trgo_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define SPI_CLK_CK_SEL_tm00_trgo_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define SPI_CLK_CK_SEL_tm00_trgo_b0                 ((uint8_t )0x08)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_CR0  [register's definitions]
N *              Offset[0x10]  SPI control register 0
N ******************************************************************************
N */
N///@{
N#define SPI_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_CR0 */
N#define SPI_CR0_DMA_TXEN_mask_w                     ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_DMA_TXEN_mask_h1                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_DMA_TXEN_mask_b3                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_DMA_TXEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_DMA_TXEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_DMA_TXEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_DMA_TXEN_enable_w                   ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_DMA_TXEN_enable_h1                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_DMA_TXEN_enable_b3                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_DMA_RXEN_mask_w                     ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_DMA_RXEN_mask_h1                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_DMA_RXEN_mask_b3                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_DMA_RXEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_DMA_RXEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_DMA_RXEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_DMA_RXEN_enable_w                   ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_DMA_RXEN_enable_h1                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_DMA_RXEN_enable_b3                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_LBM_EN_mask_w                       ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_LBM_EN_mask_h1                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_LBM_EN_mask_b2                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_LBM_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_LBM_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_LBM_EN_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_LBM_EN_enable_w                     ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_LBM_EN_enable_h1                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_LBM_EN_enable_b2                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_MODF_SEL_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_MODF_SEL_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_MODF_SEL_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_MODF_SEL_spi_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):SPI disable of 32bit */
N#define SPI_CR0_MODF_SEL_spi_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):SPI disable of 16bit */
N#define SPI_CR0_MODF_SEL_spi_disable_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):SPI disable of 8bit */
N#define SPI_CR0_MODF_SEL_switch_to_slave_w          ((uint32_t)0x00008000)  /*!< Bit Value =(1):Switch to slave of 32bit */
N#define SPI_CR0_MODF_SEL_switch_to_slave_h0         ((uint16_t)0x8000)      /*!< Bit Value =(1):Switch to slave of 16bit */
N#define SPI_CR0_MODF_SEL_switch_to_slave_b1         ((uint8_t )0x80)        /*!< Bit Value =(1):Switch to slave of 8bit */
N
N#define SPI_CR0_NSS_PEN_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSS_PEN_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSS_PEN_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSS_PEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_NSS_PEN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_NSS_PEN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_NSS_PEN_enable_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_NSS_PEN_enable_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_NSS_PEN_enable_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_NSSI_INV_mask_w                     ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSSI_INV_mask_h0                    ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSSI_INV_mask_b1                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSSI_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_NSSI_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_NSSI_INV_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_NSSI_INV_enable_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_NSSI_INV_enable_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_NSSI_INV_enable_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_NSSO_INV_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSSO_INV_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSSO_INV_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSSO_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_NSSO_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_NSSO_INV_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_NSSO_INV_enable_w                   ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_NSSO_INV_enable_h0                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_NSSO_INV_enable_b1                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_NSS_SWEN_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSS_SWEN_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSS_SWEN_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSS_SWEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_NSS_SWEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_NSS_SWEN_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_NSS_SWEN_enable_w                   ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_NSS_SWEN_enable_h0                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_NSS_SWEN_enable_b1                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_NSSI_SEL_mask_w                     ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSSI_SEL_mask_h0                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSSI_SEL_mask_b1                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSSI_SEL_nss_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):NSS of 32bit */
N#define SPI_CR0_NSSI_SEL_nss_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):NSS of 16bit */
N#define SPI_CR0_NSSI_SEL_nss_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):NSS of 8bit */
N#define SPI_CR0_NSSI_SEL_nssi_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):NSSI of 32bit */
N#define SPI_CR0_NSSI_SEL_nssi_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):NSSI of 16bit */
N#define SPI_CR0_NSSI_SEL_nssi_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):NSSI of 8bit */
N
N#define SPI_CR0_NSSI_EN_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSSI_EN_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSSI_EN_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSSI_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_NSSI_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_NSSI_EN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_NSSI_EN_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_NSSI_EN_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_NSSI_EN_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_NSSO_EN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_NSSO_EN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_NSSO_EN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_NSSO_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_NSSO_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_NSSO_EN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_NSSO_EN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_NSSO_EN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_NSSO_EN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_IO_SWP_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_IO_SWP_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_IO_SWP_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_IO_SWP_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_IO_SWP_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_IO_SWP_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_IO_SWP_enable_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_IO_SWP_enable_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_IO_SWP_enable_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_MDS_mask_w                          ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_MDS_mask_h0                         ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_MDS_mask_b0                         ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_MDS_slave_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Slave of 32bit */
N#define SPI_CR0_MDS_slave_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Slave of 16bit */
N#define SPI_CR0_MDS_slave_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):Slave of 8bit */
N#define SPI_CR0_MDS_master_w                        ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Master of 32bit */
N#define SPI_CR0_MDS_master_h0                       ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Master of 16bit */
N#define SPI_CR0_MDS_master_b0                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):Master of 8bit */
N
N#define SPI_CR0_LSB_EN_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_LSB_EN_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_LSB_EN_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_LSB_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_LSB_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_LSB_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_LSB_EN_enable_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_LSB_EN_enable_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_LSB_EN_enable_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR0_CPHA_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_CPHA_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_CPHA_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_CPHA_leading_edge_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Leading edge of 32bit */
N#define SPI_CR0_CPHA_leading_edge_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Leading edge of 16bit */
N#define SPI_CR0_CPHA_leading_edge_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Leading edge of 8bit */
N#define SPI_CR0_CPHA_trailing_edge_w                ((uint32_t)0x00000004)  /*!< Bit Value =(1):Trailing edge of 32bit */
N#define SPI_CR0_CPHA_trailing_edge_h0               ((uint16_t)0x0004)      /*!< Bit Value =(1):Trailing edge of 16bit */
N#define SPI_CR0_CPHA_trailing_edge_b0               ((uint8_t )0x04)        /*!< Bit Value =(1):Trailing edge of 8bit */
N
N#define SPI_CR0_CPOL_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_CPOL_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_CPOL_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_CPOL_low_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):Low of 32bit */
N#define SPI_CR0_CPOL_low_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0):Low of 16bit */
N#define SPI_CR0_CPOL_low_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0):Low of 8bit */
N#define SPI_CR0_CPOL_high_w                         ((uint32_t)0x00000002)  /*!< Bit Value =(1):High of 32bit */
N#define SPI_CR0_CPOL_high_h0                        ((uint16_t)0x0002)      /*!< Bit Value =(1):High of 16bit */
N#define SPI_CR0_CPOL_high_b0                        ((uint8_t )0x02)        /*!< Bit Value =(1):High of 8bit */
N
N#define SPI_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define SPI_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SPI_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_CR1  [register's definitions]
N *              Offset[0x14]  SPI control register 1
N ******************************************************************************
N */
N///@{
N#define SPI_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_CR1 */
N#define SPI_CR1_TDAT_CLR_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define SPI_CR1_TDAT_CLR_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define SPI_CR1_TDAT_CLR_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SPI_CR1_TDAT_CLR_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR1_TDAT_CLR_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR1_TDAT_CLR_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR1_TDAT_CLR_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR1_TDAT_CLR_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR1_TDAT_CLR_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR1_RDAT_CLR_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define SPI_CR1_RDAT_CLR_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SPI_CR1_RDAT_CLR_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_CR1_RDAT_CLR_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR1_RDAT_CLR_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR1_RDAT_CLR_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR1_RDAT_CLR_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR1_RDAT_CLR_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR1_RDAT_CLR_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_CR2  [register's definitions]
N *              Offset[0x18]  SPI control register 2
N ******************************************************************************
N */
N///@{
N#define SPI_CR2_default                             ((uint32_t)0x01000100)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_CR2 */
N#define SPI_CR2_CKO_MUX_mask_w                      ((uint32_t)0x70000000)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_CKO_MUX_mask_h1                     ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_CKO_MUX_mask_b3                     ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_CKO_MUX_spi_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SPI of 32bit */
N#define SPI_CR2_CKO_MUX_spi_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SPI of 16bit */
N#define SPI_CR2_CKO_MUX_spi_b3                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):SPI of 8bit */
N#define SPI_CR2_CKO_MUX_we_w                        ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):WE of 32bit */
N#define SPI_CR2_CKO_MUX_we_h1                       ((uint16_t)0x1000)      /*!< Bit Value =(0x1):WE of 16bit */
N#define SPI_CR2_CKO_MUX_we_b3                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):WE of 8bit */
N#define SPI_CR2_CKO_MUX_oe_w                        ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):OE of 32bit */
N#define SPI_CR2_CKO_MUX_oe_h1                       ((uint16_t)0x2000)      /*!< Bit Value =(0x2):OE of 16bit */
N#define SPI_CR2_CKO_MUX_oe_b3                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):OE of 8bit */
N#define SPI_CR2_CKO_MUX_tm10_w                      ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):TM10 of 32bit */
N#define SPI_CR2_CKO_MUX_tm10_h1                     ((uint16_t)0x3000)      /*!< Bit Value =(0x3):TM10 of 16bit */
N#define SPI_CR2_CKO_MUX_tm10_b3                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):TM10 of 8bit */
N#define SPI_CR2_CKO_MUX_tm16_w                      ((uint32_t)0x40000000)  /*!< Bit Value =(0x4):TM16 of 32bit */
N#define SPI_CR2_CKO_MUX_tm16_h1                     ((uint16_t)0x4000)      /*!< Bit Value =(0x4):TM16 of 16bit */
N#define SPI_CR2_CKO_MUX_tm16_b3                     ((uint8_t )0x40)        /*!< Bit Value =(0x4):TM16 of 8bit */
N#define SPI_CR2_CKO_MUX_tm20_w                      ((uint32_t)0x50000000)  /*!< Bit Value =(0x5):TM20 of 32bit */
N#define SPI_CR2_CKO_MUX_tm20_h1                     ((uint16_t)0x5000)      /*!< Bit Value =(0x5):TM20 of 16bit */
N#define SPI_CR2_CKO_MUX_tm20_b3                     ((uint8_t )0x50)        /*!< Bit Value =(0x5):TM20 of 8bit */
N
N#define SPI_CR2_NSS_SWI_mask_w                      ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_NSS_SWI_mask_h1                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_NSS_SWI_mask_b3                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_NSS_SWI_shift_w                     (25)                    /*!< Bit Shift of 32bit */
N#define SPI_CR2_NSS_SWI_shift_h1                    (9)                     /*!< Bit Shift of 16bit */
N#define SPI_CR2_NSS_SWI_shift_b3                    (1)                     /*!< Bit Shift of 8bit */
N
N#define SPI_CR2_NSS_SWO_mask_w                      ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_NSS_SWO_mask_h1                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_NSS_SWO_mask_b3                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_NSS_SWO_shift_w                     (24)                    /*!< Bit Shift of 32bit */
N#define SPI_CR2_NSS_SWO_shift_h1                    (8)                     /*!< Bit Shift of 16bit */
N#define SPI_CR2_NSS_SWO_shift_b3                    (0)                     /*!< Bit Shift of 8bit */
N
N#define SPI_CR2_DSIZE_mask_w                        ((uint32_t)0x001F0000)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_DSIZE_mask_h1                       ((uint16_t)0x001F)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_DSIZE_mask_b2                       ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_DSIZE_shift_w                       (16)                    /*!< Bit Shift of 32bit */
N#define SPI_CR2_DSIZE_shift_h1                      (0)                     /*!< Bit Shift of 16bit */
N#define SPI_CR2_DSIZE_shift_b2                      (0)                     /*!< Bit Shift of 8bit */
N
N#define SPI_CR2_RX_TH_mask_w                        ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_RX_TH_mask_h0                       ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_RX_TH_mask_b1                       ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_RX_TH_1_byte_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1-byte of 32bit */
N#define SPI_CR2_RX_TH_1_byte_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1-byte of 16bit */
N#define SPI_CR2_RX_TH_1_byte_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):1-byte of 8bit */
N#define SPI_CR2_RX_TH_2_byte_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):2-byte of 32bit */
N#define SPI_CR2_RX_TH_2_byte_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):2-byte of 16bit */
N#define SPI_CR2_RX_TH_2_byte_b1                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):2-byte of 8bit */
N#define SPI_CR2_RX_TH_3_byte_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):3-byte of 32bit */
N#define SPI_CR2_RX_TH_3_byte_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):3-byte of 16bit */
N#define SPI_CR2_RX_TH_3_byte_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):3-byte of 8bit */
N#define SPI_CR2_RX_TH_4_byte_w                      ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):4-byte of 32bit */
N#define SPI_CR2_RX_TH_4_byte_h0                     ((uint16_t)0x0300)      /*!< Bit Value =(0x3):4-byte of 16bit */
N#define SPI_CR2_RX_TH_4_byte_b1                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):4-byte of 8bit */
N
N#define SPI_CR2_TX_DIS_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_TX_DIS_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_TX_DIS_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_TX_DIS_enable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define SPI_CR2_TX_DIS_enable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define SPI_CR2_TX_DIS_enable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define SPI_CR2_TX_DIS_disable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Disable of 32bit */
N#define SPI_CR2_TX_DIS_disable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Disable of 16bit */
N#define SPI_CR2_TX_DIS_disable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define SPI_CR2_DAT_LINE_mask_w                     ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_DAT_LINE_mask_h0                    ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_DAT_LINE_mask_b0                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_DAT_LINE_spi_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SPI of 32bit */
N#define SPI_CR2_DAT_LINE_spi_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SPI of 16bit */
N#define SPI_CR2_DAT_LINE_spi_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):SPI of 8bit */
N#define SPI_CR2_DAT_LINE_1_w                        ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):1 of 32bit */
N#define SPI_CR2_DAT_LINE_1_h0                       ((uint16_t)0x0010)      /*!< Bit Value =(0x1):1 of 16bit */
N#define SPI_CR2_DAT_LINE_1_b0                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):1 of 8bit */
N#define SPI_CR2_DAT_LINE_2_w                        ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):2 of 32bit */
N#define SPI_CR2_DAT_LINE_2_h0                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):2 of 16bit */
N#define SPI_CR2_DAT_LINE_2_b0                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):2 of 8bit */
N#define SPI_CR2_DAT_LINE_4_w                        ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):4 of 32bit */
N#define SPI_CR2_DAT_LINE_4_h0                       ((uint16_t)0x0030)      /*!< Bit Value =(0x3):4 of 16bit */
N#define SPI_CR2_DAT_LINE_4_b0                       ((uint8_t )0x30)        /*!< Bit Value =(0x3):4 of 8bit */
N#define SPI_CR2_DAT_LINE_8_w                        ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):8 of 32bit */
N#define SPI_CR2_DAT_LINE_8_h0                       ((uint16_t)0x0050)      /*!< Bit Value =(0x5):8 of 16bit */
N#define SPI_CR2_DAT_LINE_8_b0                       ((uint8_t )0x50)        /*!< Bit Value =(0x5):8 of 8bit */
N
N#define SPI_CR2_COPY_EN_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_COPY_EN_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_COPY_EN_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_COPY_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR2_COPY_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR2_COPY_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR2_COPY_EN_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR2_COPY_EN_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR2_COPY_EN_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define SPI_CR2_BDIR_OE_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define SPI_CR2_BDIR_OE_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define SPI_CR2_BDIR_OE_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SPI_CR2_BDIR_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SPI_CR2_BDIR_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SPI_CR2_BDIR_OE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SPI_CR2_BDIR_OE_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define SPI_CR2_BDIR_OE_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define SPI_CR2_BDIR_OE_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_RDAT  [register's definitions]
N *              Offset[0x30]  SPI data receive register
N ******************************************************************************
N */
N///@{
N#define SPI_RDAT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_RDAT */
N#define SPI_RDAT_RDAT_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define SPI_RDAT_RDAT_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define SPI_RDAT_RDAT_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define SPI_RDAT_RDAT_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_TDAT  [register's definitions]
N *              Offset[0x34]  SPI data transmit register
N ******************************************************************************
N */
N///@{
N#define SPI_TDAT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_TDAT */
N#define SPI_TDAT_TDAT_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define SPI_TDAT_TDAT_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define SPI_TDAT_TDAT_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define SPI_TDAT_TDAT_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SPI_TDAT3  [register's definitions]
N *              Offset[0x38]  SPI TX data 3-byte register
N ******************************************************************************
N */
N///@{
N#define SPI_TDAT3_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SPI_TDAT3 */
N#define SPI_TDAT3_TDAT3_mask_w                      ((uint32_t)0x00FFFFFF)  /*!< Bit Mask of 32bit */
N#define SPI_TDAT3_TDAT3_shift_w                     (0)                     /*!< Bit Shift of 32bit */
N#define SPI_TDAT3_TDAT3_shift_h0                    (0)                     /*!< Bit Shift of 16bit */
N#define SPI_TDAT3_TDAT3_shift_b0                    (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_SPI_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_SPI.h                         */
N/*----------------------------------------------------------------------------*/
L 31 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_SPI_DRV.h" 2
N#include "MG32x02z_GPIO.h"
N
N
N#ifndef _MG32x02z_SPI_DRV_H
N/*!< _MG32x02z_SPI_DRV_H */ 
N#define _MG32x02z_SPI_DRV_H
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define SPI_BUSYF   SPI_STA_BUSYF_mask_w    /*!< SPIx data transfer busy flag */
N#define SPI_IDLF    SPI_STA_IDLF_mask_w     /*!< SPIx slave mode NSS idle detect flag */
N#define SPI_TCF     SPI_STA_TCF_mask_w      /*!< SPIx transmission complete flag */
N#define SPI_RXDF    SPI_STA_RXDF_mask_w     /*!< SPIx received data byte number is different from previous received data byte number for SPI0_RDAT register */
N#define SPI_RXF     SPI_STA_RXF_mask_w      /*!< SPIx receive data buffer level high flag */
N#define SPI_TXF     SPI_STA_TXF_mask_w      /*!< SPIx transmit data buffer level low flag */
N#define SPI_MODF    SPI_STA_MODF_mask_w     /*!< SPIx mode detect fault flag */
N#define SPI_WEF     SPI_STA_WEF_mask_w      /*!< SPIx slave mode write error flag */
N#define SPI_ROVRF   SPI_STA_ROVRF_mask_w    /*!< SPIx receive overrun flag */
N#define SPI_TUDRF   SPI_STA_TUDRF_mask_w    /*!< SPIx slave mode transmit underrun flag */
N#if (defined(MG32_2ND) || defined(MG32_3RD))
X#if (0L || 0L)
S#define SPI_IDL_STA SPI_STA_IDL_STA_mask_w  /*!< SPIx master/slave mode NSS idle detect state*/
N#endif
N#define SPI_ALLF    SPI_IDLF | SPI_TCF | SPI_RXF | SPI_TXF | SPI_MODF | SPI_WEF | SPI_ROVRF | SPI_TUDRF /*!< All event and interrupt flag */
N#define SPI_INT_IDL     SPI_INT_IDL_IE_mask_w   /*!< SPIx slave mode NSS idle detect interrupt enable */
N#define SPI_INT_TC      SPI_INT_TC_IE_mask_w    /*!< SPIx transmission complete interrupt enable */
N#define SPI_INT_RX      SPI_INT_RX_IE_mask_w    /*!< SPIx Receive data register not empty interrupt enable */
N#define SPI_INT_TX      SPI_INT_TX_IE_mask_w    /*!< SPIx TX buffer underflow the threshold SPI0_TX_TH Interrupt enable */
N#define SPI_INT_MODF    SPI_INT_MODF_IE_mask_w  /*!< SPIx mode detect fault interrupt enable */
N#define SPI_INT_WE      SPI_INT_WE_IE_mask_w    /*!< SPIx slave mode write error interrupt enable */
N#define SPI_INT_ROVR    SPI_INT_ROVR_IE_mask_w  /*!< SPIx RX buffer receive overrun interrupt enable */
N#define SPI_INT_TUDR    SPI_INT_TUDR_IE_mask_w  /*!< SPIx TX buffer transmit underrun interrupt enable */
N
N/* @} */
N
N
N/*! @enum   SPI_CLKS_Enum
N    @brief  SPIx internal clock CK_SPIx source selection.
N*/
Ntypedef enum
N{
N    SPI_CK_SPIx_PR      = 0,    /*!< PROC : CK_SPI0_PR process clock from CSC */
N    SPI_TM00_TRGO       = 2     /*!< TM00_TRGO */
N}SPI_CLKS_Enum;
N
N
N/*! @enum   SPI_PDIV_Enum
N    @brief  SPIx process clock CK_SPIx_PR input divide selection.
N*/
Ntypedef enum
N{
N    SPI_PDIV_1      = 0,    /* divided by 1 */
N    SPI_PDIV_2      = 1,    /* divided by 2 */
N    SPI_PDIV_4      = 2,    /* divided by 4 */
N    SPI_PDIV_8      = 3     /* divided by 8 */
N}SPI_PDIV_Enum;
N
N
N/*! @enum   SPI_PSC_Enum
N    @brief  SPIx internal clock CK_SPIx_INT prescaler selection.
N*/
Ntypedef enum
N{
N    SPI_PSC_1       = 0,    /* divided 1 */
N    SPI_PSC_2       = 1,    /* divided 2 */
N    SPI_PSC_3       = 2,    /* divided 3 */
N    SPI_PSC_4       = 3,    /* divided 4 */
N    SPI_PSC_5       = 4,    /* divided 5 */
N    SPI_PSC_6       = 5,    /* divided 6 */
N    SPI_PSC_7       = 6,    /* divided 7 */
N    SPI_PSC_8       = 7     /* divided 8 */
N}SPI_PSC_Enum;
N   
N
N/*! @enum   SPI_DIV_Enum
N    @brief  SPIx internal clock CK_SPIx_INT input divider selection.
N*/
Ntypedef enum
N{
N    SPI_DIV_2      = 0,    /* divided by 2 */
N    SPI_DIV_4      = 1,    /* divided by 4 */
N    SPI_DIV_8      = 2,    /* divided by 8 */
N    SPI_DIV_16     = 3     /* divided by 16 */
N}SPI_DIV_Enum;
N
N
N/*! @enum   TRS_Enum
N    @brief  SPIx transfer rate selection
N*/
Ntypedef enum
N{
N    SPI_StandardTransferRate    = 0,    /*!< Standard transfer rate */
N    SPI_DualTransferRate        = 1     /*!< Dual transfer rate */
N} TRS_Enum;
N
N
N/*! @enum   MODNSS_Enum
N    @brief  SPIx mode and NSS inputp/output selection.
N*/
Ntypedef enum
N{
N    SPI_Master                  = 0x00000010,   /* Master without NSS output */
N    SPI_MasterWithNss           = 0x00000110,   /* Master with NSS output */
N    SPI_MasterWithMODF          = 0x00000210,   /* Master without NSS output and with MODF function */
N    SPI_MasterWithNssAndMODF    = 0x00000310,   /* Master with NSS output and with MODF function */
N    SPI_Slave                   = 0x00000000,   /* Slave without NSS intput */
N    SPI_SlaveWithNss            = 0x00000200,   /* Slave with NSS intput */
N} MODNSS_Enum;
N
N
N
N/*! @enum   MODF_Enum
N    @brief  SPIx function select when master mode fault detect.
N*/
Ntypedef enum
N{
N    SPI_DisableSPI      = 0,    /* SPI disable */
N    SPI_SwitchToSlave   = 1     /* Switch to slave */
N} MODF_Enum;
N
N
N
N/*! @enum   NSSI_Enum
N    @brief  SPI0 pin select for NSS input signal.
N*/
Ntypedef enum
N{
N    SPI_NssPin  = 0,    /* SPI0_NSS pin */ 
N    SPI_NssiPin = 1     /* SPI0_NSSI pin */
N} NSSI_Enum;
N
N
N/*! @enum   CPHA_Enum
N    @brief  SPI clock phase selection.
N*/
Ntypedef enum
N{
N    SPI_LeadingEdge     = 0,    /* Leading edge */
N    SPI_TrailingEdge    = 1     /* Trailing edge */
N} CPHA_Enum;
N
N
N/*! @enum   CPOL_Enum 
N    @brief  SPI clock polarity selection.
N*/
Ntypedef enum
N{
N    SPI_Low     = 0,    /* Low */
N    SPI_High    = 1     /* High */
N} CPOL_Enum;
N
N
N/*! @enum   RNUM_Enum
N    @brief  SPI set RNUM data 
N*/
Ntypedef enum
N{
N    SPI_RNUM_0Byte  = 0,    /* 0-byte */
N    SPI_RNUM_1Byte  = 1,    /* 1-byte */
N    SPI_RNUM_2Byte  = 2,    /* 2-byte */
N    SPI_RNUM_3Byte  = 3,    /* 3-byte */
N    SPI_RNUM_4Byte  = 4     /* 4-byte */
N} RNUM_Enum;
N
N
N/*! @enum   Byte_Enum
N    @brief  Transmit bytes number selection.
N*/
Ntypedef enum
N{
N    SPI_1Byte   = 0,    /* Transmit 1byte */
N    SPI_2Byte   = 1,    /* Transmit 2byte */
N    SPI_3Byte   = 2,    /* Transmit 3byte */
N    SPI_4Byte   = 3     /* Transmit 4byte */
N} Byte_Enum;
N
N
N/*! @enum   DSIZE_Enum
N    @brief  SPI transfer data frame bit size from 4-bit to 32-bit.
N*/
Ntypedef enum
N{
N    SPI_4bits   = 4,    /**/
N    SPI_5bits   = 5, 
N    SPI_6bits   = 6,     
N    SPI_7bits   = 7,     
N    SPI_8bits   = 8,     
N    SPI_9bits   = 9,     
N    SPI_10bits  = 10,     
N    SPI_11bits  = 11,     
N    SPI_12bits  = 12,     
N    SPI_13bits  = 13, 
N    SPI_14bits  = 14,     
N    SPI_15bits  = 15,     
N    SPI_16bits  = 16,     
N    SPI_17bits  = 17,     
N    SPI_18bits  = 18,     
N    SPI_19bits  = 19,     
N    SPI_20bits  = 20,  
N    SPI_21bits  = 21, 
N    SPI_22bits  = 22,     
N    SPI_23bits  = 23,     
N    SPI_24bits  = 24,     
N    SPI_25bits  = 25,     
N    SPI_26bits  = 26,     
N    SPI_27bits  = 27,     
N    SPI_28bits  = 28,  
N    SPI_29bits  = 29, 
N    SPI_30bits  = 30,     
N    SPI_31bits  = 31,     
N    SPI_32bits  = 0   
N} DSIZE_Enum;
N
N
N/*! @enum   DATALINE_Enum
N    @brief  SPI data line number selection.
N*/
Ntypedef enum
N{
N    SPI_Standard            = 0,    /* 2-lines separated~ standard SPI mode */
N    SPI_1LineBidirection    = 1,    /* 1-line Bidirectional~ SPI0_MOSI */
N    SPI_2LinesBidirection   = 2,    /* 2-lines Bidirectional~ SPI0_D0(MOSI), SPI0_D1(MISO) */
N    SPI_4LinesBidirection   = 3,    /* 4-lines Bidirectional~ SPI0_D0 ~ SPI0_D3 */
N    SPI_4LinesDuplicate     = 4,    /* 8-lines TX~ SPI0_D0 ~ SPI0_D3 with duplicate SPI0_D4 ~ SPI0_D7 */
N    SPI_8LinesBidirection   = 5     /* 8-lines Bidirectional~ SPI0_D0 ~ SPI0_D7 */
N} DATALINE_Enum;
N
N
N/*! @enum   CKOMUX_Enum
N    @brief  SPI CLK output signal selection.
N*/
Ntypedef enum
N{
N    SPI_Clock       = 0,    /* SPI clock */
N#if (defined(MG32_1ST) || defined(MG32_3RD))
X#if (1L || 0L)
N    EMB_MweSignal   = 1,    /* EMB MWE signal */
N    EMB_MoeSignal   = 2,    /* EMB MOE signal */
N#endif
N    TM10_CKOSignal  = 3,    /* TM10_CKO */
N    TM16_CKOSignal  = 4,    /* TM16_CKO */
N#if (defined(MG32_2ND) || defined(MG32_3RD))
X#if (0L || 0L)
S    TM20_CKOSignal  = 5     /* TM20_CKO */
N#endif
N} CKOMUX_Enum;
N
N
N/*! @enum   SPI_FBS_Enum
N    @brief  SPI data order first bit selection.
N*/
Ntypedef enum
N{
N    SPI_MSB     = 0,    /*!< Trsamit and receive first bit is MSB */
N    SPI_LSB     = 1     /*!< Trsamit and receive first bit is LSB */
N}SPI_FBS_Enum;
N
N
N/*! @enum   SPI_BDIR_Enum
N    @brief  SPIx transfer bidirection select.
N*/
Ntypedef enum
N{
N    SPI_BDIR_IN     = 0,    /*!< Transfer bidirectional input */
N    SPI_BDIR_OUT    = 1     /*!< Transfer bidirectional output */
N}SPI_BDIR_Enum;
N
N
N/*! @enum   IDT_Enum
N    @brief  SPIx master NSS idle time selection
N*/
Ntypedef enum
N{
N    SPI_IDT_1T  = 0,    /*!< Master NSS idle time 1T */
N    SPI_IDT_2T  = 1     /*!< Master NSS idle time 2T */
N}IDT_Enum;
N
N/*! @enum   DOUT_MDS_Enum
N    @brief  SPIx idle state data mode selection
N*/
Ntypedef enum
N{
N    SPI_OutputWithTristate = 0, /*!< Output with tristate */
N    SPI_OutputWithDriving = 1   /*!< Output with driving */
N}DOUT_MDS_Enum;
N
N/*! @enum   DOUT_IDL_Enum
N    @brief  SPI idle state data output selection
N*/
Ntypedef enum
N{
N    SPI_DOUT_IDL_LastBit = 0,   /*!< Data output idle last bit */
N    SPI_DOUT_IDL_0       = 2,   /*!< Data output idle 0 */
N    SPI_DOUT_IDL_1       = 3,   /*!< Data output idle 1 */
N}DOUT_IDL_Enum;
N
N
N/*! @name
N*/       
N/* @{ */ 
N
N
N/**
N * @name    Function announce
N *
N */ 
N///@{  
Nvoid SPI_DeInit (SPI_Struct* SPIx);
N
Nvoid SPI_Clock_Select (SPI_Struct* SPIx, SPI_CLKS_Enum SPI_CLKS);
Nvoid SPI_PreDivider_Select (SPI_Struct* SPIx, SPI_PDIV_Enum SPI_PDIVS);
Nvoid SPI_Prescaler_Select (SPI_Struct* SPIx, SPI_PSC_Enum SPI_PSCS);
Nvoid SPI_Divider_Select (SPI_Struct* SPIx, SPI_DIV_Enum SPI_DIVS);
N
Nvoid SPI_ModeAndNss_Select (SPI_Struct* SPIx, MODNSS_Enum SPI_MNS);
Nvoid SPI_ModfHappenedAction_Select (SPI_Struct* SPIx, MODF_Enum SPI_MODFS);
N
Nvoid SPI_NSSInputSignal_Select (SPI_Struct* SPIx, NSSI_Enum SPI_NSSIS);
Nvoid SPI_SingleMasterModeNssPulse_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_NssInputInverse_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_NssOutputInverse_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_NssInputOutputSoftwareControl_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
N     
Nvoid SPI_NSSInputStatusControl_SW (SPI_Struct* SPIx, DRV_Return NewStatus);
NDRV_Return SPI_GetNSSInputStatust (SPI_Struct* SPIx);
Nvoid SPI_NSSOutputStatusControl_SW (SPI_Struct* SPIx, DRV_Return NewStatus);
Nvoid SPI_Cmd(SPI_Struct* SPIx, FunctionalState NewState);
N
Nvoid SPI_ClockPhase_Select (SPI_Struct* SPIx, CPHA_Enum SPI_CPHAS);
Nvoid SPI_ClockPolarity_Select (SPI_Struct* SPIx, CPOL_Enum SPI_CPOLS);
Nvoid SPI_FirstBit_Select (SPI_Struct* SPIx, SPI_FBS_Enum SPI_FBS);
N
Nuint8_t SPI_GetRxShadowBufferLevel (SPI_Struct* SPIx);
Nvoid SPI_ClearRxData (SPI_Struct* SPIx);
Nuint8_t SPI_GetDataBufferReceivedBytes (SPI_Struct* SPIx);
Nvoid SPI_SetDataBufferReceivedBytes (SPI_Struct* SPIx, RNUM_Enum SPI_RNUMS);
Nvoid SPI_ClearTxData (SPI_Struct* SPIx);
Nuint8_t SPI_GetTxShadowBufferLevel (SPI_Struct* SPIx);
Nuint32_t SPI_GetRxData (SPI_Struct* SPIx);
Nvoid SPI_SetTxData (SPI_Struct* SPIx, Byte_Enum SPI_Byte, uint32_t SPI_DAT);
Nuint32_t SPI_GetTxData (SPI_Struct* SPIx);
Nvoid SPI_SlaveModeReceivedThreshold_Select (SPI_Struct* SPIx, Byte_Enum SPI_RxTH);
N
Nvoid SPI_DataSize_Select (SPI_Struct* SPIx, DSIZE_Enum SPI_DSIZES);
Nvoid SPI_DataLine_Select (SPI_Struct* SPIx, DATALINE_Enum SPI_LINES);
Nvoid SPI_DataLineOutput_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_SendCopyMode_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_BidirectionalOutput_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_TransferBidirection_Select (SPI_Struct* SPIx, SPI_BDIR_Enum BDIR_SEL);
Nvoid SPI_MosiMisoSignalSwap_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
N#if (defined(MG32_3RD))
X#if (0L)
Svoid SPI_D03D47SignalSwap_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
N#endif
Nvoid SPI_LoopBackMode_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_ClockOutputSignal_Select (SPI_Struct* SPIx, CKOMUX_Enum SPI_CKOS);
N
Nvoid SPI_TXDMA_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_RXDMA_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Nvoid SPI_RXDMAPreCatch_Cmd(SPI_Struct* SPIx, FunctionalState NewState);
N
Nuint32_t SPI_GetAllFlagStatus (SPI_Struct* SPIx);
NDRV_Return SPI_GetSingleFlagStatus (SPI_Struct* SPIx, uint32_t SPI_Flag);
Nvoid SPI_ClearFlag (SPI_Struct* SPIx, uint32_t SPI_Flag);
Nvoid SPI_IT_Config (SPI_Struct* SPIx, uint32_t SPI_INTS, FunctionalState NewState);
Nvoid SPI_ITEA_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
N
N#if (defined(MG32_2ND) || defined(MG32_3RD))
X#if (0L || 0L)
Svoid SPI_DualTransferRate_Select (SPI_Struct* SPIx, TRS_Enum SPI_TRS);
Svoid SPI_NssIdleTime_Select (SPI_Struct* SPIx, IDT_Enum SPI_IDTS);
Svoid SPI_SlaveAutoFullDuplex_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_IdleStateDataMode_Select (SPI_Struct* SPIx, DOUT_MDS_Enum SPI_DOMDS);
Svoid SPI_NssInputSoftwareControl_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_TriggerClockToggle (SPI_Struct* SPIx);
Svoid SPI_SlaveHighSpeed_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_NssOutputSoftwareControl_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_SlaveSendDataDirectUpdate_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_SlaveDataReadShadowBufferTriggerToUpload_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Svoid SPI_MasterRXSamplingNextHalfClockEdge_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_SlaveAsynchronous_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_SlaveSDTMode_Cmd (SPI_Struct* SPIx, FunctionalState NewState);
Svoid SPI_MasterDataOutIdleState_Select (SPI_Struct* SPIx, DOUT_IDL_Enum IdleState);
N#endif
N
N
N
N///@}
N
N#endif  //_MG32x02z_SPI_DRV_H
N
N
L 51 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_SYS_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_SYS_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_SYS_DRV.H
N *
N * @brief       This is the C code format driver head file for SYS module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.13
N * @date        2021/03/26
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2021 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par 		Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N
N#ifndef _MG32x02z_SYS_DRV_H
N/*!< _MG32x02z_SYS_DRV_H */ 
N#define _MG32x02z_SYS_DRV_H 
N
N
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_SYS.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_SYS.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_SYS.h
N *
N * @brief       MG32x02z SYS Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_SYS_H
N#define _MG32x02z_SYS_H
N#define _MG32x02z_SYS_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_SYS_H_VER)
S    #error "MG32x02z_SYS_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      SYS_Struct
N *              SYS  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x00]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] System interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  SYS interrupt enable register */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t MID           :32;    //[31..0] Chip manufacture identification code.
X            volatile const  uint32_t MID           :32;    
N        }MBIT;
N    }MID;                               /*!< MID        ~ Offset[0x0C]  SYS chip manufacture identification code */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  CH0_LAST      :1;     //[16] DMA Channel-0 last loop command
X            volatile uint8_t  CH0_LAST      :1;     
N                                        //0 = Not
N                                        //1 = Yes
N            __IO uint8_t  CH1_LAST      :1;     //[17] DMA Channel-1 last loop command
X            volatile uint8_t  CH1_LAST      :1;     
N                                        //0 = Not
N                                        //1 = Yes
N            __IO uint8_t  CH2_LAST      :1;     //[18] DMA Channel-2 last loop command
X            volatile uint8_t  CH2_LAST      :1;     
N                                        //0 = Not
N                                        //1 = Yes
N            __IO uint8_t  GPR           :5;     //[23..19] General purpose data register bits.
X            volatile uint8_t  GPR           :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  SYS System control register 0 */
N
N} SYS_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        SYS  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define SYS_Base                        ((uint32_t)0x4C030000)              /*!< System and Chip Control */
N#define SYS                             ((SYS_Struct*) SYS_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        SYS  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        SYS_INT  [register's definitions]
N *              Offset[0x04]  SYS interrupt enable register (0x4C030004)
N ******************************************************************************
N */
N///@{
N#define SYS_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SYS_INT */
N#define SYS_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define SYS_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SYS_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SYS_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define SYS_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define SYS_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define SYS_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define SYS_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define SYS_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SYS_MID  [register's definitions]
N *              Offset[0x0C]  SYS chip manufacture identification code (0x4C03000C)
N ******************************************************************************
N */
N///@{
N#define SYS_MID_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SYS_MID */
N#define SYS_MID_MID_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define SYS_MID_MID_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define SYS_MID_MID_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define SYS_MID_MID_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        SYS_CR0  [register's definitions]
N *              Offset[0x10]  SYS System control register 0 (0x4C030010)
N ******************************************************************************
N */
N///@{
N#define SYS_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of SYS_CR0 */
N#define SYS_CR0_GPR_mask_w                          ((uint32_t)0x00F80000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_GPR_mask_h1                         ((uint16_t)0x00F8)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_GPR_mask_b2                         ((uint8_t )0xF8)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_GPR_shift_w                         (19)                    /*!< Bit Shift of 32bit */
N#define SYS_CR0_GPR_shift_h1                        (3)                     /*!< Bit Shift of 16bit */
N#define SYS_CR0_GPR_shift_b2                        (3)                     /*!< Bit Shift of 8bit */
N
N#define SYS_CR0_CH2_LAST_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_CH2_LAST_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_CH2_LAST_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_CH2_LAST_not_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Not of 32bit */
N#define SYS_CR0_CH2_LAST_not_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Not of 16bit */
N#define SYS_CR0_CH2_LAST_not_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Not of 8bit */
N#define SYS_CR0_CH2_LAST_yes_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Yes of 32bit */
N#define SYS_CR0_CH2_LAST_yes_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Yes of 16bit */
N#define SYS_CR0_CH2_LAST_yes_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Yes of 8bit */
N
N#define SYS_CR0_CH1_LAST_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_CH1_LAST_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_CH1_LAST_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_CH1_LAST_not_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Not of 32bit */
N#define SYS_CR0_CH1_LAST_not_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Not of 16bit */
N#define SYS_CR0_CH1_LAST_not_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Not of 8bit */
N#define SYS_CR0_CH1_LAST_yes_w                      ((uint32_t)0x00020000)  /*!< Bit Value =(1):Yes of 32bit */
N#define SYS_CR0_CH1_LAST_yes_h1                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Yes of 16bit */
N#define SYS_CR0_CH1_LAST_yes_b2                     ((uint8_t )0x02)        /*!< Bit Value =(1):Yes of 8bit */
N
N#define SYS_CR0_CH0_LAST_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define SYS_CR0_CH0_LAST_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define SYS_CR0_CH0_LAST_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define SYS_CR0_CH0_LAST_not_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Not of 32bit */
N#define SYS_CR0_CH0_LAST_not_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Not of 16bit */
N#define SYS_CR0_CH0_LAST_not_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Not of 8bit */
N#define SYS_CR0_CH0_LAST_yes_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Yes of 32bit */
N#define SYS_CR0_CH0_LAST_yes_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Yes of 16bit */
N#define SYS_CR0_CH0_LAST_yes_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Yes of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_SYS_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_SYS.h                         */
N/*----------------------------------------------------------------------------*/
L 37 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_SYS_DRV.h" 2
N
N
N
N/**
N * @name    Function announce
N *
N */ 
N///@{  
Nvoid SYS_ITEA_Cmd (FunctionalState NewState);
Nuint32_t SYS_GetChipMID (void);
Nuint8_t SYS_ReadGeneralReg (void);
Nvoid SYS_WriteGeneralReg (uint8_t SYS_Value);
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
Suint32_t SYS_ReadBackupReg (void);
Svoid SYS_WriteBackupReg (uint32_t SYS_Value);
N#endif
N///@}
N
N
N#endif  //_MG32x02z_SYS_DRV_H
N
L 52 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_TM_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_TM_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_TM_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the TM 
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.25
N * @date        2021/02/26
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N#ifndef _MG32x02z_TM_DRV_H
N
N/*!< _MG32x02z_TM_DRV_H */ 
N#define _MG32x02z_TM_DRV_H
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_TM.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_TM.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_TM.h
N *
N * @brief       MG32x02z TM Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_TM_H
N#define _MG32x02z_TM_H
N#define _MG32x02z_TM_H_VER                          3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_TM_H_VER)
S    #error "MG32x02z_TM_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      TM_Struct
N *              TM  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  DIRF          :1;     //[0] Main Timer up/down counting flag.
X            volatile const  uint8_t  DIRF          :1;     
N                                        //0 = Up counting
N                                        //1 = Down counting
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKF           :1;     //[2] Timer break input flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  BKF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  EXF           :1;     //[3] Timer external trigger flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  EXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TOF           :1;     //[4] Main Timer overflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TOF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TOF2          :1;     //[5] 2nd Timer overflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TOF2          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TUF           :1;     //[6] Main Timer underflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TUF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TUF2          :1;     //[7] 2nd Timer underflow flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TUF2          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF0A          :1;     //[8] Timer IC0 rising edge flag/OC0 event main flag
X            volatile uint8_t  CF0A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF1A          :1;     //[9] Timer IC1 rising edge flag/OC1 event main flag
X            volatile uint8_t  CF1A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF2A          :1;     //[10] Timer IC2 rising edge flag/OC2 event main flag
X            volatile uint8_t  CF2A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF3A          :1;     //[11] Timer IC3 rising edge flag/OC3 event main flag
X            volatile uint8_t  CF3A          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF0B          :1;     //[12] Timer IC0 falling edge flag/OC0 event sub flag
X            volatile uint8_t  CF0B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF1B          :1;     //[13] Timer IC1 falling edge flag/OC1 event sub flag
X            volatile uint8_t  CF1B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF2B          :1;     //[14] Timer IC2 falling edge flag/OC2 event sub flag
X            volatile uint8_t  CF2B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CF3B          :1;     //[15] Timer IC3 falling edge flag/OC3 event sub flag
X            volatile uint8_t  CF3B          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  DIRCF         :1;     //[16] Main Timer up/down counting direction change flag.
X            volatile uint8_t  DIRCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IDXF          :1;     //[18] Main Timer QEI external index signal input active detect and internal timer reset fla
X            volatile uint8_t  IDXF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  QPEF          :1;     //[19] Main Timer QEI phase state transition error detect flag.
X            volatile uint8_t  QPEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  TM Timer status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] Timer interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKIE          :1;     //[2] Timer break input interrupt enable.
X            volatile uint8_t  BKIE          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EXIE          :1;     //[3] Timer external trigger interrupt enable.
X            volatile uint8_t  EXIE          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TIE           :1;     //[4] Timer overflow/underflow interrupt enable.
X            volatile uint8_t  TIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TIE2          :1;     //[5] 2nd Timer overflow/underflow interrupt enable.
X            volatile uint8_t  TIE2          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CC0_IE        :1;     //[8] Timer IC0/OC0 interrupt enable.
X            volatile uint8_t  CC0_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CC1_IE        :1;     //[9] Timer IC1/OC1 interrupt enable.
X            volatile uint8_t  CC1_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CC2_IE        :1;     //[10] Timer IC2/OC2 interrupt enable.
X            volatile uint8_t  CC2_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CC3_IE        :1;     //[11] Timer IC3/OC3 interrupt enable.
X            volatile uint8_t  CC3_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DIRC_IE       :1;     //[16] Main Timer up/down counting direction change interrupt enable.
X            volatile uint8_t  DIRC_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IDX_IE        :1;     //[18] Main Timer QEI external index signal input active detect interrupt enable.
X            volatile uint8_t  IDX_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  QPE_IE        :1;     //[19] Main Timer QEI phase state transition error detect interrupt enable.
X            volatile uint8_t  QPE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  TM Timer interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :3;     //[2..0] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CKE_SEL       :2;     //[5..4] Timer internal clock CK_EXT source select.
X            volatile uint8_t  CKE_SEL       :2;     
N                                        //0x0 = ETR (CK_ETR)
N                                        //0x1 = ITR (CK_ITR)
N                                        //0x2 = IN0 (TM_IN0)
N                                        //0x3 = IN1 (TM_IN1)
N            __IO uint8_t  CKS_SEL       :1;     //[6] Counter/Timer CK_TC clock source select.
X            volatile uint8_t  CKS_SEL       :1;     
N                                        //0 = CK_INT
N                                        //1 = CK_EXT
N            __IO uint8_t  CKS2_SEL      :1;     //[7] Counter/Timer CK_TC2 clock source select.
X            volatile uint8_t  CKS2_SEL      :1;     
N                                        //0 = CK_INT
N                                        //1 = CK_EXT
N            __IO uint8_t  CKI_SEL       :2;     //[9..8] Timer input clock CK_TM source select.
X            volatile uint8_t  CKI_SEL       :2;     
N                                        //0x0 = PROC : CK_TM_PR process clock from CSC
N                                        //0x1 = Reserved
N                                        //0x2 = CK_LS
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CKI_DIV       :2;     //[13..12] Timer internal clock CK_TM_INT input divider.
X            volatile uint8_t  CKI_DIV       :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  DTG_DIV       :2;     //[17..16] Timer internal dead time clock CK_DTG divider.
X            volatile uint8_t  DTG_DIV       :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  TM Timer clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TRGI_MDS      :3;     //[2..0] Timer trigger input mode select
X            volatile uint8_t  TRGI_MDS      :3;     
N                                        //0x0 = No operation
N                                        //0x1 = Trigger-R (TRGI rising)
N                                        //0x2 = Reset-R (TRGI rising)
N                                        //0x3 = Gate-H (TRGI high)
N                                        //0x4 = Reset (TRGI dual edge)
N                                        //0x5 = Trigger-F (TRGI falling)
N                                        //0x6 = Reset-F (TRGI falling)
N                                        //0x7 = Gate-L (TRGI low)
N            __IO uint8_t  TRGI2_MDS     :3;     //[5..3] 2nd Timer trigger input mode select
X            volatile uint8_t  TRGI2_MDS     :3;     
N                                        //0x0 = No operation
N                                        //0x1 = Trigger-R (TRGI rising)
N                                        //0x2 = Reset-R (TRGI rising)
N                                        //0x3 = Gate-H (TRGI high)
N                                        //0x4 = Reset (TRGI dual edge)
N                                        //0x5 = Trigger-F (TRGI falling)
N                                        //0x6 = Reset-F (TRGI falling)
N                                        //0x7 = Gate-L (TRGI low)
N            __IO uint8_t  TRG_MUX       :2;     //[7..6] Timer trigger source TRGI select.
X            volatile uint8_t  TRG_MUX       :2;     
N                                        //0x0 = ETR (CK_ETR)
N                                        //0x1 = ITR (CK_ITR)
N                                        //0x2 = IN0 (TM_IN0)
N                                        //0x3 = IN1 (TM_IN1)
N            __IO uint8_t  ITR_MUX       :3;     //[10..8] Timer internal trigger source select
X            volatile uint8_t  ITR_MUX       :3;     
N                                        //0x0 = ITR0 (TM_ITR0)
N                                        //0x1 = ITR1 (TM_ITR1)
N                                        //0x2 = ITR2 (TM_ITR2)
N                                        //0x3 = ITR3 (TM_ITR3)
N                                        //0x4 = ITR4 (TM_ITR4)
N                                        //0x5 = ITR5 (TM_ITR5)
N                                        //0x6 = ITR6 (TM_ITR6)
N                                        //0x7 = ITR7 (TM_ITR7)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TRGO_MDS      :4;     //[15..12] Timer trigger output mode select
X            volatile uint8_t  TRGO_MDS      :4;     
N                                        //0x0 = RST : TM_RST (Main Timer Reset)
N                                        //0x1 = EN : TM_EN (Main Timer Enable)
N                                        //0x2 = UEV : TM_UEV (Main Timer Update event)
N                                        //0x3 = TOF : TM_TOF (Main Timer overflow)
N                                        //0x4 = TUF : TM_TUF (Main Timer underflow)
N                                        //0x5 = EN2 : TM_EN2 (Timer-2 Enable)
N                                        //0x6 = TOF2 :TM_TOF2 (Timer-2 overflow)
N                                        //0x7 = DIR : TM_DIR (Main Timer direction event)
N                                        //0x8 = UEV2 : TM_UEV2 (Timer-2 Update event)
N                                        //0x9 = SW : TM_TRGO_SW (software control bit)
N                                        //0xA = OS0 : TM_OS0 (channel-0 output state signal)
N                                        //0xB = OS1 : TM_OS1 (channel-1 output state signal)
N                                        //0xC = OS2 : TM_OS2 (channel-2 output state signal)
N                                        //0xD = OS3 : TM_OS3 (channel-3 output state signal)
N                                        //0xE = TRGI : TM_TRGI (internal TRGI signal)
N                                        //0xF = POE : TM_POE (Output enable register preload signal)
N            __IO uint8_t  QEI_MDS       :3;     //[18..16] Main Timer quadrature encoder interface
X            volatile uint8_t  QEI_MDS       :3;     
N                                        //0x0 = No operation (up/down control by TM_DIR)
N                                        //0x1 = IN0POS : TM_IN0 positive (high level up count, low level down count)
N                                        //0x2 = IN0NEG : TM_IN0 negative (low level up count, high level down count)
N                                        //0x3 = Reserved
N                                        //0x4 = Reserved
N                                        //0x5 = BOTH : Both TM_IN0 and TM_IN1 edge
N            __IO uint8_t  IDX_EN        :1;     //[19] Main Timer QEI external index signal input enable
X            volatile uint8_t  IDX_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IDX_MDS       :2;     //[21..20] Main Timer QEI external index signal input reset timer transition state select.
X            volatile uint8_t  IDX_MDS       :2;     
N                                        //0x0 = 1T2 : State change between 1 and 2
N                                        //0x1 = 2T3 : State change between 2 and 3
N                                        //0x2 = 3T4 : State change between 3 and 4
N                                        //0x3 = 4T1 : State change between 4 and 1
N            __IO uint8_t  UEV_SEL       :2;     //[23..22] Timer UEV output select bits for TM_TRGO
X            volatile uint8_t  UEV_SEL       :2;     
N                                        //0x0 = All : output all UEV pulses
N                                        //0x1 = TOF : output timer overflow pulses
N                                        //0x2 = UDF : output timer underflow pulses
N                                        //0x3 = Reserved
N            __IO uint8_t  TRGO_SW       :1;     //[24] Timer TRGO software control data bit.
X            volatile uint8_t  TRGO_SW       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  TRGO_INV      :1;     //[25] Timer TRGO output inverse enable bit.
X            volatile uint8_t  TRGO_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable 
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  RST_SW        :1;     //[28] Timer reset software enable bit.
X            volatile uint8_t  RST_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RST2_SW       :1;     //[29] 2nd Timer reset software enable bit.
X            volatile uint8_t  RST2_SW       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  GT_SW         :1;     //[30] Timer clock gating software enable bit.
X            volatile uint8_t  GT_SW         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  GT2_SW        :1;     //[31] 2nd Timer clock gating software enable bit.
X            volatile uint8_t  GT2_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }TRG;                               /*!< TRG        ~ Offset[0x0C]  TM Timer trigger control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] Main Timer/Counter enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EN2           :1;     //[1] 2nd Timer/Counter enable bit.
X            volatile uint8_t  EN2           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MDS           :2;     //[5..4] Timer operation mode select
X            volatile uint8_t  MDS           :2;     
N                                        //0x0 = Cascade : 16-bit counter with 16-bit prescaler  Mode
N                                        //0x1 = Separate : Separated two 16-bit counters Mode
N                                        //0x2 = Full-Counter : 32-bit counter Mode
N                                        //0x3 = Reserved
N            __IO uint8_t  DIR           :1;     //[6] Main Timer counting direction bit
X            volatile uint8_t  DIR           :1;     
N                                        //0 = Up (Up Counting)
N                                        //1 = Down (Down Counting)
N            __IO uint8_t  DIR2          :1;     //[7] 2nd Timer counting direction bit.
X            volatile uint8_t  DIR2          :1;     
N                                        //0 = Up (Up Counting)
N                                        //1 = Down (Down Counting)
N            __IO uint8_t  ASTOP_EN      :1;     //[8] Timer auto stop mode enable
X            volatile uint8_t  ASTOP_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  EX_EN         :1;     //[10] Timer external trigger event enable.
X            volatile uint8_t  EX_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  EX_INV        :1;     //[11] Timer external trigger input inverted enable.
X            volatile uint8_t  EX_INV        :1;     
N                                        //0 = Normal
N                                        //1 = Inverted
N            __IO uint8_t  UEV_DIS       :1;     //[12] Update event generation disable for main Timer
X            volatile uint8_t  UEV_DIS       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __IO uint8_t  DIR_INV       :1;     //[13] Main Timer counting direction inverted enable.
X            volatile uint8_t  DIR_INV       :1;     
N                                        //0 = Normal
N                                        //1 = Inverted
N            __IO uint8_t  USW_EN        :1;     //[14] Timer software update event generation enable.  (automatically clear by hardware)
X            volatile uint8_t  USW_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  UEX_EN        :1;     //[15] Timer external trigger update event enable.
X            volatile uint8_t  UEX_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  TM Timer control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OVR0_MDS      :1;     //[0] Timer channel 0 capture data buffer overrun mode select
X            volatile uint8_t  OVR0_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __IO uint8_t  OVR1_MDS      :1;     //[1] Timer channel 1 capture data buffer overrun mode select
X            volatile uint8_t  OVR1_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __IO uint8_t  OVR2_MDS      :1;     //[2] Timer channel 2 capture data buffer overrun mode select
X            volatile uint8_t  OVR2_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __IO uint8_t  OVR3_MDS      :1;     //[3] Timer channel 3 capture data buffer overrun mode select
X            volatile uint8_t  OVR3_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old data)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CC0A_SEN      :1;     //[8] Timer channel 0 software IC/OC event-A generation enable
X            volatile uint8_t  CC0A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC1A_SEN      :1;     //[9] Timer channel 1 software IC/OC event-A generation enable
X            volatile uint8_t  CC1A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC2A_SEN      :1;     //[10] Timer channel 2 software IC/OC event-A generation enable
X            volatile uint8_t  CC2A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC3A_SEN      :1;     //[11] Timer channel 3 software IC/OC event-A generation enable
X            volatile uint8_t  CC3A_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC0B_SEN      :1;     //[12] Timer channel 0 software IC/OC event-B generation enable
X            volatile uint8_t  CC0B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC1B_SEN      :1;     //[13] Timer channel 1 software IC/OC event-B generation enable
X            volatile uint8_t  CC1B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC2B_SEN      :1;     //[14] Timer channel 2 software IC/OC event-B generation enable
X            volatile uint8_t  CC2B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __IO uint8_t  CC3B_SEN      :1;     //[15] Timer channel 3 software IC/OC event-B generation enable
X            volatile uint8_t  CC3B_SEN      :1;     
N                                        //0 = No-Effect
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  TM Timer control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CKO_EN        :1;     //[0] Timer overflow as CKO output enable.
X            volatile uint8_t  CKO_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CKO_SEL       :1;     //[1] Timer overflow as CKO output source select.
X            volatile uint8_t  CKO_SEL       :1;     
N                                        //0 = 2nd : 2nd Timer overflow
N                                        //1 = Main : Main Timer overflow
N            __IO uint8_t  CKO_STA       :1;     //[2] Timer CKO output signal initial state
X            volatile uint8_t  CKO_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  CKO_LCK       :1;     //[3] TM_CKO_STA  register write access protected control
X            volatile uint8_t  CKO_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CKO;                               /*!< CKO        ~ Offset[0x18]  TM Timer CKO control register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x1C]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CNT           :16;    //[15..0] Main timer/counter register.
X            volatile uint16_t CNT           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x20]  TM Timer main counter register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t ARR           :16;    //[15..0] Main timer/counter auto-reload value register.
X            volatile uint16_t ARR           :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }ARR;                               /*!< ARR        ~ Offset[0x24]  TM Timer main counter auto-reload value register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t PSCNT         :16;    //[15..0] Timer prescaler or 2nd  timer/counter register
X            volatile uint16_t PSCNT         :16;    
N            __I  uint16_t CNTA          :16;    //[31..16] Main timer/counter alias register
X            volatile const  uint16_t CNTA          :16;    
N        }MBIT;
N    }PSCNT;                             /*!< PSCNT      ~ Offset[0x28]  TM Timer prescaler register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t PSARR         :16;    //[15..0] Timer prescaler or 2nd timer/counter auto-reload value register
X            volatile uint16_t PSARR         :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PSARR;                             /*!< PSARR      ~ Offset[0x2C]  TM Timer prescaler auto-reload register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CC0_MDS       :3;     //[2..0] Timer channel 0 capture and compare mode select.
X            volatile uint8_t  CC0_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N                                        //0x6 = 16bit_PWM_DTG (16bit PWM with DTG)
N                                        //0x7 = 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CC1_MDS       :3;     //[6..4] Timer channel 1 capture and compare mode select. 
X            volatile uint8_t  CC1_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N                                        //0x6 = 16bit_PWM_DTG (16bit PWM with DTG)
N                                        //0x7 = 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CC2_MDS       :3;     //[10..8] Timer channel 2 capture and compare mode select. 
X            volatile uint8_t  CC2_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N                                        //0x6 = 16bit_PWM_DTG (16bit PWM with DTG)
N                                        //0x7 = 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CC3_MDS       :3;     //[14..12] Timer channel 3 capture and compare mode select. 
X            volatile uint8_t  CC3_MDS       :3;     
N                                        //0x0 = NOP (No operation)
N                                        //0x1 = 16bit_IC (Input capture)
N                                        //0x2 = 16bit_OC (Output compare)
N                                        //0x3 = 8bitx2_OC (Two 8-bit compare)
N                                        //0x4 = 16bit_PWM (16bit PWM)
N                                        //0x5 = 8bitx2_PWM (Two 8bit PWMs)
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC_LCK        :1;     //[16] Timer output compare reload function lock enable bit for all channel
X            volatile uint8_t  OC_LCK        :1;     
N                                        //0 = un-Locked : enable unlocked
N                                        //1 = Locked : enable locked
N            __I  uint8_t                :6;     //[22..17] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  DMA_OMDS      :1;     //[23] Timer output DMA request mode select
X            volatile uint8_t  DMA_OMDS      :1;     
N                                        //0 = UEV : UEV update event only
N                                        //1 = ITR : both UEV and ITR
N            __IO uint8_t  DMA_CC0E      :1;     //[24] Direct memory access enable for OC0.
X            volatile uint8_t  DMA_CC0E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_CC1E      :1;     //[25] Direct memory access enable for OC1.
X            volatile uint8_t  DMA_CC1E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_CC2E      :1;     //[26] Direct memory access enable for OC2.
X            volatile uint8_t  DMA_CC2E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_CC3E      :1;     //[27] Direct memory access enable for IC3.
X            volatile uint8_t  DMA_CC3E      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CCMDS;                             /*!< CCMDS      ~ Offset[0x30]  TM Timer capture and compare mode select register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IC0_MUX       :2;     //[1..0] Timer channel 0 input Mux select for input capture.
X            volatile uint8_t  IC0_MUX       :2;     
N                                        //0x0 = IC00 : TM_IC0
N                                        //0x1 = IC01 : TM_ITR
N                                        //0x2 = IC02 : CMP0_OUT
N                                        //0x3 = IC03 : TM_XOR
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC1_MUX       :2;     //[5..4] Timer channel 1 input Mux select for input capture.
X            volatile uint8_t  IC1_MUX       :2;     
N                                        //0x0 = IC10 : TM_IC1
N                                        //0x1 = IC11 : TM_ITR
N                                        //0x2 = IC12 : CMP1_OUT
N                                        //0x3 = IC13 : Reserved
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC2_MUX       :2;     //[9..8] Timer channel 2 input Mux select for input capture.
X            volatile uint8_t  IC2_MUX       :2;     
N                                        //0x0 = IC20 : TM_IC2
N                                        //0x1 = IC21 : TM_ITR
N                                        //0x2 = IC22 : CMP2_OUT
N                                        //0x3 = IC23 : Reserved
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC3_MUX       :2;     //[13..12] Timer channel 3 input Mux select for input capture.
X            volatile uint8_t  IC3_MUX       :2;     
N                                        //0x0 = IC30 : TM_IC3
N                                        //0x1 = IC31 : TM_ITR
N                                        //0x2 = IC32 : CMP3_OUT
N                                        //0x3 = IC33 : TM_XOR
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IC0_TRGS      :2;     //[17..16] Timer channel 0 input trigger edge select.
X            volatile uint8_t  IC0_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  IC1_TRGS      :2;     //[19..18] Timer channel 1 input trigger edge select. 
X            volatile uint8_t  IC1_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  IC2_TRGS      :2;     //[21..20] Timer channel 2 input trigger edge select.
X            volatile uint8_t  IC2_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  IC3_TRGS      :2;     //[23..22] Timer channel 3 input trigger edge select.
X            volatile uint8_t  IC3_TRGS      :2;     
N                                        //0x0 = Disable : disable capture data
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }ICCR;                              /*!< ICCR       ~ Offset[0x34]  TM Timer input capture control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OS0_STA       :1;     //[0] Timer channel 0 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS0_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS1_STA       :1;     //[1] Timer channel 1 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS1_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS2_STA       :1;     //[2] Timer channel 2 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS2_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS3_STA       :1;     //[3] Timer channel 3 OC compare/compare-L output signal initial state.
X            volatile uint8_t  OS3_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS0_LCK       :1;     //[4] TM_OS0_STA register write access protected control
X            volatile uint8_t  OS0_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS1_LCK       :1;     //[5] TM_OS1_STA register write access protected control
X            volatile uint8_t  OS1_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS2_LCK       :1;     //[6] TM_OS2_STA register write access protected control
X            volatile uint8_t  OS2_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS3_LCK       :1;     //[7] TM_OS3_STA register write access protected control
X            volatile uint8_t  OS3_LCK       :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS0H_STA      :1;     //[8] Timer channel 0 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS0H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS1H_STA      :1;     //[9] Timer channel 1 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS1H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS2H_STA      :1;     //[10] Timer channel 2 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS2H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS3H_STA      :1;     //[11] Timer channel 3 OC compare-H output signal initial state for two 8-Bit comparator mod
X            volatile uint8_t  OS3H_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OS0H_LCK      :1;     //[12] TM_OS0H_STA register write access protected control
X            volatile uint8_t  OS0H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS1H_LCK      :1;     //[13] TM_OS1H_STA register write access protected control
X            volatile uint8_t  OS1H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS2H_LCK      :1;     //[14] TM_OS2H_STA register write access protected control
X            volatile uint8_t  OS2H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __IO uint8_t  OS3H_LCK      :1;     //[15] TM_OS3H_STA register write access protected control
X            volatile uint8_t  OS3H_LCK      :1;     
N                                        //0 = Locked (enable chip hardware control)
N                                        //1 = Un-Locked (disable chip hardware control)
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[18] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OSCR;                              /*!< OSCR       ~ Offset[0x38]  TM Timer output compare state register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OC0_OE0       :1;     //[0] Timer channel 0 OC line-0 output enable.
X            volatile uint8_t  OC0_OE0       :1;     
N                                        //0 = Disable (output by TM_BK0_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC0_OE1       :1;     //[1] Timer channel 0 OC line-1 output enable.
X            volatile uint8_t  OC0_OE1       :1;     
N                                        //0 = Disable (output by TM_BK0_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC0_OE2       :1;     //[2] Timer channel 0 OC line-2 output enable.
X            volatile uint8_t  OC0_OE2       :1;     
N                                        //0 = Disable (output by TM_BK0_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC1_OE0       :1;     //[4] Timer channel 1 OC line-0 output enable.
X            volatile uint8_t  OC1_OE0       :1;     
N                                        //0 = Disable (output by TM_BK1_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC1_OE1       :1;     //[5] Timer channel 1 OC line-1 output enable.
X            volatile uint8_t  OC1_OE1       :1;     
N                                        //0 = Disable (output by TM_BK1_STA setting)
N                                        //1 = Enable
N            __IO uint8_t  OC1_OE2       :1;     //[6] Timer channel 1 OC line-2 output enable.
X            volatile uint8_t  OC1_OE2       :1;     
N                                        //0 = Disable (output by TM_BK1_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC2_OE        :1;     //[8] Timer channel 2 OC line output enable.
X            volatile uint8_t  OC2_OE        :1;     
N                                        //0 = Disable (output by TM_BK2_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[11..9] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC3_OE        :1;     //[12] Timer channel 3 OC line output enable.
X            volatile uint8_t  OC3_OE        :1;     
N                                        //0 = Disable (output by TM_BK3_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC0N_OE       :1;     //[16] Timer channel 0 OC0N (complement) line output enable.
X            volatile uint8_t  OC0N_OE       :1;     
N                                        //0 = Disable (output by TM_BK0N_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[19..17] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC1N_OE       :1;     //[20] Timer channel 1 OC1N (complement) line output enable.
X            volatile uint8_t  OC1N_OE       :1;     
N                                        //0 = Disable (output by TM_BK1N_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  OC2N_OE       :1;     //[24] Timer channel 2 OC2N (complement) line output enable.
X            volatile uint8_t  OC2N_OE       :1;     
N                                        //0 = Disable (output by TM_BK2N_STA setting)
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[27..25] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :1;     //[28] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[29] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[30] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }OCCR0;                             /*!< OCCR0      ~ Offset[0x3C]  TM Timer output compare control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  OC0_INV       :1;     //[0] Timer channel 0 output inverse enable.
X            volatile uint8_t  OC0_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1_INV       :1;     //[1] Timer channel 1 output inverse enable.
X            volatile uint8_t  OC1_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC2_INV       :1;     //[2] Timer channel 2 output inverse enable.
X            volatile uint8_t  OC2_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC3_INV       :1;     //[3] Timer channel 3 output inverse enable.
X            volatile uint8_t  OC3_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0H_INV      :1;     //[4] Timer channel 0 output inverse enable.
X            volatile uint8_t  OC0H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1H_INV      :1;     //[5] Timer channel 1 output inverse enable.
X            volatile uint8_t  OC1H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC2H_INV      :1;     //[6] Timer channel 2 output inverse enable.
X            volatile uint8_t  OC2H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC3H_INV      :1;     //[7] Timer channel 3 output inverse enable.
X            volatile uint8_t  OC3H_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0N_INV      :1;     //[8] Timer channel 0 complement output inverse enable.
X            volatile uint8_t  OC0N_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1N_INV      :1;     //[9] Timer channel 1 complement output inverse enable.
X            volatile uint8_t  OC1N_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC2N_INV      :1;     //[10] Timer channel 2 complement output inverse enable.
X            volatile uint8_t  OC2N_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  OC0_POE0      :1;     //[16] Timer channel 0 OC line-0 output enable preload register bit
X            volatile uint8_t  OC0_POE0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0_POE1      :1;     //[17] Timer channel 0 OC line-1 output enable preload register bit
X            volatile uint8_t  OC0_POE1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC0_POE2      :1;     //[18] Timer channel 0 OC line-2 output enable preload register bit
X            volatile uint8_t  OC0_POE2      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OC1_POE0      :1;     //[20] Timer channel 1 OC line-0 output enable preload register bit
X            volatile uint8_t  OC1_POE0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1_POE1      :1;     //[21] Timer channel 1 OC line-1 output enable preload register bit
X            volatile uint8_t  OC1_POE1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OC1_POE2      :1;     //[22] Timer channel 1 OC line-2 output enable preload register bit
X            volatile uint8_t  OC1_POE2      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  POE_EN0       :1;     //[24] Timer OC preload enable bit for output enable preload register control
X            volatile uint8_t  POE_EN0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  POE_EN1       :1;     //[25] Timer OC preload enable bit for output enable preload register control
X            volatile uint8_t  POE_EN1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  POE_EN2       :1;     //[26] Timer OC preload enable bit for output enable preload register control
X            volatile uint8_t  POE_EN2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[27] 
X            volatile const  uint8_t                :1;     
N            __O  uint8_t  POE_SW        :1;     //[28] Timer output enable registers preload software enable bit
X            volatile  uint8_t  POE_SW        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[31..29] 
X            volatile const  uint8_t                :3;     
N        }MBIT;
N    }OCCR1;                             /*!< OCCR1      ~ Offset[0x40]  TM Timer output compare control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  PWM_MDS       :2;     //[1..0] Timer OC0/1/2/3 PWM mode select.
X            volatile uint8_t  PWM_MDS       :2;     
N                                        //0x0 = Edge Left-aligned
N                                        //0x1 = Center-aligned
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  DTG_DY        :8;     //[15..8] Timer output DTG dead-time delay(CK_DTG clock time base) for all channels
X            volatile uint8_t  DTG_DY        :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }PWM;                               /*!< PWM        ~ Offset[0x44]  TM Timer PWM and DTG control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  BK_EN         :1;     //[0] Timer Break Input enable for OC[2:0]. (output state stop or reset)
X            volatile uint8_t  BK_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[2..1] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BK_EN3        :1;     //[3] Timer Break Input enable for OC3. (output state stop or reset)
X            volatile uint8_t  BK_EN3        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BK_MDS        :1;     //[4] Timer break event input control mode select.
X            volatile uint8_t  BK_MDS        :1;     
N                                        //0 = Latch mode
N                                        //1 = Cycle by cycle
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKSW_EN       :1;     //[7] Timer software break input generation enable.
X            volatile uint8_t  BKSW_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN0       :1;     //[8] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN1       :1;     //[9] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN2       :1;     //[10] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN3       :1;     //[11] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN3       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN4       :1;     //[12] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN4       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN5       :1;     //[13] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN5       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN6       :1;     //[14] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN6       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKE_EN7       :1;     //[15] Timer Break external input channels' enable bit
X            volatile uint8_t  BKE_EN7       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKI_EN0       :1;     //[16] Timer Break internal input channels' enable bit
X            volatile uint8_t  BKI_EN0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKI_EN1       :1;     //[17] Timer Break internal input channels' enable bit
X            volatile uint8_t  BKI_EN1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKI_EN2       :1;     //[18] Timer Break internal input channels' enable bit
X            volatile uint8_t  BKI_EN2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BK0_CTL       :1;     //[20] Timer OC0 output switch control when break event happened
X            volatile uint8_t  BK0_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  BK1_CTL       :1;     //[21] Timer OC1 output switch control when break event happened
X            volatile uint8_t  BK1_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  BK2_CTL       :1;     //[22] Timer OC2 output switch control when break event happened
X            volatile uint8_t  BK2_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  BK3_CTL       :1;     //[23] Timer OC3 output switch control when break event happened
X            volatile uint8_t  BK3_CTL       :1;     
N                                        //0 = Stop (Switch to stop state register setting)
N                                        //1 = Hold (hold the output state)
N            __IO uint8_t  STP0_STA      :1;     //[24] Timer BK input active or stop condition output OC0 state select.
X            volatile uint8_t  STP0_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP1_STA      :1;     //[25] Timer BK input active or stop condition output OC1 state select.
X            volatile uint8_t  STP1_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP2_STA      :1;     //[26] Timer BK input active or stop condition output OC2 state select.
X            volatile uint8_t  STP2_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP3_STA      :1;     //[27] Timer BK input active or stop condition output OC3 state select.
X            volatile uint8_t  STP3_STA      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP0N_STA     :1;     //[28] Timer BK input active or stop condition output OC0N state select.
X            volatile uint8_t  STP0N_STA     :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP1N_STA     :1;     //[29] Timer BK input active or stop condition output OC1N state select.
X            volatile uint8_t  STP1N_STA     :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  STP2N_STA     :1;     //[30] Timer BK input active or stop condition output OC2N state select.
X            volatile uint8_t  STP2N_STA     :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }BS;                                /*!< BS         ~ Offset[0x48]  TM Timer break and stop control register */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x4C]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC0A          :16;    //[15..0] TM Timer capture and compare register 0A for channel 0
X            volatile uint16_t CC0A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC0A;                              /*!< CC0A       ~ Offset[0x50]  TM Timer capture and compare register 0A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC0B          :16;    //[15..0] TM Timer capture and compare register 0B for channel 0
X            volatile uint16_t CC0B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC0B;                              /*!< CC0B       ~ Offset[0x54]  TM Timer capture and compare register 0B */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC1A          :16;    //[15..0] TM Timer capture and compare register 1A for channel 1
X            volatile uint16_t CC1A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC1A;                              /*!< CC1A       ~ Offset[0x58]  TM Timer capture and compare register 1A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC1B          :16;    //[15..0] TM Timer capture and compare register 1B for channel 1
X            volatile uint16_t CC1B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC1B;                              /*!< CC1B       ~ Offset[0x5c]  TM Timer capture and compare register 1B */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC2A          :16;    //[15..0] TM Timer capture and compare register 2A for channel 2
X            volatile uint16_t CC2A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC2A;                              /*!< CC2A       ~ Offset[0x60]  TM Timer capture and compare register 2A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC2B          :16;    //[15..0] TM Timer capture and compare register 2B for channel 2
X            volatile uint16_t CC2B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC2B;                              /*!< CC2B       ~ Offset[0x64]  TM Timer capture and compare register 2B */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC3A          :16;    //[15..0] TM Timer capture and compare register 3A for channel 3
X            volatile uint16_t CC3A          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC3A;                              /*!< CC3A       ~ Offset[0x68]  TM Timer capture and compare register 3A */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CC3B          :16;    //[15..0] Timer TM capture and compare register 3B for channel 3
X            volatile uint16_t CC3B          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CC3B;                              /*!< CC3B       ~ Offset[0x6c]  TM Timer capture and compare register 3B */
N
N} TM_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        TM  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define TM00_Base                       ((uint32_t)0x55000000)              /*!< Timer Control Module-00 */
N#define TM01_Base                       ((uint32_t)0x55010000)              /*!< Timer Control Module-01 */
N#define TM10_Base                       ((uint32_t)0x55800000)              /*!< Timer Control Module-10 */
N#define TM16_Base                       ((uint32_t)0x55860000)              /*!< Timer Control Module-16 */
N#define TM20_Base                       ((uint32_t)0x56000000)              /*!< Timer Control Module-20 */
N#define TM26_Base                       ((uint32_t)0x56060000)              /*!< Timer Control Module-26 */
N#define TM36_Base                       ((uint32_t)0x56860000)              /*!< Timer Control Module-36 */
N#define TM00                            ((TM_Struct*) TM00_Base)
N#define TM01                            ((TM_Struct*) TM01_Base)
N#define TM10                            ((TM_Struct*) TM10_Base)
N#define TM16                            ((TM_Struct*) TM16_Base)
N#define TM20                            ((TM_Struct*) TM20_Base)
N#define TM26                            ((TM_Struct*) TM26_Base)
N#define TM36                            ((TM_Struct*) TM36_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        TM  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        TM_STA  [register's definitions]
N *              Offset[0x00]  TM Timer status register
N ******************************************************************************
N */
N///@{
N#define TM_STA_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_STA */
N#define TM_STA_QPEF_mask_w                          ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define TM_STA_QPEF_mask_h1                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_STA_QPEF_mask_b2                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_STA_QPEF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_QPEF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_QPEF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_QPEF_happened_w                      ((uint32_t)0x00080000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_QPEF_happened_h1                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_QPEF_happened_b2                     ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_IDXF_mask_w                          ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_STA_IDXF_mask_h1                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_STA_IDXF_mask_b2                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_STA_IDXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_IDXF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_IDXF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_IDXF_happened_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_IDXF_happened_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_IDXF_happened_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_DIRCF_mask_w                         ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_STA_DIRCF_mask_h1                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_STA_DIRCF_mask_b2                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_STA_DIRCF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_DIRCF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_DIRCF_normal_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_DIRCF_happened_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_DIRCF_happened_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_DIRCF_happened_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF3B_mask_w                          ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF3B_mask_h0                         ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF3B_mask_b1                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF3B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF3B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF3B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF3B_happened_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF3B_happened_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF3B_happened_b1                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF2B_mask_w                          ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF2B_mask_h0                         ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF2B_mask_b1                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF2B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF2B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF2B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF2B_happened_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF2B_happened_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF2B_happened_b1                     ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF1B_mask_w                          ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF1B_mask_h0                         ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF1B_mask_b1                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF1B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF1B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF1B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF1B_happened_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF1B_happened_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF1B_happened_b1                     ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF0B_mask_w                          ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF0B_mask_h0                         ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF0B_mask_b1                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF0B_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF0B_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF0B_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF0B_happened_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF0B_happened_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF0B_happened_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF3A_mask_w                          ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF3A_mask_h0                         ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF3A_mask_b1                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF3A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF3A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF3A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF3A_happened_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF3A_happened_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF3A_happened_b1                     ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF2A_mask_w                          ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF2A_mask_h0                         ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF2A_mask_b1                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF2A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF2A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF2A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF2A_happened_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF2A_happened_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF2A_happened_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF1A_mask_w                          ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF1A_mask_h0                         ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF1A_mask_b1                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF1A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF1A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF1A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF1A_happened_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF1A_happened_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF1A_happened_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_CF0A_mask_w                          ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_STA_CF0A_mask_h0                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_STA_CF0A_mask_b1                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_STA_CF0A_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_CF0A_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_CF0A_normal_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_CF0A_happened_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_CF0A_happened_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_CF0A_happened_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TUF2_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_STA_TUF2_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_STA_TUF2_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_STA_TUF2_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TUF2_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TUF2_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TUF2_happened_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TUF2_happened_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TUF2_happened_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TUF_mask_w                           ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_STA_TUF_mask_h0                          ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_STA_TUF_mask_b0                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_STA_TUF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TUF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TUF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TUF_happened_w                       ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TUF_happened_h0                      ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TUF_happened_b0                      ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TOF2_mask_w                          ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_STA_TOF2_mask_h0                         ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_STA_TOF2_mask_b0                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_STA_TOF2_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TOF2_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TOF2_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TOF2_happened_w                      ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TOF2_happened_h0                     ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TOF2_happened_b0                     ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_TOF_mask_w                           ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_STA_TOF_mask_h0                          ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_STA_TOF_mask_b0                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_STA_TOF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_TOF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_TOF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_TOF_happened_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_TOF_happened_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_TOF_happened_b0                      ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_EXF_mask_w                           ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_STA_EXF_mask_h0                          ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_STA_EXF_mask_b0                          ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_STA_EXF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_EXF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_EXF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_EXF_happened_w                       ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_EXF_happened_h0                      ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_EXF_happened_b0                      ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_BKF_mask_w                           ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_STA_BKF_mask_h0                          ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_STA_BKF_mask_b0                          ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_STA_BKF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_STA_BKF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_STA_BKF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_STA_BKF_happened_w                       ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define TM_STA_BKF_happened_h0                      ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define TM_STA_BKF_happened_b0                      ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define TM_STA_DIRF_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_STA_DIRF_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_STA_DIRF_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_STA_DIRF_up_counting_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Up counting of 32bit */
N#define TM_STA_DIRF_up_counting_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Up counting of 16bit */
N#define TM_STA_DIRF_up_counting_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Up counting of 8bit */
N#define TM_STA_DIRF_down_counting_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(1):Down counting of 32bit */
N#define TM_STA_DIRF_down_counting_h0                ((uint16_t)0x0001)      /*!< Bit Value =(1):Down counting of 16bit */
N#define TM_STA_DIRF_down_counting_b0                ((uint8_t )0x01)        /*!< Bit Value =(1):Down counting of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_INT  [register's definitions]
N *              Offset[0x04]  TM Timer interrupt enable register
N ******************************************************************************
N */
N///@{
N#define TM_INT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_INT */
N#define TM_INT_QPE_IE_mask_w                        ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define TM_INT_QPE_IE_mask_h1                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_INT_QPE_IE_mask_b2                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_INT_QPE_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_QPE_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_QPE_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_QPE_IE_enable_w                      ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_QPE_IE_enable_h1                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_QPE_IE_enable_b2                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_IDX_IE_mask_w                        ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_INT_IDX_IE_mask_h1                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_INT_IDX_IE_mask_b2                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_INT_IDX_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_IDX_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_IDX_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_IDX_IE_enable_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_IDX_IE_enable_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_IDX_IE_enable_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_DIRC_IE_mask_w                       ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_INT_DIRC_IE_mask_h1                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_INT_DIRC_IE_mask_b2                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_INT_DIRC_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_DIRC_IE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_DIRC_IE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_DIRC_IE_enable_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_DIRC_IE_enable_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_DIRC_IE_enable_b2                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC3_IE_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC3_IE_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC3_IE_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC3_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC3_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC3_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC3_IE_enable_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC3_IE_enable_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC3_IE_enable_b1                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC2_IE_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC2_IE_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC2_IE_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC2_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC2_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC2_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC2_IE_enable_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC2_IE_enable_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC2_IE_enable_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC1_IE_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC1_IE_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC1_IE_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC1_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC1_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC1_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC1_IE_enable_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC1_IE_enable_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC1_IE_enable_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_CC0_IE_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_INT_CC0_IE_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_INT_CC0_IE_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_INT_CC0_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_CC0_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_CC0_IE_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_CC0_IE_enable_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_CC0_IE_enable_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_CC0_IE_enable_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_TIE2_mask_w                          ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_INT_TIE2_mask_h0                         ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_INT_TIE2_mask_b0                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_INT_TIE2_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_TIE2_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_TIE2_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_TIE2_enable_w                        ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_TIE2_enable_h0                       ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_TIE2_enable_b0                       ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_TIE_mask_w                           ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_INT_TIE_mask_h0                          ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_INT_TIE_mask_b0                          ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_INT_TIE_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_TIE_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_TIE_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_TIE_enable_w                         ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_TIE_enable_h0                        ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_TIE_enable_b0                        ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_EXIE_mask_w                          ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_INT_EXIE_mask_h0                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_INT_EXIE_mask_b0                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_INT_EXIE_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_EXIE_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_EXIE_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_EXIE_enable_w                        ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_EXIE_enable_h0                       ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_EXIE_enable_b0                       ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_BKIE_mask_w                          ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_INT_BKIE_mask_h0                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_INT_BKIE_mask_b0                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_INT_BKIE_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_BKIE_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_BKIE_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_BKIE_enable_w                        ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_BKIE_enable_h0                       ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_BKIE_enable_b0                       ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_INT_IEA_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_INT_IEA_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_INT_IEA_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_INT_IEA_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_INT_IEA_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_INT_IEA_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_INT_IEA_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_INT_IEA_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_INT_IEA_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CLK  [register's definitions]
N *              Offset[0x08]  TM Timer clock source register
N ******************************************************************************
N */
N///@{
N#define TM_CLK_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CLK */
N#define TM_CLK_DTG_DIV_mask_w                       ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define TM_CLK_DTG_DIV_mask_h1                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_CLK_DTG_DIV_mask_b2                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_CLK_DTG_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define TM_CLK_DTG_DIV_div1_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define TM_CLK_DTG_DIV_div1_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define TM_CLK_DTG_DIV_div2_w                       ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define TM_CLK_DTG_DIV_div2_h1                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define TM_CLK_DTG_DIV_div2_b2                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define TM_CLK_DTG_DIV_div4_w                       ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define TM_CLK_DTG_DIV_div4_h1                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define TM_CLK_DTG_DIV_div4_b2                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define TM_CLK_DTG_DIV_div8_w                       ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define TM_CLK_DTG_DIV_div8_h1                      ((uint16_t)0x0003)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define TM_CLK_DTG_DIV_div8_b2                      ((uint8_t )0x03)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define TM_CLK_CKI_DIV_mask_w                       ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKI_DIV_mask_h0                      ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKI_DIV_mask_b1                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKI_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define TM_CLK_CKI_DIV_div1_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define TM_CLK_CKI_DIV_div1_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define TM_CLK_CKI_DIV_div2_w                       ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define TM_CLK_CKI_DIV_div2_h0                      ((uint16_t)0x1000)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define TM_CLK_CKI_DIV_div2_b1                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define TM_CLK_CKI_DIV_div4_w                       ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define TM_CLK_CKI_DIV_div4_h0                      ((uint16_t)0x2000)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define TM_CLK_CKI_DIV_div4_b1                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define TM_CLK_CKI_DIV_div8_w                       ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define TM_CLK_CKI_DIV_div8_h0                      ((uint16_t)0x3000)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define TM_CLK_CKI_DIV_div8_b1                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define TM_CLK_CKI_SEL_mask_w                       ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKI_SEL_mask_h0                      ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKI_SEL_mask_b1                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKI_SEL_proc_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):PROC of 32bit */
N#define TM_CLK_CKI_SEL_proc_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):PROC of 16bit */
N#define TM_CLK_CKI_SEL_proc_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):PROC of 8bit */
N#define TM_CLK_CKI_SEL_ck_ls_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CK_LS of 32bit */
N#define TM_CLK_CKI_SEL_ck_ls_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CK_LS of 16bit */
N#define TM_CLK_CKI_SEL_ck_ls_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):CK_LS of 8bit */
N
N#define TM_CLK_CKS2_SEL_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKS2_SEL_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKS2_SEL_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKS2_SEL_ck_int_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):CK_INT of 32bit */
N#define TM_CLK_CKS2_SEL_ck_int_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):CK_INT of 16bit */
N#define TM_CLK_CKS2_SEL_ck_int_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):CK_INT of 8bit */
N#define TM_CLK_CKS2_SEL_ck_ext_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):CK_EXT of 32bit */
N#define TM_CLK_CKS2_SEL_ck_ext_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):CK_EXT of 16bit */
N#define TM_CLK_CKS2_SEL_ck_ext_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):CK_EXT of 8bit */
N
N#define TM_CLK_CKS_SEL_mask_w                       ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKS_SEL_mask_h0                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKS_SEL_mask_b0                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKS_SEL_ck_int_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):CK_INT of 32bit */
N#define TM_CLK_CKS_SEL_ck_int_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):CK_INT of 16bit */
N#define TM_CLK_CKS_SEL_ck_int_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):CK_INT of 8bit */
N#define TM_CLK_CKS_SEL_ck_ext_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(1):CK_EXT of 32bit */
N#define TM_CLK_CKS_SEL_ck_ext_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(1):CK_EXT of 16bit */
N#define TM_CLK_CKS_SEL_ck_ext_b0                    ((uint8_t )0x40)        /*!< Bit Value =(1):CK_EXT of 8bit */
N
N#define TM_CLK_CKE_SEL_mask_w                       ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define TM_CLK_CKE_SEL_mask_h0                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_CLK_CKE_SEL_mask_b0                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_CLK_CKE_SEL_etr_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ETR of 32bit */
N#define TM_CLK_CKE_SEL_etr_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ETR of 16bit */
N#define TM_CLK_CKE_SEL_etr_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):ETR of 8bit */
N#define TM_CLK_CKE_SEL_itr_w                        ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):ITR of 32bit */
N#define TM_CLK_CKE_SEL_itr_h0                       ((uint16_t)0x0010)      /*!< Bit Value =(0x1):ITR of 16bit */
N#define TM_CLK_CKE_SEL_itr_b0                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):ITR of 8bit */
N#define TM_CLK_CKE_SEL_in0_w                        ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):IN0 of 32bit */
N#define TM_CLK_CKE_SEL_in0_h0                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):IN0 of 16bit */
N#define TM_CLK_CKE_SEL_in0_b0                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):IN0 of 8bit */
N#define TM_CLK_CKE_SEL_in1_w                        ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):IN1 of 32bit */
N#define TM_CLK_CKE_SEL_in1_h0                       ((uint16_t)0x0030)      /*!< Bit Value =(0x3):IN1 of 16bit */
N#define TM_CLK_CKE_SEL_in1_b0                       ((uint8_t )0x30)        /*!< Bit Value =(0x3):IN1 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_TRG  [register's definitions]
N *              Offset[0x0C]  TM Timer trigger control register
N ******************************************************************************
N */
N///@{
N#define TM_TRG_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_TRG */
N#define TM_TRG_GT2_SW_mask_w                        ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_GT2_SW_mask_h1                       ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_GT2_SW_mask_b3                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_TRG_GT2_SW_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_GT2_SW_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_GT2_SW_disable_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_GT2_SW_enable_w                      ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_GT2_SW_enable_h1                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_GT2_SW_enable_b3                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_GT_SW_mask_w                         ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_GT_SW_mask_h1                        ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_GT_SW_mask_b3                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_TRG_GT_SW_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_GT_SW_disable_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_GT_SW_disable_b3                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_GT_SW_enable_w                       ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_GT_SW_enable_h1                      ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_GT_SW_enable_b3                      ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_RST2_SW_mask_w                       ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_RST2_SW_mask_h1                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_RST2_SW_mask_b3                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_TRG_RST2_SW_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_RST2_SW_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_RST2_SW_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_RST2_SW_enable_w                     ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_RST2_SW_enable_h1                    ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_RST2_SW_enable_b3                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_RST_SW_mask_w                        ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_RST_SW_mask_h1                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_RST_SW_mask_b3                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_TRG_RST_SW_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_RST_SW_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_RST_SW_disable_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_RST_SW_enable_w                      ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_RST_SW_enable_h1                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_RST_SW_enable_b3                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_TRGO_INV_mask_w                      ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGO_INV_mask_h1                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGO_INV_mask_b3                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGO_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_TRGO_INV_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_TRGO_INV_disable_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_TRGO_INV_enable_w                    ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_TRGO_INV_enable_h1                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_TRGO_INV_enable_b3                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_TRGO_SW_mask_w                       ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGO_SW_mask_h1                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGO_SW_mask_b3                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGO_SW_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_TRG_TRGO_SW_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_TRG_TRGO_SW_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_TRG_TRGO_SW_1_w                          ((uint32_t)0x01000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_TRG_TRGO_SW_1_h1                         ((uint16_t)0x0100)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_TRG_TRGO_SW_1_b3                         ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_TRG_UEV_SEL_mask_w                       ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_UEV_SEL_mask_h1                      ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define TM_TRG_UEV_SEL_mask_b2                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define TM_TRG_UEV_SEL_all_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):All of 32bit */
N#define TM_TRG_UEV_SEL_all_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):All of 16bit */
N#define TM_TRG_UEV_SEL_all_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):All of 8bit */
N#define TM_TRG_UEV_SEL_tof_w                        ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):TOF of 32bit */
N#define TM_TRG_UEV_SEL_tof_h1                       ((uint16_t)0x0040)      /*!< Bit Value =(0x1):TOF of 16bit */
N#define TM_TRG_UEV_SEL_tof_b2                       ((uint8_t )0x40)        /*!< Bit Value =(0x1):TOF of 8bit */
N#define TM_TRG_UEV_SEL_udf_w                        ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):UDF of 32bit */
N#define TM_TRG_UEV_SEL_udf_h1                       ((uint16_t)0x0080)      /*!< Bit Value =(0x2):UDF of 16bit */
N#define TM_TRG_UEV_SEL_udf_b2                       ((uint8_t )0x80)        /*!< Bit Value =(0x2):UDF of 8bit */
N
N#define TM_TRG_IDX_MDS_mask_w                       ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_IDX_MDS_mask_h1                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_TRG_IDX_MDS_mask_b2                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_TRG_IDX_MDS_1t2_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1T2 of 32bit */
N#define TM_TRG_IDX_MDS_1t2_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1T2 of 16bit */
N#define TM_TRG_IDX_MDS_1t2_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):1T2 of 8bit */
N#define TM_TRG_IDX_MDS_2t3_w                        ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):2T3 of 32bit */
N#define TM_TRG_IDX_MDS_2t3_h1                       ((uint16_t)0x0010)      /*!< Bit Value =(0x1):2T3 of 16bit */
N#define TM_TRG_IDX_MDS_2t3_b2                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):2T3 of 8bit */
N#define TM_TRG_IDX_MDS_3t4_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):3T4 of 32bit */
N#define TM_TRG_IDX_MDS_3t4_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):3T4 of 16bit */
N#define TM_TRG_IDX_MDS_3t4_b2                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):3T4 of 8bit */
N#define TM_TRG_IDX_MDS_4t1_w                        ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):4T1 of 32bit */
N#define TM_TRG_IDX_MDS_4t1_h1                       ((uint16_t)0x0030)      /*!< Bit Value =(0x3):4T1 of 16bit */
N#define TM_TRG_IDX_MDS_4t1_b2                       ((uint8_t )0x30)        /*!< Bit Value =(0x3):4T1 of 8bit */
N
N#define TM_TRG_IDX_EN_mask_w                        ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_IDX_EN_mask_h1                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_TRG_IDX_EN_mask_b2                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_TRG_IDX_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_TRG_IDX_EN_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_TRG_IDX_EN_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_TRG_IDX_EN_enable_w                      ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_TRG_IDX_EN_enable_h1                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_TRG_IDX_EN_enable_b2                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_TRG_QEI_MDS_mask_w                       ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_QEI_MDS_mask_h1                      ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define TM_TRG_QEI_MDS_mask_b2                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_TRG_QEI_MDS_no_operation_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define TM_TRG_QEI_MDS_no_operation_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define TM_TRG_QEI_MDS_no_operation_b2              ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define TM_TRG_QEI_MDS_in0pos_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):IN0POS of 32bit */
N#define TM_TRG_QEI_MDS_in0pos_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):IN0POS of 16bit */
N#define TM_TRG_QEI_MDS_in0pos_b2                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):IN0POS of 8bit */
N#define TM_TRG_QEI_MDS_in0neg_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):IN0NEG of 32bit */
N#define TM_TRG_QEI_MDS_in0neg_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(0x2):IN0NEG of 16bit */
N#define TM_TRG_QEI_MDS_in0neg_b2                    ((uint8_t )0x02)        /*!< Bit Value =(0x2):IN0NEG of 8bit */
N#define TM_TRG_QEI_MDS_both_w                       ((uint32_t)0x00050000)  /*!< Bit Value =(0x5):BOTH of 32bit */
N#define TM_TRG_QEI_MDS_both_h1                      ((uint16_t)0x0005)      /*!< Bit Value =(0x5):BOTH of 16bit */
N#define TM_TRG_QEI_MDS_both_b2                      ((uint8_t )0x05)        /*!< Bit Value =(0x5):BOTH of 8bit */
N
N#define TM_TRG_TRGO_MDS_mask_w                      ((uint32_t)0x0000F000)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGO_MDS_mask_h0                     ((uint16_t)0xF000)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGO_MDS_mask_b1                     ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGO_MDS_rst_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):RST of 32bit */
N#define TM_TRG_TRGO_MDS_rst_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):RST of 16bit */
N#define TM_TRG_TRGO_MDS_rst_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):RST of 8bit */
N#define TM_TRG_TRGO_MDS_en_w                        ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):EN of 32bit */
N#define TM_TRG_TRGO_MDS_en_h0                       ((uint16_t)0x1000)      /*!< Bit Value =(0x1):EN of 16bit */
N#define TM_TRG_TRGO_MDS_en_b1                       ((uint8_t )0x10)        /*!< Bit Value =(0x1):EN of 8bit */
N#define TM_TRG_TRGO_MDS_uev_w                       ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):UEV of 32bit */
N#define TM_TRG_TRGO_MDS_uev_h0                      ((uint16_t)0x2000)      /*!< Bit Value =(0x2):UEV of 16bit */
N#define TM_TRG_TRGO_MDS_uev_b1                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):UEV of 8bit */
N#define TM_TRG_TRGO_MDS_tof_w                       ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):TOF of 32bit */
N#define TM_TRG_TRGO_MDS_tof_h0                      ((uint16_t)0x3000)      /*!< Bit Value =(0x3):TOF of 16bit */
N#define TM_TRG_TRGO_MDS_tof_b1                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):TOF of 8bit */
N#define TM_TRG_TRGO_MDS_tuf_w                       ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):TUF of 32bit */
N#define TM_TRG_TRGO_MDS_tuf_h0                      ((uint16_t)0x4000)      /*!< Bit Value =(0x4):TUF of 16bit */
N#define TM_TRG_TRGO_MDS_tuf_b1                      ((uint8_t )0x40)        /*!< Bit Value =(0x4):TUF of 8bit */
N#define TM_TRG_TRGO_MDS_en2_w                       ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):EN2 of 32bit */
N#define TM_TRG_TRGO_MDS_en2_h0                      ((uint16_t)0x5000)      /*!< Bit Value =(0x5):EN2 of 16bit */
N#define TM_TRG_TRGO_MDS_en2_b1                      ((uint8_t )0x50)        /*!< Bit Value =(0x5):EN2 of 8bit */
N#define TM_TRG_TRGO_MDS_tof2_w                      ((uint32_t)0x00006000)  /*!< Bit Value =(0x6):TOF2 of 32bit */
N#define TM_TRG_TRGO_MDS_tof2_h0                     ((uint16_t)0x6000)      /*!< Bit Value =(0x6):TOF2 of 16bit */
N#define TM_TRG_TRGO_MDS_tof2_b1                     ((uint8_t )0x60)        /*!< Bit Value =(0x6):TOF2 of 8bit */
N#define TM_TRG_TRGO_MDS_dir_w                       ((uint32_t)0x00007000)  /*!< Bit Value =(0x7):DIR of 32bit */
N#define TM_TRG_TRGO_MDS_dir_h0                      ((uint16_t)0x7000)      /*!< Bit Value =(0x7):DIR of 16bit */
N#define TM_TRG_TRGO_MDS_dir_b1                      ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIR of 8bit */
N#define TM_TRG_TRGO_MDS_uev2_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(0x8):UEV2 of 32bit */
N#define TM_TRG_TRGO_MDS_uev2_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(0x8):UEV2 of 16bit */
N#define TM_TRG_TRGO_MDS_uev2_b1                     ((uint8_t )0x80)        /*!< Bit Value =(0x8):UEV2 of 8bit */
N#define TM_TRG_TRGO_MDS_sw_w                        ((uint32_t)0x00009000)  /*!< Bit Value =(0x9):SW of 32bit */
N#define TM_TRG_TRGO_MDS_sw_h0                       ((uint16_t)0x9000)      /*!< Bit Value =(0x9):SW of 16bit */
N#define TM_TRG_TRGO_MDS_sw_b1                       ((uint8_t )0x90)        /*!< Bit Value =(0x9):SW of 8bit */
N#define TM_TRG_TRGO_MDS_os0_w                       ((uint32_t)0x0000A000)  /*!< Bit Value =(0xA):OS0 of 32bit */
N#define TM_TRG_TRGO_MDS_os0_h0                      ((uint16_t)0xA000)      /*!< Bit Value =(0xA):OS0 of 16bit */
N#define TM_TRG_TRGO_MDS_os0_b1                      ((uint8_t )0xA0)        /*!< Bit Value =(0xA):OS0 of 8bit */
N#define TM_TRG_TRGO_MDS_os1_w                       ((uint32_t)0x0000B000)  /*!< Bit Value =(0xB):OS1 of 32bit */
N#define TM_TRG_TRGO_MDS_os1_h0                      ((uint16_t)0xB000)      /*!< Bit Value =(0xB):OS1 of 16bit */
N#define TM_TRG_TRGO_MDS_os1_b1                      ((uint8_t )0xB0)        /*!< Bit Value =(0xB):OS1 of 8bit */
N#define TM_TRG_TRGO_MDS_os2_w                       ((uint32_t)0x0000C000)  /*!< Bit Value =(0xC):OS2 of 32bit */
N#define TM_TRG_TRGO_MDS_os2_h0                      ((uint16_t)0xC000)      /*!< Bit Value =(0xC):OS2 of 16bit */
N#define TM_TRG_TRGO_MDS_os2_b1                      ((uint8_t )0xC0)        /*!< Bit Value =(0xC):OS2 of 8bit */
N#define TM_TRG_TRGO_MDS_os3_w                       ((uint32_t)0x0000D000)  /*!< Bit Value =(0xD):OS3 of 32bit */
N#define TM_TRG_TRGO_MDS_os3_h0                      ((uint16_t)0xD000)      /*!< Bit Value =(0xD):OS3 of 16bit */
N#define TM_TRG_TRGO_MDS_os3_b1                      ((uint8_t )0xD0)        /*!< Bit Value =(0xD):OS3 of 8bit */
N#define TM_TRG_TRGO_MDS_trgi_w                      ((uint32_t)0x0000E000)  /*!< Bit Value =(0xE):TRGI of 32bit */
N#define TM_TRG_TRGO_MDS_trgi_h0                     ((uint16_t)0xE000)      /*!< Bit Value =(0xE):TRGI of 16bit */
N#define TM_TRG_TRGO_MDS_trgi_b1                     ((uint8_t )0xE0)        /*!< Bit Value =(0xE):TRGI of 8bit */
N#define TM_TRG_TRGO_MDS_poe_w                       ((uint32_t)0x0000F000)  /*!< Bit Value =(0xF):POE of 32bit */
N#define TM_TRG_TRGO_MDS_poe_h0                      ((uint16_t)0xF000)      /*!< Bit Value =(0xF):POE of 16bit */
N#define TM_TRG_TRGO_MDS_poe_b1                      ((uint8_t )0xF0)        /*!< Bit Value =(0xF):POE of 8bit */
N
N#define TM_TRG_ITR_MUX_mask_w                       ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define TM_TRG_ITR_MUX_mask_h0                      ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define TM_TRG_ITR_MUX_mask_b1                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_TRG_ITR_MUX_itr0_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ITR0 of 32bit */
N#define TM_TRG_ITR_MUX_itr0_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ITR0 of 16bit */
N#define TM_TRG_ITR_MUX_itr0_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):ITR0 of 8bit */
N#define TM_TRG_ITR_MUX_itr1_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):ITR1 of 32bit */
N#define TM_TRG_ITR_MUX_itr1_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(0x1):ITR1 of 16bit */
N#define TM_TRG_ITR_MUX_itr1_b1                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):ITR1 of 8bit */
N#define TM_TRG_ITR_MUX_itr2_w                       ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):ITR2 of 32bit */
N#define TM_TRG_ITR_MUX_itr2_h0                      ((uint16_t)0x0200)      /*!< Bit Value =(0x2):ITR2 of 16bit */
N#define TM_TRG_ITR_MUX_itr2_b1                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):ITR2 of 8bit */
N#define TM_TRG_ITR_MUX_itr3_w                       ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):ITR3 of 32bit */
N#define TM_TRG_ITR_MUX_itr3_h0                      ((uint16_t)0x0300)      /*!< Bit Value =(0x3):ITR3 of 16bit */
N#define TM_TRG_ITR_MUX_itr3_b1                      ((uint8_t )0x03)        /*!< Bit Value =(0x3):ITR3 of 8bit */
N#define TM_TRG_ITR_MUX_itr4_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):ITR4 of 32bit */
N#define TM_TRG_ITR_MUX_itr4_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x4):ITR4 of 16bit */
N#define TM_TRG_ITR_MUX_itr4_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x4):ITR4 of 8bit */
N#define TM_TRG_ITR_MUX_itr5_w                       ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):ITR5 of 32bit */
N#define TM_TRG_ITR_MUX_itr5_h0                      ((uint16_t)0x0500)      /*!< Bit Value =(0x5):ITR5 of 16bit */
N#define TM_TRG_ITR_MUX_itr5_b1                      ((uint8_t )0x05)        /*!< Bit Value =(0x5):ITR5 of 8bit */
N#define TM_TRG_ITR_MUX_itr6_w                       ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):ITR6 of 32bit */
N#define TM_TRG_ITR_MUX_itr6_h0                      ((uint16_t)0x0600)      /*!< Bit Value =(0x6):ITR6 of 16bit */
N#define TM_TRG_ITR_MUX_itr6_b1                      ((uint8_t )0x06)        /*!< Bit Value =(0x6):ITR6 of 8bit */
N#define TM_TRG_ITR_MUX_itr7_w                       ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):ITR7 of 32bit */
N#define TM_TRG_ITR_MUX_itr7_h0                      ((uint16_t)0x0700)      /*!< Bit Value =(0x7):ITR7 of 16bit */
N#define TM_TRG_ITR_MUX_itr7_b1                      ((uint8_t )0x07)        /*!< Bit Value =(0x7):ITR7 of 8bit */
N
N#define TM_TRG_TRG_MUX_mask_w                       ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRG_MUX_mask_h0                      ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRG_MUX_mask_b0                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRG_MUX_etr_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ETR of 32bit */
N#define TM_TRG_TRG_MUX_etr_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ETR of 16bit */
N#define TM_TRG_TRG_MUX_etr_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):ETR of 8bit */
N#define TM_TRG_TRG_MUX_itr_w                        ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):ITR of 32bit */
N#define TM_TRG_TRG_MUX_itr_h0                       ((uint16_t)0x0040)      /*!< Bit Value =(0x1):ITR of 16bit */
N#define TM_TRG_TRG_MUX_itr_b0                       ((uint8_t )0x40)        /*!< Bit Value =(0x1):ITR of 8bit */
N#define TM_TRG_TRG_MUX_in0_w                        ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):IN0 of 32bit */
N#define TM_TRG_TRG_MUX_in0_h0                       ((uint16_t)0x0080)      /*!< Bit Value =(0x2):IN0 of 16bit */
N#define TM_TRG_TRG_MUX_in0_b0                       ((uint8_t )0x80)        /*!< Bit Value =(0x2):IN0 of 8bit */
N#define TM_TRG_TRG_MUX_in1_w                        ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):IN1 of 32bit */
N#define TM_TRG_TRG_MUX_in1_h0                       ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):IN1 of 16bit */
N#define TM_TRG_TRG_MUX_in1_b0                       ((uint8_t )0xC0)        /*!< Bit Value =(0x3):IN1 of 8bit */
N
N#define TM_TRG_TRGI2_MDS_mask_w                     ((uint32_t)0x00000038)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGI2_MDS_mask_h0                    ((uint16_t)0x0038)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGI2_MDS_mask_b0                    ((uint8_t )0x38)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGI2_MDS_no_operation_w             ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define TM_TRG_TRGI2_MDS_no_operation_h0            ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define TM_TRG_TRGI2_MDS_no_operation_b0            ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define TM_TRG_TRGI2_MDS_trigger_r_w                ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):Trigger-R of 32bit */
N#define TM_TRG_TRGI2_MDS_trigger_r_h0               ((uint16_t)0x0008)      /*!< Bit Value =(0x1):Trigger-R of 16bit */
N#define TM_TRG_TRGI2_MDS_trigger_r_b0               ((uint8_t )0x08)        /*!< Bit Value =(0x1):Trigger-R of 8bit */
N#define TM_TRG_TRGI2_MDS_reset_r_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(0x2):Reset-R of 32bit */
N#define TM_TRG_TRGI2_MDS_reset_r_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(0x2):Reset-R of 16bit */
N#define TM_TRG_TRGI2_MDS_reset_r_b0                 ((uint8_t )0x10)        /*!< Bit Value =(0x2):Reset-R of 8bit */
N#define TM_TRG_TRGI2_MDS_gate_h_w                   ((uint32_t)0x00000018)  /*!< Bit Value =(0x3):Gate-H of 32bit */
N#define TM_TRG_TRGI2_MDS_gate_h_h0                  ((uint16_t)0x0018)      /*!< Bit Value =(0x3):Gate-H of 16bit */
N#define TM_TRG_TRGI2_MDS_gate_h_b0                  ((uint8_t )0x18)        /*!< Bit Value =(0x3):Gate-H of 8bit */
N#define TM_TRG_TRGI2_MDS_reset_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(0x4):Reset of 32bit */
N#define TM_TRG_TRGI2_MDS_reset_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(0x4):Reset of 16bit */
N#define TM_TRG_TRGI2_MDS_reset_b0                   ((uint8_t )0x20)        /*!< Bit Value =(0x4):Reset of 8bit */
N#define TM_TRG_TRGI2_MDS_trigger_f_w                ((uint32_t)0x00000028)  /*!< Bit Value =(0x5):Trigger-F of 32bit */
N#define TM_TRG_TRGI2_MDS_trigger_f_h0               ((uint16_t)0x0028)      /*!< Bit Value =(0x5):Trigger-F of 16bit */
N#define TM_TRG_TRGI2_MDS_trigger_f_b0               ((uint8_t )0x28)        /*!< Bit Value =(0x5):Trigger-F of 8bit */
N#define TM_TRG_TRGI2_MDS_reset_f_w                  ((uint32_t)0x00000030)  /*!< Bit Value =(0x6):Reset-F of 32bit */
N#define TM_TRG_TRGI2_MDS_reset_f_h0                 ((uint16_t)0x0030)      /*!< Bit Value =(0x6):Reset-F of 16bit */
N#define TM_TRG_TRGI2_MDS_reset_f_b0                 ((uint8_t )0x30)        /*!< Bit Value =(0x6):Reset-F of 8bit */
N#define TM_TRG_TRGI2_MDS_gate_l_w                   ((uint32_t)0x00000038)  /*!< Bit Value =(0x7):Gate-L of 32bit */
N#define TM_TRG_TRGI2_MDS_gate_l_h0                  ((uint16_t)0x0038)      /*!< Bit Value =(0x7):Gate-L of 16bit */
N#define TM_TRG_TRGI2_MDS_gate_l_b0                  ((uint8_t )0x38)        /*!< Bit Value =(0x7):Gate-L of 8bit */
N
N#define TM_TRG_TRGI_MDS_mask_w                      ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define TM_TRG_TRGI_MDS_mask_h0                     ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define TM_TRG_TRGI_MDS_mask_b0                     ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_TRG_TRGI_MDS_no_operation_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define TM_TRG_TRGI_MDS_no_operation_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define TM_TRG_TRGI_MDS_no_operation_b0             ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define TM_TRG_TRGI_MDS_trigger_r_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Trigger-R of 32bit */
N#define TM_TRG_TRGI_MDS_trigger_r_h0                ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Trigger-R of 16bit */
N#define TM_TRG_TRGI_MDS_trigger_r_b0                ((uint8_t )0x01)        /*!< Bit Value =(0x1):Trigger-R of 8bit */
N#define TM_TRG_TRGI_MDS_reset_r_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Reset-R of 32bit */
N#define TM_TRG_TRGI_MDS_reset_r_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Reset-R of 16bit */
N#define TM_TRG_TRGI_MDS_reset_r_b0                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Reset-R of 8bit */
N#define TM_TRG_TRGI_MDS_gate_h_w                    ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):Gate-H of 32bit */
N#define TM_TRG_TRGI_MDS_gate_h_h0                   ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Gate-H of 16bit */
N#define TM_TRG_TRGI_MDS_gate_h_b0                   ((uint8_t )0x03)        /*!< Bit Value =(0x3):Gate-H of 8bit */
N#define TM_TRG_TRGI_MDS_reset_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):Reset of 32bit */
N#define TM_TRG_TRGI_MDS_reset_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(0x4):Reset of 16bit */
N#define TM_TRG_TRGI_MDS_reset_b0                    ((uint8_t )0x04)        /*!< Bit Value =(0x4):Reset of 8bit */
N#define TM_TRG_TRGI_MDS_trigger_f_w                 ((uint32_t)0x00000005)  /*!< Bit Value =(0x5):Trigger-F of 32bit */
N#define TM_TRG_TRGI_MDS_trigger_f_h0                ((uint16_t)0x0005)      /*!< Bit Value =(0x5):Trigger-F of 16bit */
N#define TM_TRG_TRGI_MDS_trigger_f_b0                ((uint8_t )0x05)        /*!< Bit Value =(0x5):Trigger-F of 8bit */
N#define TM_TRG_TRGI_MDS_reset_f_w                   ((uint32_t)0x00000006)  /*!< Bit Value =(0x6):Reset-F of 32bit */
N#define TM_TRG_TRGI_MDS_reset_f_h0                  ((uint16_t)0x0006)      /*!< Bit Value =(0x6):Reset-F of 16bit */
N#define TM_TRG_TRGI_MDS_reset_f_b0                  ((uint8_t )0x06)        /*!< Bit Value =(0x6):Reset-F of 8bit */
N#define TM_TRG_TRGI_MDS_gate_l_w                    ((uint32_t)0x00000007)  /*!< Bit Value =(0x7):Gate-L of 32bit */
N#define TM_TRG_TRGI_MDS_gate_l_h0                   ((uint16_t)0x0007)      /*!< Bit Value =(0x7):Gate-L of 16bit */
N#define TM_TRG_TRGI_MDS_gate_l_b0                   ((uint8_t )0x07)        /*!< Bit Value =(0x7):Gate-L of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CR0  [register's definitions]
N *              Offset[0x10]  TM Timer control register 0
N ******************************************************************************
N */
N///@{
N#define TM_CR0_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CR0 */
N#define TM_CR0_UEX_EN_mask_w                        ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_UEX_EN_mask_h0                       ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_UEX_EN_mask_b1                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CR0_UEX_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_UEX_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_UEX_EN_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_UEX_EN_enable_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_UEX_EN_enable_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_UEX_EN_enable_b1                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_USW_EN_mask_w                        ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_USW_EN_mask_h0                       ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_USW_EN_mask_b1                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CR0_USW_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_USW_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_USW_EN_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_USW_EN_enable_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_USW_EN_enable_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_USW_EN_enable_b1                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_DIR_INV_mask_w                       ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_DIR_INV_mask_h0                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_DIR_INV_mask_b1                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_CR0_DIR_INV_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_CR0_DIR_INV_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_CR0_DIR_INV_normal_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_CR0_DIR_INV_inverted_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Inverted of 32bit */
N#define TM_CR0_DIR_INV_inverted_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Inverted of 16bit */
N#define TM_CR0_DIR_INV_inverted_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Inverted of 8bit */
N
N#define TM_CR0_UEV_DIS_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_CR0_UEV_DIS_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_CR0_UEV_DIS_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_CR0_UEV_DIS_enable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define TM_CR0_UEV_DIS_enable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define TM_CR0_UEV_DIS_enable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define TM_CR0_UEV_DIS_disable_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Disable of 32bit */
N#define TM_CR0_UEV_DIS_disable_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Disable of 16bit */
N#define TM_CR0_UEV_DIS_disable_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define TM_CR0_EX_INV_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EX_INV_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EX_INV_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EX_INV_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define TM_CR0_EX_INV_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define TM_CR0_EX_INV_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define TM_CR0_EX_INV_inverted_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Inverted of 32bit */
N#define TM_CR0_EX_INV_inverted_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Inverted of 16bit */
N#define TM_CR0_EX_INV_inverted_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Inverted of 8bit */
N
N#define TM_CR0_EX_EN_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EX_EN_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EX_EN_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EX_EN_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_EX_EN_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_EX_EN_disable_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_EX_EN_enable_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_EX_EN_enable_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_EX_EN_enable_b1                      ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_ASTOP_EN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_CR0_ASTOP_EN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_CR0_ASTOP_EN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR0_ASTOP_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_ASTOP_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_ASTOP_EN_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_ASTOP_EN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_ASTOP_EN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_ASTOP_EN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_DIR2_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_CR0_DIR2_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_CR0_DIR2_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CR0_DIR2_up_w                            ((uint32_t)0x00000000)  /*!< Bit Value =(0):Up of 32bit */
N#define TM_CR0_DIR2_up_h0                           ((uint16_t)0x0000)      /*!< Bit Value =(0):Up of 16bit */
N#define TM_CR0_DIR2_up_b0                           ((uint8_t )0x00)        /*!< Bit Value =(0):Up of 8bit */
N#define TM_CR0_DIR2_down_w                          ((uint32_t)0x00000080)  /*!< Bit Value =(1):Down of 32bit */
N#define TM_CR0_DIR2_down_h0                         ((uint16_t)0x0080)      /*!< Bit Value =(1):Down of 16bit */
N#define TM_CR0_DIR2_down_b0                         ((uint8_t )0x80)        /*!< Bit Value =(1):Down of 8bit */
N
N#define TM_CR0_DIR_mask_w                           ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_CR0_DIR_mask_h0                          ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_CR0_DIR_mask_b0                          ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CR0_DIR_up_w                             ((uint32_t)0x00000000)  /*!< Bit Value =(0):Up of 32bit */
N#define TM_CR0_DIR_up_h0                            ((uint16_t)0x0000)      /*!< Bit Value =(0):Up of 16bit */
N#define TM_CR0_DIR_up_b0                            ((uint8_t )0x00)        /*!< Bit Value =(0):Up of 8bit */
N#define TM_CR0_DIR_down_w                           ((uint32_t)0x00000040)  /*!< Bit Value =(1):Down of 32bit */
N#define TM_CR0_DIR_down_h0                          ((uint16_t)0x0040)      /*!< Bit Value =(1):Down of 16bit */
N#define TM_CR0_DIR_down_b0                          ((uint8_t )0x40)        /*!< Bit Value =(1):Down of 8bit */
N
N#define TM_CR0_MDS_mask_w                           ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define TM_CR0_MDS_mask_h0                          ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_CR0_MDS_mask_b0                          ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_CR0_MDS_cascade_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Cascade of 32bit */
N#define TM_CR0_MDS_cascade_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Cascade of 16bit */
N#define TM_CR0_MDS_cascade_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):Cascade of 8bit */
N#define TM_CR0_MDS_separate_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Separate of 32bit */
N#define TM_CR0_MDS_separate_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Separate of 16bit */
N#define TM_CR0_MDS_separate_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):Separate of 8bit */
N#define TM_CR0_MDS_full_counter_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Full-Counter of 32bit */
N#define TM_CR0_MDS_full_counter_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Full-Counter of 16bit */
N#define TM_CR0_MDS_full_counter_b0                  ((uint8_t )0x20)        /*!< Bit Value =(0x2):Full-Counter of 8bit */
N
N#define TM_CR0_EN2_mask_w                           ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EN2_mask_h0                          ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EN2_mask_b0                          ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EN2_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_EN2_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_EN2_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_EN2_enable_w                         ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_EN2_enable_h0                        ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_EN2_enable_b0                        ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR0_EN_mask_w                            ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_CR0_EN_mask_h0                           ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CR0_EN_mask_b0                           ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR0_EN_disable_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CR0_EN_disable_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CR0_EN_disable_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CR0_EN_enable_w                          ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR0_EN_enable_h0                         ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR0_EN_enable_b0                         ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CR1  [register's definitions]
N *              Offset[0x14]  TM Timer control register 1
N ******************************************************************************
N */
N///@{
N#define TM_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CR1 */
N#define TM_CR1_CC3B_SEN_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC3B_SEN_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC3B_SEN_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC3B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC3B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC3B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC3B_SEN_enable_w                    ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC3B_SEN_enable_h0                   ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC3B_SEN_enable_b1                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC2B_SEN_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC2B_SEN_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC2B_SEN_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC2B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC2B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC2B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC2B_SEN_enable_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC2B_SEN_enable_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC2B_SEN_enable_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC1B_SEN_mask_w                      ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC1B_SEN_mask_h0                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC1B_SEN_mask_b1                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC1B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC1B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC1B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC1B_SEN_enable_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC1B_SEN_enable_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC1B_SEN_enable_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC0B_SEN_mask_w                      ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC0B_SEN_mask_h0                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC0B_SEN_mask_b1                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC0B_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC0B_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC0B_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC0B_SEN_enable_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC0B_SEN_enable_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC0B_SEN_enable_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC3A_SEN_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC3A_SEN_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC3A_SEN_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC3A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC3A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC3A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC3A_SEN_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC3A_SEN_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC3A_SEN_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC2A_SEN_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC2A_SEN_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC2A_SEN_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC2A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC2A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC2A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC2A_SEN_enable_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC2A_SEN_enable_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC2A_SEN_enable_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC1A_SEN_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC1A_SEN_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC1A_SEN_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC1A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC1A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC1A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC1A_SEN_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC1A_SEN_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC1A_SEN_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_CC0A_SEN_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_CR1_CC0A_SEN_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_CR1_CC0A_SEN_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR1_CC0A_SEN_no_effect_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):No-Effect of 32bit */
N#define TM_CR1_CC0A_SEN_no_effect_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):No-Effect of 16bit */
N#define TM_CR1_CC0A_SEN_no_effect_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):No-Effect of 8bit */
N#define TM_CR1_CC0A_SEN_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CR1_CC0A_SEN_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CR1_CC0A_SEN_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CR1_OVR3_MDS_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR3_MDS_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR3_MDS_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR3_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR3_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR3_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR3_MDS_keep_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR3_MDS_keep_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR3_MDS_keep_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define TM_CR1_OVR2_MDS_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR2_MDS_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR2_MDS_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR2_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR2_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR2_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR2_MDS_keep_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR2_MDS_keep_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR2_MDS_keep_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define TM_CR1_OVR1_MDS_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR1_MDS_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR1_MDS_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR1_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR1_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR1_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR1_MDS_keep_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR1_MDS_keep_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR1_MDS_keep_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define TM_CR1_OVR0_MDS_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_CR1_OVR0_MDS_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CR1_OVR0_MDS_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CR1_OVR0_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define TM_CR1_OVR0_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define TM_CR1_OVR0_MDS_overwritten_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define TM_CR1_OVR0_MDS_keep_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Keep of 32bit */
N#define TM_CR1_OVR0_MDS_keep_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Keep of 16bit */
N#define TM_CR1_OVR0_MDS_keep_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Keep of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CKO  [register's definitions]
N *              Offset[0x18]  TM Timer CKO control register
N ******************************************************************************
N */
N///@{
N#define TM_CKO_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CKO */
N#define TM_CKO_CKO_LCK_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_LCK_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_LCK_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_LCK_locked_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_CKO_CKO_LCK_locked_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_CKO_CKO_LCK_locked_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_CKO_CKO_LCK_un_locked_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_CKO_CKO_LCK_un_locked_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_CKO_CKO_LCK_un_locked_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_CKO_CKO_STA_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_STA_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_STA_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_CKO_CKO_STA_0_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_CKO_CKO_STA_0_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_CKO_CKO_STA_1_w                          ((uint32_t)0x00000004)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_CKO_CKO_STA_1_h0                         ((uint16_t)0x0004)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_CKO_CKO_STA_1_b0                         ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_CKO_CKO_SEL_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_SEL_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_SEL_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_SEL_2nd_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):2nd of 32bit */
N#define TM_CKO_CKO_SEL_2nd_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):2nd of 16bit */
N#define TM_CKO_CKO_SEL_2nd_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):2nd of 8bit */
N#define TM_CKO_CKO_SEL_main_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Main of 32bit */
N#define TM_CKO_CKO_SEL_main_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Main of 16bit */
N#define TM_CKO_CKO_SEL_main_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Main of 8bit */
N
N#define TM_CKO_CKO_EN_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_CKO_CKO_EN_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CKO_CKO_EN_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CKO_CKO_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CKO_CKO_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CKO_CKO_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CKO_CKO_EN_enable_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CKO_CKO_EN_enable_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CKO_CKO_EN_enable_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CNT  [register's definitions]
N *              Offset[0x20]  TM Timer main counter register
N ******************************************************************************
N */
N///@{
N#define TM_CNT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CNT */
N#define TM_CNT_CNT_mask_w                           ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CNT_CNT_mask_h0                          ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CNT_CNT_shift_w                          (0)                     /*!< Bit Shift of 32bit */
N#define TM_CNT_CNT_shift_h0                         (0)                     /*!< Bit Shift of 16bit */
N#define TM_CNT_CNT_shift_b0                         (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_ARR  [register's definitions]
N *              Offset[0x24]  TM Timer main counter auto-reload value register
N ******************************************************************************
N */
N///@{
N#define TM_ARR_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_ARR */
N#define TM_ARR_ARR_mask_w                           ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_ARR_ARR_mask_h0                          ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_PSCNT  [register's definitions]
N *              Offset[0x28]  TM Timer prescaler register
N ******************************************************************************
N */
N///@{
N#define TM_PSCNT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_PSCNT */
N#define TM_PSCNT_CNTA_mask_w                        ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define TM_PSCNT_CNTA_mask_h1                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_PSCNT_CNTA_shift_w                       (16)                    /*!< Bit Shift of 32bit */
N#define TM_PSCNT_CNTA_shift_h1                      (0)                     /*!< Bit Shift of 16bit */
N#define TM_PSCNT_CNTA_shift_b2                      (0)                     /*!< Bit Shift of 8bit */
N
N#define TM_PSCNT_PSCNT_mask_w                       ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_PSCNT_PSCNT_mask_h0                      ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_PSCNT_PSCNT_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define TM_PSCNT_PSCNT_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define TM_PSCNT_PSCNT_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_PSARR  [register's definitions]
N *              Offset[0x2C]  TM Timer prescaler auto-reload register
N ******************************************************************************
N */
N///@{
N#define TM_PSARR_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_PSARR */
N#define TM_PSARR_PSARR_mask_w                       ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_PSARR_PSARR_mask_h0                      ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_PSARR_PSARR_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define TM_PSARR_PSARR_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define TM_PSARR_PSARR_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CCMDS  [register's definitions]
N *              Offset[0x30]  TM Timer capture and compare mode select register
N ******************************************************************************
N */
N///@{
N#define TM_CCMDS_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CCMDS */
N#define TM_CCMDS_DMA_CC3E_mask_w                    ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC3E_mask_h1                   ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC3E_mask_b3                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC3E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC3E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC3E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC3E_enable_w                  ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC3E_enable_h1                 ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC3E_enable_b3                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_CC2E_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC2E_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC2E_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC2E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC2E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC2E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC2E_enable_w                  ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC2E_enable_h1                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC2E_enable_b3                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_CC1E_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC1E_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC1E_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC1E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC1E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC1E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC1E_enable_w                  ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC1E_enable_h1                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC1E_enable_b3                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_CC0E_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_CC0E_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_CC0E_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_CC0E_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_CCMDS_DMA_CC0E_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_CCMDS_DMA_CC0E_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_CCMDS_DMA_CC0E_enable_w                  ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_CCMDS_DMA_CC0E_enable_h1                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_CCMDS_DMA_CC0E_enable_b3                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_CCMDS_DMA_OMDS_mask_w                    ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_DMA_OMDS_mask_h1                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_DMA_OMDS_mask_b2                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_DMA_OMDS_uev_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):UEV of 32bit */
N#define TM_CCMDS_DMA_OMDS_uev_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):UEV of 16bit */
N#define TM_CCMDS_DMA_OMDS_uev_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):UEV of 8bit */
N#define TM_CCMDS_DMA_OMDS_itr_w                     ((uint32_t)0x00800000)  /*!< Bit Value =(1):ITR of 32bit */
N#define TM_CCMDS_DMA_OMDS_itr_h1                    ((uint16_t)0x0080)      /*!< Bit Value =(1):ITR of 16bit */
N#define TM_CCMDS_DMA_OMDS_itr_b2                    ((uint8_t )0x80)        /*!< Bit Value =(1):ITR of 8bit */
N
N#define TM_CCMDS_OC_LCK_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_OC_LCK_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_OC_LCK_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_OC_LCK_un_locked_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):un-Locked of 32bit */
N#define TM_CCMDS_OC_LCK_un_locked_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):un-Locked of 16bit */
N#define TM_CCMDS_OC_LCK_un_locked_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):un-Locked of 8bit */
N#define TM_CCMDS_OC_LCK_locked_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Locked of 32bit */
N#define TM_CCMDS_OC_LCK_locked_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Locked of 16bit */
N#define TM_CCMDS_OC_LCK_locked_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Locked of 8bit */
N
N#define TM_CCMDS_CC3_MDS_mask_w                     ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC3_MDS_mask_h0                    ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC3_MDS_mask_b1                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC3_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC3_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC3_MDS_nop_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC3_MDS_16bit_ic_w                 ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC3_MDS_16bit_ic_h0                ((uint16_t)0x1000)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC3_MDS_16bit_ic_b1                ((uint8_t )0x10)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC3_MDS_16bit_oc_w                 ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC3_MDS_16bit_oc_h0                ((uint16_t)0x2000)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC3_MDS_16bit_oc_b1                ((uint8_t )0x20)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_oc_w                ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_oc_h0               ((uint16_t)0x3000)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_oc_b1               ((uint8_t )0x30)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC3_MDS_16bit_pwm_w                ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC3_MDS_16bit_pwm_h0               ((uint16_t)0x4000)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC3_MDS_16bit_pwm_b1               ((uint8_t )0x40)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_pwm_w               ((uint32_t)0x00005000)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_pwm_h0              ((uint16_t)0x5000)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC3_MDS_8bitx2_pwm_b1              ((uint8_t )0x50)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N
N#define TM_CCMDS_CC2_MDS_mask_w                     ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC2_MDS_mask_h0                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC2_MDS_mask_b1                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC2_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC2_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC2_MDS_nop_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_ic_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_ic_h0                ((uint16_t)0x0100)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_ic_b1                ((uint8_t )0x01)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_oc_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_oc_h0                ((uint16_t)0x0200)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_oc_b1                ((uint8_t )0x02)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_oc_w                ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_oc_h0               ((uint16_t)0x0300)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_oc_b1               ((uint8_t )0x03)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_w                ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_h0               ((uint16_t)0x0400)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_b1               ((uint8_t )0x04)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_w               ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_h0              ((uint16_t)0x0500)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_b1              ((uint8_t )0x05)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_dtg_w            ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):16bit_PWM_DTG of 32bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_dtg_h0           ((uint16_t)0x0600)      /*!< Bit Value =(0x6):16bit_PWM_DTG of 16bit */
N#define TM_CCMDS_CC2_MDS_16bit_pwm_dtg_b1           ((uint8_t )0x06)        /*!< Bit Value =(0x6):16bit_PWM_DTG of 8bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_dtg_w           ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 32bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_dtg_h0          ((uint16_t)0x0700)      /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 16bit */
N#define TM_CCMDS_CC2_MDS_8bitx2_pwm_dtg_b1          ((uint8_t )0x07)        /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 8bit */
N
N#define TM_CCMDS_CC1_MDS_mask_w                     ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC1_MDS_mask_h0                    ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC1_MDS_mask_b0                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC1_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC1_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC1_MDS_nop_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_ic_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_ic_h0                ((uint16_t)0x0010)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_ic_b0                ((uint8_t )0x10)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_oc_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_oc_h0                ((uint16_t)0x0020)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_oc_b0                ((uint8_t )0x20)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_oc_w                ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_oc_h0               ((uint16_t)0x0030)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_oc_b0               ((uint8_t )0x30)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_w                ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_h0               ((uint16_t)0x0040)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_b0               ((uint8_t )0x40)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_w               ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_h0              ((uint16_t)0x0050)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_b0              ((uint8_t )0x50)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_dtg_w            ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):16bit_PWM_DTG of 32bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_dtg_h0           ((uint16_t)0x0060)      /*!< Bit Value =(0x6):16bit_PWM_DTG of 16bit */
N#define TM_CCMDS_CC1_MDS_16bit_pwm_dtg_b0           ((uint8_t )0x60)        /*!< Bit Value =(0x6):16bit_PWM_DTG of 8bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_dtg_w           ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 32bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_dtg_h0          ((uint16_t)0x0070)      /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 16bit */
N#define TM_CCMDS_CC1_MDS_8bitx2_pwm_dtg_b0          ((uint8_t )0x70)        /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 8bit */
N
N#define TM_CCMDS_CC0_MDS_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define TM_CCMDS_CC0_MDS_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define TM_CCMDS_CC0_MDS_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define TM_CCMDS_CC0_MDS_nop_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NOP of 32bit */
N#define TM_CCMDS_CC0_MDS_nop_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NOP of 16bit */
N#define TM_CCMDS_CC0_MDS_nop_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):NOP of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_ic_w                 ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):16bit_IC of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_ic_h0                ((uint16_t)0x0001)      /*!< Bit Value =(0x1):16bit_IC of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_ic_b0                ((uint8_t )0x01)        /*!< Bit Value =(0x1):16bit_IC of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_oc_w                 ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):16bit_OC of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_oc_h0                ((uint16_t)0x0002)      /*!< Bit Value =(0x2):16bit_OC of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_oc_b0                ((uint8_t )0x02)        /*!< Bit Value =(0x2):16bit_OC of 8bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_oc_w                ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):8bitx2_OC of 32bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_oc_h0               ((uint16_t)0x0003)      /*!< Bit Value =(0x3):8bitx2_OC of 16bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_oc_b0               ((uint8_t )0x03)        /*!< Bit Value =(0x3):8bitx2_OC of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_w                ((uint32_t)0x00000004)  /*!< Bit Value =(0x4):16bit_PWM of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_h0               ((uint16_t)0x0004)      /*!< Bit Value =(0x4):16bit_PWM of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_b0               ((uint8_t )0x04)        /*!< Bit Value =(0x4):16bit_PWM of 8bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_w               ((uint32_t)0x00000005)  /*!< Bit Value =(0x5):8bitx2_PWM of 32bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_h0              ((uint16_t)0x0005)      /*!< Bit Value =(0x5):8bitx2_PWM of 16bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_b0              ((uint8_t )0x05)        /*!< Bit Value =(0x5):8bitx2_PWM of 8bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_dtg_w            ((uint32_t)0x00000006)  /*!< Bit Value =(0x6):16bit_PWM_DTG of 32bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_dtg_h0           ((uint16_t)0x0006)      /*!< Bit Value =(0x6):16bit_PWM_DTG of 16bit */
N#define TM_CCMDS_CC0_MDS_16bit_pwm_dtg_b0           ((uint8_t )0x06)        /*!< Bit Value =(0x6):16bit_PWM_DTG of 8bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_dtg_w           ((uint32_t)0x00000007)  /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 32bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_dtg_h0          ((uint16_t)0x0007)      /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 16bit */
N#define TM_CCMDS_CC0_MDS_8bitx2_pwm_dtg_b0          ((uint8_t )0x07)        /*!< Bit Value =(0x7):8bitx2_PWM_DTG of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_ICCR  [register's definitions]
N *              Offset[0x34]  TM Timer input capture control register
N ******************************************************************************
N */
N///@{
N#define TM_ICCR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_ICCR */
N#define TM_ICCR_IC3_TRGS_mask_w                     ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC3_TRGS_mask_h1                    ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC3_TRGS_mask_b2                    ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC3_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC3_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC3_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC3_TRGS_rising_edge_w              ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC3_TRGS_rising_edge_h1             ((uint16_t)0x0040)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC3_TRGS_rising_edge_b2             ((uint8_t )0x40)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC3_TRGS_falling_edge_w             ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC3_TRGS_falling_edge_h1            ((uint16_t)0x0080)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC3_TRGS_falling_edge_b2            ((uint8_t )0x80)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC3_TRGS_dual_edge_w                ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC3_TRGS_dual_edge_h1               ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC3_TRGS_dual_edge_b2               ((uint8_t )0xC0)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC2_TRGS_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC2_TRGS_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC2_TRGS_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC2_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC2_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC2_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC2_TRGS_rising_edge_w              ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC2_TRGS_rising_edge_h1             ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC2_TRGS_rising_edge_b2             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC2_TRGS_falling_edge_w             ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC2_TRGS_falling_edge_h1            ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC2_TRGS_falling_edge_b2            ((uint8_t )0x20)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC2_TRGS_dual_edge_w                ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC2_TRGS_dual_edge_h1               ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC2_TRGS_dual_edge_b2               ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC1_TRGS_mask_w                     ((uint32_t)0x000C0000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC1_TRGS_mask_h1                    ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC1_TRGS_mask_b2                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC1_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC1_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC1_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC1_TRGS_rising_edge_w              ((uint32_t)0x00040000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC1_TRGS_rising_edge_h1             ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC1_TRGS_rising_edge_b2             ((uint8_t )0x04)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC1_TRGS_falling_edge_w             ((uint32_t)0x00080000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC1_TRGS_falling_edge_h1            ((uint16_t)0x0008)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC1_TRGS_falling_edge_b2            ((uint8_t )0x08)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC1_TRGS_dual_edge_w                ((uint32_t)0x000C0000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC1_TRGS_dual_edge_h1               ((uint16_t)0x000C)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC1_TRGS_dual_edge_b2               ((uint8_t )0x0C)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC0_TRGS_mask_w                     ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC0_TRGS_mask_h1                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC0_TRGS_mask_b2                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC0_TRGS_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define TM_ICCR_IC0_TRGS_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define TM_ICCR_IC0_TRGS_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define TM_ICCR_IC0_TRGS_rising_edge_w              ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define TM_ICCR_IC0_TRGS_rising_edge_h1             ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define TM_ICCR_IC0_TRGS_rising_edge_b2             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define TM_ICCR_IC0_TRGS_falling_edge_w             ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define TM_ICCR_IC0_TRGS_falling_edge_h1            ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define TM_ICCR_IC0_TRGS_falling_edge_b2            ((uint8_t )0x02)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define TM_ICCR_IC0_TRGS_dual_edge_w                ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define TM_ICCR_IC0_TRGS_dual_edge_h1               ((uint16_t)0x0003)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define TM_ICCR_IC0_TRGS_dual_edge_b2               ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define TM_ICCR_IC3_MUX_mask_w                      ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC3_MUX_mask_h0                     ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC3_MUX_mask_b1                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC3_MUX_ic30_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC30 of 32bit */
N#define TM_ICCR_IC3_MUX_ic30_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC30 of 16bit */
N#define TM_ICCR_IC3_MUX_ic30_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC30 of 8bit */
N#define TM_ICCR_IC3_MUX_ic31_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):IC31 of 32bit */
N#define TM_ICCR_IC3_MUX_ic31_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(0x1):IC31 of 16bit */
N#define TM_ICCR_IC3_MUX_ic31_b1                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):IC31 of 8bit */
N#define TM_ICCR_IC3_MUX_ic32_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):IC32 of 32bit */
N#define TM_ICCR_IC3_MUX_ic32_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(0x2):IC32 of 16bit */
N#define TM_ICCR_IC3_MUX_ic32_b1                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):IC32 of 8bit */
N#define TM_ICCR_IC3_MUX_ic33_w                      ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):IC33 of 32bit */
N#define TM_ICCR_IC3_MUX_ic33_h0                     ((uint16_t)0x3000)      /*!< Bit Value =(0x3):IC33 of 16bit */
N#define TM_ICCR_IC3_MUX_ic33_b1                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):IC33 of 8bit */
N
N#define TM_ICCR_IC2_MUX_mask_w                      ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC2_MUX_mask_h0                     ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC2_MUX_mask_b1                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC2_MUX_ic20_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC20 of 32bit */
N#define TM_ICCR_IC2_MUX_ic20_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC20 of 16bit */
N#define TM_ICCR_IC2_MUX_ic20_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC20 of 8bit */
N#define TM_ICCR_IC2_MUX_ic21_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):IC21 of 32bit */
N#define TM_ICCR_IC2_MUX_ic21_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):IC21 of 16bit */
N#define TM_ICCR_IC2_MUX_ic21_b1                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):IC21 of 8bit */
N#define TM_ICCR_IC2_MUX_ic22_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):IC22 of 32bit */
N#define TM_ICCR_IC2_MUX_ic22_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(0x2):IC22 of 16bit */
N#define TM_ICCR_IC2_MUX_ic22_b1                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):IC22 of 8bit */
N#define TM_ICCR_IC2_MUX_ic23_w                      ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):IC23 of 32bit */
N#define TM_ICCR_IC2_MUX_ic23_h0                     ((uint16_t)0x0300)      /*!< Bit Value =(0x3):IC23 of 16bit */
N#define TM_ICCR_IC2_MUX_ic23_b1                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):IC23 of 8bit */
N
N#define TM_ICCR_IC1_MUX_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC1_MUX_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC1_MUX_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC1_MUX_ic10_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC10 of 32bit */
N#define TM_ICCR_IC1_MUX_ic10_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC10 of 16bit */
N#define TM_ICCR_IC1_MUX_ic10_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC10 of 8bit */
N#define TM_ICCR_IC1_MUX_ic11_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):IC11 of 32bit */
N#define TM_ICCR_IC1_MUX_ic11_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(0x1):IC11 of 16bit */
N#define TM_ICCR_IC1_MUX_ic11_b0                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):IC11 of 8bit */
N#define TM_ICCR_IC1_MUX_ic12_w                      ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):IC12 of 32bit */
N#define TM_ICCR_IC1_MUX_ic12_h0                     ((uint16_t)0x0020)      /*!< Bit Value =(0x2):IC12 of 16bit */
N#define TM_ICCR_IC1_MUX_ic12_b0                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):IC12 of 8bit */
N#define TM_ICCR_IC1_MUX_ic13_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):IC13 of 32bit */
N#define TM_ICCR_IC1_MUX_ic13_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):IC13 of 16bit */
N#define TM_ICCR_IC1_MUX_ic13_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):IC13 of 8bit */
N
N#define TM_ICCR_IC0_MUX_mask_w                      ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define TM_ICCR_IC0_MUX_mask_h0                     ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_ICCR_IC0_MUX_mask_b0                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_ICCR_IC0_MUX_ic00_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):IC00 of 32bit */
N#define TM_ICCR_IC0_MUX_ic00_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):IC00 of 16bit */
N#define TM_ICCR_IC0_MUX_ic00_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):IC00 of 8bit */
N#define TM_ICCR_IC0_MUX_ic01_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):IC01 of 32bit */
N#define TM_ICCR_IC0_MUX_ic01_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):IC01 of 16bit */
N#define TM_ICCR_IC0_MUX_ic01_b0                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):IC01 of 8bit */
N#define TM_ICCR_IC0_MUX_ic02_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):IC02 of 32bit */
N#define TM_ICCR_IC0_MUX_ic02_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(0x2):IC02 of 16bit */
N#define TM_ICCR_IC0_MUX_ic02_b0                     ((uint8_t )0x02)        /*!< Bit Value =(0x2):IC02 of 8bit */
N#define TM_ICCR_IC0_MUX_ic03_w                      ((uint32_t)0x00000003)  /*!< Bit Value =(0x3):IC03 of 32bit */
N#define TM_ICCR_IC0_MUX_ic03_h0                     ((uint16_t)0x0003)      /*!< Bit Value =(0x3):IC03 of 16bit */
N#define TM_ICCR_IC0_MUX_ic03_b0                     ((uint8_t )0x03)        /*!< Bit Value =(0x3):IC03 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_OSCR  [register's definitions]
N *              Offset[0x38]  TM Timer output compare state register
N ******************************************************************************
N */
N///@{
N#define TM_OSCR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_OSCR */
N#define TM_OSCR_OS3H_LCK_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3H_LCK_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3H_LCK_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS3H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS3H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS3H_LCK_un_locked_w                ((uint32_t)0x00008000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS3H_LCK_un_locked_h0               ((uint16_t)0x8000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS3H_LCK_un_locked_b1               ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS2H_LCK_mask_w                     ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2H_LCK_mask_h0                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2H_LCK_mask_b1                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS2H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS2H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS2H_LCK_un_locked_w                ((uint32_t)0x00004000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS2H_LCK_un_locked_h0               ((uint16_t)0x4000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS2H_LCK_un_locked_b1               ((uint8_t )0x40)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS1H_LCK_mask_w                     ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1H_LCK_mask_h0                    ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1H_LCK_mask_b1                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS1H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS1H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS1H_LCK_un_locked_w                ((uint32_t)0x00002000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS1H_LCK_un_locked_h0               ((uint16_t)0x2000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS1H_LCK_un_locked_b1               ((uint8_t )0x20)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS0H_LCK_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0H_LCK_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0H_LCK_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0H_LCK_locked_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS0H_LCK_locked_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS0H_LCK_locked_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS0H_LCK_un_locked_w                ((uint32_t)0x00001000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS0H_LCK_un_locked_h0               ((uint16_t)0x1000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS0H_LCK_un_locked_b1               ((uint8_t )0x10)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS3H_STA_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3H_STA_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3H_STA_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS3H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS3H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS3H_STA_1_w                        ((uint32_t)0x00000800)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS3H_STA_1_h0                       ((uint16_t)0x0800)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS3H_STA_1_b1                       ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS2H_STA_mask_w                     ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2H_STA_mask_h0                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2H_STA_mask_b1                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS2H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS2H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS2H_STA_1_w                        ((uint32_t)0x00000400)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS2H_STA_1_h0                       ((uint16_t)0x0400)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS2H_STA_1_b1                       ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS1H_STA_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1H_STA_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1H_STA_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS1H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS1H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS1H_STA_1_w                        ((uint32_t)0x00000200)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS1H_STA_1_h0                       ((uint16_t)0x0200)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS1H_STA_1_b1                       ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS0H_STA_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0H_STA_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0H_STA_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0H_STA_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS0H_STA_0_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS0H_STA_0_b1                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS0H_STA_1_w                        ((uint32_t)0x00000100)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS0H_STA_1_h0                       ((uint16_t)0x0100)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS0H_STA_1_b1                       ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS3_LCK_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3_LCK_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3_LCK_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS3_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS3_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS3_LCK_un_locked_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS3_LCK_un_locked_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS3_LCK_un_locked_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS2_LCK_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2_LCK_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2_LCK_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS2_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS2_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS2_LCK_un_locked_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS2_LCK_un_locked_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS2_LCK_un_locked_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS1_LCK_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1_LCK_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1_LCK_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS1_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS1_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS1_LCK_un_locked_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS1_LCK_un_locked_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS1_LCK_un_locked_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS0_LCK_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0_LCK_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0_LCK_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define TM_OSCR_OS0_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define TM_OSCR_OS0_LCK_locked_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define TM_OSCR_OS0_LCK_un_locked_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define TM_OSCR_OS0_LCK_un_locked_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define TM_OSCR_OS0_LCK_un_locked_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define TM_OSCR_OS3_STA_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS3_STA_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS3_STA_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS3_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS3_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS3_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS3_STA_1_w                         ((uint32_t)0x00000008)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS3_STA_1_h0                        ((uint16_t)0x0008)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS3_STA_1_b0                        ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS2_STA_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS2_STA_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS2_STA_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS2_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS2_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS2_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS2_STA_1_w                         ((uint32_t)0x00000004)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS2_STA_1_h0                        ((uint16_t)0x0004)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS2_STA_1_b0                        ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS1_STA_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS1_STA_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS1_STA_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS1_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS1_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS1_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS1_STA_1_w                         ((uint32_t)0x00000002)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS1_STA_1_h0                        ((uint16_t)0x0002)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS1_STA_1_b0                        ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_OSCR_OS0_STA_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_OSCR_OS0_STA_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OSCR_OS0_STA_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OSCR_OS0_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_OSCR_OS0_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_OSCR_OS0_STA_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_OSCR_OS0_STA_1_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_OSCR_OS0_STA_1_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_OSCR_OS0_STA_1_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_OCCR0  [register's definitions]
N *              Offset[0x3C]  TM Timer output compare control register 0
N ******************************************************************************
N */
N///@{
N#define TM_OCCR0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_OCCR0 */
N#define TM_OCCR0_OC2N_OE_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC2N_OE_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC2N_OE_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC2N_OE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC2N_OE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC2N_OE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC2N_OE_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC2N_OE_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC2N_OE_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1N_OE_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1N_OE_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1N_OE_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1N_OE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1N_OE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1N_OE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1N_OE_enable_w                   ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1N_OE_enable_h1                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1N_OE_enable_b2                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0N_OE_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0N_OE_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0N_OE_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0N_OE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0N_OE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0N_OE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0N_OE_enable_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0N_OE_enable_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0N_OE_enable_b2                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC3_OE_mask_w                      ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC3_OE_mask_h0                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC3_OE_mask_b1                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC3_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC3_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC3_OE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC3_OE_enable_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC3_OE_enable_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC3_OE_enable_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC2_OE_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC2_OE_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC2_OE_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC2_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC2_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC2_OE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC2_OE_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC2_OE_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC2_OE_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1_OE2_mask_w                     ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1_OE2_mask_h0                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1_OE2_mask_b0                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1_OE2_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1_OE2_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1_OE2_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1_OE2_enable_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1_OE2_enable_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1_OE2_enable_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1_OE1_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1_OE1_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1_OE1_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1_OE1_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1_OE1_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1_OE1_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1_OE1_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1_OE1_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1_OE1_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC1_OE0_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC1_OE0_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC1_OE0_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC1_OE0_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC1_OE0_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC1_OE0_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC1_OE0_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC1_OE0_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC1_OE0_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0_OE2_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0_OE2_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0_OE2_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0_OE2_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0_OE2_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0_OE2_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0_OE2_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0_OE2_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0_OE2_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0_OE1_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0_OE1_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0_OE1_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0_OE1_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0_OE1_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0_OE1_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0_OE1_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0_OE1_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0_OE1_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR0_OC0_OE0_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_OCCR0_OC0_OE0_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR0_OC0_OE0_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR0_OC0_OE0_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR0_OC0_OE0_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR0_OC0_OE0_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR0_OC0_OE0_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR0_OC0_OE0_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR0_OC0_OE0_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_OCCR1  [register's definitions]
N *              Offset[0x40]  TM Timer output compare control register 1
N ******************************************************************************
N */
N///@{
N#define TM_OCCR1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_OCCR1 */
N#define TM_OCCR1_POE_SW_mask_w                      ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_SW_mask_h1                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_SW_mask_b3                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_SW_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_SW_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_SW_disable_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_SW_enable_w                    ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_SW_enable_h1                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_SW_enable_b3                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_POE_EN2_mask_w                     ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_EN2_mask_h1                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_EN2_mask_b3                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_EN2_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_EN2_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_EN2_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_EN2_enable_w                   ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_EN2_enable_h1                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_EN2_enable_b3                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_POE_EN1_mask_w                     ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_EN1_mask_h1                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_EN1_mask_b3                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_EN1_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_EN1_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_EN1_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_EN1_enable_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_EN1_enable_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_EN1_enable_b3                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_POE_EN0_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_POE_EN0_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_POE_EN0_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_POE_EN0_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_POE_EN0_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_POE_EN0_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_POE_EN0_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_POE_EN0_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_POE_EN0_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_POE2_mask_w                    ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_POE2_mask_h1                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_POE2_mask_b2                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_POE2_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_POE2_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_POE2_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_POE2_enable_w                  ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_POE2_enable_h1                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_POE2_enable_b2                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_POE1_mask_w                    ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_POE1_mask_h1                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_POE1_mask_b2                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_POE1_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_POE1_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_POE1_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_POE1_enable_w                  ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_POE1_enable_h1                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_POE1_enable_b2                 ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_POE0_mask_w                    ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_POE0_mask_h1                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_POE0_mask_b2                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_POE0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_POE0_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_POE0_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_POE0_enable_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_POE0_enable_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_POE0_enable_b2                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_POE2_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_POE2_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_POE2_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_POE2_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_POE2_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_POE2_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_POE2_enable_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_POE2_enable_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_POE2_enable_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_POE1_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_POE1_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_POE1_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_POE1_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_POE1_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_POE1_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_POE1_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_POE1_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_POE1_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_POE0_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_POE0_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_POE0_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_POE0_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_POE0_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_POE0_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_POE0_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_POE0_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_POE0_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC2N_INV_mask_w                    ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC2N_INV_mask_h0                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC2N_INV_mask_b1                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC2N_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC2N_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC2N_INV_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC2N_INV_enable_w                  ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC2N_INV_enable_h0                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC2N_INV_enable_b1                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1N_INV_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1N_INV_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1N_INV_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1N_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1N_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1N_INV_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1N_INV_enable_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1N_INV_enable_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1N_INV_enable_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0N_INV_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0N_INV_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0N_INV_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0N_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0N_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0N_INV_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0N_INV_enable_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0N_INV_enable_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0N_INV_enable_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC3H_INV_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC3H_INV_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC3H_INV_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC3H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC3H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC3H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC3H_INV_enable_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC3H_INV_enable_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC3H_INV_enable_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC2H_INV_mask_w                    ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC2H_INV_mask_h0                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC2H_INV_mask_b0                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC2H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC2H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC2H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC2H_INV_enable_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC2H_INV_enable_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC2H_INV_enable_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1H_INV_mask_w                    ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1H_INV_mask_h0                   ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1H_INV_mask_b0                   ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1H_INV_enable_w                  ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1H_INV_enable_h0                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1H_INV_enable_b0                 ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0H_INV_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0H_INV_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0H_INV_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0H_INV_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0H_INV_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0H_INV_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0H_INV_enable_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0H_INV_enable_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0H_INV_enable_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC3_INV_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC3_INV_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC3_INV_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC3_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC3_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC3_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC3_INV_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC3_INV_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC3_INV_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC2_INV_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC2_INV_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC2_INV_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC2_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC2_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC2_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC2_INV_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC2_INV_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC2_INV_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC1_INV_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC1_INV_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC1_INV_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC1_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC1_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC1_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC1_INV_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC1_INV_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC1_INV_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_OCCR1_OC0_INV_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_OCCR1_OC0_INV_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_OCCR1_OC0_INV_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_OCCR1_OC0_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_OCCR1_OC0_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_OCCR1_OC0_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_OCCR1_OC0_INV_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_OCCR1_OC0_INV_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_OCCR1_OC0_INV_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_PWM  [register's definitions]
N *              Offset[0x44]  TM Timer PWM and DTG control register
N ******************************************************************************
N */
N///@{
N#define TM_PWM_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_PWM */
N#define TM_PWM_DTG_DY_mask_w                        ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define TM_PWM_DTG_DY_mask_h0                       ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define TM_PWM_DTG_DY_mask_b1                       ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define TM_PWM_DTG_DY_shift_w                       (8)                     /*!< Bit Shift of 32bit */
N#define TM_PWM_DTG_DY_shift_h0                      (8)                     /*!< Bit Shift of 16bit */
N#define TM_PWM_DTG_DY_shift_b1                      (0)                     /*!< Bit Shift of 8bit */
N
N#define TM_PWM_PWM_MDS_mask_w                       ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define TM_PWM_PWM_MDS_mask_h0                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define TM_PWM_PWM_MDS_mask_b0                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define TM_PWM_PWM_MDS_edge_left_aligned_w          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Edge Left-aligned of 32bit */
N#define TM_PWM_PWM_MDS_edge_left_aligned_h0         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Edge Left-aligned of 16bit */
N#define TM_PWM_PWM_MDS_edge_left_aligned_b0         ((uint8_t )0x00)        /*!< Bit Value =(0x0):Edge Left-aligned of 8bit */
N#define TM_PWM_PWM_MDS_center_aligned_w             ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Center-aligned of 32bit */
N#define TM_PWM_PWM_MDS_center_aligned_h0            ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Center-aligned of 16bit */
N#define TM_PWM_PWM_MDS_center_aligned_b0            ((uint8_t )0x01)        /*!< Bit Value =(0x1):Center-aligned of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_BS  [register's definitions]
N *              Offset[0x48]  TM Timer break and stop control register
N ******************************************************************************
N */
N///@{
N#define TM_BS_default                               ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_BS */
N#define TM_BS_STP2N_STA_mask_w                      ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP2N_STA_mask_h1                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP2N_STA_mask_b3                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP2N_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP2N_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP2N_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP2N_STA_1_w                         ((uint32_t)0x40000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP2N_STA_1_h1                        ((uint16_t)0x4000)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP2N_STA_1_b3                        ((uint8_t )0x40)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP1N_STA_mask_w                      ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP1N_STA_mask_h1                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP1N_STA_mask_b3                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP1N_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP1N_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP1N_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP1N_STA_1_w                         ((uint32_t)0x20000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP1N_STA_1_h1                        ((uint16_t)0x2000)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP1N_STA_1_b3                        ((uint8_t )0x20)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP0N_STA_mask_w                      ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP0N_STA_mask_h1                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP0N_STA_mask_b3                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP0N_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP0N_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP0N_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP0N_STA_1_w                         ((uint32_t)0x10000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP0N_STA_1_h1                        ((uint16_t)0x1000)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP0N_STA_1_b3                        ((uint8_t )0x10)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP3_STA_mask_w                       ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP3_STA_mask_h1                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP3_STA_mask_b3                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP3_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP3_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP3_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP3_STA_1_w                          ((uint32_t)0x08000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP3_STA_1_h1                         ((uint16_t)0x0800)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP3_STA_1_b3                         ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP2_STA_mask_w                       ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP2_STA_mask_h1                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP2_STA_mask_b3                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP2_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP2_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP2_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP2_STA_1_w                          ((uint32_t)0x04000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP2_STA_1_h1                         ((uint16_t)0x0400)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP2_STA_1_b3                         ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP1_STA_mask_w                       ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP1_STA_mask_h1                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP1_STA_mask_b3                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP1_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP1_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP1_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP1_STA_1_w                          ((uint32_t)0x02000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP1_STA_1_h1                         ((uint16_t)0x0200)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP1_STA_1_b3                         ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_STP0_STA_mask_w                       ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define TM_BS_STP0_STA_mask_h1                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_BS_STP0_STA_mask_b3                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_STP0_STA_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define TM_BS_STP0_STA_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define TM_BS_STP0_STA_0_b3                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define TM_BS_STP0_STA_1_w                          ((uint32_t)0x01000000)  /*!< Bit Value =(1):1 of 32bit */
N#define TM_BS_STP0_STA_1_h1                         ((uint16_t)0x0100)      /*!< Bit Value =(1):1 of 16bit */
N#define TM_BS_STP0_STA_1_b3                         ((uint8_t )0x01)        /*!< Bit Value =(1):1 of 8bit */
N
N#define TM_BS_BK3_CTL_mask_w                        ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK3_CTL_mask_h1                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK3_CTL_mask_b2                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK3_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK3_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK3_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK3_CTL_hold_w                        ((uint32_t)0x00800000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK3_CTL_hold_h1                       ((uint16_t)0x0080)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK3_CTL_hold_b2                       ((uint8_t )0x80)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BK2_CTL_mask_w                        ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK2_CTL_mask_h1                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK2_CTL_mask_b2                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK2_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK2_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK2_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK2_CTL_hold_w                        ((uint32_t)0x00400000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK2_CTL_hold_h1                       ((uint16_t)0x0040)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK2_CTL_hold_b2                       ((uint8_t )0x40)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BK1_CTL_mask_w                        ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK1_CTL_mask_h1                       ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK1_CTL_mask_b2                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK1_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK1_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK1_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK1_CTL_hold_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK1_CTL_hold_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK1_CTL_hold_b2                       ((uint8_t )0x20)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BK0_CTL_mask_w                        ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK0_CTL_mask_h1                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK0_CTL_mask_b2                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK0_CTL_stop_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define TM_BS_BK0_CTL_stop_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define TM_BS_BK0_CTL_stop_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define TM_BS_BK0_CTL_hold_w                        ((uint32_t)0x00100000)  /*!< Bit Value =(1):Hold of 32bit */
N#define TM_BS_BK0_CTL_hold_h1                       ((uint16_t)0x0010)      /*!< Bit Value =(1):Hold of 16bit */
N#define TM_BS_BK0_CTL_hold_b2                       ((uint8_t )0x10)        /*!< Bit Value =(1):Hold of 8bit */
N
N#define TM_BS_BKI_EN2_mask_w                        ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKI_EN2_mask_h1                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKI_EN2_mask_b2                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKI_EN2_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKI_EN2_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKI_EN2_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKI_EN2_enable_w                      ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKI_EN2_enable_h1                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKI_EN2_enable_b2                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKI_EN1_mask_w                        ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKI_EN1_mask_h1                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKI_EN1_mask_b2                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKI_EN1_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKI_EN1_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKI_EN1_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKI_EN1_enable_w                      ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKI_EN1_enable_h1                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKI_EN1_enable_b2                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKI_EN0_mask_w                        ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKI_EN0_mask_h1                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKI_EN0_mask_b2                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKI_EN0_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKI_EN0_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKI_EN0_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKI_EN0_enable_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKI_EN0_enable_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKI_EN0_enable_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN7_mask_w                        ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN7_mask_h0                       ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN7_mask_b1                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN7_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN7_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN7_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN7_enable_w                      ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN7_enable_h0                     ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN7_enable_b1                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN6_mask_w                        ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN6_mask_h0                       ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN6_mask_b1                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN6_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN6_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN6_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN6_enable_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN6_enable_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN6_enable_b1                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN5_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN5_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN5_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN5_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN5_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN5_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN5_enable_w                      ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN5_enable_h0                     ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN5_enable_b1                     ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN4_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN4_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN4_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN4_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN4_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN4_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN4_enable_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN4_enable_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN4_enable_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN3_mask_w                        ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN3_mask_h0                       ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN3_mask_b1                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN3_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN3_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN3_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN3_enable_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN3_enable_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN3_enable_b1                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN2_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN2_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN2_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN2_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN2_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN2_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN2_enable_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN2_enable_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN2_enable_b1                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN1_mask_w                        ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN1_mask_h0                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN1_mask_b1                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN1_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN1_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN1_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN1_enable_w                      ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN1_enable_h0                     ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN1_enable_b1                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKE_EN0_mask_w                        ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKE_EN0_mask_h0                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKE_EN0_mask_b1                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKE_EN0_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKE_EN0_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKE_EN0_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKE_EN0_enable_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKE_EN0_enable_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKE_EN0_enable_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BKSW_EN_mask_w                        ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define TM_BS_BKSW_EN_mask_h0                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define TM_BS_BKSW_EN_mask_b0                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define TM_BS_BKSW_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BKSW_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BKSW_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BKSW_EN_enable_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BKSW_EN_enable_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BKSW_EN_enable_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BK_MDS_mask_w                         ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK_MDS_mask_h0                        ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK_MDS_mask_b0                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK_MDS_latch_mode_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Latch mode of 32bit */
N#define TM_BS_BK_MDS_latch_mode_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Latch mode of 16bit */
N#define TM_BS_BK_MDS_latch_mode_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Latch mode of 8bit */
N#define TM_BS_BK_MDS_cycle_by_cycle_w               ((uint32_t)0x00000010)  /*!< Bit Value =(1):Cycle by cycle of 32bit */
N#define TM_BS_BK_MDS_cycle_by_cycle_h0              ((uint16_t)0x0010)      /*!< Bit Value =(1):Cycle by cycle of 16bit */
N#define TM_BS_BK_MDS_cycle_by_cycle_b0              ((uint8_t )0x10)        /*!< Bit Value =(1):Cycle by cycle of 8bit */
N
N#define TM_BS_BK_EN3_mask_w                         ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK_EN3_mask_h0                        ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK_EN3_mask_b0                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK_EN3_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BK_EN3_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BK_EN3_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BK_EN3_enable_w                       ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BK_EN3_enable_h0                      ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BK_EN3_enable_b0                      ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define TM_BS_BK_EN_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define TM_BS_BK_EN_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define TM_BS_BK_EN_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define TM_BS_BK_EN_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define TM_BS_BK_EN_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define TM_BS_BK_EN_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define TM_BS_BK_EN_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define TM_BS_BK_EN_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define TM_BS_BK_EN_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC0A  [register's definitions]
N *              Offset[0x50]  TM Timer capture and compare register 0A
N ******************************************************************************
N */
N///@{
N#define TM_CC0A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC0A */
N#define TM_CC0A_CC0A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC0A_CC0A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC0A_CC0A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC0A_CC0A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC0A_CC0A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC0B  [register's definitions]
N *              Offset[0x54]  TM Timer capture and compare register 0B
N ******************************************************************************
N */
N///@{
N#define TM_CC0B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC0B */
N#define TM_CC0B_CC0B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC0B_CC0B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC0B_CC0B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC0B_CC0B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC0B_CC0B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC1A  [register's definitions]
N *              Offset[0x58]  TM Timer capture and compare register 1A
N ******************************************************************************
N */
N///@{
N#define TM_CC1A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC1A */
N#define TM_CC1A_CC1A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC1A_CC1A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC1A_CC1A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC1A_CC1A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC1A_CC1A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC1B  [register's definitions]
N *              Offset[0x5c]  TM Timer capture and compare register 1B
N ******************************************************************************
N */
N///@{
N#define TM_CC1B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC1B */
N#define TM_CC1B_CC1B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC1B_CC1B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC1B_CC1B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC1B_CC1B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC1B_CC1B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC2A  [register's definitions]
N *              Offset[0x60]  TM Timer capture and compare register 2A
N ******************************************************************************
N */
N///@{
N#define TM_CC2A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC2A */
N#define TM_CC2A_CC2A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC2A_CC2A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC2A_CC2A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC2A_CC2A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC2A_CC2A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC2B  [register's definitions]
N *              Offset[0x64]  TM Timer capture and compare register 2B
N ******************************************************************************
N */
N///@{
N#define TM_CC2B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC2B */
N#define TM_CC2B_CC2B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC2B_CC2B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC2B_CC2B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC2B_CC2B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC2B_CC2B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC3A  [register's definitions]
N *              Offset[0x68]  TM Timer capture and compare register 3A
N ******************************************************************************
N */
N///@{
N#define TM_CC3A_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC3A */
N#define TM_CC3A_CC3A_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC3A_CC3A_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC3A_CC3A_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC3A_CC3A_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC3A_CC3A_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        TM_CC3B  [register's definitions]
N *              Offset[0x6c]  TM Timer capture and compare register 3B
N ******************************************************************************
N */
N///@{
N#define TM_CC3B_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of TM_CC3B */
N#define TM_CC3B_CC3B_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define TM_CC3B_CC3B_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define TM_CC3B_CC3B_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define TM_CC3B_CC3B_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define TM_CC3B_CC3B_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_TM_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_TM.h                          */
N/*----------------------------------------------------------------------------*/
L 36 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_TM_DRV.h" 2
N
N
N/**
N * @brief  	simple define
N *
N */ 
N#define TM_CKO_unLock   TM_CKO_CKO_LCK_un_locked_b0         /*!< for CKO unlock bit of Byte */    
N#define TM_CKO_State    TM_CKO_CKO_STA_1_b0                 /*!< for CKO state bit of Byte */  
N
N#define TM_OS0_unLock   TM_OSCR_OS0_LCK_un_locked_b0        /*!< for OS0 unlock bit of Byte */    
N#define TM_OS0_State    TM_OSCR_OS0_STA_1_b0                /*!< for OS0 state bit of Byte */    
N#define TM_OS0H_unLock  TM_OSCR_OS0H_LCK_un_locked_b1       /*!< for OS0H unlock bit of Byte */    
N#define TM_OS0H_State   TM_OSCR_OS0H_STA_1_b1               /*!< for OS0H state bit of Byte */    
N
N#define TM_OS1_unLock   TM_OSCR_OS1_LCK_un_locked_b0        /*!< for OS1 unlock bit of Byte */    
N#define TM_OS1_State    TM_OSCR_OS1_STA_1_b0                /*!< for OS1 state bit of Byte */    
N#define TM_OS1H_unLock  TM_OSCR_OS1H_LCK_un_locked_b1       /*!< for OS1H unlock bit of Byte */    
N#define TM_OS1H_State   TM_OSCR_OS1H_STA_1_b1               /*!< for OS1H state bit of Byte */    
N
N#define TM_OS2_unLock   TM_OSCR_OS2_LCK_un_locked_b0        /*!< for OS2 unlock bit of Byte */    
N#define TM_OS2_State    TM_OSCR_OS2_STA_1_b0                /*!< for OS2 state bit of Byte */    
N#define TM_OS2H_unLock  TM_OSCR_OS2H_LCK_un_locked_b1       /*!< for OS2H unlock bit of Byte */    
N#define TM_OS2H_State   TM_OSCR_OS2H_STA_1_b1               /*!< for OS2H state bit of Byte */    
N
N#define TM_OS3_unLock   TM_OSCR_OS3_LCK_un_locked_b0        /*!< for OS3 unlock bit of Byte */    
N#define TM_OS3_State    TM_OSCR_OS3_STA_1_b0                /*!< for OS3 state bit of Byte */    
N#define TM_OS3H_unLock  TM_OSCR_OS3H_LCK_un_locked_b1       /*!< for OS3H unlock bit of Byte */    
N#define TM_OS3H_State   TM_OSCR_OS3H_STA_1_b1               /*!< for OS3H state bit of Byte */    
N
N/**
N * @brief  	simple define
N *
N */ 
N#define IC0     TMx_InputMUX_Pin							/*!< IC0 the same as TMx_InputMUX_Pin */
N#define IC1     TMx_InputMUX_ITR                            /*!< CKO the same as TMx_InputMUX_ITR */
N#define IC2     TMx_InputMUX_Select2                        /*!< CKO the same as TMx_InputMUX_Select2 */
N#define IC3     TMx_InputMUX_Select3                        /*!< CKO the same as TMx_InputMUX_Select3 */
N
N
N
N/** 
N * @enum		TM_ClockSourceDef
N * @brief		declare Timer clock from internal or external 
N */        
Ntypedef enum 
N{ 
N    TM_CK_INT=0,                            /*!< Timer clock source from internal clock CK_PROC (CK_SYS/CK_APB or CK_LS) */
N    TM_CK_EXT                               /*!< Timer clock source from external clock (ETR/ITRx/IN0/IN1) */
N} TM_ClockSourceDef;
N
N/** 
N * @enum		TM_INTClockDivDef
N * @brief		declare Timer clock from internal or external 
N */        
Ntypedef enum 
N{ 
N    TM_IntDIV1=0,                           /*!< Timer internal clock divider (DIV1) */
N    TM_IntDIV2,                             /*!< Timer internal clock divider (DIV2) */
N    TM_IntDIV4,                             /*!< Timer internal clock divider (DIV4) */
N    TM_IntDIV8                              /*!< Timer internal clock divider (DIV8) */
N} TM_INTClockDivDef;
N
N/** 
N * @enum		TM_DTClockDivDef
N * @brief		Timer internal dead time clock CK_DTG divider
N */        
Ntypedef enum 
N{ 
N    TM_DTDIV1=0,                            /*!< Timer internal dead time clock divider (DIV1) */
N    TM_DTDIV2,                              /*!< Timer internal dead time clock divider (DIV2) */
N    TM_DTDIV4,                              /*!< Timer internal dead time clock divider (DIV4) */
N    TM_DTDIV8                               /*!< Timer internal dead time clock divider (DIV8) */
N} TM_DTClockDivDef;
N
N/** 
N * @enum		TM_ExternalClockSourceDef
N * @brief		declare Timer external clock source 
N */        
Ntypedef enum 
N{ 
N    TM_CKETR=0,                             /*!< Timer external clock from (ETR) */
N    TM_CKITR,                               /*!< Timer external clock from (ITR0~7) */
N    TM_CKIN0,                               /*!< Timer external clock from (IN0) */
N    TM_CKIN1                                /*!< Timer external clock from (IN1) */
N} TM_ExternalClockSourceDef;
N
N/** 
N * @enum		TM_ITRSourceDef
N * @brief		declare ITRx source 
N */        
Ntypedef enum 
N{ 
N    ITR0,                                   /*!< ITR0 : reference FuncTable what's declare */
N    ITR1,                                   /*!< ITR1 */
N    ITR2,                                   /*!< ITR2 */
N    ITR3,                                   /*!< ITR3 */
N    ITR4,                                   /*!< ITR4 */
N    ITR5,                                   /*!< ITR5 */
N    ITR6,                                   /*!< ITR6 */
N    ITR7                                    /*!< ITR7 */
N} TM_ITRSourceDef;
N
N/** 
N * @enum		TM_CounterModeDef
N * @brief		declare Timer main counter/prescaler mode  
N */        
Ntypedef enum 
N{ 
N    Cascade=0,                              /*!< 16/8-bit counter with 16/8-bit prescaler Mode (TM0x is 8bit)*/  
N    Separate,                               /*!< Separated two 16/8-bit counters Mode  (TM0x is 8bit)*/
N    Full_Counter                            /*!< 32/16-bit counter Mode  (TM0x is 16bit)*/
N} TM_CounterModeDef;
N
N/** 
N * @enum		TM_CounterResetGateSW_Def
N * @brief		select Reset or Gate action to main counter  
N */        
Ntypedef enum 
N{ 
N    ResetCounter=0x10,                      /*!< reset main counter by software */
N    GatingCounter=0x40                      /*!< gating main counter by software */
N} TM_CounterResetGateSW_Def;
N
N/** 
N * @enum		TM_PrescalerResetGateSW_Def
N * @brief		select Reset or Gate action to prescaler counter  
N */        
Ntypedef enum 
N{ 
N    ResetPrescaler=0x20,                    /*!< reset prescaler counter by software */        
N    GatingPrescaler=0x80                    /*!< reset prescaler counter by software */ 
N} TM_PrescalerResetGateSW_Def;
N
N
N/** 
N * @enum		TM_TRGITrgSourceDef
N * @brief		config TRGI source path  
N */        
Ntypedef enum 
N{ 
N    TRGI_ETR=0,                             /*!< TRGI from ETR */ 
N    TRGI_ITR,                               /*!< TRGI from ITR(0~7) - reference FuncTable */
N    TRGI_IN0,                               /*!< TRGI from IN0 */
N    TRGI_IN1                                /*!< TRGI from IN1 */
N} TM_TRGITrgSourceDef;
N
N/** 
N * @enum		TM_DirectionDef
N * @brief		declare Timer counting direction bit
N */        
Ntypedef enum 
N{ 
N    TM_UpCount=0,                           /*!< Up Counting */
N    TM_DownCount                            /*!< Down Counting */
N} TM_DirectionDef;
N
N/** 
N * @enum		TM_TRGIModeDef
N * @brief		(TRGI) Timer trigger input mode select
N */        
Ntypedef enum 
N{ 
N    TRGI_NoOP,                              /*!< No operation - default */
N    TRGI_StartupRising,                     /*!< startup counter when TRGI rising edge */
N    TRGI_ResetRising,                       /*!< reset counter when TRGI rising edge */
N    TRGI_GATE_High,                         /*!< gating counter when TRGI in high level */
N    TRGI_Rest_DualEdge,                     /*!< reset counter when TRGI rising or falling (dual) edge */
N    TRGI_StartupFalling,                    /*!< startup counter when TRGI falling edge */
N    TRGI_ResetFalling,                      /*!< reset counter when TRGI falling edge */
N    TRGI_GATE_Low                           /*!< gating counter when TRGI in low level */
N} TM_TRGIModeDef;
N
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
N/** 
N * @enum		TM_INTClockSrcDef
N * @brief		Timer input clock CK_TM36 source select.
N */        
Ntypedef enum 
N{ 
N    TM_PROC=0,                              /*!< CK_TMxx_PR process clock from CSC (CK_AHB/CK_APB) */
N    TM_CK_LS=2                              /*!< CK_LS from (XOSC/ILRCO/ECKI) */    
N} TM_INTClockSrcDef;
N#endif
N
N
N/** 
N * @enum		TM_UEVSrcDef
N * @brief		Timer input clock CK_TM36 source select.
N */        
Ntypedef enum 
N{ 
N    UEV_All,                                /*!< output all UEV pulses (overflow and underflow) */
N    UEV_TOF,                                /*!< output timer overflow pulses */    
N    UEV_UDF                                 /*!< output timer underflow pulses */    
N} TM_UEVSrcDef;
N
N/** 
N * @enum		TM_TRGOSrcDef
N * @brief		Timer trigger output mode select
N */    
Ntypedef enum 
N{ 
N    TRGO_RST,                               /*!< output TRGO from main counter's reset event */
N    TRGO_EN,                                /*!< output TRGO when main counter running state */    
N    TRGO_UEV,                               /*!< output TRGO when main counter has Update event */    
N    TRGO_TOF,                               /*!< output TRGO (TOF flag state) */    
N    TRGO_TUF,                               /*!< output TRGO (TUF flag state) */    
N    TRGO_EN2,                               /*!< output TRGO when prescaler counter running */      
N    TRGO_TOF2,                              /*!< output TRGO (TOF2 flag state) */    
N    TRGO_TMx_DIR,                           /*!< output TRGO (Main Timer direction event) */    
N    TRGO_UEV2,                              /*!< output TRGO when main counter has Update event */
N    TRGO_SW,                                /*!< output TRGO by sofware */     
N    TRGO_OS0,                               /*!< output TRGO (channel-0 output state) */    
N    TRGO_OS1,                               /*!< output TRGO (channel-1 output state) */    
N    TRGO_OS2,                               /*!< output TRGO (channel-2 output state) */    
N    TRGO_OS3,                               /*!< output TRGO (channel-3 output state) */    
N    TRGO_TRGI,                              /*!< output TRGI state */    
N    TRGO_POE                                /*!< output TRGO (preload signal) */    
N} TM_TRGOSrcDef;
N
N
N/** 
N * @enum		TM_ICxMuxDef
N * @brief		config channelx input source
N */    
Ntypedef enum 
N{ 
N    TMx_InputMUX_Pin,                       /*!< channel-n input trigger source from Pin */ 
N    TMx_InputMUX_ITR,                       /*!< channel-n input trigger source from ITR mux */ 
N    TMx_InputMUX_Line2,                     /*!< channel-n input trigger source from line2 */
N    TMx_InputMUX_Line3,                     /*!< channel-n input trigger source from line3 */
N} TM_ICxMuxDef;
N
N
N/** 
N * @enum		TM_ICxTrgDef
N * @brief		config ICx trigger event for capture data
N */    
Ntypedef enum 
N{
N    IC_Disable,                             /*!< disable capture data */
N    IC_RisingEdge,                          /*!< Rising edge capture data */
N    IC_FallingEdge,                         /*!< Falling edge capture data */
N    IC_DualEdge                             /*!< dual edge to capture data */
N} TM_ICxTrgDef;
N
N
N/** 
N * @enum		TM_CKOSrcDef
N * @brief		select Clock out source (Main or Prescaler counter)
N */    
Ntypedef enum 
N{
N    PrescalerCKO,                           /*!< Rising edge capture data */
N    MainCKO,                                /*!< disable capture data */
N} TM_CKOSrcDef;
N
N/** 
N * @enum		TM_BKExtSrcDef
N * @brief		Declare External Trigger source for Break function
N */    
Ntypedef enum 
N{
N    TMBK_ExtPin=0x01,                       /*!< TM36 Break External trigger pin */
N    TMBK_BOD1=0x02,                         /*!< TM36 Break External trigger event from BOD1 event */
N    TMBK_INTPB=0x04,                        /*!< TM36 Break External trigger event from INT_PB */
N    TMBK_ADC0OUT=0x08,                      /*!< TM36 Break External trigger event from ADC0_OUT (Window detect) */
N    TMBK_COMP0OUT=0x10,                     /*!< TM36 Break External trigger event from Comparator0 output */
N    TMBK_COMP1OUT=0x20,                     /*!< TM36 Break External trigger event from Comparator1 output */
N    TMBK_COMP2OUT=0x40,                     /*!< TM36 Break External trigger event from Comparator2 output */
N    TMBK_COMP3OUT=0x80,                     /*!< TM36 Break External trigger event from Comparator3 output */
N} TM_BKExtSrcDef;
N
N
N/** 
N * @enum		TM_BKIntSrcDef
N * @brief		Declare Internal Trigger source for Break function
N */    
Ntypedef enum 
N{
N    TMBK_ClockFailure=0x01,                 /*!< Clock failure event */
N    TMBK_CPULOCKUP=0x04,                    /*!< CPU LOCKUP */
N} TM_BKIntSrcDef;
N
N/** 
N * @enum		TM_BKModeDef
N * @brief		Declare Break mode
N */    
Ntypedef enum 
N{
N    TM_Latch,                               /*!< Break mode : Latch mode */
N    TM_CycleByCycle,                        /*!< Break mode : Cycke-by-Cycle mode */
N} TM_BKModeDef;
N
N/** 
N * @enum		TM_BKPinModeDef
N * @brief		select pin output mode when Break happended
N */    
Ntypedef enum 
N{
N    TM_BKStop,                              /*!< output Break Stop state (default) */
N    TM_BKHold,                              /*!< hold in current state  */
N} TM_BKPinModeDef;
N
N/** 
N * @enum		TM_PreloadEventSourceDef
N * @brief		Enable or Disable preload event source (XOR/INT_PB/INT_PD)
N */    
Ntypedef enum 
N{
N    TM_Preload_XOR=0x01,                    /*!< Preload event from XOR-gate */
N    TM_Preload_INT_PB=0x02,                 /*!< Preload event from INT_PB  */
N    TM_Preload_INT_PD=0x04,                 /*!< Preload event from INT_PD  */
N} TM_PreloadEventSourceDef;
N
N/** 
N * @enum		TM_OC0x3chDef
N * @brief		declare next output channel of OC0 when preload event happended
N */    
Ntypedef enum 
N{
N    TM_POC00=0x01,                          /*!< select OC00 */
N    TM_POC01=0x02,                          /*!< select OC01 */
N    TM_POC02=0x04,                          /*!< select OC02  */
N    TM_POC0_Disable=0x00,                   /*!< disable preload output */
N} TM_OC0x3chDef;
N
N
N/** 
N * @enum		TM_OC1x3chDef
N * @brief		declare next output channel of OC1 when preload event happended
N */    
Ntypedef enum 
N{
N    TM_POC10=0x10,                          /*!< select OC10 */
N    TM_POC11=0x20,                          /*!< select OC11 */
N    TM_POC12=0x40,                          /*!< select OC12 */
N    TM_POC1_Disable=0x00,                   /*!< disable preload output */
N} TM_OC1x3chDef;
N
N
N/** 
N * @enum		CHFMDef
N * @brief		declare function mode of channel x
N */    
Ntypedef enum 
N{
N    TM_NoOperation,                         /*!< No operation */
N    TM_InputCapture,                        /*!< 16 bit input capture */
N    TM_OutputCompare,                       /*!< 16 bit output compare */
N    TM_8bitx2OutputCompare,                 /*!< 8bitx2 output compare */
N    TM_16bitPWM,                            /*!< 16bit PWM */
N    TM_8bitx2PWM,                           /*!< 8bitx2 PWM */
N    TM_16bitPWMDTG,                         /*!< 16bit PWM with Dead Time control */
N    TM_8bitx2PWMDTG,                        /*!< 8bitx2 PWM with Dead Time control */
N} CHFMDef;
N
N/** 
N * @enum		ReloadTimeDef
N * @brief		Reload simultaneously to prevent glitch 
N */    
Ntypedef enum 
N{
N    TM_SimultaneouslyReload,                /*!< simultaneously reload from CCxB to CCxA when counter overflow */
N    TM_StopReload,                          /*!< stop reload from CCxB to CCxA when counter overflow */
N} ReloadTimeDef;
N
N/** 
N * @enum		OverWriteCmd
N * @brief		Overwrite or keep data 
N */    
Ntypedef enum 
N{
N    TM_OverWrite,                           /*!< Overwritten by new data */
N    TM_Keep,                                /*!< Preserved old data */
N} OverWriteCmd;
N
N/** 
N * @enum		AlignMode
N * @brief		Edge or Central align for PWM mode 
N */    
Ntypedef enum 
N{
N    TM_EdgeAlign,                           /*!< Edge Left Align */
N    TM_CenterAlign,                         /*!< Center-Align */
N} AlignMode;
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		TM_RCNTClockDef
S * @brief		Timer repetition counter clock source definition
S */    
Stypedef enum 
S{
S    TM_RCNT_CKMAIN,                         /*!< Clock input from Main timer overflow/underflow */
S    TM_RCNT_CKCKO,                          /*!< Clock input from CK_CKOM */
S} TM_RCNTClockDef;
N#endif
N
N
N
N/** 
N * @enum		EXUDMDSDef
N * @brief		QEI mode: special count mode - dpeend IN0/IN1 (please reference function table) 
N */    
Ntypedef enum 
N{
N    TM_NoEXUD,                              /*!< No operation (up/down control by TM36_DIR) */
N    TM_IN0POS,                              /*!< TMxx_IN0 positive (high level up count, low level down count) */
N    TM_IN0NEG,                              /*!< TMxx_IN0 negative (low level up count, high level down count) */
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S    TM_IN0TRG,                              /*!< TMxx_IN0 trigger (edge depending on TMxx_IN1 level) */
S    TM_IN1TRG,                              /*!< TMxx_IN1 trigger (edge depending on TMxx_IN0 level) */
N#endif                  
N    TM_BOTH,                                /*!< Both TMxx_IN0 and TM36_IN1 edge */
N} EXUDMDSDef;
N
N/** 
N * @enum		TM_QEIResetIndexDef
N * @brief		QEI mode: special count mode - dpeend IN0/IN1 (please reference function table) 
N */    
Ntypedef enum 
N{
N    TM_S1toS2,                              /*!< reset main counter between QEI state 1 and state 2 */
N    TM_S2toS3,                              /*!< reset main counter between QEI state 2 and state 3 */
N    TM_S3toS4,                              /*!< reset main counter between QEI state 3 and state 4 */
N    TM_S4toS1,                              /*!< reset main counter between QEI state 4 and state 1 */
N} TM_QEIResetIndexDef;
N
N
N
N/*! @struct TM_TimeBaseInitTypeDef
N    @brief  TM Time Base Init structure definition
N*/ 
Ntypedef struct {				
N    TM_CounterModeDef TM_CounterMode;	    /*!< Specifies the counter mode.  
N                                                This parameter can be a value of Cascade/Separate/Full_Counter */	
N
N    TM_DirectionDef TM_MainClockDirection;  /*!< Specifies the main clock count direction (TM_UpCount/TM_DownCount) */	
N
N    TM_DirectionDef TM_2ndClockDirection;   /*!< Specifies the 2nd clock count direction (TM_UpCount/TM_DownCount) */	
N
N    TM_ClockSourceDef TM_MainClockSource;   /*!< Specifies the main clock source.  
N                                                This parameter can be a value of TM_CK_INT or TM_CK_EXT */	
N
N    TM_ClockSourceDef TM_2ndClockSource;    /*!< Specifies the 2nd clock source.  
N                                                This parameter can be a value of TM_CK_INT or TM_CK_EXT */	
N
N    TM_INTClockDivDef TM_IntClockDivision;  /*!< Specifies the interrnal clock division. */
N	
N    uint16_t TM_Prescaler;			        /*!< Specifies the prescaler value used to divide the TM clock. 
N                                                This parameter can be a number between 0x0000 and 0xFFFF 
N											    PS: TM00 & TM01 only 8 bits (0x00~0xFF) */	
N
N    uint16_t TM_Period;			            /*!< Specifies the period value to be loaded into the active Auto-Reload
N                                                Register at the next update event.This parameter must be a number 
N                                                between 0x0000 and 0xFFFF.  
N											    PS: TM00 & TM01 only 8 bits (0x00~0xFF) */	
N
N} TM_TimeBaseInitTypeDef;				
N
N
N/** 
N * @enum		TM_ITSrc
N * @brief		TMx interrupt enable source  
N */    
Ntypedef enum 
N{
N#if defined(MG32_3RD)
X#if 0L
S    TMx_RTU_IE   =   TM_INT_RTU_IE_enable_w, /*!< Repetition timer underflow interrupt enable. */
N#endif
N    TMx_QPE_IE  =   TM_INT_QPE_IE_enable_w, /*!< Main Timer QEI phase state transition error detect interrupt enable. */
X    TMx_QPE_IE  =   ((uint32_t)0x00080000),  
N    TMx_IDX_IE  =   TM_INT_IDX_IE_enable_w, /*!< Main Timer QEI external index signal input active detect interrupt enable. */
X    TMx_IDX_IE  =   ((uint32_t)0x00040000),  
N    TMx_DIRC_IE =   TM_INT_DIRC_IE_enable_w,/*!< Main Timer up/down counting direction change interrupt enable . */
X    TMx_DIRC_IE =   ((uint32_t)0x00010000), 
N    TMx_CC3_IE  =   TM_INT_CC3_IE_enable_w, /*!< Timer IC3/OC3 interrupt enable. */
X    TMx_CC3_IE  =   ((uint32_t)0x00000800),  
N    TMx_CC2_IE  =   TM_INT_CC2_IE_enable_w, /*!< Timer IC2/OC2 interrupt enable. */
X    TMx_CC2_IE  =   ((uint32_t)0x00000400),  
N    TMx_CC1_IE  =   TM_INT_CC1_IE_enable_w, /*!< Timer IC1/OC1 interrupt enable. */
X    TMx_CC1_IE  =   ((uint32_t)0x00000200),  
N    TMx_CC0_IE  =   TM_INT_CC0_IE_enable_w, /*!< Timer IC0/OC0 interrupt enable. */
X    TMx_CC0_IE  =   ((uint32_t)0x00000100),  
N    TMx_TIE2_IE =   TM_INT_TIE2_enable_w,   /*!< 2nd Timer overflow/underflow interrupt enable. */
X    TMx_TIE2_IE =   ((uint32_t)0x00000020),    
N    TMx_TIE_IE  =   TM_INT_TIE_enable_w,    /*!< Timer overflow/underflow interrupt enable. */
X    TMx_TIE_IE  =   ((uint32_t)0x00000010),     
N    TMx_EXIE    =   TM_INT_EXIE_enable_w,   /*!< Timer external trigger interrupt enable. */
X    TMx_EXIE    =   ((uint32_t)0x00000008),    
N    TMx_BKIE    =   TM_INT_BKIE_enable_w,   /*!< Timer break input interrupt enable. */
X    TMx_BKIE    =   ((uint32_t)0x00000004),    
N    TMx_IEA     =   TM_INT_IEA_enable_w,    /*!< Timer interrupt all enable. When disables, 
X    TMx_IEA     =   ((uint32_t)0x00000001),    
N                                                 the timer global all interrupt event are disabled. */
N} TM_ITSrc;
N
N
N/** 
N * @enum		TM_ITSTAFlag
N * @brief		TMx status flag 
N */    
Ntypedef enum 
N{
N#if defined(MG32_3RD)
X#if 0L
S    TMx_RTUF    =   TM_STA_RTUF_happened_w, /*!< Repetition timer underflow flag. */
N#endif
N    TMx_QPEF    =   TM_STA_QPEF_happened_w, /*!< Main Timer QEI phase state transition error detect flag. */
X    TMx_QPEF    =   ((uint32_t)0x00080000),  
N    TMx_IDXF    =   TM_STA_IDXF_happened_w, /*!< Main Timer QEI external index signal input active detect. */
X    TMx_IDXF    =   ((uint32_t)0x00040000),  
N    TMx_DIRCF   =   TM_STA_DIRCF_happened_w,/*!< Main Timer up/down counting direction change flag. */
X    TMx_DIRCF   =   ((uint32_t)0x00010000), 
N    TMx_CF3B    =   TM_STA_CF3B_happened_w, /*!< Timer IC3 falling edge flag/OC3 event sub flag. */
X    TMx_CF3B    =   ((uint32_t)0x00008000),  
N    TMx_CF2B    =   TM_STA_CF2B_happened_w, /*!< Timer IC2 falling edge flag/OC2 event sub flag. */
X    TMx_CF2B    =   ((uint32_t)0x00004000),  
N    TMx_CF1B    =   TM_STA_CF1B_happened_w, /*!< Timer IC1 falling edge flag/OC1 event sub flag. */
X    TMx_CF1B    =   ((uint32_t)0x00002000),  
N    TMx_CF0B    =   TM_STA_CF0B_happened_w, /*!< Timer IC0 falling edge flag/OC0 event sub flag. */
X    TMx_CF0B    =   ((uint32_t)0x00001000),  
N    TMx_CF3A    =   TM_STA_CF3A_happened_w, /*!< Timer IC3 rising edge flag/OC3 event main flag. */
X    TMx_CF3A    =   ((uint32_t)0x00000800),  
N    TMx_CF2A    =   TM_STA_CF2A_happened_w, /*!< Timer IC2 rising edge flag/OC2 event main flag. */
X    TMx_CF2A    =   ((uint32_t)0x00000400),  
N    TMx_CF1A    =   TM_STA_CF1A_happened_w, /*!< Timer IC1 rising edge flag/OC1 event main flag. */
X    TMx_CF1A    =   ((uint32_t)0x00000200),  
N    TMx_CF0A    =   TM_STA_CF0A_happened_w, /*!< Timer IC0 rising edge flag/OC0 event main flag. */
X    TMx_CF0A    =   ((uint32_t)0x00000100),  
N    TMx_TUF2    =   TM_STA_TUF2_happened_w, /*!< 2nd Timer underflow flag. */
X    TMx_TUF2    =   ((uint32_t)0x00000080),  
N    TMx_TUF     =   TM_STA_TUF_happened_w,  /*!< Main Timer underflow flag. */
X    TMx_TUF     =   ((uint32_t)0x00000040),   
N    TMx_TOF2    =   TM_STA_TOF2_happened_w, /*!< 2nd Timer overflow flag. */
X    TMx_TOF2    =   ((uint32_t)0x00000020),  
N    TMx_TOF     =   TM_STA_TOF_happened_w,  /*!< Main Timer overflow flag. */
X    TMx_TOF     =   ((uint32_t)0x00000010),   
N    TMx_EXF     =   TM_STA_EXF_happened_w,  /*!< Timer external trigger flag. */
X    TMx_EXF     =   ((uint32_t)0x00000008),   
N    TMx_BKF     =   TM_STA_BKF_happened_w,  /*!< Timer break input flag. */
X    TMx_BKF     =   ((uint32_t)0x00000004),   
N    TMx_DIRF    =   TM_STA_DIRF_down_counting_w,    /*!< Main Timer up/down counting flag. */
X    TMx_DIRF    =   ((uint32_t)0x00000001),     
N} TM_ITSTAFlag;
N
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
N/** 
N * @enum		DMA_TMChannelSrc
N * @brief		DMA access TM channel 0/1/2 (Compare/PWM) or channel3 (Input Capture) 
N */    
Ntypedef enum 
N{
N    TMx_DMA_IC3 =   TM_CCMDS_DMA_CC3E_enable_w, /*!< Direct memory access enable for IC3 */
X    TMx_DMA_IC3 =   ((uint32_t)0x08000000),  
N    TMx_DMA_OC2 =   TM_CCMDS_DMA_CC2E_enable_w, /*!< Direct memory access enable for OC2 */
X    TMx_DMA_OC2 =   ((uint32_t)0x04000000),  
N    TMx_DMA_OC1 =   TM_CCMDS_DMA_CC1E_enable_w, /*!< Direct memory access enable for OC1 */
X    TMx_DMA_OC1 =   ((uint32_t)0x02000000),  
N    TMx_DMA_OC0 =   TM_CCMDS_DMA_CC0E_enable_w, /*!< Direct memory access enable for OC0 */
X    TMx_DMA_OC0 =   ((uint32_t)0x01000000),  
N} DMA_TMChannelSrc;
N#endif
N
N
N
N
N
N/** 
N * @enum		DMA_UpdateEventSel
N * @brief		Config DMA request of TMx 
N */    
Ntypedef enum 
N{
N    TM_UpdateEvent_TOF,                     /*!< DMA request is asserted at TOF active */
N    TM_Update_TOF_ITR,                      /*!< DMA request is asserted at both TOF active and ITR input signal */
N} DMA_UpdateEventSel;
N
N
N
N									 
N									 
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N
N///@{
Nvoid TM_DeInit(TM_Struct *TMx);
N///@}
N
N///@{
Nvoid TM_TimeBaseStruct_Init(TM_TimeBaseInitTypeDef *TM_TMBaseInitStruct);
Nvoid TM_TimeBase_Init(TM_Struct *TMx, TM_TimeBaseInitTypeDef *TM_TMBaseInitStruct);
N///@}
N
N///@{
Nvoid TM_InternalClockSource_Select(TM_Struct* TMx, TM_INTClockSrcDef INTClockSrc);
Nvoid TM_SetInternalClockDivider(TM_Struct* TMx, TM_INTClockDivDef INTClockSrc);
Nvoid TM_CounterClock_Select(TM_Struct* TMx, TM_ClockSourceDef TMClockSelect);
Nvoid TM_PrescalerClock_Select(TM_Struct* TMx, TM_ClockSourceDef TMClockSelect);
Nvoid TM_ExternalClock_Select(TM_Struct* TMx, TM_ExternalClockSourceDef TMExtClockSelect);
Nvoid TM_ITRx_Select(TM_Struct* TMx, TM_ITRSourceDef TM_ITRSource);
N///@}
N
N///@{
Nvoid TM_TimerMode_Select(TM_Struct* TMx, TM_CounterModeDef TM_TimerMode);
N///@}
N
N///@{
Nvoid TM_SetCounterDirection(TM_Struct* TMx, TM_DirectionDef DIR);
Nuint16_t TM_GetCounter(TM_Struct* TMx);
Nvoid TM_Counter_Config(TM_Struct* TMx, uint16_t TM_Counter, uint16_t TM_CounterReload);
Nvoid TM_Counter_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_Counter_SW(TM_Struct* TMx, TM_CounterResetGateSW_Def CMode, FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_SetPrescalerDirection(TM_Struct* TMx, TM_DirectionDef DIR);
Nuint16_t TM_GetPrescaler(TM_Struct* TMx);
Nvoid TM_Prescaler_Config(TM_Struct* TMx, uint16_t TM_Prescaler, uint16_t TM_PrescalerReload);
Nvoid TM_Prescaler_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_Prescaler_SW(TM_Struct* TMx, TM_PrescalerResetGateSW_Def CMode, FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_Timer_Cmd(TM_Struct* TMx, FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_GatePrescaler_SW(TM_Struct* TMx,FunctionalState NewState);
Nvoid TM_GateCounter_SW(TM_Struct* TMx,FunctionalState NewState);
Nvoid TM_ResetPrescaler_SW(TM_Struct* TMx,FunctionalState NewState);
Nvoid TM_ResetCounter_SW(TM_Struct* TMx,FunctionalState NewState);
Nvoid TM_TriggerSource_Select(TM_Struct* TMx, TM_TRGITrgSourceDef TRGISel);
Nvoid TM_TRGICounter_Select(TM_Struct* TMx, TM_TRGIModeDef TRGIMDS);
Nvoid TM_TRGIPrescaler_Select(TM_Struct* TMx, TM_TRGIModeDef TRGIMDS);
Nvoid TM_UEV_Config(TM_Struct* TMx, TM_UEVSrcDef UEVCon);
Nvoid TM_TRGOOut_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_TRGO_Select(TM_Struct* TMx, TM_TRGOSrcDef TM_TRGOCon );
Nvoid TM_InverseTRGO_Cmd(TM_Struct* TMx, FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_IN0Source_Select(TM_Struct* TMx, TM_ICxMuxDef TM_ICxSrc);
Nvoid TM_IN0TriggerEvent_Select(TM_Struct* TMx, TM_ICxTrgDef TM_ICxTrg);
Nvoid TM_IN1Source_Select(TM_Struct* TMx, TM_ICxMuxDef TM_ICxSrc);
Nvoid TM_IN1TriggerEvent_Select(TM_Struct* TMx, TM_ICxTrgDef TM_ICxTrg);
Nvoid TM_IN2Source_Select(TM_Struct* TMx, TM_ICxMuxDef TM_ICxSrc);
Nvoid TM_IN2TriggerEvent_Select(TM_Struct* TMx, TM_ICxTrgDef TM_ICxTrg);
Nvoid TM_IN3Source_Select(TM_Struct* TMx, TM_ICxMuxDef TM_ICxSrc);
Nvoid TM_IN3TriggerEvent_Select(TM_Struct* TMx, TM_ICxTrgDef TM_ICxTrg);
N///@}
N
N///@{
Nvoid TM_ClockOutSource_Select(TM_Struct* TMx, TM_CKOSrcDef TM_CKOSel);
Nvoid TM_ClockOut_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_CKOOutputState_Init(TM_Struct* TMx, BitAction PinState);
N///@}
N
N///@{
Nvoid TM_InverseOC0z_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC0zOutputState_Init(TM_Struct* TMx, BitAction PinState);
Nvoid TM_OC0zBreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_OC0zOutput_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC00Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC01Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC02Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_InverseOC0N_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC0NOutput_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC0NBreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_InverseOC0H_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC0HOutputState_Init(TM_Struct* TMx, BitAction PinState);
N///@}
N
N///@{
Nvoid TM_InverseOC1z_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC1zOutputState_Init(TM_Struct* TMx, BitAction PinState);
Nvoid TM_OC1zBreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_OC1zOutput_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC10Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC11Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC12Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_InverseOC1N_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC1NOutput_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC1NBreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_InverseOC1H_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC1HOutputState_Init(TM_Struct* TMx, BitAction PinState);
N///@}
N
N///@{
Nvoid TM_InverseOC2_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC2OutputState_Init(TM_Struct* TMx, BitAction PinState);
Nvoid TM_OC2BreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_OC2Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_InverseOC2N_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC2NOutput_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC2NBreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_InverseOC2H_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC2HOutputState_Init(TM_Struct* TMx, BitAction PinState);
N///@}
N
N///@{
Nvoid TM_InverseOC3_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC3OutputState_Init(TM_Struct* TMx, BitAction PinState);
Nvoid TM_OC3BreakStopState_Init(TM_Struct* TMx, BitAction BKPinState);
Nvoid TM_OC3Output_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_InverseOC3H_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_OC3HOutputState_Init(TM_Struct* TMx, BitAction PinState);
N///@}
N
N///@{
Nvoid TM_ExternalBreakEvent_Config(TM_Struct* TMx, TM_BKExtSrcDef BKSrc, FunctionalState NewState);
Nvoid TM_InternalBreakEvent_Config(TM_Struct* TMx, TM_BKIntSrcDef BKSrc, FunctionalState NewState);
Nvoid TM_BreakTrigger_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_BreakCH3_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_BreakCH012_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_BreakMode_Select(TM_Struct* TMx, TM_BKModeDef BKMode);
Nvoid TM_OC0BreakControl_Select(TM_Struct* TMx, TM_BKPinModeDef BKPinMode);
Nvoid TM_OC1BreakControl_Select(TM_Struct* TMx, TM_BKPinModeDef BKPinMode);
Nvoid TM_OC2BreakControl_Select(TM_Struct* TMx, TM_BKPinModeDef BKPinMode);
Nvoid TM_OC3BreakControl_Select(TM_Struct* TMx, TM_BKPinModeDef BKPinMode);
N///@}
N
N///@{
Nvoid TM_PreloadEventSource_Config(TM_Struct* TMx, uint8_t PreLoad, FunctionalState NewState);
Nvoid TM_PreloadActive_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_PreloadOC0z_Config(TM_Struct* TMx, uint8_t TM_OC0z3ch);
Nvoid TM_PreloadOC1z_Config(TM_Struct* TMx, uint8_t TM_OC1z3ch);
N///@}
N
N///@{
Nvoid TM_CH0Function_Config(TM_Struct* TMx, CHFMDef CHFuncMds);
Nvoid TM_CH1Function_Config(TM_Struct* TMx, CHFMDef CHFuncMds);
Nvoid TM_CH2Function_Config(TM_Struct* TMx, CHFMDef CHFuncMds);
Nvoid TM_CH3Function_Config(TM_Struct* TMx, CHFMDef CHFuncMds);
N///@}
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S///@{
S    void TM_OutputDelayMode_Cmd(TM_Struct* TMx, FunctionalState NewState);
S///@}
N#endif
N
N///@{
Nuint32_t TM_GetIC0Value(TM_Struct* TMx);
Nuint32_t TM_GetIC1Value(TM_Struct* TMx);
Nuint32_t TM_GetIC2Value(TM_Struct* TMx);
Nuint32_t TM_GetIC3Value(TM_Struct* TMx);
N///@}
N
N///@{
Nvoid TM_IC0OverWritten_Cmd(TM_Struct* TMx, OverWriteCmd NewState);
Nvoid TM_IC1OverWritten_Cmd(TM_Struct* TMx, OverWriteCmd NewState);
Nvoid TM_IC2OverWritten_Cmd(TM_Struct* TMx, OverWriteCmd NewState);
Nvoid TM_IC3OverWritten_Cmd(TM_Struct* TMx, OverWriteCmd NewState);
N///@}
N
N///@{
Nvoid TM_RisingCaptureIC0_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_RisingCaptureIC1_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_RisingCaptureIC2_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_RisingCaptureIC3_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_FallingCaptureIC0_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_FallingCaptureIC1_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_FallingCaptureIC2_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_FallingCaptureIC3_SW(TM_Struct* TMx, FunctionalState NewState);
N///@}
N
N///@{
Nuint16_t TM_GetCC0A(TM_Struct* TMx);
Nuint16_t TM_GetCC1A(TM_Struct* TMx);
Nuint16_t TM_GetCC2A(TM_Struct* TMx);
Nuint16_t TM_GetCC3A(TM_Struct* TMx);
Nuint16_t TM_GetCC0B(TM_Struct* TMx);
Nuint16_t TM_GetCC1B(TM_Struct* TMx);
Nuint16_t TM_GetCC2B(TM_Struct* TMx);
Nuint16_t TM_GetCC3B(TM_Struct* TMx);
N///@}
N
N///@{
Nvoid TM_SetCC0A(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC1A(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC2A(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC3A(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC0B(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC1B(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC2B(TM_Struct* TMx,uint16_t HfWDat);
Nvoid TM_SetCC3B(TM_Struct* TMx,uint16_t HfWDat);
N///@}
N
N///@{
Nvoid TM_GenerateCF0A_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF1A_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF2A_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF3A_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF0B_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF1B_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF2B_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_GenerateCF3B_SW(TM_Struct* TMx, FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_ReloadFromCCxB_Cmd(TM_Struct* TMx, ReloadTimeDef NewState);
N///@}
N
N///@{
Nvoid TM_AlignmentMode_Select(TM_Struct* TMx, AlignMode AMode);
N///@}
N
N///@{
Nvoid TM_QEI_Select(TM_Struct* TMx, EXUDMDSDef EXUDMds);
Nvoid TM_QEIReset_Cmd(TM_Struct* TMx,FunctionalState NewState);
Nvoid TM_QEIResetIDX_Select(TM_Struct* TMx,TM_QEIResetIndexDef TM_IDXSel);
Nvoid TM_InverseQEIDirection(TM_Struct* TMx,FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_AutoStop_Cmd(TM_Struct* TMx, FunctionalState NewState);
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S    void TM_RepeatAutoStopMode_Cmd(TM_Struct* TMx, FunctionalState NewState);
N#endif
N#if defined(MG32_3RD)
X#if 0L
S    void TM_RepetitionCounter_Cmd(TM_Struct* TMx, FunctionalState NewState);
S    void TM_ControlPWM_Cmd(TM_Struct* TMx, FunctionalState NewState);
S    void TM_RepetitionCounter_Config(TM_Struct* TMx, uint8_t TM_RCounter, uint8_t TM_RCounterReload);
S    void TM_RepetitionCounterClock_Select(TM_Struct* TMx, TM_RCNTClockDef RCNTClockSrc);
N#endif
N///@}
N
N///@{
Nvoid TM_SetDeadZoneClockDivider(TM_Struct* TMx, TM_DTClockDivDef DTClockDiv);
Nvoid TM_SetDeadTime(TM_Struct* TMx, uint8_t DTTime);
N///@}
N
N
N///@{
Nvoid TM_IT_Config(TM_Struct* TMx, uint32_t TM_ITSrc, FunctionalState NewState);
Nvoid TM_ITEA_Cmd(TM_Struct* TMx, FunctionalState NewState);
NDRV_Return TM_GetSingleFlagStatus(TM_Struct* TMx, uint32_t TM_ITSTAFlag);
Nuint32_t TM_GetAllFlagStatus(TM_Struct* TMx);
Nvoid TM_ClearFlag(TM_Struct* TMx, uint32_t TM_ITSrc);
N///@}
N
N///@{
Nvoid TM_ExtTRGI_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_InverseExtTRGI_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_ExtTRGI2UEV_Cmd(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_ForceUpdate_SW(TM_Struct* TMx, FunctionalState NewState);
Nvoid TM_UEV_Cmd(TM_Struct* TMx, FunctionalState NewState);
N///@}
N
N///@{
Nvoid TM_DMAChannel_Cmd(TM_Struct* TMx, uint32_t DMA_TMChannelSrc, FunctionalState NewState);
Nvoid TM_DMAUpdateMode_Select(TM_Struct* TMx, DMA_UpdateEventSel TM_UpdateEvent);
N///@}
N
N#endif
N
N
L 53 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_URT_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_URT_DRV.h" 1
N
N
N
N
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_URT_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the URT
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.16
N * @date        2021/04/21
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */
N 
N#ifndef _MG32x02z_URT_DRV_H
N 
N#define _MG32x02z_URT_DRV_H
N 
N#include "MG32x02z.h" 
N#include "MG32x02z__Common_DRV.h" 
N#include "MG32x02z_URT.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_URT.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_URT.h
N *
N * @brief       MG32x02z URT Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_URT_H
N#define _MG32x02z_URT_H
N#define _MG32x02z_URT_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_URT_H_VER)
S    #error "MG32x02z_URT_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      URT_Struct
N *              URT  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  RHF           :1;     //[0] UART receive hold flag
X            volatile uint8_t  RHF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  UGF           :1;     //[1] UART general event flag
X            volatile uint8_t  UGF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TCF           :1;     //[2] UART transmission complete flag
X            volatile uint8_t  TCF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  ERRF          :1;     //[3] UART error interrupt flag for parity error, frame error, overrun error, receive time 
X            volatile uint8_t  ERRF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  LSF           :1;     //[4] UART line statue flag for break condition, idle line, CTS detect
X            volatile uint8_t  LSF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  RXDF          :1;     //[5] UART received data byte number is different from previous received data byte number f
X            volatile const  uint8_t  RXDF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  RXF           :1;     //[6] UART receive data register not empty
X            volatile uint8_t  RXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TXF           :1;     //[7] UART transmit data register empty
X            volatile uint8_t  TXF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SADRF         :1;     //[10] UART slave address matched flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  SADRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  BRTF          :1;     //[11] UART baud-rate generator timer timeout flag
X            volatile uint8_t  BRTF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TMOF          :1;     //[12] UART timeout timer timeout flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TMOF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CALCF         :1;     //[13] UART auto baud-rate calibration complete flag
X            volatile uint8_t  CALCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BKF           :1;     //[16] UART break condition detect flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  BKF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  IDLF          :1;     //[17] UART idle line detect flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  IDLF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CTSF          :1;     //[18] UART CTS change detect interrupt flag
X            volatile uint8_t  CTSF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PEF           :1;     //[20] UART parity error flag
X            volatile uint8_t  PEF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  FEF           :1;     //[21] UART frame error flag.  (set by hardware and clear by software writing 1)
X            volatile uint8_t  FEF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  NCEF          :1;     //[22] UART receive noised character error flag
X            volatile uint8_t  NCEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  ROVRF         :1;     //[23] UART receive overrun error flag
X            volatile uint8_t  ROVRF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TXEF          :1;     //[24] UART TX error detect flag
X            volatile uint8_t  TXEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[26..25] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  RXTMOF        :1;     //[27] UART receive time out flag.  (set by hardware and clear by software writing 1)
X            volatile uint8_t  RXTMOF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  IDTMOF        :1;     //[28] UART idle state time out flag.  (set by hardware and clear by software writing 1)
X            volatile uint8_t  IDTMOF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  BKTMOF        :1;     //[29] UART break receive time out flag.  (set by hardware and clear by software writing 1)
X            volatile uint8_t  BKTMOF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  CALTMOF       :1;     //[30] UART auto baud-rate calibration sync field receive time-out time out flag
X            volatile uint8_t  CALTMOF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  URT status register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] UART interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  UG_IE         :1;     //[1] UART general event interrupt enable for URTx_SADRF , URTx_TF , URTx_RCNTF or URTx_TCN
X            volatile uint8_t  UG_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TC_IE         :1;     //[2] UART transmission complete interrupt enable
X            volatile uint8_t  TC_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ERR_IE        :1;     //[3] UART error interrupt enable for parity error, frame error, overrun error, receive tim
X            volatile uint8_t  ERR_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LS_IE         :1;     //[4] UART line statue flag for break condition, idle line, CTS detect.
X            volatile uint8_t  LS_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RX_IE         :1;     //[6] UART receive data register not empty interrupt enable
X            volatile uint8_t  RX_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TX_IE         :1;     //[7] UART transmit data register empty interrupt enable. Refer to URTx_TXF for the detail.
X            volatile uint8_t  TX_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SADR_IE       :1;     //[10] UART slave address matched interrupt enable.
X            volatile uint8_t  SADR_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BRT_IE        :1;     //[11] UART baud-rate generator timer timeout interrupt enable.
X            volatile uint8_t  BRT_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TMO_IE        :1;     //[12] UART timeout timer timeout interrupt enable.
X            volatile uint8_t  TMO_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CALC_IE       :1;     //[13] UART auto baud-rate calibration complete interrupt enable.
X            volatile uint8_t  CALC_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BK_IE         :1;     //[16] UART break condition detect interrupt enable.
X            volatile uint8_t  BK_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IDL_IE        :1;     //[17] UART idle line detect interrupt enable.
X            volatile uint8_t  IDL_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CTS_IE        :1;     //[18] UART CTS change detect interrupt enable.
X            volatile uint8_t  CTS_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PE_IE         :1;     //[20] UART parity error interrupt enable.
X            volatile uint8_t  PE_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  FE_IE         :1;     //[21] UART frame error interrupt enable.
X            volatile uint8_t  FE_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NCE_IE        :1;     //[22] UART receive noised character interrupt enable. 
X            volatile uint8_t  NCE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ROVR_IE       :1;     //[23] UART receive overrun error interrupt enable. Refer to URTx_ROVRF for the detail.
X            volatile uint8_t  ROVR_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TXE_IE        :1;     //[24] UART TX error detect interrupt enable. Refer to URTx_TXE_MDS for detail.
X            volatile uint8_t  TXE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[26..25] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  RXTMO_IE      :1;     //[27] UART receive time out interrupt enable.
X            volatile uint8_t  RXTMO_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  IDTMO_IE      :1;     //[28] UART idle state time out interrupt enable.
X            volatile uint8_t  IDTMO_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKTMO_IE      :1;     //[29] UART break receive time out interrupt enable.
X            volatile uint8_t  BKTMO_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CALTMO_IE     :1;     //[30] UART auto baud-rate calibration sync field receive time-out time out interrupt enable
X            volatile uint8_t  CALTMO_IE     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  URT interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CK_SEL        :3;     //[3..1] UART internal clock CK_UART source select.
X            volatile uint8_t  CK_SEL        :3;     
N                                        //0x0 = PROC : CK_URTx_PR process clock from CSC
N                                        //0x1 = Reserved (PROC)
N                                        //0x2 = CK_LS
N                                        //0x3 = TM00_TRGO
N                                        //0x4 = Reserved (PROC)
N            __IO uint8_t  CLK_EN        :1;     //[4] URTx_CLK signal output enable.
X            volatile uint8_t  CLK_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CLK_CKS       :1;     //[5] UART external clock output source select.
X            volatile uint8_t  CLK_CKS       :1;     
N                                        //0 = OUT : CK_URTx_OUT from clock output divider
N                                        //1 = SC : CK_URTx_SC from clock  input prescaler
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  RX_CKS        :2;     //[17..16] UART receive clock source select.
X            volatile uint8_t  RX_CKS        :2;     
N                                        //0x0 = Internal : UART internal clock source CK_URTx_INT
N                                        //0x1 = TM01_TRGO
N                                        //0x2 = TM10_TRGO
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  TX_CKS        :2;     //[21..20] UART transmission clock source select.
X            volatile uint8_t  TX_CKS        :2;     
N                                        //0x0 = Internal : UART internal clock source CK_URTx_INT
N                                        //0x1 = TM01_TRGO
N                                        //0x2 = TM10_TRGO
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BR_EN         :1;     //[24] UART baud-rate timer enable. When enables, the baud-rate timer 
X            volatile uint8_t  BR_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BR_MDS        :1;     //[25] UART baud-rate timer mode select
X            volatile uint8_t  BR_MDS        :1;     
N                                        //0 = Separated : Separated PSC and CNT counters for UART baud-rate generator
N                                        //1 = Combined : Combine to a linear counter for general using timer
N            __IO uint8_t  BRO_STA       :1;     //[26] UART baud-rate timer timeout signal initial state
X            volatile uint8_t  BRO_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  BRO_LCK       :1;     //[27] UART baud-rate timer timeout signal initial state control
X            volatile uint8_t  BRO_LCK       :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __IO uint8_t  CKO_STA       :1;     //[28] UART PSC clock output signal initial state
X            volatile uint8_t  CKO_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  CKO_LCK       :1;     //[29] UART PSC clock output signal initial state control
X            volatile uint8_t  CKO_LCK       :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  URT clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  BUSYF         :1;     //[0] UART RX busy flag
X            volatile const  uint8_t  BUSYF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Busy (Event happened)
N            __I  uint8_t  PAR           :1;     //[1] UART data receive parity bit of shift buffer
X            volatile const  uint8_t  PAR           :1;     
N            __I  uint8_t  ADR           :1;     //[2] UART data receive slave address bit of shift buffer.
X            volatile const  uint8_t  ADR           :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  NCF           :1;     //[5] UART receive noised character flag.  (set and clear by hardware)
X            volatile const  uint8_t  NCF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t  BKBF          :1;     //[6] UART send break busy flag.  (set and clear by hardware)
X            volatile const  uint8_t  BKBF          :1;     
N                                        //0 = Normal (No break transmitted or transmit finished)
N                                        //1 = Busy (Event happened)
N            __I  uint8_t  IR_BUSYF      :1;     //[7] UART IrDA data received busy flag. 
X            volatile const  uint8_t  IR_BUSYF      :1;     
N                                        //0 = No (No IrDA signal detect)
N                                        //1 = Busy (detect some IrDA signal)
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  CTS           :1;     //[12] UART CTS line status bit
X            volatile const  uint8_t  CTS           :1;     
N            __I  uint8_t                :1;     //[13] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  RX_LVL        :3;     //[26..24] UART data buffer received level indications.
X            volatile const  uint8_t  RX_LVL        :3;     
N                                        //0x0 = 0 (0-byte,empty)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :1;     //[27] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  TX_LVL        :3;     //[30..28] UART data buffer transmission remained level indications.
X            volatile const  uint8_t  TX_LVL        :3;     
N                                        //0x0 = 0 (0-byte,empty)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }STA2;                              /*!< STA2       ~ Offset[0x0C]  URT status register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] UART function enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  OS_MDS        :1;     //[1] UART RX data oversampling majority vote select.
X            volatile uint8_t  OS_MDS        :1;     
N                                        //0 = Three : Three sample bits method
N                                        //1 = One : One sample bit method and noise free
N            __IO uint8_t  HDX_EN        :1;     //[2] UART Half-duplex mode enable
X            volatile uint8_t  HDX_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DAT_LINE      :1;     //[3] UART communication data line select.
X            volatile uint8_t  DAT_LINE      :1;     
N                                        //0 = 2 : 2-lines separated ~ URTx_RX , URTx_TX
N                                        //1 = 1 : 1-line Bidirectional ~URTx_TX only.
N            __IO uint8_t  MDS           :3;     //[6..4] UART mode select
X            volatile uint8_t  MDS           :3;     
N                                        //0x0 = UART : UART mode
N                                        //0x1 = SYNC : Synchronous/Shift-Register mode
N                                        //0x2 = IDLE : Idle-line mode for multi-processor
N                                        //0x3 = ADR : Address-bit mode for multi-processor
N            __IO uint8_t  GSA_EN        :1;     //[7] UART multi-processor global slave address enable.
X            volatile uint8_t  GSA_EN        :1;     
N            __IO uint8_t  IO_SWP        :1;     //[8] URTx_RX/URTx_TX swap enable bit.
X            volatile uint8_t  IO_SWP        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RX_INV        :1;     //[10] URTx_RX input signal inverse enable.
X            volatile uint8_t  RX_INV        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TX_INV        :1;     //[11] URTx_TX output signal inverse enable.
X            volatile uint8_t  TX_INV        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DE_EN         :1;     //[12] URTx_DE signal output enable.
X            volatile uint8_t  DE_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DE_INV        :1;     //[13] URTx_DE signal inverse enable. The hardware DE output default is low level.
X            volatile uint8_t  DE_INV        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DE_GT         :2;     //[15..14] URTx_DE signal output guard time select by unit of bit time
X            volatile uint8_t  DE_GT         :2;     
N                                        //0x0 = 1/4
N                                        //0x1 = 1/2
N                                        //0x2 = 1
N                                        //0x3 = 2
N            __IO uint8_t  RX_TH         :2;     //[17..16] UART data buffer high threshold for received access
X            volatile uint8_t  RX_TH         :2;     
N                                        //0x0 = 1byte (default)
N                                        //0x1 = 2byte
N                                        //0x2 = 3byte
N                                        //0x3 = 4byte
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  IDL_MDS       :1;     //[20] UART idle line detect management mode select
X            volatile uint8_t  IDL_MDS       :1;     
N                                        //0 = No (No operation)
N                                        //1 = Load (Force to load shadow buffer)
N            __IO uint8_t  NCHAR_HE      :1;     //[21] UART receiving hold enable bit if receives a noised character
X            volatile uint8_t  NCHAR_HE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NCHAR_DIS     :1;     //[22] UART receiving noised character disable bit
X            volatile uint8_t  NCHAR_DIS     :1;     
N                                        //0 = Enable (Accept noised character)
N                                        //1 = Disable (Skip noised character)
N            __IO uint8_t  LBM_EN        :1;     //[23] UART Loop back mode enable bit
X            volatile uint8_t  LBM_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[28..25] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DDTX_EN       :1;     //[29] Hardware force to disable DMA TX function enable bit when detects a break condition
X            volatile uint8_t  DDTX_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_RXEN      :1;     //[30] Direct memory access enable to receive
X            volatile uint8_t  DMA_RXEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  DMA_TXEN      :1;     //[31] Direct memory access enable to transmit
X            volatile uint8_t  DMA_TXEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  URT control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  RXDSIZE       :2;     //[1..0] UART RX data bit length
X            volatile uint8_t  RXDSIZE       :2;     
N                                        //0x0 = 8bit
N                                        //0x1 = 7bit
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __IO uint8_t  RXPAR_EN      :1;     //[2] UART RX parity bit enable
X            volatile uint8_t  RXPAR_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RXPAR_POL     :1;     //[3] UART RX parity bit polarity. This bit is no effect for SYNC mods.
X            volatile uint8_t  RXPAR_POL     :1;     
N                                        //0x0 = Even
N                                        //0x1 = Odd
N            __IO uint8_t  RXPAR_STK     :1;     //[4] UART stuck parity bit input enable
X            volatile uint8_t  RXPAR_STK     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RXMSB_EN      :1;     //[5] UART RX data order Msb first enable
X            volatile uint8_t  RXMSB_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RXSTP_LEN     :2;     //[7..6] UART RX stop bit length select
X            volatile uint8_t  RXSTP_LEN     :2;     
N                                        //0x0 = 0.5bit
N                                        //0x1 = 1bit
N                                        //0x2 = Reserved
N                                        //0x3 = 2bit
N            __IO uint8_t  RXOS_NUM      :5;     //[12..8] UART RX data oversampling samples select
X            volatile uint8_t  RXOS_NUM      :5;     
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  TXDSIZE       :2;     //[17..16] UART TX data bit length
X            volatile uint8_t  TXDSIZE       :2;     
N                                        //0x0 = 8bit
N                                        //0x1 = 7bit
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __IO uint8_t  TXPAR_EN      :1;     //[18] UART TX parity bit enable
X            volatile uint8_t  TXPAR_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TXPAR_POL     :1;     //[19] UART TX parity bit polarity. This bit is no effect for SPI and SYNC mods.
X            volatile uint8_t  TXPAR_POL     :1;     
N                                        //0x0 = Even
N                                        //0x1 = Odd
N            __IO uint8_t  TXPAR_STK     :1;     //[20] UART stuck parity bit output enable
X            volatile uint8_t  TXPAR_STK     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TXMSB_EN      :1;     //[21] UART TX data order Msb first enable
X            volatile uint8_t  TXMSB_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TXSTP_LEN     :2;     //[23..22] UART TX stop bit length select
X            volatile uint8_t  TXSTP_LEN     :2;     
N                                        //0x0 = 0.5bit (Reserved)
N                                        //0x1 = 1bit
N                                        //0x2 = 1.5bit (Reserved)
N                                        //0x3 = 2bit
N            __IO uint8_t  TXOS_NUM      :5;     //[28..24] UART TX data oversampling samples select
X            volatile uint8_t  TXOS_NUM      :5;     
N            __I  uint8_t                :3;     //[31..29] 
X            volatile const  uint8_t                :3;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  URT control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  BK_TX         :1;     //[0] UART break condition for next data transmitted
X            volatile uint8_t  BK_TX         :1;     
N                                        //0 = Normal
N                                        //1 = Send : Send Break
N            __IO uint8_t  ADR_TX        :1;     //[1] UART slave address for next data transmitted
X            volatile uint8_t  ADR_TX        :1;     
N                                        //0 = Normal
N                                        //1 = Send : Send Address
N            __IO uint8_t  RX_EN         :1;     //[2] UART receiver enable
X            volatile uint8_t  RX_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TX_EN         :1;     //[3] UART transmitter enable.
X            volatile uint8_t  TX_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TX_HALT       :1;     //[4] UART transmitter halt enable.
X            volatile uint8_t  TX_HALT       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  NSS_SWO       :1;     //[16] UART NSS signal software output control bit when URTx_NSS_SWEN is enable.
X            volatile uint8_t  NSS_SWO       :1;     
N            __I  uint8_t                :1;     //[17] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[23..18] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  NSS_INV       :1;     //[25] UART NSS output signal inverse enable
X            volatile uint8_t  NSS_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  NSS_SWEN      :1;     //[26] UART NSS signal output set by software control function enable bit.
X            volatile uint8_t  NSS_SWEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[27] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[29..28] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  URT control register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CPOL          :1;     //[1] UART clock polarity select. It is used to select the SPI clock level in idle state.
X            volatile uint8_t  CPOL          :1;     
N                                        //0 = Low
N                                        //1 = High
N            __IO uint8_t  CPHA          :1;     //[2] UART clock phase select
X            volatile uint8_t  CPHA          :1;     
N                                        //0 = Leading edge
N                                        //1 = Trailing edge
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  DET_BK        :1;     //[4] UART bit time select for break detection or transmission
X            volatile uint8_t  DET_BK        :1;     
N                                        //0x0 = 1Bit
N                                        //0x1 = 3Bit
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  DET_IDL       :8;     //[15..8] UART idle line detect threshold value by using receive bit time
X            volatile uint8_t  DET_IDL       :8;     
N            __IO uint8_t  TXGT_LEN      :8;     //[23..16] UART TX guard time or idle-line length
X            volatile uint8_t  TXGT_LEN      :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR3;                               /*!< CR3        ~ Offset[0x1C]  URT control register 3 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __O  uint8_t  RDAT_INV      :1;     //[4] UART inverse received data enable
X            volatile  uint8_t  RDAT_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __O  uint8_t  TDAT_INV      :1;     //[5] UART inverse transmitted data enable
X            volatile  uint8_t  TDAT_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __O  uint8_t  RDAT_CLR      :1;     //[6] UART  received data clear enable
X            volatile  uint8_t  RDAT_CLR      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __O  uint8_t  TDAT_CLR      :1;     //[7] UART  transmitted data clear enable
X            volatile  uint8_t  TDAT_CLR      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RNUM          :3;     //[10..8] UART received data byte number when data shadow buffer last transfer to URTx_RDAT reg
X            volatile uint8_t  RNUM          :3;     
N                                        //0x0 = 0 (0-byte)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  TNUM          :3;     //[14..12] UART remained data byte number in data register. Value 0~4 is valid only.
X            volatile const  uint8_t  TNUM          :3;     
N                                        //0x0 = 0 (0-byte)
N                                        //0x1 = 1 (1-byte)
N                                        //0x2 = 2 (2-byte)
N                                        //0x3 = 3 (3-byte)
N                                        //0x4 = 4 (4-byte)
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR4;                               /*!< CR4        ~ Offset[0x20]  URT control register 4 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  RLR           :8;     //[7..0] UART baud-rate clock counter reload register
X            volatile uint8_t  RLR           :8;     
N            __IO uint8_t  PSR           :4;     //[11..8] UART baud-rate clock prescaler reload register
X            volatile uint8_t  PSR           :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }RLR;                               /*!< RLR        ~ Offset[0x24]  URT baud-rate clock counter reload register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  CNT           :8;     //[7..0] UART baud-rate clock counter value register.
X            volatile const  uint8_t  CNT           :8;     
N            __I  uint8_t  PSC           :4;     //[11..8] UART baud-rate clock prescaler value register.
X            volatile const  uint8_t  PSC           :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x28]  URT baud-rate clock counter register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  RCAP_DAT      :8;     //[7..0] UART capture data from RX shift buffer for Parity error / Frame error / Break detect 
X            volatile uint8_t  RCAP_DAT      :8;     
N            __IO uint8_t  RCAP_STP      :1;     //[8] UART capture stop bit from RX shift buffer.
X            volatile uint8_t  RCAP_STP      :1;     
N            __IO uint8_t  RCAP_PAR      :1;     //[9] UART capture parity bit from RX shift buffer.
X            volatile uint8_t  RCAP_PAR      :1;     
N            __IO uint8_t  RCAP_ADR      :1;     //[10] UART capture address bit from RX shift buffer.
X            volatile uint8_t  RCAP_ADR      :1;     
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }RCAP;                              /*!< RCAP       ~ Offset[0x2C]  URT RX data capture register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t RDAT          :32;    //[31..0] UART received data register
X            volatile const  uint32_t RDAT          :32;    
N        }MBIT;
N    }RDAT;                              /*!< RDAT       ~ Offset[0x30]  URT RX data register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t TDAT          :32;    //[31..0] UART transmitted data register
X            volatile uint32_t TDAT          :32;    
N        }MBIT;
N    }TDAT;                              /*!< TDAT       ~ Offset[0x34]  URT TX data register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __O  uint32_t TDAT3         :24;    //[23..0] UART transmitted data register for 3-byte data write only
X            volatile  uint32_t TDAT3         :24;    
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }TDAT3;                             /*!< TDAT3      ~ Offset[0x38]  URT TX data 3-byte register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  RSBUF         :8;     //[7..0] UART RX data shift buffer register.
X            volatile const  uint8_t  RSBUF         :8;     
N            __I  uint8_t  TSBUF         :8;     //[15..8] UART TX data shift buffer register.
X            volatile const  uint8_t  TSBUF         :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }SBUF;                              /*!< SBUF       ~ Offset[0x3C]  URT data shift buffer register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  TMO_EN        :1;     //[0] UART timeout timer enable.
X            volatile uint8_t  TMO_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TMO_RST       :1;     //[1] UART timeout timer force reset enable. (set by software and clear by hardware)
X            volatile uint8_t  TMO_RST       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TMO_MDS       :2;     //[3..2] UART timeout timer mode select
X            volatile uint8_t  TMO_MDS       :2;     
N                                        //0x0 = UART : UART timeout timer
N                                        //0x1 = General : general using timer
N            __IO uint8_t  IDTMO_EN      :1;     //[4] UART Idle timeout detection enable bit
X            volatile uint8_t  IDTMO_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RXTMO_EN      :1;     //[5] UART RX timeout enable bit for shadow buffer data loading into URTx_RDAT
X            volatile uint8_t  RXTMO_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BKTMO_EN      :1;     //[6] UART Break timeout detection enable bit
X            volatile uint8_t  BKTMO_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CALTMO_EN     :1;     //[7] UART Calibration timeout detection enable bit
X            volatile uint8_t  CALTMO_EN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TMO_CKS       :3;     //[10..8] UART timeout timer clock source select
X            volatile uint8_t  TMO_CKS       :3;     
N                                        //0x0 = UART (CK_URTx_BIT clock)
N                                        //0x1 = Input (CK_UART clock input) 
N                                        //0x2 = Noise (Noise bit receive event)
N                                        //0x3 = Reserved
N            __I  uint8_t                :3;     //[13..11] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  TMO_STA       :1;     //[14] UART timeout timer timeout signal initial state
X            volatile uint8_t  TMO_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  TMO_LCK       :1;     //[15] UART timeout timer timeout signal initial state control
X            volatile uint8_t  TMO_LCK       :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __IO uint8_t  RXTMO_TH      :8;     //[23..16] UART RX data buffer timeout detect threshold value by using receive bit time
X            volatile uint8_t  RXTMO_TH      :8;     
N            __IO uint8_t  BKTMO_TH      :4;     //[27..24] UART receive Break timeout detect threshold value by using receive bit time
X            volatile uint8_t  BKTMO_TH      :4;     
N            __IO uint8_t  CALTMO_TH     :4;     //[31..28] UART calibration timeout detect threshold value for TMO counter value comparison
X            volatile uint8_t  CALTMO_TH     :4;     
N        }MBIT;
N    }TMOUT;                             /*!< TMOUT      ~ Offset[0x40]  URT timeout control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t IDTMO_TH      :16;    //[15..0] UART receive idle timeout detect threshold value by using receive bit time
X            volatile uint16_t IDTMO_TH      :16;    
N            __IO uint16_t TMO_CNT       :16;    //[31..16] UART timeout counter value.
X            volatile uint16_t TMO_CNT       :16;    
N        }MBIT;
N    }TMOUT2;                            /*!< TMOUT2     ~ Offset[0x44]  URT timeout control register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  RXE_MDS       :2;     //[1..0] UART RX parity error detect control mode select
X            volatile uint8_t  RXE_MDS       :2;     
N                                        //0x0 = Disable
N                                        //0x1 = Enable : hardware RX auto retry number by setting URTx_RXE_NUM
N                                        //0x2 = Auto : hardware RX auto retry always unless receiving parity correct character
N            __IO uint8_t  TXE_MDS       :2;     //[3..2] UART TX error detect mode select
X            volatile uint8_t  TXE_MDS       :2;     
N                                        //0x0 = Disable
N                                        //0x1 = CHK_Low : check asserted low by RX device (for SmartCard)
N                                        //0x2 = CHK_TX : check TX data by RX input data (for LIN mode)
N                                        //0x3 = Reserved
N            __IO uint8_t  RXE_LEN       :1;     //[4] UART RX parity error detect and NACK transmission 
X            volatile uint8_t  RXE_LEN       :1;     
N                                        //0x0 = 1Bit
N                                        //0x1 = 2Bit
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  TXE_NUM       :3;     //[10..8] UART TX error detect and data resend maximum number
X            volatile uint8_t  TXE_NUM       :3;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RXE_NUM       :3;     //[14..12] UART RX parity error detect and NACK transmission retry maximum number
X            volatile uint8_t  RXE_NUM       :3;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }SC;                                /*!< SC         ~ Offset[0x48]  URT SmartCard control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  SA_RX         :8;     //[7..0] UART multi-processor mode received slave address
X            volatile uint8_t  SA_RX         :8;     
N            __IO uint8_t  SA_MSK        :8;     //[15..8] UART multi-processor slave address mask register
X            volatile uint8_t  SA_MSK        :8;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SADR;                              /*!< SADR       ~ Offset[0x4C]  URT slave address detect register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CAL_EN        :1;     //[0] UART baud-rate calibration enable
X            volatile uint8_t  CAL_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CAL_AUTO      :1;     //[1] UART Break detection and auto baud-rate calibration enable
X            volatile uint8_t  CAL_AUTO      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CAL_MDS       :2;     //[3..2] UART auto baud-rate calibration mode select.
X            volatile uint8_t  CAL_MDS       :2;     
N                                        //0x0 = Start : measure the start bit
N                                        //0x1 = Edge : measure start falling edge to next falling edge
N                                        //0x2 = Reserved
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CALC_HE       :1;     //[7] UART auto baud-rate calibration complete data receive hold enable
X            volatile uint8_t  CALC_HE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[11..8] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CAL;                               /*!< CAL        ~ Offset[0x50]  URT calibration control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IR_EN         :1;     //[0] UART IrDA data format enable
X            volatile uint8_t  IR_EN         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IR_PW         :4;     //[11..8] UART IrDA output pulse width select
X            volatile uint8_t  IR_PW         :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }IRDA;                              /*!< IRDA       ~ Offset[0x54]  URT IrDA control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CTS_EN        :1;     //[0] UART CTS hardware flow control enable
X            volatile uint8_t  CTS_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RTS_EN        :1;     //[1] UART RTS hardware flow control enable
X            volatile uint8_t  RTS_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CTS_INV       :1;     //[2] URTx_CTS input inverse enable.
X            volatile uint8_t  CTS_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RTS_INV       :1;     //[3] URTx_RTS output inverse enable
X            volatile uint8_t  RTS_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RTS_OUT       :1;     //[4] URTx_RTS output control data bit. This bit is no effect when URTx_RTS_EN is set.
X            volatile uint8_t  RTS_OUT       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }HFC;                               /*!< HFC        ~ Offset[0x58]  URT hardware flow control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  MUTE_EN       :1;     //[0] UART mute mode enable
X            volatile uint8_t  MUTE_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  MUTE_AEN0     :1;     //[8] UART mute mode auto enter by multi-processor slave address unmatched condition enable
X            volatile uint8_t  MUTE_AEN0     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MUTE_AEN1     :1;     //[9] UART mute mode auto enter by idle line detection enable bit
X            volatile uint8_t  MUTE_AEN1     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  MUTE_AEX0     :1;     //[16] UART auto exit mute mode and receive data by multi-processor slave address matched co
X            volatile uint8_t  MUTE_AEX0     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MUTE_AEX1     :1;     //[17] UART auto exit mute mode and receive data by Break condition detection enable bit
X            volatile uint8_t  MUTE_AEX1     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MUTE_AEX2     :1;     //[18] UART auto exit mute mode and receive data by  idle line detection enable bit
X            volatile uint8_t  MUTE_AEX2     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }MUTE;                              /*!< MUTE       ~ Offset[0x5C]  URT mute control register */
N
N} URT_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        URT  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define URT0_Base                       ((uint32_t)0x52000000)              /*!< UART Control Module-0 */
N#define URT1_Base                       ((uint32_t)0x52010000)              /*!< UART Control Module-1 */
N#define URT2_Base                       ((uint32_t)0x52020000)              /*!< UART Control Module-2 */
N#define URT3_Base                       ((uint32_t)0x52030000)              /*!< UART Control Module-3 */
N#define URT0                            ((URT_Struct*) URT0_Base)
N#define URT1                            ((URT_Struct*) URT1_Base)
N#define URT2                            ((URT_Struct*) URT2_Base)
N#define URT3                            ((URT_Struct*) URT3_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        URT  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        URT_STA  [register's definitions]
N *              Offset[0x00]  URT status register 1
N ******************************************************************************
N */
N///@{
N#define URT_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_STA */
N#define URT_STA_CALTMOF_mask_w                      ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define URT_STA_CALTMOF_mask_h1                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define URT_STA_CALTMOF_mask_b3                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_STA_CALTMOF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_CALTMOF_normal_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_CALTMOF_normal_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_CALTMOF_happened_w                  ((uint32_t)0x40000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_CALTMOF_happened_h1                 ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_CALTMOF_happened_b3                 ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_BKTMOF_mask_w                       ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define URT_STA_BKTMOF_mask_h1                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_STA_BKTMOF_mask_b3                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_STA_BKTMOF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_BKTMOF_normal_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_BKTMOF_normal_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_BKTMOF_happened_w                   ((uint32_t)0x20000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_BKTMOF_happened_h1                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_BKTMOF_happened_b3                  ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_IDTMOF_mask_w                       ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define URT_STA_IDTMOF_mask_h1                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_STA_IDTMOF_mask_b3                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_STA_IDTMOF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_IDTMOF_normal_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_IDTMOF_normal_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_IDTMOF_happened_w                   ((uint32_t)0x10000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_IDTMOF_happened_h1                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_IDTMOF_happened_b3                  ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_RXTMOF_mask_w                       ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define URT_STA_RXTMOF_mask_h1                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define URT_STA_RXTMOF_mask_b3                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_STA_RXTMOF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_RXTMOF_normal_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_RXTMOF_normal_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_RXTMOF_happened_w                   ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_RXTMOF_happened_h1                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_RXTMOF_happened_b3                  ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_TXEF_mask_w                         ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define URT_STA_TXEF_mask_h1                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define URT_STA_TXEF_mask_b3                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_STA_TXEF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_TXEF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_TXEF_normal_b3                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_TXEF_happened_w                     ((uint32_t)0x01000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_TXEF_happened_h1                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_TXEF_happened_b3                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_ROVRF_mask_w                        ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define URT_STA_ROVRF_mask_h1                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_STA_ROVRF_mask_b2                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_STA_ROVRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_ROVRF_normal_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_ROVRF_normal_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_ROVRF_happened_w                    ((uint32_t)0x00800000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_ROVRF_happened_h1                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_ROVRF_happened_b2                   ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_NCEF_mask_w                         ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define URT_STA_NCEF_mask_h1                        ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_STA_NCEF_mask_b2                        ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_STA_NCEF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_NCEF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_NCEF_normal_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_NCEF_happened_w                     ((uint32_t)0x00400000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_NCEF_happened_h1                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_NCEF_happened_b2                    ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_FEF_mask_w                          ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define URT_STA_FEF_mask_h1                         ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_STA_FEF_mask_b2                         ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_STA_FEF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_FEF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_FEF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_FEF_happened_w                      ((uint32_t)0x00200000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_FEF_happened_h1                     ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_FEF_happened_b2                     ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_PEF_mask_w                          ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define URT_STA_PEF_mask_h1                         ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_STA_PEF_mask_b2                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_STA_PEF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_PEF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_PEF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_PEF_happened_w                      ((uint32_t)0x00100000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_PEF_happened_h1                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_PEF_happened_b2                     ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_CTSF_mask_w                         ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define URT_STA_CTSF_mask_h1                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_STA_CTSF_mask_b2                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_STA_CTSF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_CTSF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_CTSF_normal_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_CTSF_happened_w                     ((uint32_t)0x00040000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_CTSF_happened_h1                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_CTSF_happened_b2                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_IDLF_mask_w                         ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define URT_STA_IDLF_mask_h1                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_STA_IDLF_mask_b2                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_STA_IDLF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_IDLF_normal_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_IDLF_normal_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_IDLF_happened_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_IDLF_happened_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_IDLF_happened_b2                    ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_BKF_mask_w                          ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define URT_STA_BKF_mask_h1                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_STA_BKF_mask_b2                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_STA_BKF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_BKF_normal_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_BKF_normal_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_BKF_happened_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_BKF_happened_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_BKF_happened_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_CALCF_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define URT_STA_CALCF_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_STA_CALCF_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_STA_CALCF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_CALCF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_CALCF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_CALCF_happened_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_CALCF_happened_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_CALCF_happened_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_TMOF_mask_w                         ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define URT_STA_TMOF_mask_h0                        ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_STA_TMOF_mask_b1                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_STA_TMOF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_TMOF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_TMOF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_TMOF_happened_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_TMOF_happened_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_TMOF_happened_b1                    ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_BRTF_mask_w                         ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define URT_STA_BRTF_mask_h0                        ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define URT_STA_BRTF_mask_b1                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_STA_BRTF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_BRTF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_BRTF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_BRTF_happened_w                     ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_BRTF_happened_h0                    ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_BRTF_happened_b1                    ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_SADRF_mask_w                        ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define URT_STA_SADRF_mask_h0                       ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define URT_STA_SADRF_mask_b1                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_STA_SADRF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_SADRF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_SADRF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_SADRF_happened_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_SADRF_happened_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_SADRF_happened_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_TXF_mask_w                          ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_STA_TXF_mask_h0                         ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_STA_TXF_mask_b0                         ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_STA_TXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_TXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_TXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_TXF_happened_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_TXF_happened_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_TXF_happened_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_RXF_mask_w                          ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define URT_STA_RXF_mask_h0                         ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_STA_RXF_mask_b0                         ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_STA_RXF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_RXF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_RXF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_RXF_happened_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_RXF_happened_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_RXF_happened_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_RXDF_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define URT_STA_RXDF_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_STA_RXDF_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_STA_RXDF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_RXDF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_RXDF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_RXDF_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_RXDF_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_RXDF_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_LSF_mask_w                          ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_STA_LSF_mask_h0                         ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_STA_LSF_mask_b0                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_STA_LSF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_LSF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_LSF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_LSF_happened_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_LSF_happened_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_LSF_happened_b0                     ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_ERRF_mask_w                         ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define URT_STA_ERRF_mask_h0                        ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_STA_ERRF_mask_b0                        ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_STA_ERRF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_ERRF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_ERRF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_ERRF_happened_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_ERRF_happened_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_ERRF_happened_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_TCF_mask_w                          ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_STA_TCF_mask_h0                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_STA_TCF_mask_b0                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_STA_TCF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_TCF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_TCF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_TCF_happened_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_TCF_happened_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_TCF_happened_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_UGF_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_STA_UGF_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_STA_UGF_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_STA_UGF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_UGF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_UGF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_UGF_happened_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_UGF_happened_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_UGF_happened_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA_RHF_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_STA_RHF_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_STA_RHF_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_STA_RHF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA_RHF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA_RHF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA_RHF_happened_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA_RHF_happened_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA_RHF_happened_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_INT  [register's definitions]
N *              Offset[0x04]  URT interrupt enable register
N ******************************************************************************
N */
N///@{
N#define URT_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_INT */
N#define URT_INT_CALTMO_IE_mask_w                    ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define URT_INT_CALTMO_IE_mask_h1                   ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define URT_INT_CALTMO_IE_mask_b3                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_INT_CALTMO_IE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_CALTMO_IE_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_CALTMO_IE_disable_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_CALTMO_IE_enable_w                  ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_CALTMO_IE_enable_h1                 ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_CALTMO_IE_enable_b3                 ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_BKTMO_IE_mask_w                     ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define URT_INT_BKTMO_IE_mask_h1                    ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_INT_BKTMO_IE_mask_b3                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_INT_BKTMO_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_BKTMO_IE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_BKTMO_IE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_BKTMO_IE_enable_w                   ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_BKTMO_IE_enable_h1                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_BKTMO_IE_enable_b3                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_IDTMO_IE_mask_w                     ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define URT_INT_IDTMO_IE_mask_h1                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_INT_IDTMO_IE_mask_b3                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_INT_IDTMO_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_IDTMO_IE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_IDTMO_IE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_IDTMO_IE_enable_w                   ((uint32_t)0x10000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_IDTMO_IE_enable_h1                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_IDTMO_IE_enable_b3                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_RXTMO_IE_mask_w                     ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define URT_INT_RXTMO_IE_mask_h1                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define URT_INT_RXTMO_IE_mask_b3                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_INT_RXTMO_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_RXTMO_IE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_RXTMO_IE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_RXTMO_IE_enable_w                   ((uint32_t)0x08000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_RXTMO_IE_enable_h1                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_RXTMO_IE_enable_b3                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_TXE_IE_mask_w                       ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define URT_INT_TXE_IE_mask_h1                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define URT_INT_TXE_IE_mask_b3                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_INT_TXE_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_TXE_IE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_TXE_IE_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_TXE_IE_enable_w                     ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_TXE_IE_enable_h1                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_TXE_IE_enable_b3                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_ROVR_IE_mask_w                      ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define URT_INT_ROVR_IE_mask_h1                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_INT_ROVR_IE_mask_b2                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_INT_ROVR_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_ROVR_IE_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_ROVR_IE_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_ROVR_IE_enable_w                    ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_ROVR_IE_enable_h1                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_ROVR_IE_enable_b2                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_NCE_IE_mask_w                       ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define URT_INT_NCE_IE_mask_h1                      ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_INT_NCE_IE_mask_b2                      ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_INT_NCE_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_NCE_IE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_NCE_IE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_NCE_IE_enable_w                     ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_NCE_IE_enable_h1                    ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_NCE_IE_enable_b2                    ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_FE_IE_mask_w                        ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define URT_INT_FE_IE_mask_h1                       ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_INT_FE_IE_mask_b2                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_INT_FE_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_FE_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_FE_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_FE_IE_enable_w                      ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_FE_IE_enable_h1                     ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_FE_IE_enable_b2                     ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_PE_IE_mask_w                        ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define URT_INT_PE_IE_mask_h1                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_INT_PE_IE_mask_b2                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_INT_PE_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_PE_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_PE_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_PE_IE_enable_w                      ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_PE_IE_enable_h1                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_PE_IE_enable_b2                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_CTS_IE_mask_w                       ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define URT_INT_CTS_IE_mask_h1                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_INT_CTS_IE_mask_b2                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_INT_CTS_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_CTS_IE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_CTS_IE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_CTS_IE_enable_w                     ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_CTS_IE_enable_h1                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_CTS_IE_enable_b2                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_IDL_IE_mask_w                       ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define URT_INT_IDL_IE_mask_h1                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_INT_IDL_IE_mask_b2                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_INT_IDL_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_IDL_IE_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_IDL_IE_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_IDL_IE_enable_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_IDL_IE_enable_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_IDL_IE_enable_b2                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_BK_IE_mask_w                        ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define URT_INT_BK_IE_mask_h1                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_INT_BK_IE_mask_b2                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_INT_BK_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_BK_IE_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_BK_IE_disable_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_BK_IE_enable_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_BK_IE_enable_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_BK_IE_enable_b2                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_CALC_IE_mask_w                      ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define URT_INT_CALC_IE_mask_h0                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_INT_CALC_IE_mask_b1                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_INT_CALC_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_CALC_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_CALC_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_CALC_IE_enable_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_CALC_IE_enable_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_CALC_IE_enable_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_TMO_IE_mask_w                       ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define URT_INT_TMO_IE_mask_h0                      ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_INT_TMO_IE_mask_b1                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_INT_TMO_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_TMO_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_TMO_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_TMO_IE_enable_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_TMO_IE_enable_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_TMO_IE_enable_b1                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_BRT_IE_mask_w                       ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define URT_INT_BRT_IE_mask_h0                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define URT_INT_BRT_IE_mask_b1                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_INT_BRT_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_BRT_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_BRT_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_BRT_IE_enable_w                     ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_BRT_IE_enable_h0                    ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_BRT_IE_enable_b1                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_SADR_IE_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define URT_INT_SADR_IE_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define URT_INT_SADR_IE_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_INT_SADR_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_SADR_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_SADR_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_SADR_IE_enable_w                    ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_SADR_IE_enable_h0                   ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_SADR_IE_enable_b1                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_TX_IE_mask_w                        ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_INT_TX_IE_mask_h0                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_INT_TX_IE_mask_b0                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_INT_TX_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_TX_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_TX_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_TX_IE_enable_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_TX_IE_enable_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_TX_IE_enable_b0                     ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_RX_IE_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define URT_INT_RX_IE_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_INT_RX_IE_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_INT_RX_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_RX_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_RX_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_RX_IE_enable_w                      ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_RX_IE_enable_h0                     ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_RX_IE_enable_b0                     ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_LS_IE_mask_w                        ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_INT_LS_IE_mask_h0                       ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_INT_LS_IE_mask_b0                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_INT_LS_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_LS_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_LS_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_LS_IE_enable_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_LS_IE_enable_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_LS_IE_enable_b0                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_ERR_IE_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define URT_INT_ERR_IE_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_INT_ERR_IE_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_INT_ERR_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_ERR_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_ERR_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_ERR_IE_enable_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_ERR_IE_enable_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_ERR_IE_enable_b0                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_TC_IE_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_INT_TC_IE_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_INT_TC_IE_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_INT_TC_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_TC_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_TC_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_TC_IE_enable_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_TC_IE_enable_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_TC_IE_enable_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_UG_IE_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_INT_UG_IE_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_INT_UG_IE_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_INT_UG_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_UG_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_UG_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_UG_IE_enable_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_UG_IE_enable_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_UG_IE_enable_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CLK  [register's definitions]
N *              Offset[0x08]  URT clock source register
N ******************************************************************************
N */
N///@{
N#define URT_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CLK */
N#define URT_CLK_CKO_LCK_mask_w                      ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_CKO_LCK_mask_h1                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_CLK_CKO_LCK_mask_b3                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CLK_CKO_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define URT_CLK_CKO_LCK_locked_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define URT_CLK_CKO_LCK_locked_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define URT_CLK_CKO_LCK_un_locked_w                 ((uint32_t)0x20000000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define URT_CLK_CKO_LCK_un_locked_h1                ((uint16_t)0x2000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define URT_CLK_CKO_LCK_un_locked_b3                ((uint8_t )0x20)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define URT_CLK_CKO_STA_mask_w                      ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_CKO_STA_mask_h1                     ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_CLK_CKO_STA_mask_b3                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CLK_CKO_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define URT_CLK_CKO_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define URT_CLK_CKO_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define URT_CLK_CKO_STA_1_w                         ((uint32_t)0x10000000)  /*!< Bit Value =(1):1 of 32bit */
N#define URT_CLK_CKO_STA_1_h1                        ((uint16_t)0x1000)      /*!< Bit Value =(1):1 of 16bit */
N#define URT_CLK_CKO_STA_1_b3                        ((uint8_t )0x10)        /*!< Bit Value =(1):1 of 8bit */
N
N#define URT_CLK_BRO_LCK_mask_w                      ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_BRO_LCK_mask_h1                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define URT_CLK_BRO_LCK_mask_b3                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_CLK_BRO_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define URT_CLK_BRO_LCK_locked_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define URT_CLK_BRO_LCK_locked_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define URT_CLK_BRO_LCK_un_locked_w                 ((uint32_t)0x08000000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define URT_CLK_BRO_LCK_un_locked_h1                ((uint16_t)0x0800)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define URT_CLK_BRO_LCK_un_locked_b3                ((uint8_t )0x08)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define URT_CLK_BRO_STA_mask_w                      ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_BRO_STA_mask_h1                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define URT_CLK_BRO_STA_mask_b3                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CLK_BRO_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define URT_CLK_BRO_STA_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define URT_CLK_BRO_STA_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define URT_CLK_BRO_STA_1_w                         ((uint32_t)0x04000000)  /*!< Bit Value =(1):1 of 32bit */
N#define URT_CLK_BRO_STA_1_h1                        ((uint16_t)0x0400)      /*!< Bit Value =(1):1 of 16bit */
N#define URT_CLK_BRO_STA_1_b3                        ((uint8_t )0x04)        /*!< Bit Value =(1):1 of 8bit */
N
N#define URT_CLK_BR_MDS_mask_w                       ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_BR_MDS_mask_h1                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define URT_CLK_BR_MDS_mask_b3                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_CLK_BR_MDS_separated_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Separated of 32bit */
N#define URT_CLK_BR_MDS_separated_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Separated of 16bit */
N#define URT_CLK_BR_MDS_separated_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Separated of 8bit */
N#define URT_CLK_BR_MDS_combined_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(1):Combined of 32bit */
N#define URT_CLK_BR_MDS_combined_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Combined of 16bit */
N#define URT_CLK_BR_MDS_combined_b3                  ((uint8_t )0x02)        /*!< Bit Value =(1):Combined of 8bit */
N
N#define URT_CLK_BR_EN_mask_w                        ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_BR_EN_mask_h1                       ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define URT_CLK_BR_EN_mask_b3                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_CLK_BR_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CLK_BR_EN_disable_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CLK_BR_EN_disable_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CLK_BR_EN_enable_w                      ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CLK_BR_EN_enable_h1                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CLK_BR_EN_enable_b3                     ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CLK_TX_CKS_mask_w                       ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_TX_CKS_mask_h1                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define URT_CLK_TX_CKS_mask_b2                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define URT_CLK_TX_CKS_internal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Internal of 32bit */
N#define URT_CLK_TX_CKS_internal_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Internal of 16bit */
N#define URT_CLK_TX_CKS_internal_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Internal of 8bit */
N#define URT_CLK_TX_CKS_tm01_trgo_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):TM01_TRGO of 32bit */
N#define URT_CLK_TX_CKS_tm01_trgo_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(0x1):TM01_TRGO of 16bit */
N#define URT_CLK_TX_CKS_tm01_trgo_b2                 ((uint8_t )0x10)        /*!< Bit Value =(0x1):TM01_TRGO of 8bit */
N#define URT_CLK_TX_CKS_tm10_trgo_w                  ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):TM10_TRGO of 32bit */
N#define URT_CLK_TX_CKS_tm10_trgo_h1                 ((uint16_t)0x0020)      /*!< Bit Value =(0x2):TM10_TRGO of 16bit */
N#define URT_CLK_TX_CKS_tm10_trgo_b2                 ((uint8_t )0x20)        /*!< Bit Value =(0x2):TM10_TRGO of 8bit */
N
N#define URT_CLK_RX_CKS_mask_w                       ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define URT_CLK_RX_CKS_mask_h1                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define URT_CLK_RX_CKS_mask_b2                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define URT_CLK_RX_CKS_internal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Internal of 32bit */
N#define URT_CLK_RX_CKS_internal_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Internal of 16bit */
N#define URT_CLK_RX_CKS_internal_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Internal of 8bit */
N#define URT_CLK_RX_CKS_tm01_trgo_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):TM01_TRGO of 32bit */
N#define URT_CLK_RX_CKS_tm01_trgo_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):TM01_TRGO of 16bit */
N#define URT_CLK_RX_CKS_tm01_trgo_b2                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):TM01_TRGO of 8bit */
N#define URT_CLK_RX_CKS_tm10_trgo_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):TM10_TRGO of 32bit */
N#define URT_CLK_RX_CKS_tm10_trgo_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(0x2):TM10_TRGO of 16bit */
N#define URT_CLK_RX_CKS_tm10_trgo_b2                 ((uint8_t )0x02)        /*!< Bit Value =(0x2):TM10_TRGO of 8bit */
N
N#define URT_CLK_CLK_CKS_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define URT_CLK_CLK_CKS_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_CLK_CLK_CKS_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CLK_CLK_CKS_out_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):OUT of 32bit */
N#define URT_CLK_CLK_CKS_out_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):OUT of 16bit */
N#define URT_CLK_CLK_CKS_out_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):OUT of 8bit */
N#define URT_CLK_CLK_CKS_sc_w                        ((uint32_t)0x00000020)  /*!< Bit Value =(1):SC of 32bit */
N#define URT_CLK_CLK_CKS_sc_h0                       ((uint16_t)0x0020)      /*!< Bit Value =(1):SC of 16bit */
N#define URT_CLK_CLK_CKS_sc_b0                       ((uint8_t )0x20)        /*!< Bit Value =(1):SC of 8bit */
N
N#define URT_CLK_CLK_EN_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_CLK_CLK_EN_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CLK_CLK_EN_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CLK_CLK_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CLK_CLK_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CLK_CLK_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CLK_CLK_EN_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CLK_CLK_EN_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CLK_CLK_EN_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CLK_CK_SEL_mask_w                       ((uint32_t)0x0000000E)  /*!< Bit Mask of 32bit */
N#define URT_CLK_CK_SEL_mask_h0                      ((uint16_t)0x000E)      /*!< Bit Mask of 16bit */
N#define URT_CLK_CK_SEL_mask_b0                      ((uint8_t )0x0E)        /*!< Bit Mask of 8bit */
N#define URT_CLK_CK_SEL_proc_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):PROC of 32bit */
N#define URT_CLK_CK_SEL_proc_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):PROC of 16bit */
N#define URT_CLK_CK_SEL_proc_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):PROC of 8bit */
N#define URT_CLK_CK_SEL_ck_ls_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(0x2):CK_LS of 32bit */
N#define URT_CLK_CK_SEL_ck_ls_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(0x2):CK_LS of 16bit */
N#define URT_CLK_CK_SEL_ck_ls_b0                     ((uint8_t )0x04)        /*!< Bit Value =(0x2):CK_LS of 8bit */
N#define URT_CLK_CK_SEL_tm00_trgo_w                  ((uint32_t)0x00000006)  /*!< Bit Value =(0x3):TM00_TRGO of 32bit */
N#define URT_CLK_CK_SEL_tm00_trgo_h0                 ((uint16_t)0x0006)      /*!< Bit Value =(0x3):TM00_TRGO of 16bit */
N#define URT_CLK_CK_SEL_tm00_trgo_b0                 ((uint8_t )0x06)        /*!< Bit Value =(0x3):TM00_TRGO of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_STA2  [register's definitions]
N *              Offset[0x0C]  URT status register 2
N ******************************************************************************
N */
N///@{
N#define URT_STA2_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_STA2 */
N#define URT_STA2_TX_LVL_mask_w                      ((uint32_t)0x70000000)  /*!< Bit Mask of 32bit */
N#define URT_STA2_TX_LVL_mask_h1                     ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define URT_STA2_TX_LVL_mask_b3                     ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define URT_STA2_TX_LVL_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define URT_STA2_TX_LVL_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define URT_STA2_TX_LVL_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define URT_STA2_TX_LVL_1_w                         ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):1 of 32bit */
N#define URT_STA2_TX_LVL_1_h1                        ((uint16_t)0x1000)      /*!< Bit Value =(0x1):1 of 16bit */
N#define URT_STA2_TX_LVL_1_b3                        ((uint8_t )0x10)        /*!< Bit Value =(0x1):1 of 8bit */
N#define URT_STA2_TX_LVL_2_w                         ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):2 of 32bit */
N#define URT_STA2_TX_LVL_2_h1                        ((uint16_t)0x2000)      /*!< Bit Value =(0x2):2 of 16bit */
N#define URT_STA2_TX_LVL_2_b3                        ((uint8_t )0x20)        /*!< Bit Value =(0x2):2 of 8bit */
N#define URT_STA2_TX_LVL_3_w                         ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):3 of 32bit */
N#define URT_STA2_TX_LVL_3_h1                        ((uint16_t)0x3000)      /*!< Bit Value =(0x3):3 of 16bit */
N#define URT_STA2_TX_LVL_3_b3                        ((uint8_t )0x30)        /*!< Bit Value =(0x3):3 of 8bit */
N#define URT_STA2_TX_LVL_4_w                         ((uint32_t)0x40000000)  /*!< Bit Value =(0x4):4 of 32bit */
N#define URT_STA2_TX_LVL_4_h1                        ((uint16_t)0x4000)      /*!< Bit Value =(0x4):4 of 16bit */
N#define URT_STA2_TX_LVL_4_b3                        ((uint8_t )0x40)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define URT_STA2_RX_LVL_mask_w                      ((uint32_t)0x07000000)  /*!< Bit Mask of 32bit */
N#define URT_STA2_RX_LVL_mask_h1                     ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define URT_STA2_RX_LVL_mask_b3                     ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define URT_STA2_RX_LVL_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define URT_STA2_RX_LVL_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define URT_STA2_RX_LVL_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define URT_STA2_RX_LVL_1_w                         ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):1 of 32bit */
N#define URT_STA2_RX_LVL_1_h1                        ((uint16_t)0x0100)      /*!< Bit Value =(0x1):1 of 16bit */
N#define URT_STA2_RX_LVL_1_b3                        ((uint8_t )0x01)        /*!< Bit Value =(0x1):1 of 8bit */
N#define URT_STA2_RX_LVL_2_w                         ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):2 of 32bit */
N#define URT_STA2_RX_LVL_2_h1                        ((uint16_t)0x0200)      /*!< Bit Value =(0x2):2 of 16bit */
N#define URT_STA2_RX_LVL_2_b3                        ((uint8_t )0x02)        /*!< Bit Value =(0x2):2 of 8bit */
N#define URT_STA2_RX_LVL_3_w                         ((uint32_t)0x03000000)  /*!< Bit Value =(0x3):3 of 32bit */
N#define URT_STA2_RX_LVL_3_h1                        ((uint16_t)0x0300)      /*!< Bit Value =(0x3):3 of 16bit */
N#define URT_STA2_RX_LVL_3_b3                        ((uint8_t )0x03)        /*!< Bit Value =(0x3):3 of 8bit */
N#define URT_STA2_RX_LVL_4_w                         ((uint32_t)0x04000000)  /*!< Bit Value =(0x4):4 of 32bit */
N#define URT_STA2_RX_LVL_4_h1                        ((uint16_t)0x0400)      /*!< Bit Value =(0x4):4 of 16bit */
N#define URT_STA2_RX_LVL_4_b3                        ((uint8_t )0x04)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define URT_STA2_CTS_mask_w                         ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define URT_STA2_CTS_mask_h0                        ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_STA2_CTS_mask_b1                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_STA2_CTS_shift_w                        (12)                    /*!< Bit Shift of 32bit */
N#define URT_STA2_CTS_shift_h0                       (12)                    /*!< Bit Shift of 16bit */
N#define URT_STA2_CTS_shift_b1                       (4)                     /*!< Bit Shift of 8bit */
N
N#define URT_STA2_IR_BUSYF_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_STA2_IR_BUSYF_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_STA2_IR_BUSYF_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_STA2_IR_BUSYF_no_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define URT_STA2_IR_BUSYF_no_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define URT_STA2_IR_BUSYF_no_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define URT_STA2_IR_BUSYF_busy_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Busy of 32bit */
N#define URT_STA2_IR_BUSYF_busy_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Busy of 16bit */
N#define URT_STA2_IR_BUSYF_busy_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Busy of 8bit */
N
N#define URT_STA2_BKBF_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define URT_STA2_BKBF_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_STA2_BKBF_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_STA2_BKBF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA2_BKBF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA2_BKBF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA2_BKBF_busy_w                        ((uint32_t)0x00000040)  /*!< Bit Value =(1):Busy of 32bit */
N#define URT_STA2_BKBF_busy_h0                       ((uint16_t)0x0040)      /*!< Bit Value =(1):Busy of 16bit */
N#define URT_STA2_BKBF_busy_b0                       ((uint8_t )0x40)        /*!< Bit Value =(1):Busy of 8bit */
N
N#define URT_STA2_NCF_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define URT_STA2_NCF_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_STA2_NCF_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_STA2_NCF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA2_NCF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA2_NCF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA2_NCF_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define URT_STA2_NCF_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define URT_STA2_NCF_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define URT_STA2_ADR_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_STA2_ADR_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_STA2_ADR_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_STA2_ADR_shift_w                        (2)                     /*!< Bit Shift of 32bit */
N#define URT_STA2_ADR_shift_h0                       (2)                     /*!< Bit Shift of 16bit */
N#define URT_STA2_ADR_shift_b0                       (2)                     /*!< Bit Shift of 8bit */
N
N#define URT_STA2_PAR_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_STA2_PAR_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_STA2_PAR_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_STA2_PAR_shift_w                        (1)                     /*!< Bit Shift of 32bit */
N#define URT_STA2_PAR_shift_h0                       (1)                     /*!< Bit Shift of 16bit */
N#define URT_STA2_PAR_shift_b0                       (1)                     /*!< Bit Shift of 8bit */
N
N#define URT_STA2_BUSYF_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_STA2_BUSYF_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_STA2_BUSYF_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_STA2_BUSYF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_STA2_BUSYF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_STA2_BUSYF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_STA2_BUSYF_busy_w                       ((uint32_t)0x00000001)  /*!< Bit Value =(1):Busy of 32bit */
N#define URT_STA2_BUSYF_busy_h0                      ((uint16_t)0x0001)      /*!< Bit Value =(1):Busy of 16bit */
N#define URT_STA2_BUSYF_busy_b0                      ((uint8_t )0x01)        /*!< Bit Value =(1):Busy of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CR0  [register's definitions]
N *              Offset[0x10]  URT control register 0
N ******************************************************************************
N */
N///@{
N#define URT_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CR0 */
N#define URT_CR0_DMA_TXEN_mask_w                     ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DMA_TXEN_mask_h1                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DMA_TXEN_mask_b3                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DMA_TXEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_DMA_TXEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_DMA_TXEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_DMA_TXEN_enable_w                   ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_DMA_TXEN_enable_h1                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_DMA_TXEN_enable_b3                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_DMA_RXEN_mask_w                     ((uint32_t)0x40000000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DMA_RXEN_mask_h1                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DMA_RXEN_mask_b3                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DMA_RXEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_DMA_RXEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_DMA_RXEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_DMA_RXEN_enable_w                   ((uint32_t)0x40000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_DMA_RXEN_enable_h1                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_DMA_RXEN_enable_b3                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_DDTX_EN_mask_w                      ((uint32_t)0x20000000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DDTX_EN_mask_h1                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DDTX_EN_mask_b3                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DDTX_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_DDTX_EN_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_DDTX_EN_disable_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_DDTX_EN_enable_w                    ((uint32_t)0x20000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_DDTX_EN_enable_h1                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_DDTX_EN_enable_b3                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_LBM_EN_mask_w                       ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_LBM_EN_mask_h1                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_CR0_LBM_EN_mask_b2                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_CR0_LBM_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_LBM_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_LBM_EN_disable_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_LBM_EN_enable_w                     ((uint32_t)0x00800000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_LBM_EN_enable_h1                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_LBM_EN_enable_b2                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_NCHAR_DIS_mask_w                    ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_NCHAR_DIS_mask_h1                   ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_CR0_NCHAR_DIS_mask_b2                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_CR0_NCHAR_DIS_enable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define URT_CR0_NCHAR_DIS_enable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define URT_CR0_NCHAR_DIS_enable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define URT_CR0_NCHAR_DIS_disable_w                 ((uint32_t)0x00400000)  /*!< Bit Value =(1):Disable of 32bit */
N#define URT_CR0_NCHAR_DIS_disable_h1                ((uint16_t)0x0040)      /*!< Bit Value =(1):Disable of 16bit */
N#define URT_CR0_NCHAR_DIS_disable_b2                ((uint8_t )0x40)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define URT_CR0_NCHAR_HE_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_NCHAR_HE_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_CR0_NCHAR_HE_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CR0_NCHAR_HE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_NCHAR_HE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_NCHAR_HE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_NCHAR_HE_enable_w                   ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_NCHAR_HE_enable_h1                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_NCHAR_HE_enable_b2                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_IDL_MDS_mask_w                      ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_IDL_MDS_mask_h1                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CR0_IDL_MDS_mask_b2                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR0_IDL_MDS_no_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define URT_CR0_IDL_MDS_no_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define URT_CR0_IDL_MDS_no_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define URT_CR0_IDL_MDS_load_w                      ((uint32_t)0x00100000)  /*!< Bit Value =(1):Load of 32bit */
N#define URT_CR0_IDL_MDS_load_h1                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Load of 16bit */
N#define URT_CR0_IDL_MDS_load_b2                     ((uint8_t )0x10)        /*!< Bit Value =(1):Load of 8bit */
N
N#define URT_CR0_RX_TH_mask_w                        ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_RX_TH_mask_h1                       ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define URT_CR0_RX_TH_mask_b2                       ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define URT_CR0_RX_TH_1byte_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1byte of 32bit */
N#define URT_CR0_RX_TH_1byte_h1                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1byte of 16bit */
N#define URT_CR0_RX_TH_1byte_b2                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):1byte of 8bit */
N#define URT_CR0_RX_TH_2byte_w                       ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):2byte of 32bit */
N#define URT_CR0_RX_TH_2byte_h1                      ((uint16_t)0x0001)      /*!< Bit Value =(0x1):2byte of 16bit */
N#define URT_CR0_RX_TH_2byte_b2                      ((uint8_t )0x01)        /*!< Bit Value =(0x1):2byte of 8bit */
N#define URT_CR0_RX_TH_3byte_w                       ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):3byte of 32bit */
N#define URT_CR0_RX_TH_3byte_h1                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):3byte of 16bit */
N#define URT_CR0_RX_TH_3byte_b2                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):3byte of 8bit */
N#define URT_CR0_RX_TH_4byte_w                       ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):4byte of 32bit */
N#define URT_CR0_RX_TH_4byte_h1                      ((uint16_t)0x0003)      /*!< Bit Value =(0x3):4byte of 16bit */
N#define URT_CR0_RX_TH_4byte_b2                      ((uint8_t )0x03)        /*!< Bit Value =(0x3):4byte of 8bit */
N
N#define URT_CR0_DE_GT_mask_w                        ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DE_GT_mask_h0                       ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DE_GT_mask_b1                       ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DE_GT_1_4_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1/4 of 32bit */
N#define URT_CR0_DE_GT_1_4_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1/4 of 16bit */
N#define URT_CR0_DE_GT_1_4_b1                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):1/4 of 8bit */
N#define URT_CR0_DE_GT_1_2_w                         ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):1/2 of 32bit */
N#define URT_CR0_DE_GT_1_2_h0                        ((uint16_t)0x4000)      /*!< Bit Value =(0x1):1/2 of 16bit */
N#define URT_CR0_DE_GT_1_2_b1                        ((uint8_t )0x40)        /*!< Bit Value =(0x1):1/2 of 8bit */
N#define URT_CR0_DE_GT_1_w                           ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):1 of 32bit */
N#define URT_CR0_DE_GT_1_h0                          ((uint16_t)0x8000)      /*!< Bit Value =(0x2):1 of 16bit */
N#define URT_CR0_DE_GT_1_b1                          ((uint8_t )0x80)        /*!< Bit Value =(0x2):1 of 8bit */
N#define URT_CR0_DE_GT_2_w                           ((uint32_t)0x0000C000)  /*!< Bit Value =(0x3):2 of 32bit */
N#define URT_CR0_DE_GT_2_h0                          ((uint16_t)0xC000)      /*!< Bit Value =(0x3):2 of 16bit */
N#define URT_CR0_DE_GT_2_b1                          ((uint8_t )0xC0)        /*!< Bit Value =(0x3):2 of 8bit */
N
N#define URT_CR0_DE_INV_mask_w                       ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DE_INV_mask_h0                      ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DE_INV_mask_b1                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DE_INV_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_DE_INV_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_DE_INV_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_DE_INV_enable_w                     ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_DE_INV_enable_h0                    ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_DE_INV_enable_b1                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_DE_EN_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DE_EN_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DE_EN_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DE_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_DE_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_DE_EN_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_DE_EN_enable_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_DE_EN_enable_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_DE_EN_enable_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_TX_INV_mask_w                       ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define URT_CR0_TX_INV_mask_h0                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define URT_CR0_TX_INV_mask_b1                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_CR0_TX_INV_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_TX_INV_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_TX_INV_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_TX_INV_enable_w                     ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_TX_INV_enable_h0                    ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_TX_INV_enable_b1                    ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_RX_INV_mask_w                       ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define URT_CR0_RX_INV_mask_h0                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define URT_CR0_RX_INV_mask_b1                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR0_RX_INV_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_RX_INV_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_RX_INV_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_RX_INV_enable_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_RX_INV_enable_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_RX_INV_enable_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_IO_SWP_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define URT_CR0_IO_SWP_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define URT_CR0_IO_SWP_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_CR0_IO_SWP_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_IO_SWP_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_IO_SWP_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_IO_SWP_enable_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_IO_SWP_enable_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_IO_SWP_enable_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_GSA_EN_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_CR0_GSA_EN_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_CR0_GSA_EN_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_CR0_GSA_EN_shift_w                      (7)                     /*!< Bit Shift of 32bit */
N#define URT_CR0_GSA_EN_shift_h0                     (7)                     /*!< Bit Shift of 16bit */
N#define URT_CR0_GSA_EN_shift_b0                     (7)                     /*!< Bit Shift of 8bit */
N
N#define URT_CR0_MDS_mask_w                          ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define URT_CR0_MDS_mask_h0                         ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define URT_CR0_MDS_mask_b0                         ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define URT_CR0_MDS_uart_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):UART of 32bit */
N#define URT_CR0_MDS_uart_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):UART of 16bit */
N#define URT_CR0_MDS_uart_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0x0):UART of 8bit */
N#define URT_CR0_MDS_sync_w                          ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):SYNC of 32bit */
N#define URT_CR0_MDS_sync_h0                         ((uint16_t)0x0010)      /*!< Bit Value =(0x1):SYNC of 16bit */
N#define URT_CR0_MDS_sync_b0                         ((uint8_t )0x10)        /*!< Bit Value =(0x1):SYNC of 8bit */
N#define URT_CR0_MDS_idle_w                          ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):IDLE of 32bit */
N#define URT_CR0_MDS_idle_h0                         ((uint16_t)0x0020)      /*!< Bit Value =(0x2):IDLE of 16bit */
N#define URT_CR0_MDS_idle_b0                         ((uint8_t )0x20)        /*!< Bit Value =(0x2):IDLE of 8bit */
N#define URT_CR0_MDS_adr_w                           ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):ADR of 32bit */
N#define URT_CR0_MDS_adr_h0                          ((uint16_t)0x0030)      /*!< Bit Value =(0x3):ADR of 16bit */
N#define URT_CR0_MDS_adr_b0                          ((uint8_t )0x30)        /*!< Bit Value =(0x3):ADR of 8bit */
N
N#define URT_CR0_DAT_LINE_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define URT_CR0_DAT_LINE_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_CR0_DAT_LINE_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_CR0_DAT_LINE_2_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):2 of 32bit */
N#define URT_CR0_DAT_LINE_2_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):2 of 16bit */
N#define URT_CR0_DAT_LINE_2_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):2 of 8bit */
N#define URT_CR0_DAT_LINE_1_w                        ((uint32_t)0x00000008)  /*!< Bit Value =(1):1 of 32bit */
N#define URT_CR0_DAT_LINE_1_h0                       ((uint16_t)0x0008)      /*!< Bit Value =(1):1 of 16bit */
N#define URT_CR0_DAT_LINE_1_b0                       ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define URT_CR0_HDX_EN_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_CR0_HDX_EN_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_CR0_HDX_EN_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR0_HDX_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_HDX_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_HDX_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_HDX_EN_enable_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_HDX_EN_enable_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_HDX_EN_enable_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR0_OS_MDS_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_CR0_OS_MDS_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_CR0_OS_MDS_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_CR0_OS_MDS_three_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Three of 32bit */
N#define URT_CR0_OS_MDS_three_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Three of 16bit */
N#define URT_CR0_OS_MDS_three_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Three of 8bit */
N#define URT_CR0_OS_MDS_one_w                        ((uint32_t)0x00000002)  /*!< Bit Value =(1):One of 32bit */
N#define URT_CR0_OS_MDS_one_h0                       ((uint16_t)0x0002)      /*!< Bit Value =(1):One of 16bit */
N#define URT_CR0_OS_MDS_one_b0                       ((uint8_t )0x02)        /*!< Bit Value =(1):One of 8bit */
N
N#define URT_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CR1  [register's definitions]
N *              Offset[0x14]  URT control register 1
N ******************************************************************************
N */
N///@{
N#define URT_CR1_default                             ((uint32_t)0x0F400F40)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CR1 */
N#define URT_CR1_TXOS_NUM_mask_w                     ((uint32_t)0x1F000000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXOS_NUM_mask_h1                    ((uint16_t)0x1F00)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXOS_NUM_mask_b3                    ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXOS_NUM_shift_w                    (24)                    /*!< Bit Shift of 32bit */
N#define URT_CR1_TXOS_NUM_shift_h1                   (8)                     /*!< Bit Shift of 16bit */
N#define URT_CR1_TXOS_NUM_shift_b3                   (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_CR1_TXSTP_LEN_mask_w                    ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXSTP_LEN_mask_h1                   ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXSTP_LEN_mask_b2                   ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXSTP_LEN_0_5bit_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0.5bit of 32bit */
N#define URT_CR1_TXSTP_LEN_0_5bit_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0.5bit of 16bit */
N#define URT_CR1_TXSTP_LEN_0_5bit_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):0.5bit of 8bit */
N#define URT_CR1_TXSTP_LEN_1bit_w                    ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):1bit of 32bit */
N#define URT_CR1_TXSTP_LEN_1bit_h1                   ((uint16_t)0x0040)      /*!< Bit Value =(0x1):1bit of 16bit */
N#define URT_CR1_TXSTP_LEN_1bit_b2                   ((uint8_t )0x40)        /*!< Bit Value =(0x1):1bit of 8bit */
N#define URT_CR1_TXSTP_LEN_1_5bit_w                  ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):1.5bit of 32bit */
N#define URT_CR1_TXSTP_LEN_1_5bit_h1                 ((uint16_t)0x0080)      /*!< Bit Value =(0x2):1.5bit of 16bit */
N#define URT_CR1_TXSTP_LEN_1_5bit_b2                 ((uint8_t )0x80)        /*!< Bit Value =(0x2):1.5bit of 8bit */
N#define URT_CR1_TXSTP_LEN_2bit_w                    ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):2bit of 32bit */
N#define URT_CR1_TXSTP_LEN_2bit_h1                   ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):2bit of 16bit */
N#define URT_CR1_TXSTP_LEN_2bit_b2                   ((uint8_t )0xC0)        /*!< Bit Value =(0x3):2bit of 8bit */
N
N#define URT_CR1_TXMSB_EN_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXMSB_EN_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXMSB_EN_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXMSB_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR1_TXMSB_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR1_TXMSB_EN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR1_TXMSB_EN_enable_w                   ((uint32_t)0x00200000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR1_TXMSB_EN_enable_h1                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR1_TXMSB_EN_enable_b2                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR1_TXPAR_STK_mask_w                    ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXPAR_STK_mask_h1                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXPAR_STK_mask_b2                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXPAR_STK_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR1_TXPAR_STK_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR1_TXPAR_STK_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR1_TXPAR_STK_enable_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR1_TXPAR_STK_enable_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR1_TXPAR_STK_enable_b2                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR1_TXPAR_POL_mask_w                    ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXPAR_POL_mask_h1                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXPAR_POL_mask_b2                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXPAR_POL_even_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Even of 32bit */
N#define URT_CR1_TXPAR_POL_even_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Even of 16bit */
N#define URT_CR1_TXPAR_POL_even_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):Even of 8bit */
N#define URT_CR1_TXPAR_POL_odd_w                     ((uint32_t)0x00080000)  /*!< Bit Value =(0x1):Odd of 32bit */
N#define URT_CR1_TXPAR_POL_odd_h1                    ((uint16_t)0x0008)      /*!< Bit Value =(0x1):Odd of 16bit */
N#define URT_CR1_TXPAR_POL_odd_b2                    ((uint8_t )0x08)        /*!< Bit Value =(0x1):Odd of 8bit */
N
N#define URT_CR1_TXPAR_EN_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXPAR_EN_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXPAR_EN_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXPAR_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR1_TXPAR_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR1_TXPAR_EN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR1_TXPAR_EN_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR1_TXPAR_EN_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR1_TXPAR_EN_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR1_TXDSIZE_mask_w                      ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define URT_CR1_TXDSIZE_mask_h1                     ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define URT_CR1_TXDSIZE_mask_b2                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define URT_CR1_TXDSIZE_8bit_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):8bit of 32bit */
N#define URT_CR1_TXDSIZE_8bit_h1                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):8bit of 16bit */
N#define URT_CR1_TXDSIZE_8bit_b2                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):8bit of 8bit */
N#define URT_CR1_TXDSIZE_7bit_w                      ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):7bit of 32bit */
N#define URT_CR1_TXDSIZE_7bit_h1                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):7bit of 16bit */
N#define URT_CR1_TXDSIZE_7bit_b2                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):7bit of 8bit */
N
N#define URT_CR1_RXOS_NUM_mask_w                     ((uint32_t)0x00001F00)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXOS_NUM_mask_h0                    ((uint16_t)0x1F00)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXOS_NUM_mask_b1                    ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXOS_NUM_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define URT_CR1_RXOS_NUM_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define URT_CR1_RXOS_NUM_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_CR1_RXSTP_LEN_mask_w                    ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXSTP_LEN_mask_h0                   ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXSTP_LEN_mask_b0                   ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXSTP_LEN_0_5bit_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0.5bit of 32bit */
N#define URT_CR1_RXSTP_LEN_0_5bit_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0.5bit of 16bit */
N#define URT_CR1_RXSTP_LEN_0_5bit_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):0.5bit of 8bit */
N#define URT_CR1_RXSTP_LEN_1bit_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):1bit of 32bit */
N#define URT_CR1_RXSTP_LEN_1bit_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(0x1):1bit of 16bit */
N#define URT_CR1_RXSTP_LEN_1bit_b0                   ((uint8_t )0x40)        /*!< Bit Value =(0x1):1bit of 8bit */
N#define URT_CR1_RXSTP_LEN_2bit_w                    ((uint32_t)0x000000C0)  /*!< Bit Value =(0x3):2bit of 32bit */
N#define URT_CR1_RXSTP_LEN_2bit_h0                   ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):2bit of 16bit */
N#define URT_CR1_RXSTP_LEN_2bit_b0                   ((uint8_t )0xC0)        /*!< Bit Value =(0x3):2bit of 8bit */
N
N#define URT_CR1_RXMSB_EN_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXMSB_EN_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXMSB_EN_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXMSB_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR1_RXMSB_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR1_RXMSB_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR1_RXMSB_EN_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR1_RXMSB_EN_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR1_RXMSB_EN_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR1_RXPAR_STK_mask_w                    ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXPAR_STK_mask_h0                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXPAR_STK_mask_b0                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXPAR_STK_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR1_RXPAR_STK_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR1_RXPAR_STK_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR1_RXPAR_STK_enable_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR1_RXPAR_STK_enable_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR1_RXPAR_STK_enable_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR1_RXPAR_POL_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXPAR_POL_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXPAR_POL_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXPAR_POL_even_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Even of 32bit */
N#define URT_CR1_RXPAR_POL_even_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Even of 16bit */
N#define URT_CR1_RXPAR_POL_even_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):Even of 8bit */
N#define URT_CR1_RXPAR_POL_odd_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(0x1):Odd of 32bit */
N#define URT_CR1_RXPAR_POL_odd_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(0x1):Odd of 16bit */
N#define URT_CR1_RXPAR_POL_odd_b0                    ((uint8_t )0x08)        /*!< Bit Value =(0x1):Odd of 8bit */
N
N#define URT_CR1_RXPAR_EN_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXPAR_EN_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXPAR_EN_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXPAR_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR1_RXPAR_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR1_RXPAR_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR1_RXPAR_EN_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR1_RXPAR_EN_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR1_RXPAR_EN_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR1_RXDSIZE_mask_w                      ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define URT_CR1_RXDSIZE_mask_h0                     ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define URT_CR1_RXDSIZE_mask_b0                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define URT_CR1_RXDSIZE_8bit_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):8bit of 32bit */
N#define URT_CR1_RXDSIZE_8bit_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):8bit of 16bit */
N#define URT_CR1_RXDSIZE_8bit_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):8bit of 8bit */
N#define URT_CR1_RXDSIZE_7bit_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):7bit of 32bit */
N#define URT_CR1_RXDSIZE_7bit_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(0x1):7bit of 16bit */
N#define URT_CR1_RXDSIZE_7bit_b0                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):7bit of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CR2  [register's definitions]
N *              Offset[0x18]  URT control register 2
N ******************************************************************************
N */
N///@{
N#define URT_CR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CR2 */
N#define URT_CR2_NSS_SWEN_mask_w                     ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define URT_CR2_NSS_SWEN_mask_h1                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define URT_CR2_NSS_SWEN_mask_b3                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR2_NSS_SWEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR2_NSS_SWEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR2_NSS_SWEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR2_NSS_SWEN_enable_w                   ((uint32_t)0x04000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR2_NSS_SWEN_enable_h1                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR2_NSS_SWEN_enable_b3                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR2_NSS_INV_mask_w                      ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define URT_CR2_NSS_INV_mask_h1                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define URT_CR2_NSS_INV_mask_b3                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_CR2_NSS_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR2_NSS_INV_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR2_NSS_INV_disable_b3                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR2_NSS_INV_enable_w                    ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR2_NSS_INV_enable_h1                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR2_NSS_INV_enable_b3                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR2_NSS_SWO_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define URT_CR2_NSS_SWO_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_CR2_NSS_SWO_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_CR2_NSS_SWO_shift_w                     (16)                    /*!< Bit Shift of 32bit */
N#define URT_CR2_NSS_SWO_shift_h1                    (0)                     /*!< Bit Shift of 16bit */
N#define URT_CR2_NSS_SWO_shift_b2                    (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_CR2_TX_HALT_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_CR2_TX_HALT_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CR2_TX_HALT_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR2_TX_HALT_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR2_TX_HALT_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR2_TX_HALT_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR2_TX_HALT_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR2_TX_HALT_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR2_TX_HALT_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR2_TX_EN_mask_w                        ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define URT_CR2_TX_EN_mask_h0                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_CR2_TX_EN_mask_b0                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_CR2_TX_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR2_TX_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR2_TX_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR2_TX_EN_enable_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR2_TX_EN_enable_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR2_TX_EN_enable_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR2_RX_EN_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_CR2_RX_EN_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_CR2_RX_EN_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR2_RX_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR2_RX_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR2_RX_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR2_RX_EN_enable_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR2_RX_EN_enable_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR2_RX_EN_enable_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR2_ADR_TX_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_CR2_ADR_TX_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_CR2_ADR_TX_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_CR2_ADR_TX_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_CR2_ADR_TX_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_CR2_ADR_TX_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_CR2_ADR_TX_send_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Send of 32bit */
N#define URT_CR2_ADR_TX_send_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Send of 16bit */
N#define URT_CR2_ADR_TX_send_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Send of 8bit */
N
N#define URT_CR2_BK_TX_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_CR2_BK_TX_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_CR2_BK_TX_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_CR2_BK_TX_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define URT_CR2_BK_TX_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define URT_CR2_BK_TX_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define URT_CR2_BK_TX_send_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Send of 32bit */
N#define URT_CR2_BK_TX_send_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Send of 16bit */
N#define URT_CR2_BK_TX_send_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Send of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CR3  [register's definitions]
N *              Offset[0x1C]  URT control register 3
N ******************************************************************************
N */
N///@{
N#define URT_CR3_default                             ((uint32_t)0x00000A00)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CR3 */
N#define URT_CR3_TXGT_LEN_mask_w                     ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define URT_CR3_TXGT_LEN_mask_h1                    ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_CR3_TXGT_LEN_mask_b2                    ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N#define URT_CR3_DET_IDL_mask_w                      ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define URT_CR3_DET_IDL_mask_h0                     ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define URT_CR3_DET_IDL_mask_b1                     ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_CR3_DET_IDL_shift_w                     (8)                     /*!< Bit Shift of 32bit */
N#define URT_CR3_DET_IDL_shift_h0                    (8)                     /*!< Bit Shift of 16bit */
N#define URT_CR3_DET_IDL_shift_b1                    (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_CR3_DET_BK_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_CR3_DET_BK_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CR3_DET_BK_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR3_DET_BK_1bit_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1Bit of 32bit */
N#define URT_CR3_DET_BK_1bit_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1Bit of 16bit */
N#define URT_CR3_DET_BK_1bit_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):1Bit of 8bit */
N#define URT_CR3_DET_BK_3bit_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):3Bit of 32bit */
N#define URT_CR3_DET_BK_3bit_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):3Bit of 16bit */
N#define URT_CR3_DET_BK_3bit_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):3Bit of 8bit */
N
N#define URT_CR3_CPHA_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_CR3_CPHA_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_CR3_CPHA_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_CR3_CPHA_leading_edge_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Leading edge of 32bit */
N#define URT_CR3_CPHA_leading_edge_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Leading edge of 16bit */
N#define URT_CR3_CPHA_leading_edge_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Leading edge of 8bit */
N#define URT_CR3_CPHA_trailing_edge_w                ((uint32_t)0x00000004)  /*!< Bit Value =(1):Trailing edge of 32bit */
N#define URT_CR3_CPHA_trailing_edge_h0               ((uint16_t)0x0004)      /*!< Bit Value =(1):Trailing edge of 16bit */
N#define URT_CR3_CPHA_trailing_edge_b0               ((uint8_t )0x04)        /*!< Bit Value =(1):Trailing edge of 8bit */
N
N#define URT_CR3_CPOL_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_CR3_CPOL_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_CR3_CPOL_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_CR3_CPOL_low_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):Low of 32bit */
N#define URT_CR3_CPOL_low_h0                         ((uint16_t)0x0000)      /*!< Bit Value =(0):Low of 16bit */
N#define URT_CR3_CPOL_low_b0                         ((uint8_t )0x00)        /*!< Bit Value =(0):Low of 8bit */
N#define URT_CR3_CPOL_high_w                         ((uint32_t)0x00000002)  /*!< Bit Value =(1):High of 32bit */
N#define URT_CR3_CPOL_high_h0                        ((uint16_t)0x0002)      /*!< Bit Value =(1):High of 16bit */
N#define URT_CR3_CPOL_high_b0                        ((uint8_t )0x02)        /*!< Bit Value =(1):High of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CR4  [register's definitions]
N *              Offset[0x20]  URT control register 4
N ******************************************************************************
N */
N///@{
N#define URT_CR4_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CR4 */
N#define URT_CR4_TNUM_mask_w                         ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define URT_CR4_TNUM_mask_h0                        ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define URT_CR4_TNUM_mask_b1                        ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define URT_CR4_TNUM_0_w                            ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define URT_CR4_TNUM_0_h0                           ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define URT_CR4_TNUM_0_b1                           ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define URT_CR4_TNUM_1_w                            ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):1 of 32bit */
N#define URT_CR4_TNUM_1_h0                           ((uint16_t)0x1000)      /*!< Bit Value =(0x1):1 of 16bit */
N#define URT_CR4_TNUM_1_b1                           ((uint8_t )0x10)        /*!< Bit Value =(0x1):1 of 8bit */
N#define URT_CR4_TNUM_2_w                            ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):2 of 32bit */
N#define URT_CR4_TNUM_2_h0                           ((uint16_t)0x2000)      /*!< Bit Value =(0x2):2 of 16bit */
N#define URT_CR4_TNUM_2_b1                           ((uint8_t )0x20)        /*!< Bit Value =(0x2):2 of 8bit */
N#define URT_CR4_TNUM_3_w                            ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):3 of 32bit */
N#define URT_CR4_TNUM_3_h0                           ((uint16_t)0x3000)      /*!< Bit Value =(0x3):3 of 16bit */
N#define URT_CR4_TNUM_3_b1                           ((uint8_t )0x30)        /*!< Bit Value =(0x3):3 of 8bit */
N#define URT_CR4_TNUM_4_w                            ((uint32_t)0x00004000)  /*!< Bit Value =(0x4):4 of 32bit */
N#define URT_CR4_TNUM_4_h0                           ((uint16_t)0x4000)      /*!< Bit Value =(0x4):4 of 16bit */
N#define URT_CR4_TNUM_4_b1                           ((uint8_t )0x40)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define URT_CR4_RNUM_mask_w                         ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define URT_CR4_RNUM_mask_h0                        ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define URT_CR4_RNUM_mask_b1                        ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define URT_CR4_RNUM_0_w                            ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0 of 32bit */
N#define URT_CR4_RNUM_0_h0                           ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0 of 16bit */
N#define URT_CR4_RNUM_0_b1                           ((uint8_t )0x00)        /*!< Bit Value =(0x0):0 of 8bit */
N#define URT_CR4_RNUM_1_w                            ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):1 of 32bit */
N#define URT_CR4_RNUM_1_h0                           ((uint16_t)0x0100)      /*!< Bit Value =(0x1):1 of 16bit */
N#define URT_CR4_RNUM_1_b1                           ((uint8_t )0x01)        /*!< Bit Value =(0x1):1 of 8bit */
N#define URT_CR4_RNUM_2_w                            ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):2 of 32bit */
N#define URT_CR4_RNUM_2_h0                           ((uint16_t)0x0200)      /*!< Bit Value =(0x2):2 of 16bit */
N#define URT_CR4_RNUM_2_b1                           ((uint8_t )0x02)        /*!< Bit Value =(0x2):2 of 8bit */
N#define URT_CR4_RNUM_3_w                            ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):3 of 32bit */
N#define URT_CR4_RNUM_3_h0                           ((uint16_t)0x0300)      /*!< Bit Value =(0x3):3 of 16bit */
N#define URT_CR4_RNUM_3_b1                           ((uint8_t )0x03)        /*!< Bit Value =(0x3):3 of 8bit */
N#define URT_CR4_RNUM_4_w                            ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):4 of 32bit */
N#define URT_CR4_RNUM_4_h0                           ((uint16_t)0x0400)      /*!< Bit Value =(0x4):4 of 16bit */
N#define URT_CR4_RNUM_4_b1                           ((uint8_t )0x04)        /*!< Bit Value =(0x4):4 of 8bit */
N
N#define URT_CR4_TDAT_CLR_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_CR4_TDAT_CLR_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_CR4_TDAT_CLR_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_CR4_TDAT_CLR_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR4_TDAT_CLR_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR4_TDAT_CLR_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR4_TDAT_CLR_enable_w                   ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR4_TDAT_CLR_enable_h0                  ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR4_TDAT_CLR_enable_b0                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR4_RDAT_CLR_mask_w                     ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define URT_CR4_RDAT_CLR_mask_h0                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_CR4_RDAT_CLR_mask_b0                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_CR4_RDAT_CLR_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR4_RDAT_CLR_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR4_RDAT_CLR_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR4_RDAT_CLR_enable_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR4_RDAT_CLR_enable_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR4_RDAT_CLR_enable_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR4_TDAT_INV_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define URT_CR4_TDAT_INV_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_CR4_TDAT_INV_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_CR4_TDAT_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR4_TDAT_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR4_TDAT_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR4_TDAT_INV_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR4_TDAT_INV_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR4_TDAT_INV_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CR4_RDAT_INV_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_CR4_RDAT_INV_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_CR4_RDAT_INV_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_CR4_RDAT_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CR4_RDAT_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CR4_RDAT_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CR4_RDAT_INV_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CR4_RDAT_INV_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CR4_RDAT_INV_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_RLR  [register's definitions]
N *              Offset[0x24]  URT baud-rate clock counter reload register
N ******************************************************************************
N */
N///@{
N#define URT_RLR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_RLR */
N#define URT_RLR_PSR_mask_w                          ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define URT_RLR_PSR_mask_h0                         ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define URT_RLR_PSR_mask_b1                         ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define URT_RLR_PSR_shift_w                         (8)                     /*!< Bit Shift of 32bit */
N#define URT_RLR_PSR_shift_h0                        (8)                     /*!< Bit Shift of 16bit */
N#define URT_RLR_PSR_shift_b1                        (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_RLR_RLR_mask_w                          ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define URT_RLR_RLR_mask_h0                         ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_RLR_RLR_mask_b0                         ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_RLR_RLR_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define URT_RLR_RLR_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define URT_RLR_RLR_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CNT  [register's definitions]
N *              Offset[0x28]  URT baud-rate clock counter register
N ******************************************************************************
N */
N///@{
N#define URT_CNT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CNT */
N#define URT_CNT_PSC_mask_w                          ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define URT_CNT_PSC_mask_h0                         ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define URT_CNT_PSC_mask_b1                         ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define URT_CNT_PSC_shift_w                         (8)                     /*!< Bit Shift of 32bit */
N#define URT_CNT_PSC_shift_h0                        (8)                     /*!< Bit Shift of 16bit */
N#define URT_CNT_PSC_shift_b1                        (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_CNT_CNT_mask_w                          ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define URT_CNT_CNT_mask_h0                         ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_CNT_CNT_mask_b0                         ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_CNT_CNT_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define URT_CNT_CNT_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define URT_CNT_CNT_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_RCAP  [register's definitions]
N *              Offset[0x2C]  URT RX data capture register
N ******************************************************************************
N */
N///@{
N#define URT_RCAP_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_RCAP */
N#define URT_RCAP_RCAP_ADR_mask_w                    ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define URT_RCAP_RCAP_ADR_mask_h0                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define URT_RCAP_RCAP_ADR_mask_b1                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_RCAP_RCAP_ADR_shift_w                   (10)                    /*!< Bit Shift of 32bit */
N#define URT_RCAP_RCAP_ADR_shift_h0                  (10)                    /*!< Bit Shift of 16bit */
N#define URT_RCAP_RCAP_ADR_shift_b1                  (2)                     /*!< Bit Shift of 8bit */
N
N#define URT_RCAP_RCAP_PAR_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define URT_RCAP_RCAP_PAR_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define URT_RCAP_RCAP_PAR_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_RCAP_RCAP_PAR_shift_w                   (9)                     /*!< Bit Shift of 32bit */
N#define URT_RCAP_RCAP_PAR_shift_h0                  (9)                     /*!< Bit Shift of 16bit */
N#define URT_RCAP_RCAP_PAR_shift_b1                  (1)                     /*!< Bit Shift of 8bit */
N
N#define URT_RCAP_RCAP_STP_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define URT_RCAP_RCAP_STP_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define URT_RCAP_RCAP_STP_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_RCAP_RCAP_STP_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define URT_RCAP_RCAP_STP_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define URT_RCAP_RCAP_STP_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_RCAP_RCAP_DAT_mask_w                    ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define URT_RCAP_RCAP_DAT_mask_h0                   ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_RCAP_RCAP_DAT_mask_b0                   ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_RCAP_RCAP_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define URT_RCAP_RCAP_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define URT_RCAP_RCAP_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_RDAT  [register's definitions]
N *              Offset[0x30]  URT RX data register
N ******************************************************************************
N */
N///@{
N#define URT_RDAT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_RDAT */
N#define URT_RDAT_RDAT_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define URT_RDAT_RDAT_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define URT_RDAT_RDAT_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define URT_RDAT_RDAT_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_TDAT  [register's definitions]
N *              Offset[0x34]  URT TX data register
N ******************************************************************************
N */
N///@{
N#define URT_TDAT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_TDAT */
N#define URT_TDAT_TDAT_mask_w                        ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define URT_TDAT_TDAT_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define URT_TDAT_TDAT_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define URT_TDAT_TDAT_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_TDAT3  [register's definitions]
N *              Offset[0x38]  URT TX data 3-byte register
N ******************************************************************************
N */
N///@{
N#define URT_TDAT3_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_TDAT3 */
N#define URT_TDAT3_TDAT3_mask_w                      ((uint32_t)0x00FFFFFF)  /*!< Bit Mask of 32bit */
N#define URT_TDAT3_TDAT3_shift_w                     (0)                     /*!< Bit Shift of 32bit */
N#define URT_TDAT3_TDAT3_shift_h0                    (0)                     /*!< Bit Shift of 16bit */
N#define URT_TDAT3_TDAT3_shift_b0                    (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_SBUF  [register's definitions]
N *              Offset[0x3C]  URT data shift buffer register
N ******************************************************************************
N */
N///@{
N#define URT_SBUF_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_SBUF */
N#define URT_SBUF_TSBUF_mask_w                       ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define URT_SBUF_TSBUF_mask_h0                      ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define URT_SBUF_TSBUF_mask_b1                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_SBUF_TSBUF_shift_w                      (8)                     /*!< Bit Shift of 32bit */
N#define URT_SBUF_TSBUF_shift_h0                     (8)                     /*!< Bit Shift of 16bit */
N#define URT_SBUF_TSBUF_shift_b1                     (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_SBUF_RSBUF_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define URT_SBUF_RSBUF_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_SBUF_RSBUF_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_SBUF_RSBUF_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define URT_SBUF_RSBUF_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define URT_SBUF_RSBUF_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_TMOUT  [register's definitions]
N *              Offset[0x40]  URT timeout control register
N ******************************************************************************
N */
N///@{
N#define URT_TMOUT_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_TMOUT */
N#define URT_TMOUT_CALTMO_TH_mask_w                  ((uint32_t)0xF0000000)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_CALTMO_TH_mask_h1                 ((uint16_t)0xF000)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_CALTMO_TH_mask_b3                 ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_CALTMO_TH_shift_w                 (28)                    /*!< Bit Shift of 32bit */
N#define URT_TMOUT_CALTMO_TH_shift_h1                (12)                    /*!< Bit Shift of 16bit */
N#define URT_TMOUT_CALTMO_TH_shift_b3                (4)                     /*!< Bit Shift of 8bit */
N
N#define URT_TMOUT_BKTMO_TH_mask_w                   ((uint32_t)0x0F000000)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_BKTMO_TH_mask_h1                  ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_BKTMO_TH_mask_b3                  ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_BKTMO_TH_shift_w                  (24)                    /*!< Bit Shift of 32bit */
N#define URT_TMOUT_BKTMO_TH_shift_h1                 (8)                     /*!< Bit Shift of 16bit */
N#define URT_TMOUT_BKTMO_TH_shift_b3                 (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_TMOUT_RXTMO_TH_mask_w                   ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_RXTMO_TH_mask_h1                  ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_RXTMO_TH_mask_b2                  ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_RXTMO_TH_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define URT_TMOUT_RXTMO_TH_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define URT_TMOUT_RXTMO_TH_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_TMOUT_TMO_LCK_mask_w                    ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_TMO_LCK_mask_h0                   ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_TMO_LCK_mask_b1                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_TMO_LCK_locked_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define URT_TMOUT_TMO_LCK_locked_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define URT_TMOUT_TMO_LCK_locked_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define URT_TMOUT_TMO_LCK_un_locked_w               ((uint32_t)0x00008000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define URT_TMOUT_TMO_LCK_un_locked_h0              ((uint16_t)0x8000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define URT_TMOUT_TMO_LCK_un_locked_b1              ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define URT_TMOUT_TMO_STA_mask_w                    ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_TMO_STA_mask_h0                   ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_TMO_STA_mask_b1                   ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_TMO_STA_0_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define URT_TMOUT_TMO_STA_0_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define URT_TMOUT_TMO_STA_0_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define URT_TMOUT_TMO_STA_1_w                       ((uint32_t)0x00004000)  /*!< Bit Value =(1):1 of 32bit */
N#define URT_TMOUT_TMO_STA_1_h0                      ((uint16_t)0x4000)      /*!< Bit Value =(1):1 of 16bit */
N#define URT_TMOUT_TMO_STA_1_b1                      ((uint8_t )0x40)        /*!< Bit Value =(1):1 of 8bit */
N
N#define URT_TMOUT_TMO_CKS_mask_w                    ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_TMO_CKS_mask_h0                   ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_TMO_CKS_mask_b1                   ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_TMO_CKS_uart_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):UART of 32bit */
N#define URT_TMOUT_TMO_CKS_uart_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):UART of 16bit */
N#define URT_TMOUT_TMO_CKS_uart_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):UART of 8bit */
N#define URT_TMOUT_TMO_CKS_input_w                   ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Input of 32bit */
N#define URT_TMOUT_TMO_CKS_input_h0                  ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Input of 16bit */
N#define URT_TMOUT_TMO_CKS_input_b1                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):Input of 8bit */
N#define URT_TMOUT_TMO_CKS_noise_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Noise of 32bit */
N#define URT_TMOUT_TMO_CKS_noise_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Noise of 16bit */
N#define URT_TMOUT_TMO_CKS_noise_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Noise of 8bit */
N
N#define URT_TMOUT_CALTMO_EN_mask_w                  ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_CALTMO_EN_mask_h0                 ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_CALTMO_EN_mask_b0                 ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_CALTMO_EN_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_TMOUT_CALTMO_EN_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_TMOUT_CALTMO_EN_disable_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_TMOUT_CALTMO_EN_enable_w                ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_TMOUT_CALTMO_EN_enable_h0               ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_TMOUT_CALTMO_EN_enable_b0               ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_TMOUT_BKTMO_EN_mask_w                   ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_BKTMO_EN_mask_h0                  ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_BKTMO_EN_mask_b0                  ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_BKTMO_EN_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_TMOUT_BKTMO_EN_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_TMOUT_BKTMO_EN_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_TMOUT_BKTMO_EN_enable_w                 ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_TMOUT_BKTMO_EN_enable_h0                ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_TMOUT_BKTMO_EN_enable_b0                ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_TMOUT_RXTMO_EN_mask_w                   ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_RXTMO_EN_mask_h0                  ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_RXTMO_EN_mask_b0                  ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_RXTMO_EN_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_TMOUT_RXTMO_EN_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_TMOUT_RXTMO_EN_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_TMOUT_RXTMO_EN_enable_w                 ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_TMOUT_RXTMO_EN_enable_h0                ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_TMOUT_RXTMO_EN_enable_b0                ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_TMOUT_IDTMO_EN_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_IDTMO_EN_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_IDTMO_EN_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_IDTMO_EN_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_TMOUT_IDTMO_EN_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_TMOUT_IDTMO_EN_disable_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_TMOUT_IDTMO_EN_enable_w                 ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_TMOUT_IDTMO_EN_enable_h0                ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_TMOUT_IDTMO_EN_enable_b0                ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_TMOUT_TMO_MDS_mask_w                    ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_TMO_MDS_mask_h0                   ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_TMO_MDS_mask_b0                   ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_TMO_MDS_uart_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):UART of 32bit */
N#define URT_TMOUT_TMO_MDS_uart_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):UART of 16bit */
N#define URT_TMOUT_TMO_MDS_uart_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):UART of 8bit */
N#define URT_TMOUT_TMO_MDS_general_w                 ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):General of 32bit */
N#define URT_TMOUT_TMO_MDS_general_h0                ((uint16_t)0x0004)      /*!< Bit Value =(0x1):General of 16bit */
N#define URT_TMOUT_TMO_MDS_general_b0                ((uint8_t )0x04)        /*!< Bit Value =(0x1):General of 8bit */
N
N#define URT_TMOUT_TMO_RST_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_TMO_RST_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_TMO_RST_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_TMO_RST_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_TMOUT_TMO_RST_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_TMOUT_TMO_RST_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_TMOUT_TMO_RST_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_TMOUT_TMO_RST_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_TMOUT_TMO_RST_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_TMOUT_TMO_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT_TMO_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT_TMO_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_TMOUT_TMO_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_TMOUT_TMO_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_TMOUT_TMO_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_TMOUT_TMO_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_TMOUT_TMO_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_TMOUT_TMO_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_TMOUT2  [register's definitions]
N *              Offset[0x44]  URT timeout control register 2
N ******************************************************************************
N */
N///@{
N#define URT_TMOUT2_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_TMOUT2 */
N#define URT_TMOUT2_TMO_CNT_mask_w                   ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT2_TMO_CNT_mask_h1                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT2_TMO_CNT_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define URT_TMOUT2_TMO_CNT_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define URT_TMOUT2_TMO_CNT_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_TMOUT2_IDTMO_TH_mask_w                  ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define URT_TMOUT2_IDTMO_TH_mask_h0                 ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define URT_TMOUT2_IDTMO_TH_shift_w                 (0)                     /*!< Bit Shift of 32bit */
N#define URT_TMOUT2_IDTMO_TH_shift_h0                (0)                     /*!< Bit Shift of 16bit */
N#define URT_TMOUT2_IDTMO_TH_shift_b0                (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_SC  [register's definitions]
N *              Offset[0x48]  URT SmartCard control register
N ******************************************************************************
N */
N///@{
N#define URT_SC_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_SC */
N#define URT_SC_RXE_NUM_mask_w                       ((uint32_t)0x00007000)  /*!< Bit Mask of 32bit */
N#define URT_SC_RXE_NUM_mask_h0                      ((uint16_t)0x7000)      /*!< Bit Mask of 16bit */
N#define URT_SC_RXE_NUM_mask_b1                      ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define URT_SC_RXE_NUM_shift_w                      (12)                    /*!< Bit Shift of 32bit */
N#define URT_SC_RXE_NUM_shift_h0                     (12)                    /*!< Bit Shift of 16bit */
N#define URT_SC_RXE_NUM_shift_b1                     (4)                     /*!< Bit Shift of 8bit */
N
N#define URT_SC_TXE_NUM_mask_w                       ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define URT_SC_TXE_NUM_mask_h0                      ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define URT_SC_TXE_NUM_mask_b1                      ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define URT_SC_TXE_NUM_shift_w                      (8)                     /*!< Bit Shift of 32bit */
N#define URT_SC_TXE_NUM_shift_h0                     (8)                     /*!< Bit Shift of 16bit */
N#define URT_SC_TXE_NUM_shift_b1                     (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_SC_RXE_LEN_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_SC_RXE_LEN_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_SC_RXE_LEN_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_SC_RXE_LEN_1bit_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):1Bit of 32bit */
N#define URT_SC_RXE_LEN_1bit_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):1Bit of 16bit */
N#define URT_SC_RXE_LEN_1bit_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):1Bit of 8bit */
N#define URT_SC_RXE_LEN_2bit_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):2Bit of 32bit */
N#define URT_SC_RXE_LEN_2bit_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):2Bit of 16bit */
N#define URT_SC_RXE_LEN_2bit_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):2Bit of 8bit */
N
N#define URT_SC_TXE_MDS_mask_w                       ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define URT_SC_TXE_MDS_mask_h0                      ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define URT_SC_TXE_MDS_mask_b0                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define URT_SC_TXE_MDS_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define URT_SC_TXE_MDS_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define URT_SC_TXE_MDS_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define URT_SC_TXE_MDS_chk_low_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):CHK_Low of 32bit */
N#define URT_SC_TXE_MDS_chk_low_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CHK_Low of 16bit */
N#define URT_SC_TXE_MDS_chk_low_b0                   ((uint8_t )0x04)        /*!< Bit Value =(0x1):CHK_Low of 8bit */
N#define URT_SC_TXE_MDS_chk_tx_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):CHK_TX of 32bit */
N#define URT_SC_TXE_MDS_chk_tx_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(0x2):CHK_TX of 16bit */
N#define URT_SC_TXE_MDS_chk_tx_b0                    ((uint8_t )0x08)        /*!< Bit Value =(0x2):CHK_TX of 8bit */
N
N#define URT_SC_RXE_MDS_mask_w                       ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define URT_SC_RXE_MDS_mask_h0                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define URT_SC_RXE_MDS_mask_b0                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define URT_SC_RXE_MDS_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define URT_SC_RXE_MDS_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define URT_SC_RXE_MDS_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define URT_SC_RXE_MDS_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Enable of 32bit */
N#define URT_SC_RXE_MDS_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Enable of 16bit */
N#define URT_SC_RXE_MDS_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):Enable of 8bit */
N#define URT_SC_RXE_MDS_auto_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Auto of 32bit */
N#define URT_SC_RXE_MDS_auto_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Auto of 16bit */
N#define URT_SC_RXE_MDS_auto_b0                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):Auto of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_SADR  [register's definitions]
N *              Offset[0x4C]  URT slave address detect register
N ******************************************************************************
N */
N///@{
N#define URT_SADR_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_SADR */
N#define URT_SADR_SA_MSK_mask_w                      ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define URT_SADR_SA_MSK_mask_h0                     ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define URT_SADR_SA_MSK_mask_b1                     ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define URT_SADR_SA_MSK_shift_w                     (8)                     /*!< Bit Shift of 32bit */
N#define URT_SADR_SA_MSK_shift_h0                    (8)                     /*!< Bit Shift of 16bit */
N#define URT_SADR_SA_MSK_shift_b1                    (0)                     /*!< Bit Shift of 8bit */
N
N#define URT_SADR_SA_RX_mask_w                       ((uint32_t)0x000000FF)  /*!< Bit Mask of 32bit */
N#define URT_SADR_SA_RX_mask_h0                      ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define URT_SADR_SA_RX_mask_b0                      ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_CAL  [register's definitions]
N *              Offset[0x50]  URT calibration control register
N ******************************************************************************
N */
N///@{
N#define URT_CAL_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_CAL */
N#define URT_CAL_CALC_HE_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define URT_CAL_CALC_HE_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define URT_CAL_CALC_HE_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define URT_CAL_CALC_HE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CAL_CALC_HE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CAL_CALC_HE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CAL_CALC_HE_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CAL_CALC_HE_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CAL_CALC_HE_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CAL_CAL_MDS_mask_w                      ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define URT_CAL_CAL_MDS_mask_h0                     ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define URT_CAL_CAL_MDS_mask_b0                     ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define URT_CAL_CAL_MDS_start_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Start of 32bit */
N#define URT_CAL_CAL_MDS_start_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Start of 16bit */
N#define URT_CAL_CAL_MDS_start_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):Start of 8bit */
N#define URT_CAL_CAL_MDS_edge_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):Edge of 32bit */
N#define URT_CAL_CAL_MDS_edge_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(0x1):Edge of 16bit */
N#define URT_CAL_CAL_MDS_edge_b0                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):Edge of 8bit */
N
N#define URT_CAL_CAL_AUTO_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_CAL_CAL_AUTO_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_CAL_CAL_AUTO_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_CAL_CAL_AUTO_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CAL_CAL_AUTO_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CAL_CAL_AUTO_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CAL_CAL_AUTO_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CAL_CAL_AUTO_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CAL_CAL_AUTO_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_CAL_CAL_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_CAL_CAL_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_CAL_CAL_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_CAL_CAL_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_CAL_CAL_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_CAL_CAL_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_CAL_CAL_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_CAL_CAL_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_CAL_CAL_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_IRDA  [register's definitions]
N *              Offset[0x54]  URT IrDA control register
N ******************************************************************************
N */
N///@{
N#define URT_IRDA_default                            ((uint32_t)0x00000300)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_IRDA */
N#define URT_IRDA_IR_PW_mask_w                       ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define URT_IRDA_IR_PW_mask_h0                      ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define URT_IRDA_IR_PW_mask_b1                      ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N
N#define URT_IRDA_IR_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_IRDA_IR_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_IRDA_IR_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_IRDA_IR_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_IRDA_IR_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_IRDA_IR_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_IRDA_IR_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_IRDA_IR_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_IRDA_IR_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_HFC  [register's definitions]
N *              Offset[0x58]  URT hardware flow control register
N ******************************************************************************
N */
N///@{
N#define URT_HFC_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_HFC */
N#define URT_HFC_RTS_OUT_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define URT_HFC_RTS_OUT_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define URT_HFC_RTS_OUT_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define URT_HFC_RTS_OUT_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define URT_HFC_RTS_OUT_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define URT_HFC_RTS_OUT_0_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define URT_HFC_RTS_OUT_1_w                         ((uint32_t)0x00000010)  /*!< Bit Value =(1):1 of 32bit */
N#define URT_HFC_RTS_OUT_1_h0                        ((uint16_t)0x0010)      /*!< Bit Value =(1):1 of 16bit */
N#define URT_HFC_RTS_OUT_1_b0                        ((uint8_t )0x10)        /*!< Bit Value =(1):1 of 8bit */
N
N#define URT_HFC_RTS_INV_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define URT_HFC_RTS_INV_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define URT_HFC_RTS_INV_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define URT_HFC_RTS_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_HFC_RTS_INV_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_HFC_RTS_INV_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_HFC_RTS_INV_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_HFC_RTS_INV_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_HFC_RTS_INV_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_HFC_CTS_INV_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define URT_HFC_CTS_INV_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_HFC_CTS_INV_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_HFC_CTS_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_HFC_CTS_INV_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_HFC_CTS_INV_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_HFC_CTS_INV_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_HFC_CTS_INV_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_HFC_CTS_INV_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_HFC_RTS_EN_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define URT_HFC_RTS_EN_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_HFC_RTS_EN_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_HFC_RTS_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_HFC_RTS_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_HFC_RTS_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_HFC_RTS_EN_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_HFC_RTS_EN_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_HFC_RTS_EN_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_HFC_CTS_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_HFC_CTS_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_HFC_CTS_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_HFC_CTS_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_HFC_CTS_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_HFC_CTS_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_HFC_CTS_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_HFC_CTS_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_HFC_CTS_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        URT_MUTE  [register's definitions]
N *              Offset[0x5C]  URT mute control register
N ******************************************************************************
N */
N///@{
N#define URT_MUTE_default                            ((uint32_t)0x00010100)  /*!< Reg Reset Default Value */
N
N/* Bit fields of URT_MUTE */
N#define URT_MUTE_MUTE_AEX2_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define URT_MUTE_MUTE_AEX2_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define URT_MUTE_MUTE_AEX2_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define URT_MUTE_MUTE_AEX2_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_MUTE_MUTE_AEX2_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_MUTE_MUTE_AEX2_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_MUTE_MUTE_AEX2_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_MUTE_MUTE_AEX2_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_MUTE_MUTE_AEX2_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_MUTE_MUTE_AEX1_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define URT_MUTE_MUTE_AEX1_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define URT_MUTE_MUTE_AEX1_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_MUTE_MUTE_AEX1_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_MUTE_MUTE_AEX1_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_MUTE_MUTE_AEX1_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_MUTE_MUTE_AEX1_enable_w                 ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_MUTE_MUTE_AEX1_enable_h1                ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_MUTE_MUTE_AEX1_enable_b2                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_MUTE_MUTE_AEX0_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define URT_MUTE_MUTE_AEX0_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_MUTE_MUTE_AEX0_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_MUTE_MUTE_AEX0_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_MUTE_MUTE_AEX0_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_MUTE_MUTE_AEX0_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_MUTE_MUTE_AEX0_enable_w                 ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_MUTE_MUTE_AEX0_enable_h1                ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_MUTE_MUTE_AEX0_enable_b2                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_MUTE_MUTE_AEN1_mask_w                   ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define URT_MUTE_MUTE_AEN1_mask_h0                  ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define URT_MUTE_MUTE_AEN1_mask_b1                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define URT_MUTE_MUTE_AEN1_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_MUTE_MUTE_AEN1_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_MUTE_MUTE_AEN1_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_MUTE_MUTE_AEN1_enable_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_MUTE_MUTE_AEN1_enable_h0                ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_MUTE_MUTE_AEN1_enable_b1                ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_MUTE_MUTE_AEN0_mask_w                   ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define URT_MUTE_MUTE_AEN0_mask_h0                  ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define URT_MUTE_MUTE_AEN0_mask_b1                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_MUTE_MUTE_AEN0_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_MUTE_MUTE_AEN0_disable_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_MUTE_MUTE_AEN0_disable_b1               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_MUTE_MUTE_AEN0_enable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_MUTE_MUTE_AEN0_enable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_MUTE_MUTE_AEN0_enable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define URT_MUTE_MUTE_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define URT_MUTE_MUTE_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define URT_MUTE_MUTE_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define URT_MUTE_MUTE_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define URT_MUTE_MUTE_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define URT_MUTE_MUTE_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define URT_MUTE_MUTE_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define URT_MUTE_MUTE_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define URT_MUTE_MUTE_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_URT_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_URT.h                         */
N/*----------------------------------------------------------------------------*/
L 42 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_URT_DRV.h" 2
N
N
N///@{
N#define URT_IT_CALTMO    URT_STA_CALTMOF_mask_w     /*!< Baud rate calibration sync field receive time out interrupt. */
N#define URT_IT_BKTMO     URT_STA_BKTMOF_mask_w      /*!< Break receive time out interrupt. */
N#define URT_IT_IDTMO     URT_STA_IDTMOF_mask_w      /*!< Idle state time out interrupt. */
N#define URT_IT_RXTMO     URT_STA_RXTMOF_mask_w      /*!< Receive time out interrupt. */
N#if defined(URT_STA_TUDRF_mask_w)
X#if 0L
S#define URT_IT_TUDR      URT_STA_TUDRF_mask_w       /*!< URT SPI Slave mode transmit underrun interrupt.*/
N#endif
N#define URT_IT_TXE       URT_STA_TXEF_mask_w        /*!< TX error detect interrupt. */
N#define URT_IT_ROVR      URT_STA_ROVRF_mask_w       /*!< Receive overrun error interrupt. */
N#define URT_IT_NCE       URT_STA_NCEF_mask_w        /*!< Receive noised character error detect interrupt. */
N#define URT_IT_FE        URT_STA_FEF_mask_w         /*!< Receive frame error detect interrupt. */
N#define URT_IT_PE        URT_STA_PEF_mask_w         /*!< Receive parity error detect interrupt. */
N#define URT_IT_CTS       URT_STA_CTSF_mask_w        /*!< CTS change detect interrupt. */
N#define URT_IT_IDL       URT_STA_IDLF_mask_w        /*!< RX idle line detect interrupt. */
N#define URT_IT_BK        URT_STA_BKF_mask_w         /*!< Break condition detect interrupt. */
N#define URT_IT_CALC      URT_STA_CALCF_mask_w       /*!< Auto baudrate calibration complete interrupt. */
N#define URT_IT_TMO       URT_STA_TMOF_mask_w        /*!< Timeout timer timeout interrupt. */
N#define URT_IT_BRT       URT_STA_BRTF_mask_w        /*!< Baud rate generator timer timeout interrupt. */
N#define URT_IT_SADR      URT_STA_SADRF_mask_w       /*!< Slave address matched interrupt. */
N#define URT_IT_TX        URT_STA_TXF_mask_w         /*!< Transmit data register empty interrupt. */
N#define URT_IT_RX        URT_STA_RXF_mask_w         /*!< Receive data register not empty interrupt. */
N#define URT_IT_LS        URT_STA_LSF_mask_w         /*!< URT line status relationship interrupt. */
N#define URT_IT_ERR       URT_STA_ERRF_mask_w        /*!< URT error relationship interrupt. */
N#define URT_IT_TC        URT_STA_TCF_mask_w         /*!< Transmission complete interrupt.(shadow buffer , data register , shift buffer empty) */
N#define URT_IT_UG        URT_STA_UGF_mask_w         /*!< URT genernal event relationship interrupt. */
N#define URT_IT_Mask      0x7BF73CDE                 /*!< Compare URT interrupt setting range. */
N
N
N#define URT_EVENT_RXDF    URT_STA_RXDF_mask_w       /*!< URT received data byte number is different from previous received data byte number for URT_RDAT */
N#define URT_EVENT_RHF     URT_STA_RHF_mask_w        /*!< URT received hold flag. */
N#define URT_EVENT_IRBUSYF URT_STA2_IR_BUSYF_mask_w  /*!< URT IrDa data received busy flag. */
N#define URT_EVENT_BKBF    URT_STA2_BKBF_mask_w      /*!< URT send break busy flag. */
N#define URT_EVENT_NCF     URT_STA2_NCF_mask_w       /*!< URT receive noised character flag. */
N#define URT_EVENT_RXBUSYF URT_STA2_BUSYF_mask_w     /*!< URT RX busy flag. */
N
N#if defined(URT_STA_CALOVF_mask_w)
X#if 0L
S    #define URT_EVENT_CALOVF    URT_STA_CALOVF_mask_w   /*!<The event flag is that result of calibration is overflow baudrate generator counter.*/
N#endif
N#if defined(URT_STA_CALUDF_mask_w)
X#if 0L
S    #define URT_EVENT_CALUDF    URT_STA_CALUDF_mask_w   /*!<The event flag is that result of calibration is underflow baudrate generator counter.*/
N#endif
N///@}
N
N
N///@{
N#define URT_ExitMute_IdleDetect         URT_MUTE_MUTE_AEX2_enable_b2  /*!<URT auto exit mute mode definitions*/ 
N#define URT_ExitMute_BreakDetect        URT_MUTE_MUTE_AEX1_enable_b2  /*!<URT auto exit mute mode definitions*/ 
N#define URT_ExitMute_AddressMatch       URT_MUTE_MUTE_AEX0_enable_b2  /*!<URT auto exit mute mode definitions*/ 
N
N#define URT_EnterMute_idleDetect        URT_MUTE_MUTE_AEN1_enable_b1  /*!<URT auto enter mute mode definitions*/ 
N#define URT_EnterMute_AddressUnmatch    URT_MUTE_MUTE_AEN0_enable_b1  /*!<URT auto enter mute mode definitions*/ 
N///@}
N
N
N///@{
N//#define 
N
N///@}
N
N
N///@{
N/*! @enum   URT_STOP_TypeDef
N    @brief  URT stop bit select definitions.
N*/
Ntypedef enum
N{
N	URT_StopBits_1_0  = 0x40,                                             /*!< URT stop bit is 1bit.   */
N	URT_StopBits_2_0  = 0xC0,                                             /*!< URT stop bit is 2bit.   */
N    
N    #if defined(URT_CR1_RXSTP_LEN_0_5bit_w)
X    #if 1L
N        URT_StopBits_0_5  = 0x00,                                         /*!< URT stop bit is 0.5bit. */ 
N    #endif
N    
N    #if defined(URT_CR1_RXSTP_LEN_1_5bit_w)
X    #if 0L
S        URT_StopBits_1_5  = 0x80,                                         /*!< URT stop bit is 1.5bit. */    
N    #endif
N}URT_STOP_TypeDef;
N
N/*! @enum   URT_DataOrder_TypeDef
N    @brief  URT data order select definitions.
N*/ 
Ntypedef enum
N{
N	URT_DataTyped_LSB    = 0x00,       /*!< URT data order is LSB */
N	URT_DataTyped_MSB    = 0x20        /*!< URT data order is MSB */
N}URT_DataOrder_TypeDef;
N
N/*! @enum   URT_Parity_TypeDef
N    @brief  URT parity bit select definitions.
N*/ 
Ntypedef enum 
N{
N   	URT_Parity_No		= 0x00,        /*!< URT no parity bit. */
N	URT_Parity_Even	    = 0x04,        /*!< URT parity bit is even. */   
N	URT_Parity_Odd 	    = 0x0C,        /*!< URT parity bit is oddd. */
N	URT_Parity_All_H	= 0x1C,        /*!< URT parity bit always is H.*/
N	URT_Parity_All_L	= 0x14         /*!< URT parity bit always is L.*/
N}URT_Parity_TypeDef;
N
N/*! @enum   URT_DataLength_TypeDef
N    @brief  URT data length select definitions.
N*/ 
Ntypedef enum
N{
N	URT_DataLength_8      = 0x00,      /*!< URT data length is 8 bit. */ 
N    URT_DataLength_7      = 0x01       /*!< URT data length is 7 bit. */
N}URT_DataLength_TypeDef;
N
N
N/*! @enum   URT_Mode_TypeDef
N    @brief  URT mode configuration
N*/
Ntypedef enum
N{
N	URT_URT_mode     = URT_CR0_MDS_uart_w,        /*!< Uart mode*/
X	URT_URT_mode     = ((uint32_t)0x00000000),         
N	URT_SYNC_mode    = URT_CR0_MDS_sync_w,        /*!< Synchronous/Shift-Register mode*/
X	URT_SYNC_mode    = ((uint32_t)0x00000010),         
N	URT_IDLE_mode    = URT_CR0_MDS_idle_w,        /*!< Idle-line mode for multi-processor*/
X	URT_IDLE_mode    = ((uint32_t)0x00000020),         
N	URT_ADR_mode     = URT_CR0_MDS_adr_w,         /*!< Address-bit mode for multi-processor*/
X	URT_ADR_mode     = ((uint32_t)0x00000030),          
N}URT_Mode_TypeDef;
N
N
N#if defined(URT_CR0_SYNC_MDS_mask_w)
X#if 0L
S/*! @enum   URT_SYNCMode_TypeDef
S    @brief  URT SYNC mode configuration
S*/
Stypedef enum
S{
S    URT_SYNC_MASTER    = URT_CR0_SYNC_MDS_master_w,
S    URT_SYNC_SLAVE     = URT_CR0_SYNC_MDS_slave_w,
S}URT_SYNCMode_TypeDef;
N#endif
N
N/*! @enum   URT_DataLine_TypeDef
N    @brief  Data line select definitions.
N*/
Ntypedef enum
N{
N    URT_DataLine_2     =  URT_CR0_DAT_LINE_2_b0,         /*!< URT Data line is 2-line.*/
X    URT_DataLine_2     =  ((uint8_t )0x00),          
N    URT_DataLine_1     =  URT_CR0_DAT_LINE_1_b0          /*!< URT Data line is 1-line.*/
X    URT_DataLine_1     =  ((uint8_t )0x08)           
N}URT_DataLine_TypeDef;
N///@}
N
N
N
N///@{
N/*! @enum   URT_BDMode_TypeDef
N    @brief  URT Baud rate generator mode select definitions.
N*/ 
Ntypedef enum
N{
N    URT_BDMode_Separated    =   URT_CLK_BR_MDS_separated_w,    /*!< Pre counter and baudrate counter relationship is separated */
X    URT_BDMode_Separated    =   ((uint32_t)0x00000000),     
N    URT_BDMode_Combined     =   URT_CLK_BR_MDS_combined_w      /*!< Pre counter and baudrate counter relationship is combined*/
X    URT_BDMode_Combined     =   ((uint32_t)0x02000000)       
N}URT_BDMode_TypeDef;
N
N/*! @enum   URT_BDClock_TypeDef
N    @brief  URT Baud rate generator clock source select definitions.
N*/ 
Ntypedef enum
N{
N    URT_BDClock_PROC         =  URT_CLK_CK_SEL_proc_w,                                               /*!< URT baud rate generator clock source from PROC. */
X    URT_BDClock_PROC         =  ((uint32_t)0x00000000),                                                
N    URT_BDClock_LS        =  URT_CLK_CK_SEL_ck_ls_w,                                                 /*!< URT baud rate generator clock source from LS. */
X    URT_BDClock_LS        =  ((uint32_t)0x00000004),                                                  
N    URT_BDClock_Timer00TRGO  =  URT_CLK_CK_SEL_tm00_trgo_w,                                          /*!< URT baud rate generator clock source from TRGO. */ 
X    URT_BDClock_Timer00TRGO  =  ((uint32_t)0x00000006),                                            
N    
N    #if defined(URT_CLK_CK_SEL_ext_clk_w)
X    #if 0L
S        URT_BDClock_EXT      =  URT_CLK_CK_SEL_ext_clk_w,                                            /*!< URT baud rate generator clock source from External pin*/
N    #endif
N    
N    #if defined(URT_CLK_CK_SEL_nco0_p0_w)
X    #if 0L
S        URT_BDClock_NCO0_P0  =  URT_CLK_CK_SEL_nco0_p0_w,                                             /*!< URT baud rate generator clock source from NCO0_P0*/
N    #endif
N}URT_BDClock_TypeDef;
N
N
N#if defined(URT_CLK_BR_CKS_mask_w)
X#if 0L
S/*! @enum   URT_BRCounterClock_TypeDef
S    @brief  UART baud-rate timer clock source select.
S*/ 
Stypedef enum
S{
S    URT_BRCountClock_PSC     = URT_CLK_BR_CKS_psc_w,                           /*!< URT baud-rate timer clock source from clock prescaler output.*/                          
S    URT_BRCountClock_CK_URT  = URT_CLK_BR_CKS_ck_urtx_w,                       /*!< URT baud-rate timer clock source from URT internal clock input.*/
S}URT_BRCounterClock_TypeDef;
S
N#endif
N
N
N/*! @enum   URT_CLKSource_TypeDef
N    @brief  URT URT_CLK output clock source
N*/
Ntypedef enum
N{
N    URT_CK_OUT 	    =	URT_CLK_CLK_CKS_out_w,                                 /*!< URT_CLK output clock source from CK_URTx_OUT*/
X    URT_CK_OUT 	    =	((uint32_t)0x00000000),                                  
N	URT_CK_SC		=	URT_CLK_CLK_CKS_sc_w,                                  /*!< URT_CLK output clock source from CK_URTx_SC */
X	URT_CK_SC		=	((uint32_t)0x00000020),                                   
N}URT_CLKSource_TypeDef;
N
N
N/*! @enum  URT_TXClock_TypeDef
N    @brief URT TX clock source select definitions.
N*/
Ntypedef enum
N{
N    URT_TXClock_Internal     =  URT_CLK_TX_CKS_internal_w,                    /*!< URT TX clock source from Baudrate generator. */
X    URT_TXClock_Internal     =  ((uint32_t)0x00000000),                     
N    URT_TXClock_Timer01TRGO  =  URT_CLK_TX_CKS_tm01_trgo_w,                   /*!< URT TX clock source from Timer01 TRGO. */
X    URT_TXClock_Timer01TRGO  =  ((uint32_t)0x00100000),                    
N    URT_TXClock_Timer10TRGO  =  URT_CLK_TX_CKS_tm10_trgo_w,                   /*!< URT TX clock source from Timer10 TRGO. */
X    URT_TXClock_Timer10TRGO  =  ((uint32_t)0x00200000),                    
N    
N    #if defined(URT_CLK_TX_CKS_ext_clk_w)
X    #if 0L
S        URT_TXClock_EXT      =  URT_CLK_TX_CKS_ext_clk_w,                     /*!< URT TX clock source from external pin. */
N    #endif
N    
N}URT_TXClock_TypeDef;
N
N
N/*! @enum  URT_RXClock_TypeDef
N    @brief URT RX clock source select definitions.
N*/
Ntypedef enum
N{
N    URT_RXClock_Internal     =  URT_CLK_RX_CKS_internal_w,                     /*!< URT RX clock source from Baudrate generator. */
X    URT_RXClock_Internal     =  ((uint32_t)0x00000000),                      
N    URT_RXClock_Timer01TRGO  =  URT_CLK_RX_CKS_tm01_trgo_w,                    /*!< URT RX clock source from Timer01 TRGO. */
X    URT_RXClock_Timer01TRGO  =  ((uint32_t)0x00010000),                     
N    URT_RXClock_Timer10TRGO  =  URT_CLK_RX_CKS_tm10_trgo_w,                    /*!< URT RX clock source from Timer10 TRGO. */
X    URT_RXClock_Timer10TRGO  =  ((uint32_t)0x00020000),                     
N    
N    #if defined(URT_CLK_RX_CKS_ext_clk_w)
X    #if 0L
S        URT_RXClock_EXT      =  URT_CLK_RX_CKS_ext_clk_w,                      /*!< URT TX clock source from external pin. */
N    #endif
N    
N}URT_RXClock_TypeDef;
N
N
N/*! @enum   URT_RXSMP_TypeDef
N    @brief  URT RX oversample time mode
N*/
Ntypedef enum
N{
N	URT_RXSMP_3TIME		= URT_CR0_OS_MDS_three_w,                 /*!< URT RX data oversampling majority vote from 3 sample bits method. */               
X	URT_RXSMP_3TIME		= ((uint32_t)0x00000000),                                 
N	URT_RXSMP_1TIME		= URT_CR0_OS_MDS_one_w                    /*!< URT RX data oversampling majority vote from one sample bit method and noise free.*/
X	URT_RXSMP_1TIME		= ((uint32_t)0x00000002)                     
N}URT_RXSMP_TypeDef;
N
N
N///@}
N
N
N///@{
N
N
N/*! @enum   URT_TMOMDS_TypeDef
N    @brief  URT timerout timer mode source select definitions.
N*/
Ntypedef enum
N{
N   URT_TMOMDS_URT     = URT_TMOUT_TMO_MDS_uart_w,       /*!< Timeout timer mode is URT mode ( URT detect timeout using) */
X   URT_TMOMDS_URT     = ((uint32_t)0x00000000),        
N   URT_TMOMDS_General = URT_TMOUT_TMO_MDS_general_w     /*!< Timeout timer mode is general mode ( General timer using )*/
X   URT_TMOMDS_General = ((uint32_t)0x00000004)      
N}URT_TMOMDS_TypeDef; 
N
N
N/*! @enum   URT_TMOCLK_TypeDef
N    @brief  URT timerout timer clock source select definitions.
N*/
Ntypedef enum
N{
N	URT_TMOCLK_BitTime  = URT_TMOUT_TMO_CKS_uart_w,      /*!< Timeout timer clock source is from RX baudrate.*/
X	URT_TMOCLK_BitTime  = ((uint32_t)0x00000000),       
N	URT_TMOCLK_CK_URTX  = URT_TMOUT_TMO_CKS_input_w,     /*!< Timeout timer clock source is from URT function clock source*/
X	URT_TMOCLK_CK_URTX  = ((uint32_t)0x00000100),      
N	URT_TMOCLK_Noise    = URT_TMOUT_TMO_CKS_noise_w      /*!< Timeout timer clock source is from Noise detect time.*/
X	URT_TMOCLK_Noise    = ((uint32_t)0x00000200)       
N}URT_TMOCLK_TypeDef;
N
N///@}
N
N
N
N///@{
N
N/*! @enum   URT_RXTH_TypeDef
N    @brief  URT RX shadow buffer threshold byte number select definitions.
N*/
Ntypedef enum
N{
N    URT_RXTH_1BYTE   =  URT_CR0_RX_TH_1byte_w,       /*!< URT RX shadow buffer threshold is 1 byte */
X    URT_RXTH_1BYTE   =  ((uint32_t)0x00000000),        
N    URT_RXTH_2BYTE   =  URT_CR0_RX_TH_2byte_w,       /*!< URT RX shadow buffer threshold is 2 byte */
X    URT_RXTH_2BYTE   =  ((uint32_t)0x00010000),        
N    URT_RXTH_3BYTE   =  URT_CR0_RX_TH_3byte_w,       /*!< URT RX shadow buffer threshold is 3 byte */
X    URT_RXTH_3BYTE   =  ((uint32_t)0x00020000),        
N    URT_RXTH_4BYTE   =  URT_CR0_RX_TH_4byte_w,       /*!< URT RX shadow buffer threshold is 4 byte */
X    URT_RXTH_4BYTE   =  ((uint32_t)0x00030000),        
N}URT_RXTH_TypeDef;
N
N
N/*! @enum   URT_RCAP_TypeDef
N    @brief  URT capture status bit select definitions.
N*/
Ntypedef enum
N{
N    URT_RCAP_ADR    =   URT_RCAP_RCAP_ADR_mask_w,      /*!< Capture address bit value.*/    
X    URT_RCAP_ADR    =   ((uint32_t)0x00000400),           
N    URT_RCAP_PAR    =   URT_RCAP_RCAP_PAR_mask_w,      /*!< Capture parity bit value.*/
X    URT_RCAP_PAR    =   ((uint32_t)0x00000200),       
N    URT_RCAP_STP    =   URT_RCAP_RCAP_STP_mask_w,      /*!< Capture stop bit value.*/
X    URT_RCAP_STP    =   ((uint32_t)0x00000100),       
N}URT_RCAP_TypeDef;
N
N
N/*! @enum   URT_SBUFBit_TypeDef
N    @brief  URT shift buffer status bit select definitions.
N*/
Ntypedef enum
N{
N    URT_SBUF_ADR    =   URT_STA2_ADR_mask_w,          /*!< Shift buffer address bit.*/
X    URT_SBUF_ADR    =   ((uint32_t)0x00000004),           
N    URT_SBUF_PAR    =   URT_STA2_PAR_mask_w,          /*!< Shift buffer parity bit.*/
X    URT_SBUF_PAR    =   ((uint32_t)0x00000002),           
N}URT_SBUFBit_TypeDef;
N
N
N/*! @enum   URT_DEGT_TypeDef
N    @brief  URT DE signal output guard time select definitions.
N*/
Ntypedef enum
N{
N    URT_DEGT_1_4  =  URT_CR0_DE_GT_1_4_w,              /*!< DE guard time is 1/4 bit time.*/
X    URT_DEGT_1_4  =  ((uint32_t)0x00000000),               
N    URT_DEGT_1_2  =  URT_CR0_DE_GT_1_2_w,              /*!< DE guard time is 1/2 bit time.*/
X    URT_DEGT_1_2  =  ((uint32_t)0x00004000),               
N    URT_DEGT_1    =  URT_CR0_DE_GT_1_w,                /*!< DE guard time is 1 bit time.*/
X    URT_DEGT_1    =  ((uint32_t)0x00008000),                 
N    URT_DEGT_2    =  URT_CR0_DE_GT_2_w                 /*!< DE guard time is 2 bit time.*/
X    URT_DEGT_2    =  ((uint32_t)0x0000C000)                  
N}URT_DEGT_TypeDef;
N
N
N/*! @enum    URT_IDLEMOde_TypeDef
N    @brief   URT idle line detect management mode select definitions.
N*/
Ntypedef enum
N{
N    URT_IDLEMode_No   =  URT_CR0_IDL_MDS_no_w,         /*!< No operation.*/
X    URT_IDLEMode_No   =  ((uint32_t)0x00000000),          
N    URT_IDLEMode_Load =  URT_CR0_IDL_MDS_load_w,       /*!< Force to load shadow buffer.*/
X    URT_IDLEMode_Load =  ((uint32_t)0x00100000),        
N}URT_IDLEMOde_TypeDef;
N
N///@}
N
N
N///@{
N
N/*! @enum   URT_CPHA_TypeDef
N    @brief  SYNC mode sampling type select definitions.
N*/
Ntypedef enum
N{
N    URT_CPHA0_LeadEdge  =   URT_CR3_CPHA_leading_edge_w ,        /*!< Sampling on leading edge. */
X    URT_CPHA0_LeadEdge  =   ((uint32_t)0x00000000) ,         
N    URT_CPHA1_TrailEdge =   URT_CR3_CPHA_trailing_edge_w,        /*!< Sampling on trailing edge. */
X    URT_CPHA1_TrailEdge =   ((uint32_t)0x00000004),         
N
N}URT_CPHA_TypeDef;
N
N/*! @enum   URT_CPOL_TypeDef
N    @brief  SYNC mode clock polarity type select definitions.
N*/
Ntypedef enum
N{
N    URT_CPOL0_Low     = URT_CR3_CPOL_low_w,             /*!< clock is low in idle state. */
X    URT_CPOL0_Low     = ((uint32_t)0x00000000),              
N    URT_CPOL1_High    = URT_CR3_CPOL_high_w,            /*!< clock is high in idle state.*/
X    URT_CPOL1_High    = ((uint32_t)0x00000002),             
N}URT_CPOL_TypeDef;
N
N
N#if defined(URT_CR2_DOUT_MDS_mask_w)
X#if 0L
S/*! @enum  URT_MOSIIdleStatus_TypeDef
S    @brief URT's SPI Master Mode MOSI Stauts control in bus idle.
S*/
Stypedef enum
S{
S    URT_mSPI_MOSI_Idle_Tristate       =  (URT_CR2_DOUT_MDS_disable_b3| URT_CR2_DOUT_IDL_lbit_b3),         /*!< MOSI IDLE status is tristate in SPI master mode.     */
S    URT_mSPI_MOSI_Idle_LastBit        =  (URT_CR2_DOUT_MDS_enable_b3 | URT_CR2_DOUT_IDL_lbit_b3),         /*!< MOSI IDLE status is keeping last status value in SPI master mode. */
S    URT_mSPI_MOSI_Idle_Low            =  (URT_CR2_DOUT_MDS_enable_b3 | URT_CR2_DOUT_IDL_0_b3),            /*!< MOSI IDLE status is high in SPI master mode.*/
S    URT_mSPI_MOSI_Idle_High           =  (URT_CR2_DOUT_MDS_enable_b3 | URT_CR2_DOUT_IDL_1_b3),            /*!< MOSI IDLE status is low in SPI master mode.*/
S}URT_MOSIIdleStatus_TypeDef;
N#endif
N///@}
N
N///@{
N/*! @enum    URT_CALMode_TypeDef
N    @brief   URT auto calibration mode select definitions.
N*/
N
Ntypedef enum
N{
N    URT_CALMode_Start = URT_CAL_CAL_MDS_start_w,         /*!< Measure the start bit.*/
X    URT_CALMode_Start = ((uint32_t)0x00000000),          
N    URT_CALMode_Edge  = URT_CAL_CAL_MDS_edge_w           /*!< Measure start falling edge to next falling edge.*/
X    URT_CALMode_Edge  = ((uint32_t)0x00000004)            
N}URT_CALMode_TypeDef;
N
N
N/*! @enum    URT_ExtraBK_TypeDef
N    @brief   URT extra break bit select definitions.
N*/
Ntypedef enum
N{
N    URT_ExtraBK_1BIT   =  URT_CR3_DET_BK_1bit_w,           /*!< Extra break bit is 1 bit.*/          
X    URT_ExtraBK_1BIT   =  ((uint32_t)0x00000000),                      
N    URT_ExtraBK_3BIT   =  URT_CR3_DET_BK_3bit_w            /*!< Extra break bit is 3 bit.*/
X    URT_ExtraBK_3BIT   =  ((uint32_t)0x00000010)             
N}URT_ExtraBK_TypeDef;
N///@}
N
N///@{
N
N/*! @enum   URT_IrDAPulse_TypeDef
N    @brief  IrDa output pulse width configuration.
N*/
Ntypedef enum
N{
N	URT_IrDATra_1			=	0,                          /*!< IrDa output pulse width is  1 / URTX_TXOS_NUM. */
N	URT_IrDATra_2			=	1,                          /*!< IrDa output pulse width is  2 / URTX_TXOS_NUM. */                 
N	URT_IrDATra_3			=	2,                          /*!< IrDa output pulse width is  3 / URTX_TXOS_NUM. */
N	URT_IrDATra_4			=	3,                          /*!< IrDa output pulse width is  4 / URTX_TXOS_NUM. */
N	URT_IrDATra_5			=	4,                          /*!< IrDa output pulse width is  5 / URTX_TXOS_NUM. */
N	URT_IrDATra_6			=	5,                          /*!< IrDa output pulse width is  6 / URTX_TXOS_NUM. */
N	URT_IrDATra_7			=	6,                          /*!< IrDa output pulse width is  7 / URTX_TXOS_NUM. */
N	URT_IrDATra_8			=	7,                          /*!< IrDa output pulse width is  8 / URTX_TXOS_NUM. */
N	URT_IrDATra_9			=	8,                          /*!< IrDa output pulse width is  9 / URTX_TXOS_NUM. */
N	URT_IrDATra_10			=	9,                          /*!< IrDa output pulse width is  10 / URTX_TXOS_NUM. */
N	URT_IrDATra_11			=	10,                         /*!< IrDa output pulse width is  11 / URTX_TXOS_NUM. */
N	URT_IrDATra_12			=	11,                         /*!< IrDa output pulse width is  12 / URTX_TXOS_NUM. */
N	URT_IrDATra_13			=	12,                         /*!< IrDa output pulse width is  13 / URTX_TXOS_NUM. */
N	URT_IrDATra_14			=	13,                         /*!< IrDa output pulse width is  14 / URTX_TXOS_NUM. */
N	URT_IrDATra_15			=	14,                         /*!< IrDa output pulse width is  15 / URTX_TXOS_NUM. */
N	URT_IrDATra_16_			=	15,                         /*!< IrDa output pulse width is  16 / URTX_TXOS_NUM. */
N}URT_IrDAPulse_TypeDef;
N///@}
N
N
N///@{
N
N/*! @enum  URT_RXPERetryMode_TypeDef
N    @brief RX parity error retry time select definitions.
N*/
Ntypedef enum
N{
N    URT_RXPERetry_Disable   =  URT_SC_RXE_MDS_disable_w,  /*!< RX no auto retry when detecting parity error.*/   
X    URT_RXPERetry_Disable   =  ((uint32_t)0x00000000),      
N    URT_RXPERetry_Limited   =  URT_SC_RXE_MDS_enable_w,   /*!< RX limited time auto retry when detecting party error.*/
X    URT_RXPERetry_Limited   =  ((uint32_t)0x00000001),    
N    URT_RXPERetry_Unlimited =  URT_SC_RXE_MDS_auto_w      /*!< RX alway auto retry unless recceiving parity correct character.*/
X    URT_RXPERetry_Unlimited =  ((uint32_t)0x00000002)       
N}URT_RXPERetryMode_TypeDef;
N
N/*! @enum   URT_RXErrorSignal_TypeDef
N    @brief  URT error signal length select definitions.
N*/
Ntypedef enum
N{
N    URT_RXErrorSignal_1BIT = URT_SC_RXE_LEN_1bit_w,      /*!< URT RX parity error detect and NACK transmission 1 bit time length.*/
X    URT_RXErrorSignal_1BIT = ((uint32_t)0x00000000),       
N    URT_RXErrorSignal_2BIT = URT_SC_RXE_LEN_2bit_w,      /*!< URT RX parity error detect and NACK transmission 2 bit time length.*/
X    URT_RXErrorSignal_2BIT = ((uint32_t)0x00000010),       
N}URT_RXErrorSignal_TypeDef;
N
N
N/*! @param  URT_RXPERetryTime_TypeDef
N    @brief  URT RX parity error auto retry time select definitions.
N*/
Ntypedef enum
N{
N    URT_RXPERetry_0 =   (0 << URT_SC_RXE_NUM_shift_w),   /*!< No auto retry.*/
X    URT_RXPERetry_0 =   (0 << (12)),    
N    URT_RXPERetry_1 =   (1 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 1 time.*/
X    URT_RXPERetry_1 =   (1 << (12)),    
N    URT_RXPERetry_2 =   (2 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 2 times.*/
X    URT_RXPERetry_2 =   (2 << (12)),    
N    URT_RXPERetry_3 =   (3 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 3 times.*/
X    URT_RXPERetry_3 =   (3 << (12)),    
N    URT_RXPERetry_4 =   (4 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 4 times.*/
X    URT_RXPERetry_4 =   (4 << (12)),    
N    URT_RXPERetry_5 =   (5 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 5 times.*/
X    URT_RXPERetry_5 =   (5 << (12)),    
N    URT_RXPERetry_6 =   (6 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 6 times.*/
X    URT_RXPERetry_6 =   (6 << (12)),    
N    URT_RXPERetry_7 =   (7 << URT_SC_RXE_NUM_shift_w),   /*!< Auto retry 7 times.*/
X    URT_RXPERetry_7 =   (7 << (12)),    
N}URT_RXPERetryTime_TypeDef;
N
N
N/*! @param  URT_TXErrorReSendTime_TypeDef
N    @brief  URT TX auto resend time select definitions.
N*/
Ntypedef enum
N{
N    URT_TXErrorResend_0 = (0 << URT_SC_TXE_NUM_shift_w),  /*!< No auto resend. */
X    URT_TXErrorResend_0 = (0 << (8)),   
N    URT_TXErrorResend_1 = (1 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 1 time.*/
X    URT_TXErrorResend_1 = (1 << (8)),   
N    URT_TXErrorResend_2 = (2 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 2 times.*/
X    URT_TXErrorResend_2 = (2 << (8)),   
N    URT_TXErrorResend_3 = (3 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 3 times.*/
X    URT_TXErrorResend_3 = (3 << (8)),   
N    URT_TXErrorResend_4 = (4 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 4 times.*/
X    URT_TXErrorResend_4 = (4 << (8)),   
N    URT_TXErrorResend_5 = (5 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 5 times.*/
X    URT_TXErrorResend_5 = (5 << (8)),   
N    URT_TXErrorResend_6 = (6 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 6 times.*/
X    URT_TXErrorResend_6 = (6 << (8)),   
N    URT_TXErrorResend_7 = (7 << URT_SC_TXE_NUM_shift_w),  /*!< Auto resend 7 times.*/
X    URT_TXErrorResend_7 = (7 << (8)),   
N}URT_TXErrorReSendTime_TypeDef;
N
N
N/*! @enum  URT_TXErrorMode_TypeDef
N    @brief URT TX error detect mode select definitions.
N*/
Ntypedef enum
N{ 
N    URT_TXErrorDetect_Disable       = URT_SC_TXE_MDS_disable_w,  /*!< TX error detect disable */
X    URT_TXErrorDetect_Disable       = ((uint32_t)0x00000000),   
N    URT_TXErrorDetect_ErrorSignal   = URT_SC_TXE_MDS_chk_low_w,  /*!< TX error detect mode is that check low in stop bit.*/
X    URT_TXErrorDetect_ErrorSignal   = ((uint32_t)0x00000004),   
N    URT_TXErrorDetect_TX            = URT_SC_TXE_MDS_chk_tx_w    /*!< TX error detect mode is that TX detect*/
X    URT_TXErrorDetect_TX            = ((uint32_t)0x00000008)     
N}URT_TXErrorMode_TypeDef;
N///@}
N
N
N#if defined(URT_CLK_ECK_CKS_mask_w)
X#if 0L
S/*! @enum  URT_ExternalClockMux_TypeDef
S    @brief URT external clock input pin select definitions.
S*/
Stypedef enum
S{
S    URT_ExternalClockInput_CLK      = URT_CLK_ECK_CKS_clk_w,
S    URT_ExternalClockInput_RX       = URT_CLK_ECK_CKS_rx_w,
S}URT_ExternalClockMux_TypeDef;
N#endif
N
N
N/*! @struct URT_Data_TypeDef
N    @brief  URT data character configuration.
N*/ 
Ntypedef struct
N{
N    URT_DataLength_TypeDef  URT_TX_DataLength;  /*!< URT TX data length select. */ 
N    URT_DataLength_TypeDef  URT_RX_DataLength;	/*!< URT RX data length select. */
N    URT_DataOrder_TypeDef   URT_TX_DataOrder;   /*!< URT TX data order select. */
N    URT_DataOrder_TypeDef   URT_RX_DataOrder;   /*!< URT RX data order select. */
N    URT_STOP_TypeDef        URT_TX_StopBits;    /*!< URT TX stop bit select. */
N    URT_STOP_TypeDef        URT_RX_StopBits;	/*!< URT RX stop bit select. */
N    URT_Parity_TypeDef      URT_TX_Parity;      /*!< URT TX parity mode select. */
N    URT_Parity_TypeDef      URT_RX_Parity;      /*!< URT RX parity mode select. */
N    FunctionalState         URT_TX_DataInverse; /*!< URT TX Data inverse enable or disable*/
N    FunctionalState         URT_RX_DataInverse; /*!< URT RX Data inverse enable or disable*/
N}URT_Data_TypeDef;
N
N
N/*! @struct URT_BRG_TypeDef
N    @brief  URT baudrate generator configuration.
N*/ 
Ntypedef struct
N{
N	URT_BDClock_TypeDef		       URT_InteranlClockSource;        /*!< Baud rate generator clock source select. */
N	URT_BDMode_TypeDef	           URT_BaudRateMode;               /*!< Baud rate generator counter mode select. */
N	uint8_t				  	       URT_PrescalerCounterReload;     /*!< Prescaler counter reload value. */
N	uint8_t				  	       URT_BaudRateCounterReload;      /*!< Baud rate counter reload value. */
N}URT_BRG_TypeDef;
N
N
N/*! @struct URT_IrDA_TypeDef
N    @brief  URT IrDa mode configuration.
N*/ 
Ntypedef struct
N{
N    URT_IrDAPulse_TypeDef        URT_IrDaPulseWidth;         /*!< IrDa output pulse select. */
N}URT_IrDA_TypeDef;
N
N
N/*! @struct URT_RXParityError_TypeDef
N    @brief  URT RX parity error relationship configuration.
N*/
Ntypedef struct
N{
N    URT_RXPERetryMode_TypeDef    URT_RXPERetryMode;         /*!< RX parity error auto retry mode select. */
N    URT_RXErrorSignal_TypeDef    URT_RXErrorSignal;         /*!< RX error signal length select.*/
N    URT_RXPERetryTime_TypeDef    URT_RXPERetryTime;         /*!< RX auto retry time select when auto retry mode is limited time auto retry.*/
N}URT_RXParityError_TypeDef;
N
N
N///@{
Nvoid URT_IT_Config( URT_Struct*  , uint32_t , FunctionalState );
Nvoid URT_ITEA_Cmd( URT_Struct*  , FunctionalState );
Nuint32_t URT_GetITAllFlagStatus( URT_Struct* );
NDRV_Return URT_GetITSingleFlagStatus( URT_Struct*  , uint32_t );
Nvoid URT_ClearITFlag( URT_Struct*  , uint32_t );
NDRV_Return URT_GetRxDifferentFlag( URT_Struct* );
NDRV_Return URT_GetRxHoldFlag( URT_Struct* );
Nvoid URT_ClearRxHoldFlag( URT_Struct* );
NDRV_Return URT_GetIrDaBusyFlag( URT_Struct* );
NDRV_Return URT_GetBreakBusyFlag( URT_Struct* );
NDRV_Return URT_GetRxBusyFlag( URT_Struct* );
NDRV_Return URT_GetRxNoiseFlag( URT_Struct* );
Nuint32_t URT_GetITStatus(URT_Struct* URTX);
N///@}
N
N
N///@{
Nvoid URT_DataCharacter_Config( URT_Struct* , URT_Data_TypeDef* );
Nvoid URT_Mode_Select( URT_Struct*  , URT_Mode_TypeDef );
Nvoid URT_DataLine_Select( URT_Struct* , URT_DataLine_TypeDef );
Nvoid URT_HalfDuplexMode_Cmd( URT_Struct* , FunctionalState );
Nvoid URT_LoopBackMode_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_TX_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_RX_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_RXInverse_Cmd(URT_Struct*  , FunctionalState );
Nvoid URT_TXInverse_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_NoiseDataSkip_Cmd(URT_Struct* , FunctionalState );
Nvoid URT_Cmd( URT_Struct*  , FunctionalState );
N///@}
N
N
N
N///@{
Nvoid URT_BaudRateGenerator_Config( URT_Struct*  , URT_BRG_TypeDef* );
Nvoid URT_BaudRateGeneratorMode_Select( URT_Struct*  , URT_BDMode_TypeDef );
Nvoid URT_BaudRateGeneratorClock_Select( URT_Struct*  , URT_BDClock_TypeDef );
N
N#if defined(URT_CLK_BR_CKS_mask_w)
X#if 0L
Svoid URT_BaudRateCounterClockSource_Select( URT_Struct* , URT_BRCounterClock_TypeDef );
N#endif
N
Nuint8_t URT_GetBaudRateGeneratorPreReload( URT_Struct* );
Nuint8_t URT_GetBaudRateGeneratorCountReload( URT_Struct* );
Nuint8_t URT_GetBaudRateGeneratorPre( URT_Struct* );
Nuint8_t URT_GetBaudRateGeneratorCount( URT_Struct* );
N
Nvoid URT_BaudRateGenerator_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_CLKSignalSource_Select( URT_Struct*  , URT_CLKSource_TypeDef );
Nvoid URT_CLKSignal_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_CtrlBROSignalStatus_SW( URT_Struct*  , BitAction );
Nvoid URT_CtrlCLKSignalStatus_SW( URT_Struct*  , BitAction );
Nvoid URT_TXClockSource_Select( URT_Struct*  , URT_TXClock_TypeDef );
Nvoid URT_RXClockSource_Select( URT_Struct*  , URT_RXClock_TypeDef );
NDRV_Return URT_TXOverSamplingSampleNumber_Select( URT_Struct*  , uint8_t );
NDRV_Return URT_RXOverSamplingSampleNumber_Select( URT_Struct*  , uint8_t );
Nvoid URT_RXOverSamplingMode_Select( URT_Struct*  , URT_RXSMP_TypeDef );
N
N///@}
N
N
N///@{
Nvoid URT_TimeroutTimer_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_TriggerTimeoutTimerRst_SW( URT_Struct*  );
Nvoid URT_TimeoutMode_Select( URT_Struct*  , URT_TMOMDS_TypeDef );
Nvoid URT_TimeoutTimerClockSource_Select( URT_Struct*  , URT_TMOCLK_TypeDef );
Nvoid URT_IdleDetect_Select( URT_Struct*  , uint8_t );
Nvoid URT_IdleTimeoutDetect_Config( URT_Struct*  , FunctionalState  , uint16_t );
Nvoid URT_RXTimeoutDetect_Config( URT_Struct*  , FunctionalState  , uint8_t );
NDRV_Return URT_BreakTimeoutDetect_Config( URT_Struct*  , FunctionalState  , uint8_t );
NDRV_Return URT_CalibrationTimeoutDetect_Config( URT_Struct*  , FunctionalState  , uint8_t );
Nvoid URT_CtrlTMOSignalStatus_SW( URT_Struct*  , BitAction );
Nuint16_t URT_GetTimeoutTimerCounter( URT_Struct* );
Nvoid URT_SetTimeoutTimerCounter( URT_Struct* , uint16_t );
Nuint16_t URT_GetTimeoutTimerReload( URT_Struct* );
Nvoid URT_SetTimeoutTimerCompare( URT_Struct* , uint16_t);
N///@}
N
N
N///@{
Nuint8_t URT_GetTXShadowBufferLevel( URT_Struct* );
Nuint8_t URT_GetRXShadowBufferLevel( URT_Struct* );
Nvoid URT_ClearTXData( URT_Struct* );
Nvoid URT_ClearRXData( URT_Struct* );
Nuint8_t URT_GetTXDataRegLevel( URT_Struct* );
Nvoid URT_RXShadowBufferThreshold_Select( URT_Struct*  , URT_RXTH_TypeDef );
Nuint8_t URT_GetRXDataRegLevel( URT_Struct* );
Nuint32_t URT_GetRXData( URT_Struct* );
Nuint8_t URT_GetCaptureData( URT_Struct* );
Nuint8_t URT_GetCaptureStatusBit( URT_Struct*  , URT_RCAP_TypeDef );
Nuint8_t URT_GetRXShiftBufferStatusBit( URT_Struct*  , URT_SBUFBit_TypeDef );
Nuint8_t URT_GetTXShiftBufferData( URT_Struct* );
Nuint8_t URT_GetRXShiftBufferData( URT_Struct* );
Nvoid URT_RTS_Cmd( URT_Struct* , FunctionalState  );
Nvoid URT_RTSInverse_Cmd( URT_Struct* URTX, FunctionalState URT_RTS_INV);
Nvoid URT_CtrlRTS_SW( URT_Struct*  , BitAction );
Nvoid URT_CTS_Cmd( URT_Struct* , FunctionalState);
NDRV_Return URT_GetCTSLineStatus( URT_Struct* );
Nvoid URT_CTSInverse_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_DE_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_DEInverse_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_DEGuardTime_Select( URT_Struct*  , URT_DEGT_TypeDef );
Nvoid URT_IdlehandleMode_Select( URT_Struct*  , URT_IDLEMOde_TypeDef );
Nvoid URT_TXHalt_Cmd(URT_Struct*  , FunctionalState );
Nvoid URT_TXGuardTime_Select( URT_Struct*  , uint8_t );
NDRV_Return URT_SetTXData( URT_Struct*  , uint8_t  , uint32_t );
N///@}
N
N
N
N///@{
Nvoid URT_CPHAMode_Select( URT_Struct*  , URT_CPHA_TypeDef );
Nvoid URT_CPOLMode_Select( URT_Struct* , URT_CPOL_TypeDef );
N
N#if defined(URT_CR0_SYNC_MDS_mask_w)
X#if 0L
S    void URT_SYNCMode_Select( URT_Struct* URTX , URT_SYNCMode_TypeDef URT_SYNC_MDS);
N#endif
N
N#if defined(URT_CR2_NSSI_EN_mask_w)
X#if 0L
S    void URT_NssInput_Cmd( URT_Struct* , FunctionalState);
N#endif
N#if defined(URT_CR2_DOUT_MDS_mask_w)
X#if 0L
S    void URT_SPIMasterDataOutputIdleStatus_Select( URT_Struct* , URT_MOSIIdleStatus_TypeDef);
N#endif
Nvoid URT_NssInverse_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_NssSW_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_CtrlNSS_SW( URT_Struct*  , BitAction );
N///@}
N
N
N
N///@{
Nvoid URT_SetSlaveAddressMask( URT_Struct*  , uint8_t );
Nvoid URT_SetSlaveAddress( URT_Struct*  , uint8_t );
Nvoid URT_GlobalAddress_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_SendAddress( URT_Struct*  , uint8_t );
N///@}
N
N
N
N///@{
Nvoid URT_CalibrationMode_Select( URT_Struct*  , URT_CALMode_TypeDef );
Nvoid URT_AutoCalibration_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_Calibration_SW( URT_Struct*  , FunctionalState );
Nvoid URT_CalibrationCompleteDataHold_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_ExtraBreakBit_Select( URT_Struct*  , URT_ExtraBK_TypeDef );
Nvoid URT_SendBreak( URT_Struct* );
N
N#if defined(URT_STA_CALOVF_mask_w) && defined(URT_STA_CALUDF_mask_w)
X#if 0L && 0L
S    DRV_Return URT_GetCalibrationResult(URT_Struct*);
N#endif
N
N///@}
N
N
N///@{
Nvoid URT_TXDMA_Cmd( URT_Struct* , FunctionalState );
Nvoid URT_RXDMA_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_BreakDisableDMA_Cmd( URT_Struct*  , FunctionalState );
N///@}
N
N
N///@{
Nvoid URT_IrDA_Config( URT_Struct*  , URT_IrDA_TypeDef* );
Nvoid URT_IrDA_Cmd( URT_Struct*  , FunctionalState );
N///@}
N
N
N
N///@{
Nvoid URT_AutoExitMuteMode_Select( URT_Struct* , uint8_t );
Nvoid URT_AutoEnterMuteMode_Select( URT_Struct* , uint8_t );
Nvoid URT_Mute_Cmd( URT_Struct*  , FunctionalState );
N///@}
N
N
N///@{
Nvoid URT_NoiseCapture_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_NoiseHoldData_Cmd( URT_Struct*  , FunctionalState );
Nvoid URT_RXParityError_Config( URT_Struct*  , URT_RXParityError_TypeDef*  );
Nvoid URT_TXErrorDetectMode_Select( URT_Struct*  , URT_TXErrorMode_TypeDef );
Nvoid URT_TXErrorResendTime_Select( URT_Struct*  , URT_TXErrorReSendTime_TypeDef );
N
N///@}
N
N
N///@{
Nvoid URT_RxTxSwap_Cmd(URT_Struct*, FunctionalState);
N#if defined(URT_CLK_ECK_CKS_mask_w)
X#if 0L
S    void URT_ExternalClockMux_Select(URT_Struct*,  URT_ExternalClockMux_TypeDef);
N#endif
N///@}
N
N
N///@{
N#if defined(URT_CR0_SDT_EN_mask_w)
X#if 0L
S    void URT_SDT_Cmd( URT_Struct* , FunctionalState);
N#endif
N///@}
N
N
N#endif
N
N
L 54 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_WWDT_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_WWDT_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_WWDT_DRV.H
N *
N * @brief       This is the C code format driver head file for the WWDT module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.10
N * @date        2018/01/31
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N 
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_WWDT.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_WWDT.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_WWDT.h
N *
N * @brief       MG32x02z WWDT Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_WWDT_H
N#define _MG32x02z_WWDT_H
N#define _MG32x02z_WWDT_H_VER                        3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_WWDT_H_VER)
S    #error "MG32x02z_WWDT_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      WWDT_Struct
N *              WWDT  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TF            :1;     //[1] WWDT timer timeout interrupt flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TF            :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WINF          :1;     //[2] WWDT counter refreshing and value over the window compare threshold condition flag
X            volatile uint8_t  WINF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WRNF          :1;     //[3] WWDT counter warning flag
X            volatile uint8_t  WRNF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  WWDT status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TIE           :1;     //[1] WWDT timer timeout interrupt enable.
X            volatile uint8_t  TIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WIN_IE        :1;     //[2] WWDT counter refreshing and value over the window compare threshold condition interru
X            volatile uint8_t  WIN_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WRN_IE        :1;     //[3] WWDT counter warning interrupt enable.
X            volatile uint8_t  WRN_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  WWDT interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_SEL        :1;     //[2] WWDT input clock CK_WWDT source select.
X            volatile uint8_t  CK_SEL        :1;     
N                                        //0x0 = CK_APB
N                                        //0x1 = CK_UT
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CK_DIV        :3;     //[6..4] WWDT internal clock CK_WWDT_INT input divider.
X            volatile uint8_t  CK_DIV        :3;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N                                        //0x5 = DIV32 : divided by 32
N                                        //0x6 = DIV64 : divided by 64
N                                        //0x7 = DIV128 : divided by 128
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CK_PDIV       :1;     //[8] WWDT internal clock CK_WWDT_INT pre-divider value.
X            volatile uint8_t  CK_PDIV       :1;     
N                                        //0 = divided by 1
N                                        //1 = divided by 256
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  WWDT clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] WWDT key register and counter reload enable control
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  WWDT write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] WWDT function enable bit. When disables, WWDT_CNT will keep the counter value.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[3..1] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  RSTF_EN       :1;     //[4] WWDT timer underflow reset generation enable bit.
X            volatile uint8_t  RSTF_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RSTW_EN       :1;     //[5] WWDT reload counter out of window reset generation enable bit.
X            volatile uint8_t  RSTW_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  WWDT control register 0 */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x14]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CNT           :10;    //[9..0] WWDT counter value register.
X            volatile const  uint16_t CNT           :10;    
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CNT;                               /*!< CNT        ~ Offset[0x18]  WWDT counter register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t RLR           :10;    //[9..0] WWDT counter reload register.
X            volatile uint16_t RLR           :10;    
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }RLR;                               /*!< RLR        ~ Offset[0x1C]  WWDT reload register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t WIN           :10;    //[9..0] WWDT window compare threshold register.
X            volatile uint16_t WIN           :10;    
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }WIN;                               /*!< WIN        ~ Offset[0x20]  WWDT window compare register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t WRN           :10;    //[9..0] WWDT warning interrupt compare threshold register.
X            volatile uint16_t WRN           :10;    
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }WRN;                               /*!< WRN        ~ Offset[0x24]  WWDT warning compare register */
N
N} WWDT_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        WWDT  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define WWDT_Base                       ((uint32_t)0x5D010000)              /*!< System Window Watch Dog Timer Control */
N#define WWDT                            ((WWDT_Struct*) WWDT_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        WWDT  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        WWDT_STA  [register's definitions]
N *              Offset[0x00]  WWDT status register (0x5D010000)
N ******************************************************************************
N */
N///@{
N#define WWDT_STA_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_STA */
N#define WWDT_STA_WRNF_mask_w                        ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define WWDT_STA_WRNF_mask_h0                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define WWDT_STA_WRNF_mask_b0                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define WWDT_STA_WRNF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define WWDT_STA_WRNF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define WWDT_STA_WRNF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define WWDT_STA_WRNF_happened_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define WWDT_STA_WRNF_happened_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define WWDT_STA_WRNF_happened_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define WWDT_STA_WINF_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define WWDT_STA_WINF_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define WWDT_STA_WINF_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define WWDT_STA_WINF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define WWDT_STA_WINF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define WWDT_STA_WINF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define WWDT_STA_WINF_happened_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define WWDT_STA_WINF_happened_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define WWDT_STA_WINF_happened_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define WWDT_STA_TF_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define WWDT_STA_TF_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define WWDT_STA_TF_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define WWDT_STA_TF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define WWDT_STA_TF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define WWDT_STA_TF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define WWDT_STA_TF_happened_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define WWDT_STA_TF_happened_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define WWDT_STA_TF_happened_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_INT  [register's definitions]
N *              Offset[0x04]  WWDT interrupt enable register (0x5D010004)
N ******************************************************************************
N */
N///@{
N#define WWDT_INT_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_INT */
N#define WWDT_INT_WRN_IE_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define WWDT_INT_WRN_IE_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define WWDT_INT_WRN_IE_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define WWDT_INT_WRN_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define WWDT_INT_WRN_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define WWDT_INT_WRN_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define WWDT_INT_WRN_IE_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define WWDT_INT_WRN_IE_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define WWDT_INT_WRN_IE_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define WWDT_INT_WIN_IE_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define WWDT_INT_WIN_IE_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define WWDT_INT_WIN_IE_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define WWDT_INT_WIN_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define WWDT_INT_WIN_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define WWDT_INT_WIN_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define WWDT_INT_WIN_IE_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define WWDT_INT_WIN_IE_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define WWDT_INT_WIN_IE_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define WWDT_INT_TIE_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define WWDT_INT_TIE_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define WWDT_INT_TIE_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define WWDT_INT_TIE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define WWDT_INT_TIE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define WWDT_INT_TIE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define WWDT_INT_TIE_enable_w                       ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define WWDT_INT_TIE_enable_h0                      ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define WWDT_INT_TIE_enable_b0                      ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_CLK  [register's definitions]
N *              Offset[0x08]  WWDT clock source register (0x5D010008)
N ******************************************************************************
N */
N///@{
N#define WWDT_CLK_default                            ((uint32_t)0x00000170)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_CLK */
N#define WWDT_CLK_CK_PDIV_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define WWDT_CLK_CK_PDIV_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define WWDT_CLK_CK_PDIV_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define WWDT_CLK_CK_PDIV_divided_by_1_w             ((uint32_t)0x00000000)  /*!< Bit Value =(0):divided by 1 of 32bit */
N#define WWDT_CLK_CK_PDIV_divided_by_1_h0            ((uint16_t)0x0000)      /*!< Bit Value =(0):divided by 1 of 16bit */
N#define WWDT_CLK_CK_PDIV_divided_by_1_b1            ((uint8_t )0x00)        /*!< Bit Value =(0):divided by 1 of 8bit */
N#define WWDT_CLK_CK_PDIV_divided_by_256_w           ((uint32_t)0x00000100)  /*!< Bit Value =(1):divided by 256 of 32bit */
N#define WWDT_CLK_CK_PDIV_divided_by_256_h0          ((uint16_t)0x0100)      /*!< Bit Value =(1):divided by 256 of 16bit */
N#define WWDT_CLK_CK_PDIV_divided_by_256_b1          ((uint8_t )0x01)        /*!< Bit Value =(1):divided by 256 of 8bit */
N
N#define WWDT_CLK_CK_DIV_mask_w                      ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define WWDT_CLK_CK_DIV_mask_h0                     ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define WWDT_CLK_CK_DIV_mask_b0                     ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define WWDT_CLK_CK_DIV_div1_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define WWDT_CLK_CK_DIV_div1_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define WWDT_CLK_CK_DIV_div1_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define WWDT_CLK_CK_DIV_div2_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define WWDT_CLK_CK_DIV_div2_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define WWDT_CLK_CK_DIV_div2_b0                     ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define WWDT_CLK_CK_DIV_div4_w                      ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define WWDT_CLK_CK_DIV_div4_h0                     ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define WWDT_CLK_CK_DIV_div4_b0                     ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define WWDT_CLK_CK_DIV_div8_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define WWDT_CLK_CK_DIV_div8_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define WWDT_CLK_CK_DIV_div8_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define WWDT_CLK_CK_DIV_div16_w                     ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define WWDT_CLK_CK_DIV_div16_h0                    ((uint16_t)0x0040)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define WWDT_CLK_CK_DIV_div16_b0                    ((uint8_t )0x40)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N#define WWDT_CLK_CK_DIV_div32_w                     ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):DIV32 of 32bit */
N#define WWDT_CLK_CK_DIV_div32_h0                    ((uint16_t)0x0050)      /*!< Bit Value =(0x5):DIV32 of 16bit */
N#define WWDT_CLK_CK_DIV_div32_b0                    ((uint8_t )0x50)        /*!< Bit Value =(0x5):DIV32 of 8bit */
N#define WWDT_CLK_CK_DIV_div64_w                     ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):DIV64 of 32bit */
N#define WWDT_CLK_CK_DIV_div64_h0                    ((uint16_t)0x0060)      /*!< Bit Value =(0x6):DIV64 of 16bit */
N#define WWDT_CLK_CK_DIV_div64_b0                    ((uint8_t )0x60)        /*!< Bit Value =(0x6):DIV64 of 8bit */
N#define WWDT_CLK_CK_DIV_div128_w                    ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):DIV128 of 32bit */
N#define WWDT_CLK_CK_DIV_div128_h0                   ((uint16_t)0x0070)      /*!< Bit Value =(0x7):DIV128 of 16bit */
N#define WWDT_CLK_CK_DIV_div128_b0                   ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIV128 of 8bit */
N
N#define WWDT_CLK_CK_SEL_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define WWDT_CLK_CK_SEL_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define WWDT_CLK_CK_SEL_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define WWDT_CLK_CK_SEL_ck_apb_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_APB of 32bit */
N#define WWDT_CLK_CK_SEL_ck_apb_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_APB of 16bit */
N#define WWDT_CLK_CK_SEL_ck_apb_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_APB of 8bit */
N#define WWDT_CLK_CK_SEL_ck_ut_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):CK_UT of 32bit */
N#define WWDT_CLK_CK_SEL_ck_ut_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CK_UT of 16bit */
N#define WWDT_CLK_CK_SEL_ck_ut_b0                    ((uint8_t )0x04)        /*!< Bit Value =(0x1):CK_UT of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_KEY  [register's definitions]
N *              Offset[0x0C]  WWDT write protected Key register (0x5D01000C)
N ******************************************************************************
N */
N///@{
N#define WWDT_KEY_default                            ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_KEY */
N#define WWDT_KEY_KEY_mask_w                         ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define WWDT_KEY_KEY_mask_h0                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define WWDT_KEY_KEY_unprotected_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define WWDT_KEY_KEY_unprotected_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define WWDT_KEY_KEY_unprotected_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define WWDT_KEY_KEY_protected_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define WWDT_KEY_KEY_protected_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define WWDT_KEY_KEY_protected_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_CR0  [register's definitions]
N *              Offset[0x10]  WWDT control register 0 (0x5D010010)
N ******************************************************************************
N */
N///@{
N#define WWDT_CR0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_CR0 */
N#define WWDT_CR0_RSTW_EN_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define WWDT_CR0_RSTW_EN_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define WWDT_CR0_RSTW_EN_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define WWDT_CR0_RSTW_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define WWDT_CR0_RSTW_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define WWDT_CR0_RSTW_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define WWDT_CR0_RSTW_EN_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define WWDT_CR0_RSTW_EN_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define WWDT_CR0_RSTW_EN_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define WWDT_CR0_RSTF_EN_mask_w                     ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define WWDT_CR0_RSTF_EN_mask_h0                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define WWDT_CR0_RSTF_EN_mask_b0                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define WWDT_CR0_RSTF_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define WWDT_CR0_RSTF_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define WWDT_CR0_RSTF_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define WWDT_CR0_RSTF_EN_enable_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define WWDT_CR0_RSTF_EN_enable_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define WWDT_CR0_RSTF_EN_enable_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define WWDT_CR0_EN_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define WWDT_CR0_EN_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define WWDT_CR0_EN_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define WWDT_CR0_EN_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define WWDT_CR0_EN_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define WWDT_CR0_EN_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define WWDT_CR0_EN_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define WWDT_CR0_EN_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define WWDT_CR0_EN_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_CNT  [register's definitions]
N *              Offset[0x18]  WWDT counter register (0x5D010018)
N ******************************************************************************
N */
N///@{
N#define WWDT_CNT_default                            ((uint32_t)0x000003FF)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_CNT */
N#define WWDT_CNT_CNT_mask_w                         ((uint32_t)0x000003FF)  /*!< Bit Mask of 32bit */
N#define WWDT_CNT_CNT_mask_h0                        ((uint16_t)0x03FF)      /*!< Bit Mask of 16bit */
N#define WWDT_CNT_CNT_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define WWDT_CNT_CNT_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define WWDT_CNT_CNT_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_RLR  [register's definitions]
N *              Offset[0x1C]  WWDT reload register (0x5D01001C)
N ******************************************************************************
N */
N///@{
N#define WWDT_RLR_default                            ((uint32_t)0x000003FF)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_RLR */
N#define WWDT_RLR_RLR_mask_w                         ((uint32_t)0x000003FF)  /*!< Bit Mask of 32bit */
N#define WWDT_RLR_RLR_mask_h0                        ((uint16_t)0x03FF)      /*!< Bit Mask of 16bit */
N#define WWDT_RLR_RLR_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define WWDT_RLR_RLR_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define WWDT_RLR_RLR_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_WIN  [register's definitions]
N *              Offset[0x20]  WWDT window compare register (0x5D010020)
N ******************************************************************************
N */
N///@{
N#define WWDT_WIN_default                            ((uint32_t)0x000003FF)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_WIN */
N#define WWDT_WIN_WIN_mask_w                         ((uint32_t)0x000003FF)  /*!< Bit Mask of 32bit */
N#define WWDT_WIN_WIN_mask_h0                        ((uint16_t)0x03FF)      /*!< Bit Mask of 16bit */
N#define WWDT_WIN_WIN_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define WWDT_WIN_WIN_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define WWDT_WIN_WIN_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        WWDT_WRN  [register's definitions]
N *              Offset[0x24]  WWDT warning compare register (0x5D010024)
N ******************************************************************************
N */
N///@{
N#define WWDT_WRN_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of WWDT_WRN */
N#define WWDT_WRN_WRN_mask_w                         ((uint32_t)0x000003FF)  /*!< Bit Mask of 32bit */
N#define WWDT_WRN_WRN_mask_h0                        ((uint16_t)0x03FF)      /*!< Bit Mask of 16bit */
N#define WWDT_WRN_WRN_shift_w                        (0)                     /*!< Bit Shift of 32bit */
N#define WWDT_WRN_WRN_shift_h0                       (0)                     /*!< Bit Shift of 16bit */
N#define WWDT_WRN_WRN_shift_b0                       (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_WWDT_H
N
N/*----------------------------------------------------------------------------*/
N/*                        End of file MG32x02z_WWDT.h                         */
N/*----------------------------------------------------------------------------*/
L 31 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_WWDT_DRV.h" 2
N
N#ifndef _MG32x02z_WWDT_DRV_H
N/*!< _MG32x02z_WWDT_DRV_H */ 
N#define _MG32x02z_WWDT_DRV_H
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define WWDT_RSTW       WWDT_CR0_RSTW_EN_mask_b0    /*!< WWDT reload counter out of window reset generation enable bit */
N#define WWDT_RSTF       WWDT_CR0_RSTF_EN_mask_b0    /*!< WWDT timer underflow reset generation enable bit */
N
N#define WWDT_WRNF       WWDT_STA_WRNF_mask_w                /*!< WWDT counter warning flag */
N#define WWDT_WINF       WWDT_STA_WINF_mask_w                /*!< WWDT counter refreshing and value over the window compare threshold condition flag  */
N#define WWDT_TF         WWDT_STA_TF_mask_w                  /*!< WWDT timer timeout interrupt flag */
N#define WWDT_ALLF       (WWDT_WRNF | WWDT_WINF | WWDT_TF)   /*!< WWDT all flag */
N
N#define WWDT_INT_WRN    WWDT_INT_WRN_IE_mask_w      /*!< WWDT counter warning interrupt enable */
N#define WWDT_INT_WIN    WWDT_INT_WIN_IE_mask_w      /*!< WWDT counter refreshing and value over the window compare threshold condition interrupt enable */
N#define WWDT_INT_TF     WWDT_INT_TIE_mask_w         /*!< WWDT timer timeout interrupt enable */
N/* @} */
N
N
N
N/*! @enum   WWDT_CLKS_TypeDef
N    @brief  WWDT input clock select
N*/
Ntypedef enum   
N{
N    WWDT_CK_APB     = 0,    /*!< WWDT clock source select CK_APB */
N    WWDT_CK_UT      = 1     /*!< WWDT clock source select UT */
N}WWDT_CLKS_TypeDef;
N
N
N/*! @enum   WWDT_DIVS_TypeDef
N    @brief  WWDT internal clock CK_WWDT_INT input divider
N*/
Ntypedef enum
N{   
N    WWDT_DIV_1      = 0,    /*!< Select clock divided by 1 */
N    WWDT_DIV_2      = 1,    /*!< Select clock divided by 2 */
N    WWDT_DIV_4      = 2,    /*!< Select clock divided by 4 */
N    WWDT_DIV_8      = 3,    /*!< Select clock divided by 8 */
N    WWDT_DIV_16     = 4,    /*!< Select clock divided by 16 */
N    WWDT_DIV_32     = 5,    /*!< Select clock divided by 32 */
N    WWDT_DIV_64     = 6,    /*!< Select clock divided by 64 */
N    WWDT_DIV_128    = 7     /*!< Select clock divided by 128 */
N}WWDT_DIVS_TypeDef;
N
N
N/*! @enum   WWDT_PDIVS_TypeDef
N    @brief  WWDT internal clock CK_WWDT_INT pre-divider valuer
N*/
Ntypedef enum
N{
N    WWDT_PDIV_1     = 0,    /*!< Select clock pre-divider by 1 */
N    WWDT_PDIV_256   = 1     /*!< Select clock pre-divider by 256 */
N}WWDT_PDIVS_TypeDef;
N
N
N/**
N * @name	Function announce
N *
N */ 
Nvoid WWDT_CLK_Select(WWDT_CLKS_TypeDef WWDT_CLKS);
Nvoid WWDT_DIV_Select (WWDT_DIVS_TypeDef WWDT_DIVS);
N
Nvoid WWDT_PDIV_Select (WWDT_PDIVS_TypeDef WWDT_PDIVS);
Nvoid WWDT_Cmd (FunctionalState NewState);
N
Nuint16_t WWDT_GetCounter (void);
Nvoid WWDT_RefreshCounter (void);
Nuint16_t WWDT_GetReloadReg (void);
Nvoid WWDT_SetReloadReg (uint16_t WWDT_RLR);
Nuint16_t WWDT_GetWindowThreshold (void);
Nvoid WWDT_SetWindowThreshold (uint16_t WWDT_WIN);
Nuint16_t WWDT_GetWarningThreshold (void);
Nvoid WWDT_SetWarningThreshold (uint16_t WWDT_WRN);
N
Nvoid WWDT_RstEvent_Config (uint8_t WWDT_RSTGS, FunctionalState NewState);
Nuint32_t WWDT_GetAllFlagStatus (void);
NDRV_Return WWDT_GetSingleFlagStatus (uint32_t WWDT_ITSrc);
Nvoid WWDT_ClearFlag (uint32_t WWDT_ITSrc);
Nvoid WWDT_IT_Config (uint32_t WWDT_ITSrc, FunctionalState NewState);
N
N#endif  //_MG32x02z_WWDT_DRV_H
N
N
L 55 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_DMA_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DMA_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DMA_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the DMA
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.18
N * @date        2020/11/12
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N
N#ifndef __MG32x02z_DMA_DRV_H
N#define __MG32x02z_DMA_DRV_H
N//#define _MG32x02z_DMA_DRV_H_VER 0.01
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_DMA.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_DMA.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DMA.h
N *
N * @brief       MG32x02z DMA Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_DMA_H
N#define _MG32x02z_DMA_H
N#define _MG32x02z_DMA_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_DMA_H_VER)
S    #error "MG32x02z_DMA_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      DMA_Struct
N *              DMA  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  CH0_GIF       :1;     //[0] DMA channel-0 global interrupt flag
X            volatile const  uint8_t  CH0_GIF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_TCF       :1;     //[1] DMA channel-0 transfer complete flag
X            volatile uint8_t  CH0_TCF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_THF       :1;     //[2] DMA channel-0 transfer half flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH0_THF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_ERRF      :1;     //[3] DMA channel-0 transfer error flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH0_ERRF      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t  CH1_GIF       :1;     //[4] DMA channel-1 global interrupt flag
X            volatile const  uint8_t  CH1_GIF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_TCF       :1;     //[5] DMA channel-1 transfer complete flag
X            volatile uint8_t  CH1_TCF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_THF       :1;     //[6] DMA channel-1 transfer half flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH1_THF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_ERRF      :1;     //[7] DMA channel-1 transfer error flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH1_ERRF      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t  CH2_GIF       :1;     //[8] DMA channel-2 global interrupt flag
X            volatile const  uint8_t  CH2_GIF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_TCF       :1;     //[9] DMA channel-2 transfer complete flag
X            volatile uint8_t  CH2_TCF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_THF       :1;     //[10] DMA channel-2 transfer half flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH2_THF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_ERRF      :1;     //[11] DMA channel-2 transfer error flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  CH2_ERRF      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :15;    //[30..16] 
X            volatile const  uint16_t               :15;    
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  DMA status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] DMA interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :15;    //[30..16] 
X            volatile const  uint16_t               :15;    
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  DMA interrupt enable register */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] DMA controller enable.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PRI_MDS       :1;     //[1] DMA channel priority mode select.
X            volatile uint8_t  PRI_MDS       :1;     
N                                        //0 = Round : control by Round Robin method
N                                        //1 = Level : control by channel priority level
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  GPL_CHS       :2;     //[5..4] DMA channel select for extra GPL function
X            volatile uint8_t  GPL_CHS       :2;     
N                                        //0x0 = Disable : no any channel with GPL function
N                                        //0x1 = CH0
N                                        //0x2 = CH1
N                                        //0x3 = CH2
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  CH0_ENB       :1;     //[16] DMA channel-0 operation enable bit. This bit is as same as DMA_CH0_EN.
X            volatile uint8_t  CH0_ENB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_ENB       :1;     //[17] DMA channel-0 operation enable bit. This bit is as same as DMA_CH1_EN.
X            volatile uint8_t  CH1_ENB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_ENB       :1;     //[18] DMA channel-0 operation enable bit. This bit is as same as DMA_CH2_EN.
X            volatile uint8_t  CH2_ENB       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  DMA global control register 0 */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x14]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  MAIN_STA      :3;     //[2..0] DMA main state machine status for debug only.
X            volatile const  uint8_t  MAIN_STA      :3;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  CH_STA        :3;     //[6..4] DMA channel state machine status for debug only.
X            volatile const  uint8_t  CH_STA        :3;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  SEL_CH0       :1;     //[8] DMA channel select channel-0 status for debug only.
X            volatile const  uint8_t  SEL_CH0       :1;     
N            __I  uint8_t  SEL_CH1       :1;     //[9] DMA channel select channel-1 status for debug only.
X            volatile const  uint8_t  SEL_CH1       :1;     
N            __I  uint8_t  SEL_CH2       :1;     //[10] DMA channel select channel-2 status for debug only.
X            volatile const  uint8_t  SEL_CH2       :1;     
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  XMDS_CH0      :3;     //[18..16] DMA channel-0 XMDA control status for debug only.
X            volatile const  uint8_t  XMDS_CH0      :3;     
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  XMDS_CH1      :3;     //[22..20] DMA channel-1 XMDA control status for debug only.
X            volatile const  uint8_t  XMDS_CH1      :3;     
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  XMDS_CH2      :3;     //[26..24] DMA channel-2 XMDA control status for debug only.
X            volatile const  uint8_t  XMDS_CH2      :3;     
N            __I  uint8_t                :1;     //[27] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  DMA global control register 2 */
N
N    __I uint32_t  RESERVED2;            /*!< RESERVED2  ~ Offset[0x1C]  Reserved */
X    volatile const uint32_t  RESERVED2;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH0_EN        :1;     //[0] DMA channel operation enable
X            volatile uint8_t  CH0_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_HOLD      :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  CH0_HOLD      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_LOOP      :1;     //[2] DMA loop mode enable
X            volatile uint8_t  CH0_LOOP      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_ADSEL     :1;     //[3] DMA address increased mode select
X            volatile uint8_t  CH0_ADSEL     :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_XMDS      :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  CH0_XMDS      :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  CH0_PLS       :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  CH0_PLS       :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  CH0_BSIZE     :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  CH0_BSIZE     :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_REQ       :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  CH0_REQ       :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_CIE       :1;     //[17] DMA channel-0 transfer complete interrupt enable.
X            volatile uint8_t  CH0_CIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_HIE       :1;     //[18] DMA channel-0 transfer half interrupt enable.
X            volatile uint8_t  CH0_HIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_EIE       :1;     //[19] DMA channel-0 transfer error interrupt enable.
X            volatile uint8_t  CH0_EIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH0_TC2F      :1;     //[25] DMA channel-0 transfer complete flag
X            volatile uint8_t  CH0_TC2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_TH2F      :1;     //[26] DMA channel-0 transfer half flag
X            volatile uint8_t  CH0_TH2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH0_ERR2F     :1;     //[27] DMA channel-0 transfer error flag
X            volatile uint8_t  CH0_ERR2F     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CH0A;                              /*!< CH0A       ~ Offset[0x20]  DMA channel-0 control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH0_SRC       :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  CH0_SRC       :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH0_DET       :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  CH0_DET       :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH0_SINC      :1;     //[16] DMA source memory transfer address auto increased enable
X            volatile uint8_t  CH0_SINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_DINC      :1;     //[17] DMA destination memory transfer address auto increased enable
X            volatile uint8_t  CH0_DINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_SSYNC     :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  CH0_SSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH0_DSYNC     :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  CH0_DSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH0_XPIN      :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  CH0_XPIN      :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CH0B;                              /*!< CH0B       ~ Offset[0x24]  DMA channel-0 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CH0_NUM       :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t CH0_NUM       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH0NUM;                            /*!< CH0NUM     ~ Offset[0x28]  DMA channel-0 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CH0_CNT       :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CH0_CNT       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH0CNT;                            /*!< CH0CNT     ~ Offset[0x2C]  DMA channel-0 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH0_SSA       :32;    //[31..0] DMA source memory transfer start address.
X            volatile uint32_t CH0_SSA       :32;    
N        }MBIT;
N    }CH0SSA;                            /*!< CH0SSA     ~ Offset[0x30]  DMA channel-0 source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH0_SCA       :32;    //[31..0] DMA source memory transfer current address
X            volatile const  uint32_t CH0_SCA       :32;    
N        }MBIT;
N    }CH0SCA;                            /*!< CH0SCA     ~ Offset[0x34]  DMA channel-0 source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH0_DSA       :32;    //[31..0] DMA destination memory transfer start address.
X            volatile uint32_t CH0_DSA       :32;    
N        }MBIT;
N    }CH0DSA;                            /*!< CH0DSA     ~ Offset[0x38]  DMA channel-0 destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH0_DCA       :32;    //[31..0] DMA destination memory transfer current address
X            volatile const  uint32_t CH0_DCA       :32;    
N        }MBIT;
N    }CH0DCA;                            /*!< CH0DCA     ~ Offset[0x3C]  DMA channel-0 destination current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH1_EN        :1;     //[0] DMA channel operation enable
X            volatile uint8_t  CH1_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_HOLD      :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  CH1_HOLD      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_LOOP      :1;     //[2] DMA loop mode enable
X            volatile uint8_t  CH1_LOOP      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_ADSEL     :1;     //[3] DMA address increased mode select
X            volatile uint8_t  CH1_ADSEL     :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_XMDS      :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  CH1_XMDS      :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  CH1_PLS       :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  CH1_PLS       :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  CH1_BSIZE     :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  CH1_BSIZE     :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_REQ       :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  CH1_REQ       :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_CIE       :1;     //[17] DMA channel-1 transfer complete interrupt enable.
X            volatile uint8_t  CH1_CIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_HIE       :1;     //[18] DMA channel-1 transfer half interrupt enable.
X            volatile uint8_t  CH1_HIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_EIE       :1;     //[19] DMA channel-1 transfer error interrupt enable.
X            volatile uint8_t  CH1_EIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH1_TC2F      :1;     //[25] DMA channel-1 transfer complete flag
X            volatile uint8_t  CH1_TC2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_TH2F      :1;     //[26] DMA channel-1 transfer half flag
X            volatile uint8_t  CH1_TH2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH1_ERR2F     :1;     //[27] DMA channel-1 transfer error flag
X            volatile uint8_t  CH1_ERR2F     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CH1A;                              /*!< CH1A       ~ Offset[0x40]  DMA channel-1 control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH1_SRC       :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  CH1_SRC       :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH1_DET       :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  CH1_DET       :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH1_SINC      :1;     //[16] DMA source memory transfer address auto increased enable
X            volatile uint8_t  CH1_SINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_DINC      :1;     //[17] DMA destination memory transfer address auto increased enable
X            volatile uint8_t  CH1_DINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_SSYNC     :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  CH1_SSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH1_DSYNC     :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  CH1_DSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH1_XPIN      :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  CH1_XPIN      :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CH1B;                              /*!< CH1B       ~ Offset[0x44]  DMA channel-1 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CH1_NUM       :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t CH1_NUM       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH1NUM;                            /*!< CH1NUM     ~ Offset[0x48]  DMA channel-1 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CH1_CNT       :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CH1_CNT       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH1CNT;                            /*!< CH1CNT     ~ Offset[0x4C]  DMA channel-1 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH1_SSA       :32;    //[31..0] DMA source memory transfer start address.
X            volatile uint32_t CH1_SSA       :32;    
N        }MBIT;
N    }CH1SSA;                            /*!< CH1SSA     ~ Offset[0x50]  DMA channel-1 source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH1_SCA       :32;    //[31..0] DMA source memory transfer current address
X            volatile const  uint32_t CH1_SCA       :32;    
N        }MBIT;
N    }CH1SCA;                            /*!< CH1SCA     ~ Offset[0x54]  DMA channel-1 source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH1_DSA       :32;    //[31..0] DMA destination memory transfer start address.
X            volatile uint32_t CH1_DSA       :32;    
N        }MBIT;
N    }CH1DSA;                            /*!< CH1DSA     ~ Offset[0x58]  DMA channel-1 destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH1_DCA       :32;    //[31..0] DMA destination memory transfer current address
X            volatile const  uint32_t CH1_DCA       :32;    
N        }MBIT;
N    }CH1DCA;                            /*!< CH1DCA     ~ Offset[0x5C]  DMA channel-1 destination current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH2_EN        :1;     //[0] DMA channel operation enable
X            volatile uint8_t  CH2_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_HOLD      :1;     //[1] DMA channel operation hold enable
X            volatile uint8_t  CH2_HOLD      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_LOOP      :1;     //[2] DMA loop mode enable
X            volatile uint8_t  CH2_LOOP      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_ADSEL     :1;     //[3] DMA address increased mode select
X            volatile uint8_t  CH2_ADSEL     :1;     
N                                        //0 = Normal : sequential increment 1
N                                        //1 = SKIP3 : address increment from 0 to 1,2 then return 0
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_XMDS      :2;     //[9..8] DMA channel external pin trigger request mode select
X            volatile uint8_t  CH2_XMDS      :2;     
N                                        //0x0 = Disable : disable external request pin input
N                                        //0x1 = Single : single request mode
N                                        //0x2 = Block : block request mode
N                                        //0x3 = Demand : demand request mode(active high)
N            __IO uint8_t  CH2_PLS       :2;     //[11..10] DMA channel priority level select.
X            volatile uint8_t  CH2_PLS       :2;     
N                                        //0x0 = LV0 : lowest priority
N                                        //0x1 = LV1 : normal priority
N                                        //0x2 = LV2 : high priority
N                                        //0x3 = LV3 : highest priority
N            __IO uint8_t  CH2_BSIZE     :2;     //[13..12] DMA transfer burst size
X            volatile uint8_t  CH2_BSIZE     :2;     
N                                        //0x0 = One
N                                        //0x1 = Two
N                                        //0x2 = Reserved
N                                        //0x3 = Four
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_REQ       :1;     //[15] DMA channel data transfer request enable
X            volatile uint8_t  CH2_REQ       :1;     
N                                        //0 = No : no effect
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_CIE       :1;     //[17] DMA channel-2 transfer complete interrupt enable.
X            volatile uint8_t  CH2_CIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_HIE       :1;     //[18] DMA channel-2 transfer half interrupt enable.
X            volatile uint8_t  CH2_HIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_EIE       :1;     //[19] DMA channel-2 transfer error interrupt enable.
X            volatile uint8_t  CH2_EIE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CH2_TC2F      :1;     //[25] DMA channel-2 transfer complete flag
X            volatile uint8_t  CH2_TC2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_TH2F      :1;     //[26] DMA channel-2 transfer half flag
X            volatile uint8_t  CH2_TH2F      :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __IO uint8_t  CH2_ERR2F     :1;     //[27] DMA channel-2 transfer error flag
X            volatile uint8_t  CH2_ERR2F     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CH2A;                              /*!< CH2A       ~ Offset[0x60]  DMA channel-2 control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH2_SRC       :4;     //[3..0] DMA channel transfer peripheral source select
X            volatile uint8_t  CH2_SRC       :4;     
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH2_DET       :4;     //[11..8] DMA channel transfer peripheral destination select
X            volatile uint8_t  CH2_DET       :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CH2_SINC      :1;     //[16] DMA source memory transfer address auto increased enable
X            volatile uint8_t  CH2_SINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_DINC      :1;     //[17] DMA destination memory transfer address auto increased enable
X            volatile uint8_t  CH2_DINC      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_SSYNC     :1;     //[18] DMA source process synchronization enable bit
X            volatile uint8_t  CH2_SSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH2_DSYNC     :1;     //[19] DMA destination process synchronization enable bit
X            volatile uint8_t  CH2_DSYNC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH2_XPIN      :1;     //[24] DMA channel external trigger pin select.
X            volatile uint8_t  CH2_XPIN      :1;     
N                                        //0x0 = TRG0 : DMA_TRG0 pin
N                                        //0x1 = TRG1 : DMA_TRG1 pin
N            __I  uint8_t                :7;     //[31..25] 
X            volatile const  uint8_t                :7;     
N        }MBIT;
N    }CH2B;                              /*!< CH2B       ~ Offset[0x64]  DMA channel-2 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t CH2_NUM       :16;    //[15..0] DMA transfer data count initial number
X            volatile uint16_t CH2_NUM       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH2NUM;                            /*!< CH2NUM     ~ Offset[0x68]  DMA channel-2 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t CH2_CNT       :16;    //[15..0] DMA transfer data count current value
X            volatile const  uint16_t CH2_CNT       :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CH2CNT;                            /*!< CH2CNT     ~ Offset[0x6C]  DMA channel-2 control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH2_SSA       :32;    //[31..0] DMA source memory transfer start address.
X            volatile uint32_t CH2_SSA       :32;    
N        }MBIT;
N    }CH2SSA;                            /*!< CH2SSA     ~ Offset[0x70]  DMA channel-2 source start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH2_SCA       :32;    //[31..0] DMA source memory transfer current address
X            volatile const  uint32_t CH2_SCA       :32;    
N        }MBIT;
N    }CH2SCA;                            /*!< CH2SCA     ~ Offset[0x74]  DMA channel-2 source current address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t CH2_DSA       :32;    //[31..0] DMA destination memory transfer start address.
X            volatile uint32_t CH2_DSA       :32;    
N        }MBIT;
N    }CH2DSA;                            /*!< CH2DSA     ~ Offset[0x78]  DMA channel-2 destination start address register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CH2_DCA       :32;    //[31..0] DMA destination memory transfer current address
X            volatile const  uint32_t CH2_DCA       :32;    
N        }MBIT;
N    }CH2DCA;                            /*!< CH2DCA     ~ Offset[0x7C]  DMA channel-2 destination current address register */
N
N} DMA_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        DMA  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define DMA_Base                        ((uint32_t)0x4BF00000)              /*!< Direct Memory Access Control */
N#define DMA                             ((DMA_Struct*) DMA_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        DMA  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        DMA_STA  [register's definitions]
N *              Offset[0x00]  DMA status register (0x4BF00000)
N ******************************************************************************
N */
N///@{
N#define DMA_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_STA */
N#define DMA_STA_CH2_ERRF_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_ERRF_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_ERRF_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_ERRF_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_ERRF_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_ERRF_normal_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_ERRF_happened_w                 ((uint32_t)0x00000800)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_ERRF_happened_h0                ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_ERRF_happened_b1                ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH2_THF_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_THF_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_THF_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_THF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_THF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_THF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_THF_happened_w                  ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_THF_happened_h0                 ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_THF_happened_b1                 ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH2_TCF_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_TCF_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_TCF_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_TCF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_TCF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_TCF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_TCF_happened_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_TCF_happened_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_TCF_happened_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH2_GIF_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH2_GIF_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH2_GIF_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH2_GIF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH2_GIF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH2_GIF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH2_GIF_happened_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH2_GIF_happened_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH2_GIF_happened_b1                 ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_ERRF_mask_w                     ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_ERRF_mask_h0                    ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_ERRF_mask_b0                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_ERRF_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_ERRF_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_ERRF_normal_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_ERRF_happened_w                 ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_ERRF_happened_h0                ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_ERRF_happened_b0                ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_THF_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_THF_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_THF_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_THF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_THF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_THF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_THF_happened_w                  ((uint32_t)0x00000040)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_THF_happened_h0                 ((uint16_t)0x0040)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_THF_happened_b0                 ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_TCF_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_TCF_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_TCF_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_TCF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_TCF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_TCF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_TCF_happened_w                  ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_TCF_happened_h0                 ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_TCF_happened_b0                 ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH1_GIF_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH1_GIF_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH1_GIF_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH1_GIF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH1_GIF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH1_GIF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH1_GIF_happened_w                  ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH1_GIF_happened_h0                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH1_GIF_happened_b0                 ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_ERRF_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_ERRF_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_ERRF_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_ERRF_normal_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_ERRF_normal_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_ERRF_normal_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_ERRF_happened_w                 ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_ERRF_happened_h0                ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_ERRF_happened_b0                ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_THF_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_THF_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_THF_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_THF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_THF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_THF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_THF_happened_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_THF_happened_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_THF_happened_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_TCF_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_TCF_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_TCF_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_TCF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_TCF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_TCF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_TCF_happened_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_TCF_happened_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_TCF_happened_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_STA_CH0_GIF_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_STA_CH0_GIF_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_STA_CH0_GIF_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_STA_CH0_GIF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_STA_CH0_GIF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_STA_CH0_GIF_normal_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_STA_CH0_GIF_happened_w                  ((uint32_t)0x00000001)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_STA_CH0_GIF_happened_h0                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_STA_CH0_GIF_happened_b0                 ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_INT  [register's definitions]
N *              Offset[0x04]  DMA interrupt enable register (0x4BF00004)
N ******************************************************************************
N */
N///@{
N#define DMA_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_INT */
N#define DMA_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CR0  [register's definitions]
N *              Offset[0x10]  DMA global control register 0 (0x4BF00010)
N ******************************************************************************
N */
N///@{
N#define DMA_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CR0 */
N#define DMA_CR0_CH2_ENB_mask_w                      ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_CH2_ENB_mask_h1                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_CH2_ENB_mask_b2                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_CH2_ENB_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_CH2_ENB_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_CH2_ENB_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_CH2_ENB_enable_w                    ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_CH2_ENB_enable_h1                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_CH2_ENB_enable_b2                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CR0_CH1_ENB_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_CH1_ENB_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_CH1_ENB_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_CH1_ENB_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_CH1_ENB_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_CH1_ENB_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_CH1_ENB_enable_w                    ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_CH1_ENB_enable_h1                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_CH1_ENB_enable_b2                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CR0_CH0_ENB_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_CH0_ENB_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_CH0_ENB_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_CH0_ENB_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_CH0_ENB_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_CH0_ENB_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_CH0_ENB_enable_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_CH0_ENB_enable_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_CH0_ENB_enable_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CR0_GPL_CHS_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_GPL_CHS_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_GPL_CHS_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_GPL_CHS_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CR0_GPL_CHS_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CR0_GPL_CHS_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CR0_GPL_CHS_ch0_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):CH0 of 32bit */
N#define DMA_CR0_GPL_CHS_ch0_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):CH0 of 16bit */
N#define DMA_CR0_GPL_CHS_ch0_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):CH0 of 8bit */
N#define DMA_CR0_GPL_CHS_ch1_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):CH1 of 32bit */
N#define DMA_CR0_GPL_CHS_ch1_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):CH1 of 16bit */
N#define DMA_CR0_GPL_CHS_ch1_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):CH1 of 8bit */
N#define DMA_CR0_GPL_CHS_ch2_w                       ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):CH2 of 32bit */
N#define DMA_CR0_GPL_CHS_ch2_h0                      ((uint16_t)0x0030)      /*!< Bit Value =(0x3):CH2 of 16bit */
N#define DMA_CR0_GPL_CHS_ch2_b0                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):CH2 of 8bit */
N
N#define DMA_CR0_PRI_MDS_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_PRI_MDS_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_PRI_MDS_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_PRI_MDS_round_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Round of 32bit */
N#define DMA_CR0_PRI_MDS_round_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Round of 16bit */
N#define DMA_CR0_PRI_MDS_round_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Round of 8bit */
N#define DMA_CR0_PRI_MDS_level_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Level of 32bit */
N#define DMA_CR0_PRI_MDS_level_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Level of 16bit */
N#define DMA_CR0_PRI_MDS_level_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Level of 8bit */
N
N#define DMA_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CR2  [register's definitions]
N *              Offset[0x18]  DMA global control register 2 (0x4BF00018)
N ******************************************************************************
N */
N///@{
N#define DMA_CR2_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CR2 */
N#define DMA_CR2_XMDS_CH2_mask_w                     ((uint32_t)0x07000000)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_XMDS_CH2_mask_h1                    ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_XMDS_CH2_mask_b3                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_XMDS_CH2_shift_w                    (24)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_XMDS_CH2_shift_h1                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_XMDS_CH2_shift_b3                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_XMDS_CH1_mask_w                     ((uint32_t)0x00700000)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_XMDS_CH1_mask_h1                    ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_XMDS_CH1_mask_b2                    ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_XMDS_CH1_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_XMDS_CH1_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_XMDS_CH1_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_XMDS_CH0_mask_w                     ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_XMDS_CH0_mask_h1                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_XMDS_CH0_mask_b2                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_XMDS_CH0_shift_w                    (16)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_XMDS_CH0_shift_h1                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_XMDS_CH0_shift_b2                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_SEL_CH2_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_SEL_CH2_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_SEL_CH2_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_SEL_CH2_shift_w                     (10)                    /*!< Bit Shift of 32bit */
N#define DMA_CR2_SEL_CH2_shift_h0                    (10)                    /*!< Bit Shift of 16bit */
N#define DMA_CR2_SEL_CH2_shift_b1                    (2)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_SEL_CH1_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_SEL_CH1_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_SEL_CH1_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_SEL_CH1_shift_w                     (9)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_SEL_CH1_shift_h0                    (9)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_SEL_CH1_shift_b1                    (1)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_SEL_CH0_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_SEL_CH0_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_SEL_CH0_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_SEL_CH0_shift_w                     (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_SEL_CH0_shift_h0                    (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_SEL_CH0_shift_b1                    (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_CH_STA_mask_w                       ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_CH_STA_mask_h0                      ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_CH_STA_mask_b0                      ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_CH_STA_shift_w                      (4)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_CH_STA_shift_h0                     (4)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_CH_STA_shift_b0                     (4)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CR2_MAIN_STA_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define DMA_CR2_MAIN_STA_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define DMA_CR2_MAIN_STA_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DMA_CR2_MAIN_STA_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CR2_MAIN_STA_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CR2_MAIN_STA_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0A  [register's definitions]
N *              Offset[0x20]  DMA channel-0 control register 0 (0x4BF00020)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0A_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0A */
N#define DMA_CH0A_CH0_ERR2F_mask_w                   ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_ERR2F_mask_h1                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_ERR2F_mask_b3                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_ERR2F_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_ERR2F_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_ERR2F_normal_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_ERR2F_happened_w               ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH0A_CH0_ERR2F_happened_h1              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH0A_CH0_ERR2F_happened_b3              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH0A_CH0_TH2F_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_TH2F_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_TH2F_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_TH2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_TH2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_TH2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_TH2F_happened_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH0A_CH0_TH2F_happened_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH0A_CH0_TH2F_happened_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH0A_CH0_TC2F_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_TC2F_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_TC2F_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_TC2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_TC2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_TC2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_TC2F_happened_w                ((uint32_t)0x02000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH0A_CH0_TC2F_happened_h1               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH0A_CH0_TC2F_happened_b3               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH0A_CH0_EIE_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_EIE_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_EIE_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_EIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_EIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_EIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_EIE_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_EIE_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_EIE_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_HIE_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_HIE_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_HIE_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_HIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_HIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_HIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_HIE_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_HIE_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_HIE_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_CIE_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_CIE_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_CIE_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_CIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_CIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_CIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_CIE_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_CIE_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_CIE_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_REQ_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_REQ_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_REQ_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_REQ_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define DMA_CH0A_CH0_REQ_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define DMA_CH0A_CH0_REQ_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define DMA_CH0A_CH0_REQ_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_REQ_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_REQ_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_BSIZE_mask_w                   ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_BSIZE_mask_h0                  ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_BSIZE_mask_b1                  ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_BSIZE_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define DMA_CH0A_CH0_BSIZE_one_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define DMA_CH0A_CH0_BSIZE_one_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define DMA_CH0A_CH0_BSIZE_two_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Two of 32bit */
N#define DMA_CH0A_CH0_BSIZE_two_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Two of 16bit */
N#define DMA_CH0A_CH0_BSIZE_two_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):Two of 8bit */
N#define DMA_CH0A_CH0_BSIZE_four_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Four of 32bit */
N#define DMA_CH0A_CH0_BSIZE_four_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Four of 16bit */
N#define DMA_CH0A_CH0_BSIZE_four_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):Four of 8bit */
N
N#define DMA_CH0A_CH0_PLS_mask_w                     ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_PLS_mask_h0                    ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_PLS_mask_b1                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_PLS_lv0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):LV0 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):LV0 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv0_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):LV0 of 8bit */
N#define DMA_CH0A_CH0_PLS_lv1_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):LV1 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv1_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LV1 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv1_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):LV1 of 8bit */
N#define DMA_CH0A_CH0_PLS_lv2_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):LV2 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv2_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):LV2 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv2_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):LV2 of 8bit */
N#define DMA_CH0A_CH0_PLS_lv3_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):LV3 of 32bit */
N#define DMA_CH0A_CH0_PLS_lv3_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):LV3 of 16bit */
N#define DMA_CH0A_CH0_PLS_lv3_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):LV3 of 8bit */
N
N#define DMA_CH0A_CH0_XMDS_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_XMDS_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_XMDS_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_XMDS_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CH0A_CH0_XMDS_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CH0A_CH0_XMDS_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CH0A_CH0_XMDS_single_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Single of 32bit */
N#define DMA_CH0A_CH0_XMDS_single_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Single of 16bit */
N#define DMA_CH0A_CH0_XMDS_single_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):Single of 8bit */
N#define DMA_CH0A_CH0_XMDS_block_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Block of 32bit */
N#define DMA_CH0A_CH0_XMDS_block_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Block of 16bit */
N#define DMA_CH0A_CH0_XMDS_block_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Block of 8bit */
N#define DMA_CH0A_CH0_XMDS_demand_w                  ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Demand of 32bit */
N#define DMA_CH0A_CH0_XMDS_demand_h0                 ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Demand of 16bit */
N#define DMA_CH0A_CH0_XMDS_demand_b1                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):Demand of 8bit */
N
N#define DMA_CH0A_CH0_ADSEL_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_ADSEL_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_ADSEL_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_ADSEL_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH0A_CH0_ADSEL_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH0A_CH0_ADSEL_normal_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH0A_CH0_ADSEL_skip3_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):SKIP3 of 32bit */
N#define DMA_CH0A_CH0_ADSEL_skip3_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):SKIP3 of 16bit */
N#define DMA_CH0A_CH0_ADSEL_skip3_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):SKIP3 of 8bit */
N
N#define DMA_CH0A_CH0_LOOP_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_LOOP_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_LOOP_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_LOOP_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_LOOP_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_LOOP_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_LOOP_enable_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_LOOP_enable_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_LOOP_enable_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_HOLD_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_HOLD_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_HOLD_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_HOLD_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_HOLD_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_HOLD_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_HOLD_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_HOLD_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_HOLD_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0A_CH0_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CH0A_CH0_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH0A_CH0_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH0A_CH0_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0A_CH0_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0A_CH0_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0A_CH0_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0A_CH0_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0A_CH0_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0B  [register's definitions]
N *              Offset[0x24]  DMA channel-0 control register 1 (0x4BF00024)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0B_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0B */
N#define DMA_CH0B_CH0_XPIN_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_XPIN_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_XPIN_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_XPIN_trg0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define DMA_CH0B_CH0_XPIN_trg0_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define DMA_CH0B_CH0_XPIN_trg0_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define DMA_CH0B_CH0_XPIN_trg1_w                    ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define DMA_CH0B_CH0_XPIN_trg1_h1                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define DMA_CH0B_CH0_XPIN_trg1_b3                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N
N#define DMA_CH0B_CH0_DSYNC_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_DSYNC_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_DSYNC_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_DSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_DSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_DSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_DSYNC_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_DSYNC_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_DSYNC_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_SSYNC_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_SSYNC_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_SSYNC_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_SSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_SSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_SSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_SSYNC_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_SSYNC_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_SSYNC_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_DINC_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_DINC_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_DINC_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_DINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_DINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_DINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_DINC_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_DINC_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_DINC_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_SINC_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_SINC_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_SINC_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_SINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH0B_CH0_SINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH0B_CH0_SINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH0B_CH0_SINC_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH0B_CH0_SINC_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH0B_CH0_SINC_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH0B_CH0_DET_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_DET_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_DET_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_DET_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0B_CH0_DET_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0B_CH0_DET_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CH0B_CH0_SRC_mask_w                     ((uint32_t)0x0000000F)  /*!< Bit Mask of 32bit */
N#define DMA_CH0B_CH0_SRC_mask_h0                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define DMA_CH0B_CH0_SRC_mask_b0                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH0B_CH0_SRC_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0B_CH0_SRC_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0B_CH0_SRC_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0NUM  [register's definitions]
N *              Offset[0x28]  DMA channel-0 control register 1 (0x4BF00028)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0NUM_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0NUM */
N#define DMA_CH0NUM_CH0_NUM_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0NUM_CH0_NUM_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH0NUM_CH0_NUM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0NUM_CH0_NUM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0NUM_CH0_NUM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0CNT  [register's definitions]
N *              Offset[0x2C]  DMA channel-0 control register 1 (0x4BF0002C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0CNT_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0CNT */
N#define DMA_CH0CNT_CH0_CNT_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0CNT_CH0_CNT_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH0CNT_CH0_CNT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0CNT_CH0_CNT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0CNT_CH0_CNT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0SSA  [register's definitions]
N *              Offset[0x30]  DMA channel-0 source start address register (0x4BF00030)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0SSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0SSA */
N#define DMA_CH0SSA_CH0_SSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0SSA_CH0_SSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0SSA_CH0_SSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0SSA_CH0_SSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0SCA  [register's definitions]
N *              Offset[0x34]  DMA channel-0 source current address register (0x4BF00034)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0SCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0SCA */
N#define DMA_CH0SCA_CH0_SCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0SCA_CH0_SCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0SCA_CH0_SCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0SCA_CH0_SCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0DSA  [register's definitions]
N *              Offset[0x38]  DMA channel-0 destination start address register (0x4BF00038)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0DSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0DSA */
N#define DMA_CH0DSA_CH0_DSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0DSA_CH0_DSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0DSA_CH0_DSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0DSA_CH0_DSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH0DCA  [register's definitions]
N *              Offset[0x3C]  DMA channel-0 destination current address register (0x4BF0003C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH0DCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH0DCA */
N#define DMA_CH0DCA_CH0_DCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH0DCA_CH0_DCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH0DCA_CH0_DCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH0DCA_CH0_DCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1A  [register's definitions]
N *              Offset[0x40]  DMA channel-1 control register 0 (0x4BF00040)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1A_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1A */
N#define DMA_CH1A_CH1_ERR2F_mask_w                   ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_ERR2F_mask_h1                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_ERR2F_mask_b3                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_ERR2F_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_ERR2F_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_ERR2F_normal_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_ERR2F_happened_w               ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH1A_CH1_ERR2F_happened_h1              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH1A_CH1_ERR2F_happened_b3              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH1A_CH1_TH2F_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_TH2F_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_TH2F_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_TH2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_TH2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_TH2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_TH2F_happened_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH1A_CH1_TH2F_happened_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH1A_CH1_TH2F_happened_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH1A_CH1_TC2F_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_TC2F_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_TC2F_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_TC2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_TC2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_TC2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_TC2F_happened_w                ((uint32_t)0x02000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH1A_CH1_TC2F_happened_h1               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH1A_CH1_TC2F_happened_b3               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH1A_CH1_EIE_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_EIE_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_EIE_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_EIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_EIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_EIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_EIE_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_EIE_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_EIE_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_HIE_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_HIE_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_HIE_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_HIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_HIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_HIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_HIE_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_HIE_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_HIE_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_CIE_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_CIE_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_CIE_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_CIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_CIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_CIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_CIE_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_CIE_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_CIE_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_REQ_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_REQ_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_REQ_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_REQ_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define DMA_CH1A_CH1_REQ_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define DMA_CH1A_CH1_REQ_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define DMA_CH1A_CH1_REQ_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_REQ_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_REQ_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_BSIZE_mask_w                   ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_BSIZE_mask_h0                  ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_BSIZE_mask_b1                  ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_BSIZE_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define DMA_CH1A_CH1_BSIZE_one_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define DMA_CH1A_CH1_BSIZE_one_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define DMA_CH1A_CH1_BSIZE_two_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Two of 32bit */
N#define DMA_CH1A_CH1_BSIZE_two_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Two of 16bit */
N#define DMA_CH1A_CH1_BSIZE_two_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):Two of 8bit */
N#define DMA_CH1A_CH1_BSIZE_four_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Four of 32bit */
N#define DMA_CH1A_CH1_BSIZE_four_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Four of 16bit */
N#define DMA_CH1A_CH1_BSIZE_four_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):Four of 8bit */
N
N#define DMA_CH1A_CH1_PLS_mask_w                     ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_PLS_mask_h0                    ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_PLS_mask_b1                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_PLS_lv0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):LV0 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):LV0 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv0_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):LV0 of 8bit */
N#define DMA_CH1A_CH1_PLS_lv1_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):LV1 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv1_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LV1 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv1_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):LV1 of 8bit */
N#define DMA_CH1A_CH1_PLS_lv2_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):LV2 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv2_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):LV2 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv2_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):LV2 of 8bit */
N#define DMA_CH1A_CH1_PLS_lv3_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):LV3 of 32bit */
N#define DMA_CH1A_CH1_PLS_lv3_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):LV3 of 16bit */
N#define DMA_CH1A_CH1_PLS_lv3_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):LV3 of 8bit */
N
N#define DMA_CH1A_CH1_XMDS_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_XMDS_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_XMDS_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_XMDS_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CH1A_CH1_XMDS_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CH1A_CH1_XMDS_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CH1A_CH1_XMDS_single_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Single of 32bit */
N#define DMA_CH1A_CH1_XMDS_single_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Single of 16bit */
N#define DMA_CH1A_CH1_XMDS_single_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):Single of 8bit */
N#define DMA_CH1A_CH1_XMDS_block_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Block of 32bit */
N#define DMA_CH1A_CH1_XMDS_block_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Block of 16bit */
N#define DMA_CH1A_CH1_XMDS_block_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Block of 8bit */
N#define DMA_CH1A_CH1_XMDS_demand_w                  ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Demand of 32bit */
N#define DMA_CH1A_CH1_XMDS_demand_h0                 ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Demand of 16bit */
N#define DMA_CH1A_CH1_XMDS_demand_b1                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):Demand of 8bit */
N
N#define DMA_CH1A_CH1_ADSEL_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_ADSEL_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_ADSEL_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_ADSEL_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH1A_CH1_ADSEL_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH1A_CH1_ADSEL_normal_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH1A_CH1_ADSEL_skip3_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):SKIP3 of 32bit */
N#define DMA_CH1A_CH1_ADSEL_skip3_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):SKIP3 of 16bit */
N#define DMA_CH1A_CH1_ADSEL_skip3_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):SKIP3 of 8bit */
N
N#define DMA_CH1A_CH1_LOOP_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_LOOP_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_LOOP_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_LOOP_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_LOOP_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_LOOP_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_LOOP_enable_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_LOOP_enable_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_LOOP_enable_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_HOLD_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_HOLD_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_HOLD_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_HOLD_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_HOLD_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_HOLD_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_HOLD_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_HOLD_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_HOLD_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1A_CH1_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CH1A_CH1_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH1A_CH1_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH1A_CH1_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1A_CH1_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1A_CH1_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1A_CH1_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1A_CH1_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1A_CH1_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1B  [register's definitions]
N *              Offset[0x44]  DMA channel-1 control register 1 (0x4BF00044)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1B_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1B */
N#define DMA_CH1B_CH1_XPIN_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_XPIN_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_XPIN_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_XPIN_trg0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define DMA_CH1B_CH1_XPIN_trg0_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define DMA_CH1B_CH1_XPIN_trg0_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define DMA_CH1B_CH1_XPIN_trg1_w                    ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define DMA_CH1B_CH1_XPIN_trg1_h1                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define DMA_CH1B_CH1_XPIN_trg1_b3                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N
N#define DMA_CH1B_CH1_DSYNC_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_DSYNC_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_DSYNC_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_DSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_DSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_DSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_DSYNC_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_DSYNC_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_DSYNC_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_SSYNC_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_SSYNC_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_SSYNC_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_SSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_SSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_SSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_SSYNC_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_SSYNC_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_SSYNC_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_DINC_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_DINC_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_DINC_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_DINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_DINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_DINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_DINC_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_DINC_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_DINC_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_SINC_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_SINC_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_SINC_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_SINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH1B_CH1_SINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH1B_CH1_SINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH1B_CH1_SINC_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH1B_CH1_SINC_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH1B_CH1_SINC_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH1B_CH1_DET_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_DET_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_DET_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_DET_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1B_CH1_DET_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1B_CH1_DET_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CH1B_CH1_SRC_mask_w                     ((uint32_t)0x0000000F)  /*!< Bit Mask of 32bit */
N#define DMA_CH1B_CH1_SRC_mask_h0                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define DMA_CH1B_CH1_SRC_mask_b0                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH1B_CH1_SRC_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1B_CH1_SRC_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1B_CH1_SRC_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1NUM  [register's definitions]
N *              Offset[0x48]  DMA channel-1 control register 1 (0x4BF00048)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1NUM_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1NUM */
N#define DMA_CH1NUM_CH1_NUM_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1NUM_CH1_NUM_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH1NUM_CH1_NUM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1NUM_CH1_NUM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1NUM_CH1_NUM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1CNT  [register's definitions]
N *              Offset[0x4C]  DMA channel-1 control register 1 (0x4BF0004C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1CNT_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1CNT */
N#define DMA_CH1CNT_CH1_CNT_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1CNT_CH1_CNT_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH1CNT_CH1_CNT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1CNT_CH1_CNT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1CNT_CH1_CNT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1SSA  [register's definitions]
N *              Offset[0x50]  DMA channel-1 source start address register (0x4BF00050)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1SSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1SSA */
N#define DMA_CH1SSA_CH1_SSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1SSA_CH1_SSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1SSA_CH1_SSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1SSA_CH1_SSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1SCA  [register's definitions]
N *              Offset[0x54]  DMA channel-1 source current address register (0x4BF00054)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1SCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1SCA */
N#define DMA_CH1SCA_CH1_SCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1SCA_CH1_SCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1SCA_CH1_SCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1SCA_CH1_SCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1DSA  [register's definitions]
N *              Offset[0x58]  DMA channel-1 destination start address register (0x4BF00058)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1DSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1DSA */
N#define DMA_CH1DSA_CH1_DSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1DSA_CH1_DSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1DSA_CH1_DSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1DSA_CH1_DSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH1DCA  [register's definitions]
N *              Offset[0x5C]  DMA channel-1 destination current address register (0x4BF0005C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH1DCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH1DCA */
N#define DMA_CH1DCA_CH1_DCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH1DCA_CH1_DCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH1DCA_CH1_DCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH1DCA_CH1_DCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2A  [register's definitions]
N *              Offset[0x60]  DMA channel-2 control register 0 (0x4BF00060)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2A_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2A */
N#define DMA_CH2A_CH2_ERR2F_mask_w                   ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_ERR2F_mask_h1                  ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_ERR2F_mask_b3                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_ERR2F_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_ERR2F_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_ERR2F_normal_b3                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_ERR2F_happened_w               ((uint32_t)0x08000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH2A_CH2_ERR2F_happened_h1              ((uint16_t)0x0800)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH2A_CH2_ERR2F_happened_b3              ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH2A_CH2_TH2F_mask_w                    ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_TH2F_mask_h1                   ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_TH2F_mask_b3                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_TH2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_TH2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_TH2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_TH2F_happened_w                ((uint32_t)0x04000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH2A_CH2_TH2F_happened_h1               ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH2A_CH2_TH2F_happened_b3               ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH2A_CH2_TC2F_mask_w                    ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_TC2F_mask_h1                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_TC2F_mask_b3                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_TC2F_normal_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_TC2F_normal_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_TC2F_normal_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_TC2F_happened_w                ((uint32_t)0x02000000)  /*!< Bit Value =(1):Happened of 32bit */
N#define DMA_CH2A_CH2_TC2F_happened_h1               ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define DMA_CH2A_CH2_TC2F_happened_b3               ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DMA_CH2A_CH2_EIE_mask_w                     ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_EIE_mask_h1                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_EIE_mask_b2                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_EIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_EIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_EIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_EIE_enable_w                   ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_EIE_enable_h1                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_EIE_enable_b2                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_HIE_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_HIE_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_HIE_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_HIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_HIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_HIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_HIE_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_HIE_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_HIE_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_CIE_mask_w                     ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_CIE_mask_h1                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_CIE_mask_b2                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_CIE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_CIE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_CIE_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_CIE_enable_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_CIE_enable_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_CIE_enable_b2                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_REQ_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_REQ_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_REQ_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_REQ_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):No of 32bit */
N#define DMA_CH2A_CH2_REQ_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):No of 16bit */
N#define DMA_CH2A_CH2_REQ_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):No of 8bit */
N#define DMA_CH2A_CH2_REQ_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_REQ_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_REQ_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_BSIZE_mask_w                   ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_BSIZE_mask_h0                  ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_BSIZE_mask_b1                  ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_BSIZE_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define DMA_CH2A_CH2_BSIZE_one_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define DMA_CH2A_CH2_BSIZE_one_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define DMA_CH2A_CH2_BSIZE_two_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Two of 32bit */
N#define DMA_CH2A_CH2_BSIZE_two_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Two of 16bit */
N#define DMA_CH2A_CH2_BSIZE_two_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):Two of 8bit */
N#define DMA_CH2A_CH2_BSIZE_four_w                   ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Four of 32bit */
N#define DMA_CH2A_CH2_BSIZE_four_h0                  ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Four of 16bit */
N#define DMA_CH2A_CH2_BSIZE_four_b1                  ((uint8_t )0x30)        /*!< Bit Value =(0x3):Four of 8bit */
N
N#define DMA_CH2A_CH2_PLS_mask_w                     ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_PLS_mask_h0                    ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_PLS_mask_b1                    ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_PLS_lv0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):LV0 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):LV0 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv0_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):LV0 of 8bit */
N#define DMA_CH2A_CH2_PLS_lv1_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):LV1 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv1_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LV1 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv1_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):LV1 of 8bit */
N#define DMA_CH2A_CH2_PLS_lv2_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):LV2 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv2_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):LV2 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv2_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):LV2 of 8bit */
N#define DMA_CH2A_CH2_PLS_lv3_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):LV3 of 32bit */
N#define DMA_CH2A_CH2_PLS_lv3_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):LV3 of 16bit */
N#define DMA_CH2A_CH2_PLS_lv3_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):LV3 of 8bit */
N
N#define DMA_CH2A_CH2_XMDS_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_XMDS_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_XMDS_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_XMDS_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DMA_CH2A_CH2_XMDS_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DMA_CH2A_CH2_XMDS_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DMA_CH2A_CH2_XMDS_single_w                  ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Single of 32bit */
N#define DMA_CH2A_CH2_XMDS_single_h0                 ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Single of 16bit */
N#define DMA_CH2A_CH2_XMDS_single_b1                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):Single of 8bit */
N#define DMA_CH2A_CH2_XMDS_block_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Block of 32bit */
N#define DMA_CH2A_CH2_XMDS_block_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Block of 16bit */
N#define DMA_CH2A_CH2_XMDS_block_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Block of 8bit */
N#define DMA_CH2A_CH2_XMDS_demand_w                  ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Demand of 32bit */
N#define DMA_CH2A_CH2_XMDS_demand_h0                 ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Demand of 16bit */
N#define DMA_CH2A_CH2_XMDS_demand_b1                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):Demand of 8bit */
N
N#define DMA_CH2A_CH2_ADSEL_mask_w                   ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_ADSEL_mask_h0                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_ADSEL_mask_b0                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_ADSEL_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DMA_CH2A_CH2_ADSEL_normal_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DMA_CH2A_CH2_ADSEL_normal_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DMA_CH2A_CH2_ADSEL_skip3_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):SKIP3 of 32bit */
N#define DMA_CH2A_CH2_ADSEL_skip3_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):SKIP3 of 16bit */
N#define DMA_CH2A_CH2_ADSEL_skip3_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):SKIP3 of 8bit */
N
N#define DMA_CH2A_CH2_LOOP_mask_w                    ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_LOOP_mask_h0                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_LOOP_mask_b0                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_LOOP_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_LOOP_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_LOOP_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_LOOP_enable_w                  ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_LOOP_enable_h0                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_LOOP_enable_b0                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_HOLD_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_HOLD_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_HOLD_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_HOLD_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_HOLD_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_HOLD_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_HOLD_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_HOLD_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_HOLD_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2A_CH2_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DMA_CH2A_CH2_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH2A_CH2_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH2A_CH2_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2A_CH2_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2A_CH2_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2A_CH2_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2A_CH2_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2A_CH2_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2B  [register's definitions]
N *              Offset[0x64]  DMA channel-2 control register 1 (0x4BF00064)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2B_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2B */
N#define DMA_CH2B_CH2_XPIN_mask_w                    ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_XPIN_mask_h1                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_XPIN_mask_b3                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_XPIN_trg0_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TRG0 of 32bit */
N#define DMA_CH2B_CH2_XPIN_trg0_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TRG0 of 16bit */
N#define DMA_CH2B_CH2_XPIN_trg0_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):TRG0 of 8bit */
N#define DMA_CH2B_CH2_XPIN_trg1_w                    ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):TRG1 of 32bit */
N#define DMA_CH2B_CH2_XPIN_trg1_h1                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):TRG1 of 16bit */
N#define DMA_CH2B_CH2_XPIN_trg1_b3                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):TRG1 of 8bit */
N
N#define DMA_CH2B_CH2_DSYNC_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_DSYNC_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_DSYNC_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_DSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_DSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_DSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_DSYNC_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_DSYNC_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_DSYNC_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_SSYNC_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_SSYNC_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_SSYNC_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_SSYNC_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_SSYNC_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_SSYNC_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_SSYNC_enable_w                 ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_SSYNC_enable_h1                ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_SSYNC_enable_b2                ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_DINC_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_DINC_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_DINC_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_DINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_DINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_DINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_DINC_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_DINC_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_DINC_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_SINC_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_SINC_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_SINC_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_SINC_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DMA_CH2B_CH2_SINC_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DMA_CH2B_CH2_SINC_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DMA_CH2B_CH2_SINC_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DMA_CH2B_CH2_SINC_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DMA_CH2B_CH2_SINC_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DMA_CH2B_CH2_DET_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_DET_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_DET_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_DET_shift_w                    (8)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2B_CH2_DET_shift_h0                   (8)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2B_CH2_DET_shift_b1                   (0)                     /*!< Bit Shift of 8bit */
N
N#define DMA_CH2B_CH2_SRC_mask_w                     ((uint32_t)0x0000000F)  /*!< Bit Mask of 32bit */
N#define DMA_CH2B_CH2_SRC_mask_h0                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define DMA_CH2B_CH2_SRC_mask_b0                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define DMA_CH2B_CH2_SRC_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2B_CH2_SRC_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2B_CH2_SRC_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2NUM  [register's definitions]
N *              Offset[0x68]  DMA channel-2 control register 1 (0x4BF00068)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2NUM_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2NUM */
N#define DMA_CH2NUM_CH2_NUM_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2NUM_CH2_NUM_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH2NUM_CH2_NUM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2NUM_CH2_NUM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2NUM_CH2_NUM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2CNT  [register's definitions]
N *              Offset[0x6C]  DMA channel-2 control register 1 (0x4BF0006C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2CNT_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2CNT */
N#define DMA_CH2CNT_CH2_CNT_mask_w                   ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2CNT_CH2_CNT_mask_h0                  ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DMA_CH2CNT_CH2_CNT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2CNT_CH2_CNT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2CNT_CH2_CNT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2SSA  [register's definitions]
N *              Offset[0x70]  DMA channel-2 source start address register (0x4BF00070)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2SSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2SSA */
N#define DMA_CH2SSA_CH2_SSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2SSA_CH2_SSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2SSA_CH2_SSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2SSA_CH2_SSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2SCA  [register's definitions]
N *              Offset[0x74]  DMA channel-2 source current address register (0x4BF00074)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2SCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2SCA */
N#define DMA_CH2SCA_CH2_SCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2SCA_CH2_SCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2SCA_CH2_SCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2SCA_CH2_SCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2DSA  [register's definitions]
N *              Offset[0x78]  DMA channel-2 destination start address register (0x4BF00078)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2DSA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2DSA */
N#define DMA_CH2DSA_CH2_DSA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2DSA_CH2_DSA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2DSA_CH2_DSA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2DSA_CH2_DSA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DMA_CH2DCA  [register's definitions]
N *              Offset[0x7C]  DMA channel-2 destination current address register (0x4BF0007C)
N ******************************************************************************
N */
N///@{
N#define DMA_CH2DCA_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DMA_CH2DCA */
N#define DMA_CH2DCA_CH2_DCA_mask_w                   ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define DMA_CH2DCA_CH2_DCA_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define DMA_CH2DCA_CH2_DCA_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define DMA_CH2DCA_CH2_DCA_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_DMA_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_DMA.h                         */
N/*----------------------------------------------------------------------------*/
L 42 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DMA_DRV.h" 2
N#include "MG32x02z__ExtraStruct.h"
N#if defined(MG32_1ST)
X#if 1L
N#include "MG32x02z_SYS.H"
N#endif
N
N/** @brief transfer error interrupt enable. */
N#define DMA_Error_ITE       DMA_CH0A_CH0_EIE_mask_b2  
N/** @brief transfer half interrupt enable */
N#define DMA_Half_ITE        DMA_CH0A_CH0_HIE_mask_b2     
N/** @brief transfer complete interrupt enable */
N#define DMA_Complete_ITE    DMA_CH0A_CH0_CIE_mask_b2    
N
N/** @brief DMA channel-4 transfer error flag */
N#define DMA_FLAG_CH4_ERRF                 DMA_STA_CH4_ERRF_mask_w   /* DMA channel-4 transfer error flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-4 transfer half flag */
N#define DMA_FLAG_CH4_THF                  DMA_STA_CH4_THF_mask_w    /* DMA channel-4 transfer half flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-4 transfer complete flag */
N#define DMA_FLAG_CH4_TCF                  DMA_STA_CH4_TCF_mask_w    /* DMA channel-4 transfer complete flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-4 global interrupt flag */
N#define DMA_FLAG_CH4_GIF                  DMA_STA_CH4_GIF_mask_w    /* DMA channel-4 global interrupt flag. This bit will be set if any of other channel event interrupt flag is set. */
N/** @brief DMA channel-3 transfer error flag */
N#define DMA_FLAG_CH3_ERRF                 DMA_STA_CH3_ERRF_mask_w   /* DMA channel-3 transfer error flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-3 transfer half flag */
N#define DMA_FLAG_CH3_THF                  DMA_STA_CH3_THF_mask_w    /* DMA channel-3 transfer half flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-3 transfer complete flag */
N#define DMA_FLAG_CH3_TCF                  DMA_STA_CH3_TCF_mask_w    /* DMA channel-3 transfer complete flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-3 global interrupt flag */
N#define DMA_FLAG_CH3_GIF                  DMA_STA_CH3_GIF_mask_w    /* DMA channel-3 global interrupt flag. This bit will be set if any of other channel event interrupt flag is set. */
N/** @brief DMA channel-2 transfer error flag */
N#define DMA_FLAG_CH2_ERRF                 DMA_STA_CH2_ERRF_mask_w   /* DMA channel-2 transfer error flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-2 transfer half flag */
N#define DMA_FLAG_CH2_THF                  DMA_STA_CH2_THF_mask_w    /* DMA channel-2 transfer half flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-2 transfer complete flag */
N#define DMA_FLAG_CH2_TCF                  DMA_STA_CH2_TCF_mask_w    /* DMA channel-2 transfer complete flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-2 global interrupt flag */
N#define DMA_FLAG_CH2_GIF                  DMA_STA_CH2_GIF_mask_w    /* DMA channel-2 global interrupt flag. This bit will be set if any of other channel event interrupt flag is set. */
N/** @brief DMA channel-1 transfer error flag */
N#define DMA_FLAG_CH1_ERRF                 DMA_STA_CH1_ERRF_mask_w   /* DMA channel-1 transfer error flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-1 transfer half flag */
N#define DMA_FLAG_CH1_THF                  DMA_STA_CH1_THF_mask_w    /* DMA channel-1 transfer half flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-1 transfer complete flag */
N#define DMA_FLAG_CH1_TCF                  DMA_STA_CH1_TCF_mask_w    /* DMA channel-1 transfer complete flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-1 global interrupt flag */
N#define DMA_FLAG_CH1_GIF                  DMA_STA_CH1_GIF_mask_w    /* DMA channel-1 global interrupt flag. This bit will be set if any of other channel event interrupt flag is set. */
N/** @brief DMA channel-0 transfer error flag */
N#define DMA_FLAG_CH0_ERRF                 DMA_STA_CH0_ERRF_mask_w   /* DMA channel-0 transfer error flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-0 transfer half flag */
N#define DMA_FLAG_CH0_THF                  DMA_STA_CH0_THF_mask_w    /* DMA channel-0 transfer half flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-0 transfer complete flag */
N#define DMA_FLAG_CH0_TCF                  DMA_STA_CH0_TCF_mask_w    /* DMA channel-0 transfer complete flag. (set by hardware and clear by software writing 1) */
N/** @brief DMA channel-0 global interrupt flag */
N#define DMA_FLAG_CH0_GIF                  DMA_STA_CH0_GIF_mask_w    /* DMA channel-0 global interrupt flag. This bit will be set if any of other channel event interrupt flag is set. */
N
N
N
N
N/** 
N * @enum        DMA_ChannelFlagDef
N * @brief       specifies the DMA Channel flag 
N */        
Ntypedef enum 
N{ 
N    DMA_Chx_TCF = DMA_CH0A_CH0_TC2F_happened_b3,                    /*!< select DMA channel x complete flag */
X    DMA_Chx_TCF = ((uint8_t )0x02),                     
N    DMA_Chx_THF = DMA_CH0A_CH0_TH2F_happened_b3,                    /*!< select DMA channel x half flag */
X    DMA_Chx_THF = ((uint8_t )0x04),                     
N    DMA_Chx_ERRF = DMA_CH0A_CH0_ERR2F_happened_b3,                  /*!< select DMA channel x error flag */
X    DMA_Chx_ERRF = ((uint8_t )0x08),                   
N    DMA_Chx_AllFlags = DMA_Chx_TCF | DMA_Chx_THF | DMA_Chx_ERRF,    /*!< Select DMA channel x all flags */
N        
N} DMA_ChannelFlagDef;
N
N/** 
N * @enum        DMA_DataWithGPLDef
N * @brief       specifies the DMA GPL source to check
N */        
Ntypedef enum 
N{ 
N    DMA_GPL_DISABLE,    /*!< no any channel with GPL function */
N    DMA_GPL_CHANNEL_0,  /*!< select DMA channel 0 data through GPL macro */
N    DMA_GPL_CHANNEL_1,  /*!< select DMA channel 1 data through GPL macro */
N    DMA_GPL_CHANNEL_2,  /*!< select DMA channel 2 data through GPL macro  */
N#if defined(MG32_3RD)
X#if 0L
S    DMA_GPL_CHANNEL_3,  /*!< select DMA channel 3 data through GPL macro  */
S    DMA_GPL_CHANNEL_4,  /*!< select DMA channel 4 data through GPL macro  */
N#endif
N} DMA_DataWithGPLDef;
N
N
N/** 
N * @enum		DMA_PriorityModeDef
N * @brief		DMA channel priority mode select
N */        
Ntypedef enum 
N{ 
N    DMA_Round_Robin,    /*!< control by Round Robin method */
N    DMA_Priority_Level, /*!< control by channel priority level */
N} DMA_PriorityModeDef;
N
N
N/** 
N * @enum		DMA_BurstSizeDef
N * @brief		Indicates the number of transfers that make up a single DMA data transfer
N */        
Ntypedef enum 
N{ 
N    DMA_BurstSize_1Byte=0,  /*!< 1 byte */
N    DMA_BurstSize_2Byte=1,  /*!< 2 bytes */
N    DMA_BurstSize_4Byte=3,  /*!< 4 bytes */
N} DMA_BurstSizeDef;
N
N
N
N
N/** 
N * @enum		DMA_ExtTriggerModeDef
N * @brief		DMA channel external pin trigger request mode select. 
N */        
Ntypedef enum 
N{ 
N    DMA_DisableExtTrg,  /*!< disable external request pin input */
N    DMA_SingleExtTrg,   /*!< single request mode */
N    DMA_BlockExtTrg,    /*!< block request mode */
N    DMA_DemandExtTrg,   /*!< demand request mode (active high) */
N} DMA_ExtTriggerModeDef;
N
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		DMA_SourcenRequestDef
N * @brief		DMA channel transfer peripheral source select
N */        
Ntypedef enum 
N{ 
N    DMA_MEM_Read=0,     /*!< from memory */
N    DMA_ADC0_IN=1,      /*!< from ADC conversion data */
N    DMA_I2C0_RX=2,      /*!< from I2C0 external in data */
N    DMA_I2C1_RX=3,      /*!< from I2C1 external in data */
N    DMA_URT0_RX=4,      /*!< from URT0 RX data */
N    DMA_URT1_RX=5,      /*!< from URT1 RX data */
N    DMA_URT2_RX=6,      /*!< from URT2 RX data */
N    DMA_URT3_RX=7,      /*!< from URT3 RX data */
N    DMA_SPI0_RX=8,      /*!< from SPI0 MISO data */
N    DMA_TM36_IC3=15,    /*!< from TM36 capture data */
N} DMA_SourcenRequestDef;
N
N/** 
N * @enum		DMA_DestinationRequestDef
N * @brief		DMA channel transfer peripheral destination select
N */        
Ntypedef enum 
N{ 
N    DMA_MEM_Write=0,    /*!< to memory */
N    DMA_DAC0_OUT=1,     /*!< to DAC output control */
N    DMA_I2C0_TX=2,      /*!< to I2C0 output */
N    DMA_I2C1_TX=3,      /*!< to I2C1 output */
N    DMA_URT0_TX=4,      /*!< to URT0 TX output */
N    DMA_URT1_TX=5,      /*!< to URT1 TX output */
N    DMA_URT2_TX=6,      /*!< to URT2 TX output */
N    DMA_URT3_TX=7,      /*!< to URT3 TX output */
N    DMA_SPI0_TX=8,      /*!< to SPI0 MOSI output */
N    DMA_GPL_Write=11,   /*!< to GPL function control */
N    DMA_TM36_CC0B=12,   /*!< to TM36 channel 0 - buffer data */
N    DMA_TM36_CC1B=13,   /*!< to TM36 channel 1 - buffer data */
N    DMA_TM36_CC2B=14,   /*!< to TM36 channel 2 - buffer data */
N} DMA_DestinationRequestDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		DMA_SourcenRequestDef
S * @brief		DMA channel transfer peripheral source select
S */        
Stypedef enum 
S{ 
S    DMA_MEM_Read=0,     /*!< from memory */
S    DMA_ADC0_IN=1,      /*!< from ADC conversion data */
S    DMA_I2C0_RX=2,      /*!< from I2C0 external in data */
S    DMA_URT0_RX=4,      /*!< from URT0 RX data */
S    DMA_URT1_RX=5,      /*!< from URT1 RX data */
S    DMA_SPI0_RX=8,      /*!< from SPI0 MISO data */
S    DMA_TM36_IC3=15,    /*!< from TM36 capture data */
S} DMA_SourcenRequestDef;
S
S/** 
S * @enum		DMA_DestinationRequestDef
S * @brief		DMA channel transfer peripheral destination select
S */        
Stypedef enum 
S{ 
S    DMA_MEM_Write=0,    /*!< to memory */
S    DMA_I2C0_TX=2,      /*!< to I2C0 output */
S    DMA_URT0_TX=4,      /*!< to URT0 TX output */
S    DMA_URT1_TX=5,      /*!< to URT1 TX output */
S    DMA_SPI0_TX=8,      /*!< to SPI0 MOSI output */
S    DMA_GPL_Write=11,   /*!< to GPL function control */
S    DMA_TM36_CC0B=12,   /*!< to TM36 channel 0 - buffer data */
S    DMA_TM36_CC1B=13,   /*!< to TM36 channel 1 - buffer data */
S    DMA_TM36_CC2B=14,   /*!< to TM36 channel 2 - buffer data */
S} DMA_DestinationRequestDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		DMA_SourcenRequestDef
S * @brief		DMA channel transfer peripheral source select
S */        
Stypedef enum 
S{ 
S    DMA_MEM_Read=0,     /*!< from memory */
S    DMA_ADC0_IN=1,      /*!< from ADC conversion data */
S    DMA_I2C0_RX=2,      /*!< from I2C0 external in data */
S    DMA_I2C1_RX=3,      /*!< from I2C1 external in data */
S    DMA_URT0_RX=4,      /*!< from URT0 RX data */
S    DMA_URT1_RX=5,      /*!< from URT1 RX data */
S    DMA_URT2_RX=6,      /*!< from URT2 RX data */
S    DMA_SPI0_RX=8,      /*!< from SPI0 MISO data */
S    DMA_USB_RX=10,      /*!< from USB_RX data */
S    DMA_TM36_IC3=15,    /*!< from TM36 capture data */
S} DMA_SourcenRequestDef;
S
S/** 
S * @enum		DMA_DestinationRequestDef
S * @brief		DMA channel transfer peripheral destination select
S */        
Stypedef enum 
S{ 
S    DMA_MEM_Write=0,    /*!< to memory */
S    DMA_DAC0_OUT=1,     /*!< to DAC output control */
S    DMA_I2C0_TX=2,      /*!< to I2C0 output */
S    DMA_I2C1_TX=3,      /*!< to I2C1 output */
S    DMA_URT0_TX=4,      /*!< to URT0 TX output */
S    DMA_URT1_TX=5,      /*!< to URT1 TX output */
S    DMA_URT2_TX=6,      /*!< to URT2 TX output */
S    DMA_SPI0_TX=8,      /*!< to SPI0 MOSI output */
S    DMA_USB_TX=10,      /*!< to USB TX output */
S    DMA_GPL_Write=11,   /*!< to GPL function control */
S    DMA_TM36_CC0B=12,   /*!< to TM36 channel 0 - buffer data */
S    DMA_TM36_CC1B=13,   /*!< to TM36 channel 1 - buffer data */
S    DMA_TM36_CC2B=14,   /*!< to TM36 channel 2 - buffer data */
S} DMA_DestinationRequestDef;
N#endif
N
N
N
N/** 
N * @enum		DMA_ExternTriggerPinDef
N * @brief		DMA channel external trigger pin select.
N */        
Ntypedef enum 
N{ 
N    DMA_ExtTRG0=0,  /*!< control by DMA_TRG0 pin state  */
N    DMA_ExtTRG1=1,  /*!< control by DMA_TRG1 pin state  */
N} DMA_ExternTriggerPinDef;
N
N/** 
N * @enum		DMA_ChxCurrentStateDef
N * @brief		the current DMA channel state
N */        
Ntypedef enum 
N{ 
N    DMA_HoldState,  /*!< DMA in holding state  */
N    DMA_Running,    /*!< DMA running state  */
N    DMA_Idle,       /*!< DMA finish state  */
N    DMA_Finish,     /*!< DMA idle state  */
N} DMA_ChxCurrentStateDef;
N
N/** 
N * @enum		DMA_LevelPriorityDef
N * @brief		config DMA level priority 
N */        
Ntypedef enum 
N{ 
N    DMA_LowestPriority,     /*!< lowest priority  */
N    DMA_NormalPriority,     /*!< normal priority  */
N    DMA_HighPriority,       /*!< high priority  */
N    DMA_HighestPriority,    /*!< highest priority  */
N} DMA_LevelPriorityDef;
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S/** 
S * @enum		DMA_FGBUSWidfthDef
S * @brief		DMA flash-to-GPL transfer bus width select.
S */        
Stypedef enum 
S{ 
S    DMA_Flash2GPL_8bit,		/*!< 8bit  */
S    DMA_Flash2GPL_32bit,	/*!< 32bit  */
S} DMA_FGBUSWidfthDef;
N#endif
N
N
N/** 
N * @struct  DMA_BaseInitTypeDef
N * @brief   DMA Base channel initial structure
N */        
Ntypedef struct 				
N{ 
N    DMA_ExternTriggerPinDef ExtTrgPin;  /*!< Specifies the extern trigger pin select.  
N                                             This parameter can be a value of DMA_ExtTRG0/DMA_ExtTRG1 */	
N    
N    DMA_ExtTriggerModeDef ExtTrgMode;   /*!< select DMA channel 0 data through GPL macro 
N                                             This parameter can be a value of DMA_DisableExtTrg/DMA_SingleExtTrg
N                                             DMA_BlockExtTrg/DMA_DemandExtTrg */	
N    
N    
N    DMAChannel_Struct* DMAChx;          /*!< Specifies the DMA channel : DMAChannel0/1/2 */ 
N    
N    FunctionalState	DMALoopCmd;			/*!< Specifies the DMA loop mode : 
N                                             This parameter can be a value of ENABLE/DISABLE */ 
N    
N    FunctionalState SrcSINCSel;	        /*!< Specifies the DMA auto increase source address mode : 
N                                             This parameter can be a value of ENABLE/DISABLE */ 
N    
N	FunctionalState DestDINCSel;		/*!< Specifies the DMA auto increase destination address mode : 
N                                             This parameter can be a value of ENABLE/DISABLE */ 
N
N	DMA_SourcenRequestDef SrcSymSel;	/*!< DMA channel transfer peripheral source select */ 
N
N	DMA_DestinationRequestDef DestSymSel;/*!< DMA channel transfer peripheral destination select */
N	
N	DMA_BurstSizeDef BurstDataSize;     /*!< specifies DMA transfer burst size : 1/2/4 Bytes */ 
N	
N	uint32_t DMATransferNUM;			/*!< Specifies the DMA transfer data count initial number.
N                                             0 (0 meas 131072) ~ 131071 (transfer 65535 data) */
N
N	void* DMASourceAddr;			    /*!< Specifies the DMA source memory address */
N
N	void* DMADestinationAddr;		    /*!< Specifies the DMA destination memory address */
N    
N} DMA_BaseInitTypeDef;
N
N
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
N
Nvoid DMA_DeInit(DMA_Struct* DMAx);
Nvoid DMA_BaseInitStructure_Init(DMA_BaseInitTypeDef* DMA_BaseInitStruct);
Nvoid DMA_Base_Init(DMA_BaseInitTypeDef* DMA_BaseInitStruct);
Nvoid DMA_Cmd(FunctionalState NewState);
Nvoid DMA_SetExtraGPLChannel(DMA_Struct* DMAx,DMA_DataWithGPLDef GPLChxSel);
NDMA_DataWithGPLDef DMA_GetCHxUseGPL(DMA_Struct* DMAx);
Nvoid DMA_PriorityMode_Select(DMA_Struct* DMAx, DMA_PriorityModeDef DMAPriorityModeSel);
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
Svoid DMA_FlashMode_Select(DMA_Struct* DMAx, DMA_FGBUSWidfthDef FGBSel);
N#endif
Nvoid DMA_StartRequest(DMAChannel_Struct* DMAChx);
Nvoid DMA_Channel_Cmd(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_SetBurstSize(DMAChannel_Struct* DMAChx, DMA_BurstSizeDef BurstSizeSel);
Nvoid DMA_LoopMode_Cmd(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_LastCycle_Cmd(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_Hold_Cmd(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_IncreaseTxPerformance(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_IncreaseRxPerformance(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_SetExtTriggerMode(DMAChannel_Struct* DMAChx, DMA_ExtTriggerModeDef DMAExtTrgSel);
Nvoid DMA_SetExtTriggerPin(DMAChannel_Struct* DMAChx, DMA_ExternTriggerPinDef DMAExtTrgPinSel);
Nvoid DMA_AutoIncreaseDestinationAddress(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_AutoIncreaseSourceAddress(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_Destination_Select(DMAChannel_Struct* DMAChx, DMA_DestinationRequestDef DestinationMacroSel);
Nvoid DMA_Source_Select(DMAChannel_Struct* DMAChx, DMA_SourcenRequestDef SourceMacroSel);
Nvoid DMA_SetDestinationAddress(DMAChannel_Struct* DMAChx, void* DestinationAddress);
Nvoid DMA_SetSourceAddress(DMAChannel_Struct* DMAChx, void* SourceAddress);
Nuint32_t* DMA_GetCurrentSourceAddress(DMAChannel_Struct* DMAChx);
Nuint32_t* DMA_GetCurrentDestinationAddress(DMAChannel_Struct* DMAChx);
Nvoid DMA_SetTransferDataNumber(DMAChannel_Struct* DMAChx, uint32_t NumDatas);
Nuint32_t DMA_GetRemainDataCount(DMAChannel_Struct* DMAChx);
Nvoid DMA_SetPriority(DMAChannel_Struct* DMAChx, DMA_LevelPriorityDef DMALevelSel);
Nvoid DMA_SetChxSKIP3Mode(DMAChannel_Struct* DMAChx, FunctionalState NewState);
Nvoid DMA_IT_Config(DMAChannel_Struct* DMAChx, uint32_t DMA_ITSrc, FunctionalState NewState);
Nvoid DMA_ITEA_Cmd(DMA_Struct* DMAx, FunctionalState NewState);
NDRV_Return DMA_GetSingleFlagStatus(DMA_Struct* DMAx, uint32_t DMA_ITSrc);
Nuint32_t DMA_GetAllFlagStatus(DMA_Struct* DMAx);
Nvoid DMA_ClearFlag(DMA_Struct* DMAx, uint32_t DMA_ITSrc);
NDRV_Return DMA_GetChannelFlag(DMAChannel_Struct* DMAChx, DMA_ChannelFlagDef DMA_ChxITSrc);
Nvoid DMA_ClearChannelFlag(DMAChannel_Struct* DMAChx, DMA_ChannelFlagDef DMA_ChxITSrc);
N
N///@}
N
N#ifdef __cplusplus
S}
N#endif
N#endif
L 56 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_RTC_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_RTC_DRV.h" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_RTC_DRV.H
N *
N * @brief       This is the C code format driver head file for the RTC module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.11
N * @date        2018/05/30
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2018 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par 		Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_RTC.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_RTC.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_RTC.h
N *
N * @brief       MG32x02z RTC Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_RTC_H
N#define _MG32x02z_RTC_H
N#define _MG32x02z_RTC_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_RTC_H_VER)
S    #error "MG32x02z_RTC_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      RTC_Struct
N *              RTC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ALMF          :1;     //[1] RTC alarm matched interrupt flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  ALMF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  PCF           :1;     //[2] RTC periodic interrupt flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  PCF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TSF           :1;     //[3] RTC time stamp interrupt flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TSF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  TOF           :1;     //[4] RTC timer overflow interrupt flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  TOF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  RCRF          :1;     //[5] RTC reload or capture flag
X            volatile uint8_t  RCRF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  RTC status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] RTC interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ALM_IE        :1;     //[1] RTC alarm matched interrupt enable.
X            volatile uint8_t  ALM_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PC_IE         :1;     //[2] RTC periodic interrupt enable.
X            volatile uint8_t  PC_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TS_IE         :1;     //[3] RTC time stamp interrupt enable.
X            volatile uint8_t  TS_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TIE           :1;     //[4] RTC timer overflow interrupt enable.
X            volatile uint8_t  TIE           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RCR_IE        :1;     //[5] RTC_RCR register reload finished, software capture finished or RTC_ALM register value
X            volatile uint8_t  RCR_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  RTC interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_SEL        :2;     //[3..2] RTC input clock CK_RTC source select.
X            volatile uint8_t  CK_SEL        :2;     
N                                        //0x0 = CK_LS
N                                        //0x1 = CK_UT
N                                        //0x2 = CK_APB
N                                        //0x3 = TM01_TRGO
N            __IO uint8_t  CK_DIV        :2;     //[5..4] RTC internal clock CK_RTC_INT input divider
X            volatile uint8_t  CK_DIV        :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CK_PDIV       :1;     //[7] RTC internal clock CK_RTC_INT input pre-divider
X            volatile uint8_t  CK_PDIV       :1;     
N                                        //0x0 = DIV4096 : divided by 4096
N                                        //0x1 = DIV1 : divided by 1
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  RTC clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] RTC key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __IO uint16_t LOCK          :16;    //[31..16] RTC lock register
X            volatile uint16_t LOCK          :16;    
N                                        //0 = Unlocked
N                                        //1 = Locked
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  RTC write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] RTC function enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ALM_EN        :1;     //[1] RTC Alarm enable bit
X            volatile uint8_t  ALM_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  RCR_MDS       :2;     //[5..4] RTC timer reload or capture control mode select
X            volatile uint8_t  RCR_MDS       :2;     
N                                        //0x0 = Directly capture
N                                        //0x1 = Delayed capture
N                                        //0x2 = Forced reload
N                                        //0x3 = Auto reload
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  OUT_SEL       :2;     //[9..8] RTC output signal select
X            volatile uint8_t  OUT_SEL       :2;     
N                                        //0x0 = ALM : Alarm compare output event
N                                        //0x1 = PC : CK_RTC_INT periodic clock signal
N                                        //0x2 = TS : Time stamp trigger event
N                                        //0x3 = TO : Timer overflow signal toggle output
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TS_TRGS       :2;     //[13..12] RTC time stamp trigger edge select.
X            volatile uint8_t  TS_TRGS       :2;     
N                                        //0x0 = Disable
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __O  uint8_t  OUT_STA       :1;     //[14] RTC_OUT output signal initial state
X            volatile  uint8_t  OUT_STA       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  OUT_LCK       :1;     //[15] RTC_OUT output signal initial state control
X            volatile uint8_t  OUT_LCK       :1;     
N                                        //0 = Locked
N                                        //1 = Un-Locked
N            __IO uint8_t  ALM_WPEN      :1;     //[16] RTC detect RTC_ALMF flag wakeup from STOP mode enable bit.
X            volatile uint8_t  ALM_WPEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  PC_WPEN       :1;     //[17] RTC detect RTC_PCF flag wakeup from STOP mode enable bit.
X            volatile uint8_t  PC_WPEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[18] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TF_WPEN       :1;     //[19] RTC detect RTC_TOF flag wakeup from STOP mode enable bit.
X            volatile uint8_t  TF_WPEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  RTC control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  RC_START      :1;     //[0] RTC timer counter reload and software capture start enable
X            volatile uint8_t  RC_START      :1;     
N                                        //0 = No effect
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  RTC control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t RLR           :32;    //[31..0] RTC counter reload register. The value 0xFFFFFFFF is invalid.
X            volatile uint32_t RLR           :32;    
N        }MBIT;
N    }RLR;                               /*!< RLR        ~ Offset[0x18]  RTC reload register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint32_t ALM           :32;    //[31..0] RTC alarm compared value register
X            volatile uint32_t ALM           :32;    
N        }MBIT;
N    }ALM;                               /*!< ALM        ~ Offset[0x1C]  RTC alarm compare register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint32_t CAP           :32;    //[31..0] RTC counter capture register
X            volatile const  uint32_t CAP           :32;    
N        }MBIT;
N    }CAP;                               /*!< CAP        ~ Offset[0x20]  RTC capture register */
N
N} RTC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        RTC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define RTC_Base                        ((uint32_t)0x5D040000)              /*!< Real Time Clock Control */
N#define RTC                             ((RTC_Struct*) RTC_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        RTC  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        RTC_STA  [register's definitions]
N *              Offset[0x00]  RTC status register (0x5D040000)
N ******************************************************************************
N */
N///@{
N#define RTC_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_STA */
N#define RTC_STA_RCRF_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define RTC_STA_RCRF_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define RTC_STA_RCRF_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RTC_STA_RCRF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RTC_STA_RCRF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RTC_STA_RCRF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RTC_STA_RCRF_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define RTC_STA_RCRF_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define RTC_STA_RCRF_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RTC_STA_TOF_mask_w                          ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RTC_STA_TOF_mask_h0                         ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RTC_STA_TOF_mask_b0                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RTC_STA_TOF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RTC_STA_TOF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RTC_STA_TOF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RTC_STA_TOF_happened_w                      ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define RTC_STA_TOF_happened_h0                     ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define RTC_STA_TOF_happened_b0                     ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RTC_STA_TSF_mask_w                          ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RTC_STA_TSF_mask_h0                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RTC_STA_TSF_mask_b0                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RTC_STA_TSF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RTC_STA_TSF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RTC_STA_TSF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RTC_STA_TSF_happened_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define RTC_STA_TSF_happened_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define RTC_STA_TSF_happened_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RTC_STA_PCF_mask_w                          ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RTC_STA_PCF_mask_h0                         ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RTC_STA_PCF_mask_b0                         ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RTC_STA_PCF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RTC_STA_PCF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RTC_STA_PCF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RTC_STA_PCF_happened_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define RTC_STA_PCF_happened_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define RTC_STA_PCF_happened_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define RTC_STA_ALMF_mask_w                         ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RTC_STA_ALMF_mask_h0                        ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RTC_STA_ALMF_mask_b0                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RTC_STA_ALMF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define RTC_STA_ALMF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define RTC_STA_ALMF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define RTC_STA_ALMF_happened_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define RTC_STA_ALMF_happened_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define RTC_STA_ALMF_happened_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_INT  [register's definitions]
N *              Offset[0x04]  RTC interrupt enable register (0x5D040004)
N ******************************************************************************
N */
N///@{
N#define RTC_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_INT */
N#define RTC_INT_RCR_IE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define RTC_INT_RCR_IE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define RTC_INT_RCR_IE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define RTC_INT_RCR_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_INT_RCR_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_INT_RCR_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_INT_RCR_IE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_INT_RCR_IE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_INT_RCR_IE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_INT_TIE_mask_w                          ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define RTC_INT_TIE_mask_h0                         ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define RTC_INT_TIE_mask_b0                         ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define RTC_INT_TIE_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_INT_TIE_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_INT_TIE_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_INT_TIE_enable_w                        ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_INT_TIE_enable_h0                       ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_INT_TIE_enable_b0                       ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_INT_TS_IE_mask_w                        ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define RTC_INT_TS_IE_mask_h0                       ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RTC_INT_TS_IE_mask_b0                       ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RTC_INT_TS_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_INT_TS_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_INT_TS_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_INT_TS_IE_enable_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_INT_TS_IE_enable_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_INT_TS_IE_enable_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_INT_PC_IE_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define RTC_INT_PC_IE_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define RTC_INT_PC_IE_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define RTC_INT_PC_IE_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_INT_PC_IE_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_INT_PC_IE_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_INT_PC_IE_enable_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_INT_PC_IE_enable_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_INT_PC_IE_enable_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_INT_ALM_IE_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RTC_INT_ALM_IE_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RTC_INT_ALM_IE_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RTC_INT_ALM_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_INT_ALM_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_INT_ALM_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_INT_ALM_IE_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_INT_ALM_IE_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_INT_ALM_IE_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RTC_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RTC_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RTC_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_CLK  [register's definitions]
N *              Offset[0x08]  RTC clock source register (0x5D040008)
N ******************************************************************************
N */
N///@{
N#define RTC_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_CLK */
N#define RTC_CLK_CK_PDIV_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define RTC_CLK_CK_PDIV_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define RTC_CLK_CK_PDIV_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RTC_CLK_CK_PDIV_div4096_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV4096 of 32bit */
N#define RTC_CLK_CK_PDIV_div4096_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV4096 of 16bit */
N#define RTC_CLK_CK_PDIV_div4096_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV4096 of 8bit */
N#define RTC_CLK_CK_PDIV_div1_w                      ((uint32_t)0x00000080)  /*!< Bit Value =(0x1):DIV1 of 32bit */
N#define RTC_CLK_CK_PDIV_div1_h0                     ((uint16_t)0x0080)      /*!< Bit Value =(0x1):DIV1 of 16bit */
N#define RTC_CLK_CK_PDIV_div1_b0                     ((uint8_t )0x80)        /*!< Bit Value =(0x1):DIV1 of 8bit */
N
N#define RTC_CLK_CK_DIV_mask_w                       ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define RTC_CLK_CK_DIV_mask_h0                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define RTC_CLK_CK_DIV_mask_b0                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define RTC_CLK_CK_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define RTC_CLK_CK_DIV_div1_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define RTC_CLK_CK_DIV_div1_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define RTC_CLK_CK_DIV_div2_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define RTC_CLK_CK_DIV_div2_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define RTC_CLK_CK_DIV_div2_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define RTC_CLK_CK_DIV_div4_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define RTC_CLK_CK_DIV_div4_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define RTC_CLK_CK_DIV_div4_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define RTC_CLK_CK_DIV_div8_w                       ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define RTC_CLK_CK_DIV_div8_h0                      ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define RTC_CLK_CK_DIV_div8_b0                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N
N#define RTC_CLK_CK_SEL_mask_w                       ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define RTC_CLK_CK_SEL_mask_h0                      ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define RTC_CLK_CK_SEL_mask_b0                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define RTC_CLK_CK_SEL_ck_ls_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_LS of 32bit */
N#define RTC_CLK_CK_SEL_ck_ls_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_LS of 16bit */
N#define RTC_CLK_CK_SEL_ck_ls_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_LS of 8bit */
N#define RTC_CLK_CK_SEL_ck_ut_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):CK_UT of 32bit */
N#define RTC_CLK_CK_SEL_ck_ut_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(0x1):CK_UT of 16bit */
N#define RTC_CLK_CK_SEL_ck_ut_b0                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):CK_UT of 8bit */
N#define RTC_CLK_CK_SEL_ck_apb_w                     ((uint32_t)0x00000008)  /*!< Bit Value =(0x2):CK_APB of 32bit */
N#define RTC_CLK_CK_SEL_ck_apb_h0                    ((uint16_t)0x0008)      /*!< Bit Value =(0x2):CK_APB of 16bit */
N#define RTC_CLK_CK_SEL_ck_apb_b0                    ((uint8_t )0x08)        /*!< Bit Value =(0x2):CK_APB of 8bit */
N#define RTC_CLK_CK_SEL_tm01_trgo_w                  ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define RTC_CLK_CK_SEL_tm01_trgo_h0                 ((uint16_t)0x000C)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define RTC_CLK_CK_SEL_tm01_trgo_b0                 ((uint8_t )0x0C)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_KEY  [register's definitions]
N *              Offset[0x0C]  RTC write protected Key register (0x5D04000C)
N ******************************************************************************
N */
N///@{
N#define RTC_KEY_default                             ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_KEY */
N#define RTC_KEY_LOCK_mask_w                         ((uint32_t)0xFFFF0000)  /*!< Bit Mask of 32bit */
N#define RTC_KEY_LOCK_mask_h1                        ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define RTC_KEY_LOCK_unlocked_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unlocked of 32bit */
N#define RTC_KEY_LOCK_unlocked_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Unlocked of 16bit */
N#define RTC_KEY_LOCK_unlocked_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):Unlocked of 8bit */
N#define RTC_KEY_LOCK_locked_w                       ((uint32_t)0x00010000)  /*!< Bit Value =(1):Locked of 32bit */
N#define RTC_KEY_LOCK_locked_h1                      ((uint16_t)0x0001)      /*!< Bit Value =(1):Locked of 16bit */
N#define RTC_KEY_LOCK_locked_b2                      ((uint8_t )0x01)        /*!< Bit Value =(1):Locked of 8bit */
N
N#define RTC_KEY_KEY_mask_w                          ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define RTC_KEY_KEY_mask_h0                         ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define RTC_KEY_KEY_unprotected_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define RTC_KEY_KEY_unprotected_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define RTC_KEY_KEY_unprotected_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define RTC_KEY_KEY_protected_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define RTC_KEY_KEY_protected_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define RTC_KEY_KEY_protected_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_CR0  [register's definitions]
N *              Offset[0x10]  RTC control register 0 (0x5D040010)
N ******************************************************************************
N */
N///@{
N#define RTC_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_CR0 */
N#define RTC_CR0_TF_WPEN_mask_w                      ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_TF_WPEN_mask_h1                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_TF_WPEN_mask_b2                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_TF_WPEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_CR0_TF_WPEN_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_CR0_TF_WPEN_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_CR0_TF_WPEN_enable_w                    ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_CR0_TF_WPEN_enable_h1                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_CR0_TF_WPEN_enable_b2                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_CR0_PC_WPEN_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_PC_WPEN_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_PC_WPEN_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_PC_WPEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_CR0_PC_WPEN_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_CR0_PC_WPEN_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_CR0_PC_WPEN_enable_w                    ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_CR0_PC_WPEN_enable_h1                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_CR0_PC_WPEN_enable_b2                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_CR0_ALM_WPEN_mask_w                     ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_ALM_WPEN_mask_h1                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_ALM_WPEN_mask_b2                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_ALM_WPEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_CR0_ALM_WPEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_CR0_ALM_WPEN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_CR0_ALM_WPEN_enable_w                   ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_CR0_ALM_WPEN_enable_h1                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_CR0_ALM_WPEN_enable_b2                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_CR0_OUT_LCK_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_OUT_LCK_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_OUT_LCK_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_OUT_LCK_locked_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Locked of 32bit */
N#define RTC_CR0_OUT_LCK_locked_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Locked of 16bit */
N#define RTC_CR0_OUT_LCK_locked_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Locked of 8bit */
N#define RTC_CR0_OUT_LCK_un_locked_w                 ((uint32_t)0x00008000)  /*!< Bit Value =(1):Un-Locked of 32bit */
N#define RTC_CR0_OUT_LCK_un_locked_h0                ((uint16_t)0x8000)      /*!< Bit Value =(1):Un-Locked of 16bit */
N#define RTC_CR0_OUT_LCK_un_locked_b1                ((uint8_t )0x80)        /*!< Bit Value =(1):Un-Locked of 8bit */
N
N#define RTC_CR0_OUT_STA_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_OUT_STA_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_OUT_STA_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_OUT_STA_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define RTC_CR0_OUT_STA_0_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define RTC_CR0_OUT_STA_0_b1                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define RTC_CR0_OUT_STA_1_w                         ((uint32_t)0x00004000)  /*!< Bit Value =(1):1 of 32bit */
N#define RTC_CR0_OUT_STA_1_h0                        ((uint16_t)0x4000)      /*!< Bit Value =(1):1 of 16bit */
N#define RTC_CR0_OUT_STA_1_b1                        ((uint8_t )0x40)        /*!< Bit Value =(1):1 of 8bit */
N
N#define RTC_CR0_TS_TRGS_mask_w                      ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_TS_TRGS_mask_h0                     ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_TS_TRGS_mask_b1                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_TS_TRGS_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define RTC_CR0_TS_TRGS_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define RTC_CR0_TS_TRGS_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define RTC_CR0_TS_TRGS_rising_edge_w               ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define RTC_CR0_TS_TRGS_rising_edge_h0              ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define RTC_CR0_TS_TRGS_rising_edge_b1              ((uint8_t )0x10)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define RTC_CR0_TS_TRGS_falling_edge_w              ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define RTC_CR0_TS_TRGS_falling_edge_h0             ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define RTC_CR0_TS_TRGS_falling_edge_b1             ((uint8_t )0x20)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define RTC_CR0_TS_TRGS_dual_edge_w                 ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define RTC_CR0_TS_TRGS_dual_edge_h0                ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define RTC_CR0_TS_TRGS_dual_edge_b1                ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define RTC_CR0_OUT_SEL_mask_w                      ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_OUT_SEL_mask_h0                     ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_OUT_SEL_mask_b1                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_OUT_SEL_alm_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ALM of 32bit */
N#define RTC_CR0_OUT_SEL_alm_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ALM of 16bit */
N#define RTC_CR0_OUT_SEL_alm_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):ALM of 8bit */
N#define RTC_CR0_OUT_SEL_pc_w                        ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):PC of 32bit */
N#define RTC_CR0_OUT_SEL_pc_h0                       ((uint16_t)0x0100)      /*!< Bit Value =(0x1):PC of 16bit */
N#define RTC_CR0_OUT_SEL_pc_b1                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):PC of 8bit */
N#define RTC_CR0_OUT_SEL_ts_w                        ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):TS of 32bit */
N#define RTC_CR0_OUT_SEL_ts_h0                       ((uint16_t)0x0200)      /*!< Bit Value =(0x2):TS of 16bit */
N#define RTC_CR0_OUT_SEL_ts_b1                       ((uint8_t )0x02)        /*!< Bit Value =(0x2):TS of 8bit */
N#define RTC_CR0_OUT_SEL_to_w                        ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):TO of 32bit */
N#define RTC_CR0_OUT_SEL_to_h0                       ((uint16_t)0x0300)      /*!< Bit Value =(0x3):TO of 16bit */
N#define RTC_CR0_OUT_SEL_to_b1                       ((uint8_t )0x03)        /*!< Bit Value =(0x3):TO of 8bit */
N
N#define RTC_CR0_RCR_MDS_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_RCR_MDS_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_RCR_MDS_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_RCR_MDS_directly_capture_w          ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Directly capture of 32bit */
N#define RTC_CR0_RCR_MDS_directly_capture_h0         ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Directly capture of 16bit */
N#define RTC_CR0_RCR_MDS_directly_capture_b0         ((uint8_t )0x00)        /*!< Bit Value =(0x0):Directly capture of 8bit */
N#define RTC_CR0_RCR_MDS_delayed_capture_w           ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):Delayed capture of 32bit */
N#define RTC_CR0_RCR_MDS_delayed_capture_h0          ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Delayed capture of 16bit */
N#define RTC_CR0_RCR_MDS_delayed_capture_b0          ((uint8_t )0x10)        /*!< Bit Value =(0x1):Delayed capture of 8bit */
N#define RTC_CR0_RCR_MDS_forced_reload_w             ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):Forced reload of 32bit */
N#define RTC_CR0_RCR_MDS_forced_reload_h0            ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Forced reload of 16bit */
N#define RTC_CR0_RCR_MDS_forced_reload_b0            ((uint8_t )0x20)        /*!< Bit Value =(0x2):Forced reload of 8bit */
N#define RTC_CR0_RCR_MDS_auto_reload_w               ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):Auto reload of 32bit */
N#define RTC_CR0_RCR_MDS_auto_reload_h0              ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Auto reload of 16bit */
N#define RTC_CR0_RCR_MDS_auto_reload_b0              ((uint8_t )0x30)        /*!< Bit Value =(0x3):Auto reload of 8bit */
N
N#define RTC_CR0_ALM_EN_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_ALM_EN_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_ALM_EN_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_ALM_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_CR0_ALM_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_CR0_ALM_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_CR0_ALM_EN_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_CR0_ALM_EN_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_CR0_ALM_EN_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define RTC_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RTC_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RTC_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RTC_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define RTC_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define RTC_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define RTC_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_CR1  [register's definitions]
N *              Offset[0x14]  RTC control register 1 (0x5D040014)
N ******************************************************************************
N */
N///@{
N#define RTC_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_CR1 */
N#define RTC_CR1_RC_START_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define RTC_CR1_RC_START_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define RTC_CR1_RC_START_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define RTC_CR1_RC_START_no_effect_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):No effect of 32bit */
N#define RTC_CR1_RC_START_no_effect_h0               ((uint16_t)0x0000)      /*!< Bit Value =(0):No effect of 16bit */
N#define RTC_CR1_RC_START_no_effect_b0               ((uint8_t )0x00)        /*!< Bit Value =(0):No effect of 8bit */
N#define RTC_CR1_RC_START_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define RTC_CR1_RC_START_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define RTC_CR1_RC_START_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_RLR  [register's definitions]
N *              Offset[0x18]  RTC reload register (0x5D040018)
N ******************************************************************************
N */
N///@{
N#define RTC_RLR_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_RLR */
N#define RTC_RLR_RLR_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define RTC_RLR_RLR_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define RTC_RLR_RLR_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define RTC_RLR_RLR_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_ALM  [register's definitions]
N *              Offset[0x1C]  RTC alarm compare register (0x5D04001C)
N ******************************************************************************
N */
N///@{
N#define RTC_ALM_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_ALM */
N#define RTC_ALM_ALM_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        RTC_CAP  [register's definitions]
N *              Offset[0x20]  RTC capture register (0x5D040020)
N ******************************************************************************
N */
N///@{
N#define RTC_CAP_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of RTC_CAP */
N#define RTC_CAP_CAP_mask_w                          ((uint32_t)0xFFFFFFFF)  /*!< Bit Mask of 32bit */
N#define RTC_CAP_CAP_shift_w                         (0)                     /*!< Bit Shift of 32bit */
N#define RTC_CAP_CAP_shift_h0                        (0)                     /*!< Bit Shift of 16bit */
N#define RTC_CAP_CAP_shift_b0                        (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_RTC_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_RTC.h                         */
N/*----------------------------------------------------------------------------*/
L 30 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_RTC_DRV.h" 2
N
N#ifndef _MG32x02z_RTC_DRV_H
N/*!< _MG32x02z_RTC_DRV_H */ 
N#define _MG32x02z_RTC_DRV_H
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define RTC_RCRF    RTC_STA_RCRF_mask_w     /*!< RTC_RCR register reload finished, software capture finished or RTC_ALM register value update allowed flag */
N#define RTC_TOF     RTC_STA_TOF_mask_w      /*!< RTC timer overflow interrupt flag */
N#define RTC_TSF     RTC_STA_TSF_mask_w      /*!< RTC time stamp interrupt flag */
N#define RTC_PCF     RTC_STA_PCF_mask_w      /*!< RTC periodic interrupt flag */
N#define RTC_ALMF    RTC_STA_ALMF_mask_w     /*!< RTC alarm matched interrupt flag */
N#define RTC_ALLF    (RTC_RCRF | RTC_TOF | RTC_TSF | RTC_PCF | RTC_ALMF)     /*!< RTC all flag */
N
N#define RTC_INT_RCR     RTC_INT_RCR_IE_mask_w   /*!< RTC_RCR register reload finished, software capture finished or RTC_ALM register value update allowed interrupt enable */
N#define RTC_INT_TO      RTC_INT_TIE_mask_w      /*!< RTC timer overflow/underflow interrupt enable */
N#define RTC_INT_TS      RTC_INT_TS_IE_mask_w    /*!< RTC time stamp interrupt enable */
N#define RTC_INT_PC      RTC_INT_PC_IE_mask_w    /*!< RTC periodic interrupt enable */
N#define RTC_INT_ALM     RTC_INT_ALM_IE_mask_w   /*!< RTC alarm matched interrupt enable */
N
N#define RTC_TF_WPEN     RTC_CR0_TF_WPEN_mask_w      /*!< RTC detect RTC_TOF flag wakeup from STOP mode enable bit */
N#define RTC_PC_WPEN     RTC_CR0_PC_WPEN_mask_w      /*!< RTC detect RTC_PCF flag wakeup from STOP mode enable bit */
N#define RTC_ALM_WPEN    RTC_CR0_ALM_WPEN_mask_w     /*!< RTC detect RTC_ALMF flag wakeup from STOP mode enable bit */
N
N#define RTC_OUT_UNLOCK  RTC_CR0_OUT_LCK_mask_b1     /*!< RTC_OUT output signal initial state control */
N#define RTC_OUT_MASK    RTC_CR0_OUT_STA_mask_b1     /*!< RTC_OUT output signal initial state */
N
N#define RTC_START       RTC_CR1_RC_START_mask_b0    /*!< RTC timer counter reload and software capture start enable */
N#define RTC_ALM_EN      RTC_CR0_ALM_EN_mask_b0      /*!< RTC Alarm enable bit */
N#define RTC_CR0_EN      RTC_CR0_EN_mask_b0          /*!< RTC function enable bit */
N
N/* @} */
N
N
N/*! @enum   RTC_CLKS_TypeDef
N    @brief  RTC input clock CK_RTC source select 
N*/
Ntypedef enum   
N{
N    RTC_CK_LS       = 0,    /*!< RTC input clock CK_RTC source select CK_LS */
N    RTC_CK_UT       = 1,    /*!< RTC input clock CK_RTC source select CK_UT */
N    RTC_CK_APB      = 2,    /*!< RTC input clock CK_RTC source select CK_APB */
N    RTC_TM01_TRGO   = 3     /*!< RTC input clock CK_RTC source select TM01_TRGO */
N    
N}RTC_CLKS_TypeDef;
N
N
N/*! @enum   RTC_PDIVS_TypeDef
N    @brief  RTC internal clock CK_RTC_INT input pre-divider
N*/
Ntypedef enum   
N{
N    RTC_PDIV_4096   = 0,    /*!< RTC internal clock CK_RTC_INT input pre-divider divided by 4096 */
N    RTC_PDIV_1      = 1     /*!< RTC internal clock CK_RTC_INT input pre-divider divided by 1 */
N}RTC_PDIVS_TypeDef;
N
N
N/*! @enum   RTC_DIVS_TypeDef
N    @brief  RTC internal clock CK_RTC_INT input divider
N*/
Ntypedef enum   
N{
N    RTC_DIV_1   = 0,    /*!< RTC internal clock CK_RTC_INT input divider divided by 1 */
N    RTC_DIV_2   = 1,    /*!< RTC internal clock CK_RTC_INT input divider divided by 2 */
N    RTC_DIV_4   = 2,    /*!< RTC internal clock CK_RTC_INT input divider divided by 4 */
N    RTC_DIV_8   = 3,    /*!< RTC internal clock CK_RTC_INT input divider divided by 8 */
N}RTC_DIVS_TypeDef;
N
N
N/*! @enum   RTC_TS_TRGS_TypeDef
N    @brief  RTC time stamp trigger edge select.
N*/
Ntypedef enum   
N{
N    RTC_TS_TRGS_Disable        = 0,     /*!< RTC time stamp trigger edge select disable */
N    RTC_TS_TRGS_RisingEdge     = 1,     /*!< RTC time stamp trigger edge select rising edge */
N    RTC_TS_TRGS_FallingEdge    = 2,     /*!< RTC time stamp trigger edge select falling edge */
N    RTC_TS_TRGS_DualEdge       = 3      /*!< RTC time stamp trigger edge select dual edge */
N}RTC_TS_TRGS_TypeDef;
N
N
N/*! @enum   RTC_RCR_MODS_TypeDef
N    @brief  RTC_RCR register control mode select.
N*/
Ntypedef enum   
N{
N    RTC_RCR_MOD_DirectlyCapture    = 0,    /*!< RTC_RCR register control mode select directly capture */
N    RTC_RCR_MOD_DelayedCapture     = 1,    /*!< RTC_RCR register control mode select delay capture */
N    RTC_RCR_MOD_ForceReload        = 2,    /*!< RTC_RCR register control mode select forced reload */
N    RTC_RCR_MOD_AutoReload         = 3     /*!< RTC_RCR register control mode select auto reload */
N}RTC_RCR_MODS_TypeDef;
N
N
N/*! @enum   RTC_OUTS_TypeDef
N    @brief  RTC signal ourput source select.
N*/
Ntypedef enum
N{
N    RTC_ALM     = 0,    /*!< RTC output signal select ALM */
N    RTC_PC      = 1,    /*!< RTC output signal select PC */
N    RTC_TS      = 2,    /*!< RTC output signal select TS */
N    RTC_TO      = 3     /*!< RTC output signal select TO */
N}RTC_OUTS_TypeDef;
N
N/**
N * @name	Function announce
N *
N */ 
N///@{  
Nvoid RTC_CLK_Select (RTC_CLKS_TypeDef RTC_CLKS);
Nvoid RTC_PreDivider_Select (RTC_PDIVS_TypeDef RTC_PDIV);
Nvoid RTC_Divider_Select (RTC_DIVS_TypeDef RTC_DIV);
N
Nuint32_t RTC_GetAlarmCompareValue (void);
Nvoid RTC_SetAlarmCompareValue (uint32_t RTC_ALM);
Nvoid RTC_Alarm_Cmd (FunctionalState NewState);
NDRV_Return RTC_GetAlarmState (void);
N
Nuint32_t RTC_GetReloadReg (void);
Nuint32_t RTC_GetCaptureReg (void);
Nvoid RTC_SetReloadReg (uint32_t RTC_RCR);
N
Nvoid RTC_Cmd (FunctionalState NewState);
Nvoid RTC_RCR_Mode_Select (RTC_RCR_MODS_TypeDef RTC_MODS);
N
Nvoid RTC_StopModeWakeUpEvent_Config (uint32_t RTC_WK, FunctionalState NewState);
Nvoid RTC_OutputSignal_Select (RTC_OUTS_TypeDef RTC_OUTS);
Nvoid RTC_InitOutputSignalState_Cmd (FunctionalState NewState);
N
Nvoid RTC_TriggerStamp_Select (RTC_TS_TRGS_TypeDef RTC_TSS);
Nvoid RTC_TriggerStamp_SW (void);
N
Nuint32_t RTC_GetAllFlagStatus (void);
NDRV_Return RTC_GetSingleFlagStatus (uint32_t RTC_Flag);
Nvoid RTC_ClearFlag (uint32_t RTC_Flag);
Nvoid RTC_IT_Config (uint32_t RTC_INT, FunctionalState NewState);
Nvoid RTC_ITEA_Cmd (FunctionalState NewState);
N///@}
N
N#endif  //_MG32x02z_RTC_DRV_H
N
N
L 57 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_CM0_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CM0_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CM0_DRV.h
N *
N * @brief       This is the C Code Include format example file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2018/05/21
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N#ifndef _MG32x02z_CM0_DRV_H
N#define _MG32x02z_CM0_DRV_H
N#define _MG32x02z_CM0_DRV_H_VER                            0.01           /*!<MG32x02z Driver ver.*/
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "MG32x02z__Common_DRV.h"
N
N
N/** 
N * @name    SysTick
N *
N */ 
N///@{ 
N
N/** 
N * @enum		CM0_SysTickClkSrcDef
N * @brief		CM0 Selects the SysTick timer clock source. 
N */    
Ntypedef enum{
N    Reference = 0,
N    CK_ST = 0,
N    Processor = 1,
N    }CM0_SysTickClkSrcDef;
N
N// Systick
N#define __CM0_SysTickIT_Enable()                    SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk
N#define __CM0_SysTickIT_Disable()                   SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk
N
N#define __CM0_SysTick_Enable()                      SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk
N#define __CM0_SysTick_Disable()                     SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk
N
N#define __CM0_SysTickClcokSource_Processor()        SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk
N#define __CM0_SysTickClcokSource_Reference()        SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk
N#define __CM0_SysTickClcokSource_CK_ST()            SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk
N
N#define __CM0_GetSysTickCurrentValue()              SysTick->VAL
N
Nvoid CM0_SysTick_Cmd(FunctionalState State);
Nvoid CM0_SysTickIT_Cmd(FunctionalState State);
Nvoid CM0_SysTickClockSource_Select(CM0_SysTickClkSrcDef Select);
Nuint32_t CM0_GetSysTickCurrentValue(void);
N
N///@}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 58 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N#include "MG32x02z_EMB_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_EMB_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EMB_DRV.h
N *
N * @brief       This is the C code format driver head file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V2.22
N * @date        2020/04/06
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par         Disclaimer 
N *      The Demo software is provided "AS IS"  without any warranty, either 
N *      expressed or implied, including, but not limited to, the implied warranties 
N *      of merchantability and fitness for a particular purpose.  The author will 
N *      not be liable for any special, incidental, consequential or indirect 
N *      damages due to loss of data or any other reason. 
N *      These statements agree with the world wide and local dictated laws about 
N *      authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N
N#ifndef __MG32x02z_EMB_DRV_H
N#define __MG32x02z_EMB_DRV_H
N//#define _MG32x02z_EMB_DRV_H_VER                            0.01
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N     
N#include "MG32x02z__Common_DRV.h" 
N#include "MG32x02z_EMB.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_EMB.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EMB.h
N *
N * @brief       MG32x02z EMB Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_EMB_H
N#define _MG32x02z_EMB_H
N#define _MG32x02z_EMB_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_EMB_H_VER)
S    #error "MG32x02z_EMB_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      EMB_Struct
N *              EMB  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  BUSYF         :1;     //[0] EMB write/read access busy flag.
X            volatile const  uint8_t  BUSYF         :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WPEF          :1;     //[2] EMB bus write-protect error detect flag
X            volatile uint8_t  WPEF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (reset event happened)
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  EMB status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] EMB controller interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WPE_IE        :1;     //[2] EMB bus write-protect error detect interrupt enable.
X            volatile uint8_t  WPE_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  EMB interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :4;     //[3..0] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  CK_PSC        :3;     //[6..4] EMB output clock MCLK prescaler. The value range 0~7 is indicated divider 1~8.
X            volatile uint8_t  CK_PSC        :3;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  EMB clock source register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x0C]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] EMB controller enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WEN           :1;     //[1] EMB write access enable bit. 
X            volatile uint8_t  WEN           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SYNC_EN       :1;     //[3] EMB synchronous transaction enable bit
X            volatile uint8_t  SYNC_EN       :1;     
N                                        //0 = Async (asynchronous access)
N                                        //1 = Sync (synchronous access)
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BUS_MDS       :1;     //[10] EMB address and data bus mode select.
X            volatile uint8_t  BUS_MDS       :1;     
N                                        //0 = Multiplex
N                                        //1 = Separated
N            __IO uint8_t  ADR_TWO       :1;     //[11] EMB two address phase timing mode enable
X            volatile uint8_t  ADR_TWO       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ADR_SEL       :2;     //[13..12] EMB bus address range select
X            volatile uint8_t  ADR_SEL       :2;     
N                                        //0x0 = 16bit
N                                        //0x1 = 24bit
N                                        //0x2 = 30bit
N                                        //0x3 = Reserved
N            __I  uint8_t                :1;     //[14] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CE_MDS        :2;     //[17..16] EMB MCE signal mode select.
X            volatile uint8_t  CE_MDS        :2;     
N                                        //0x0 = CE : chip enable signal
N                                        //0x1 = ALE : same as ALE timing
N                                        //0x2 = ALE2 : 2nd phase address latch enable
N                                        //0x3 = Reserved
N            __I  uint8_t                :1;     //[18] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[19] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[20] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  ALE2_MDS      :1;     //[24] EMB MALE2 signal mode select. When EMB_MAM1_SEL=ALES, this register bit is no effect.
X            volatile uint8_t  ALE2_MDS      :1;     
N                                        //0x0 = ALE2 : 2nd phase address latch enable
N                                        //0x1 = ALE : same as ALE timing
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OE_CTL        :1;     //[26] EMB MOE control timing select.
X            volatile uint8_t  OE_CTL        :1;     
N                                        //0x0 = TOGGLE : high-to-low change
N                                        //0x1 = LOW : drive low during read access
N            __IO uint8_t  WE_CTL        :1;     //[27] EMB MWE control timing select.
X            volatile uint8_t  WE_CTL        :1;     
N                                        //0x0 = TOGGLE : high-to-low change
N                                        //0x1 = LOW : drive low during write access
N            __I  uint8_t                :3;     //[30..28] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  DMA_EN        :1;     //[31] Direct memory access enable.
X            volatile uint8_t  DMA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  EMB control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CE_INV        :1;     //[0] EMB MCE output inverse enable bit. The hardware active level is default logic low.
X            volatile uint8_t  CE_INV        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ALE_INV       :1;     //[1] EMB MALE output inverse enable bit. The hardware active level is default logic high.
X            volatile uint8_t  ALE_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ALE2_INV      :1;     //[2] EMB MALE2 output inverse enable bit. The hardware active level is default logic high.
X            volatile uint8_t  ALE2_INV      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CLK_INV       :1;     //[3] EMB MCLK clock output inverse enable bit.
X            volatile uint8_t  CLK_INV       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :3;     //[7..5] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  MA_SWAP       :1;     //[8] EMB MA[15:0] signals Msb/Lsb swap enable bit.
X            volatile uint8_t  MA_SWAP       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  MAM1_SEL      :2;     //[13..12] EMB internal memory address A-1 signal output pin select
X            volatile uint8_t  MAM1_SEL      :2;     
N                                        //0x0 = No : not output A-1 signal
N                                        //0x1 = MAD15
N                                        //0x2 = MBW1
N                                        //0x3 = MALE2
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CE_SWEN       :1;     //[16] EMB MCE signal output software control enable bit
X            volatile uint8_t  CE_SWEN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CE_SWO        :1;     //[17] EMB MCE signal software control output data bit.
X            volatile uint8_t  CE_SWO        :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  ALE_SWEN      :1;     //[18] EMB MALE signal output software control enable bit
X            volatile uint8_t  ALE_SWEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ALE_SWO       :1;     //[19] EMB MALE signal software control output data bit.
X            volatile uint8_t  ALE_SWO       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  ALE2_SWEN     :1;     //[20] EMB MALE2 signal output software control enable bit
X            volatile uint8_t  ALE2_SWEN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ALE2_SWO      :1;     //[21] EMB MALE2 signal software control output data bit.
X            volatile uint8_t  ALE2_SWO      :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  BW0_SWEN      :1;     //[22] EMB BW0 signal output software control enable bit
X            volatile uint8_t  BW0_SWEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BW0_SWO       :1;     //[23] EMB BW0 signal software control output data bit.
X            volatile uint8_t  BW0_SWO       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __IO uint8_t  BW1_SWEN      :1;     //[24] EMB BW0 signal output software control enable bit
X            volatile uint8_t  BW1_SWEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BW1_SWO       :1;     //[25] EMB BW0 signal software control output data bit.
X            volatile uint8_t  BW1_SWO       :1;     
N                                        //0 = 0 (Output 0)
N                                        //1 = 1 (Output 1)
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  OE_MUX        :2;     //[29..28] MOE output signal select.
X            volatile uint8_t  OE_MUX        :2;     
N                                        //0x0 = OE : EMB Output Enable signal
N                                        //0x1 = TM10 : TM10_CKO
N                                        //0x2 = TM16 : TM16_CKO
N                                        //0x3 = TM20 : TM20_CKO
N            __IO uint8_t  WE_MUX        :2;     //[31..30] MWE output signal select.
X            volatile uint8_t  WE_MUX        :2;     
N                                        //0x0 = WE : EMB Write Enable signal
N                                        //0x1 = TM10 : TM10_CKO
N                                        //0x2 = TM16 : TM16_CKO
N                                        //0x3 = TM20 : TM20_CKO
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  EMB control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ALES          :1;     //[0] EMB SRAM/NOR bus ALE/ALE2 setup time
X            volatile uint8_t  ALES          :1;     
N            __I  uint8_t                :3;     //[3..1] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  ALEW          :3;     //[6..4] EMB SRAM/NOR bus ALE/ALE2 pulse width
X            volatile uint8_t  ALEW          :3;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ALEH          :1;     //[8] EMB SRAM/NOR bus ALE/ALE2 hold time
X            volatile uint8_t  ALEH          :1;     
N            __I  uint8_t                :3;     //[11..9] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  ACCS          :1;     //[12] EMB SRAM/NOR bus data access setup time
X            volatile uint8_t  ACCS          :1;     
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  ACCW          :4;     //[19..16] EMB SRAM/NOR bus data access time
X            volatile uint8_t  ACCW          :4;     
N            __IO uint8_t  ACCH          :1;     //[20] EMB SRAM/NOR bus data write access hold time
X            volatile uint8_t  ACCH          :1;     
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :2;     //[25..24] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CR2;                               /*!< CR2        ~ Offset[0x18]  EMB control register 2 */
N
N} EMB_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        EMB  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define EMB_Base                        ((uint32_t)0x4D020000)              /*!< External Memory Bus Controller */
N#define EMB                             ((EMB_Struct*) EMB_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        EMB  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        EMB_STA  [register's definitions]
N *              Offset[0x00]  EMB status register (0x4D020000)
N ******************************************************************************
N */
N///@{
N#define EMB_STA_default                             ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EMB_STA */
N#define EMB_STA_WPEF_mask_w                         ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EMB_STA_WPEF_mask_h0                        ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EMB_STA_WPEF_mask_b0                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EMB_STA_WPEF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define EMB_STA_WPEF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define EMB_STA_WPEF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define EMB_STA_WPEF_happened_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define EMB_STA_WPEF_happened_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define EMB_STA_WPEF_happened_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define EMB_STA_BUSYF_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EMB_STA_BUSYF_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EMB_STA_BUSYF_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_STA_BUSYF_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define EMB_STA_BUSYF_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define EMB_STA_BUSYF_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EMB_INT  [register's definitions]
N *              Offset[0x04]  EMB interrupt enable register (0x4D020004)
N ******************************************************************************
N */
N///@{
N#define EMB_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EMB_INT */
N#define EMB_INT_WPE_IE_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EMB_INT_WPE_IE_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EMB_INT_WPE_IE_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EMB_INT_WPE_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_INT_WPE_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_INT_WPE_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_INT_WPE_IE_enable_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_INT_WPE_IE_enable_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_INT_WPE_IE_enable_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EMB_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EMB_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EMB_CLK  [register's definitions]
N *              Offset[0x08]  EMB clock source register (0x4D020008)
N ******************************************************************************
N */
N///@{
N#define EMB_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EMB_CLK */
N#define EMB_CLK_CK_PSC_mask_w                       ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define EMB_CLK_CK_PSC_mask_h0                      ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define EMB_CLK_CK_PSC_mask_b0                      ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N#define EMB_CLK_CK_PSC_shift_w                      (4)                     /*!< Bit Shift of 32bit */
N#define EMB_CLK_CK_PSC_shift_h0                     (4)                     /*!< Bit Shift of 16bit */
N#define EMB_CLK_CK_PSC_shift_b0                     (4)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EMB_CR0  [register's definitions]
N *              Offset[0x10]  EMB control register 0 (0x4D020010)
N ******************************************************************************
N */
N///@{
N#define EMB_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EMB_CR0 */
N#define EMB_CR0_DMA_EN_mask_w                       ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_DMA_EN_mask_h1                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_DMA_EN_mask_b3                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_DMA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR0_DMA_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR0_DMA_EN_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR0_DMA_EN_enable_w                     ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR0_DMA_EN_enable_h1                    ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR0_DMA_EN_enable_b3                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR0_WE_CTL_mask_w                       ((uint32_t)0x08000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_WE_CTL_mask_h1                      ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_WE_CTL_mask_b3                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_WE_CTL_toggle_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TOGGLE of 32bit */
N#define EMB_CR0_WE_CTL_toggle_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TOGGLE of 16bit */
N#define EMB_CR0_WE_CTL_toggle_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):TOGGLE of 8bit */
N#define EMB_CR0_WE_CTL_low_w                        ((uint32_t)0x08000000)  /*!< Bit Value =(0x1):LOW of 32bit */
N#define EMB_CR0_WE_CTL_low_h1                       ((uint16_t)0x0800)      /*!< Bit Value =(0x1):LOW of 16bit */
N#define EMB_CR0_WE_CTL_low_b3                       ((uint8_t )0x08)        /*!< Bit Value =(0x1):LOW of 8bit */
N
N#define EMB_CR0_OE_CTL_mask_w                       ((uint32_t)0x04000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_OE_CTL_mask_h1                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_OE_CTL_mask_b3                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_OE_CTL_toggle_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):TOGGLE of 32bit */
N#define EMB_CR0_OE_CTL_toggle_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):TOGGLE of 16bit */
N#define EMB_CR0_OE_CTL_toggle_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):TOGGLE of 8bit */
N#define EMB_CR0_OE_CTL_low_w                        ((uint32_t)0x04000000)  /*!< Bit Value =(0x1):LOW of 32bit */
N#define EMB_CR0_OE_CTL_low_h1                       ((uint16_t)0x0400)      /*!< Bit Value =(0x1):LOW of 16bit */
N#define EMB_CR0_OE_CTL_low_b3                       ((uint8_t )0x04)        /*!< Bit Value =(0x1):LOW of 8bit */
N
N#define EMB_CR0_ALE2_MDS_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_ALE2_MDS_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_ALE2_MDS_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_ALE2_MDS_ale2_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ALE2 of 32bit */
N#define EMB_CR0_ALE2_MDS_ale2_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ALE2 of 16bit */
N#define EMB_CR0_ALE2_MDS_ale2_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):ALE2 of 8bit */
N#define EMB_CR0_ALE2_MDS_ale_w                      ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):ALE of 32bit */
N#define EMB_CR0_ALE2_MDS_ale_h1                     ((uint16_t)0x0100)      /*!< Bit Value =(0x1):ALE of 16bit */
N#define EMB_CR0_ALE2_MDS_ale_b3                     ((uint8_t )0x01)        /*!< Bit Value =(0x1):ALE of 8bit */
N
N#define EMB_CR0_CE_MDS_mask_w                       ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_CE_MDS_mask_h1                      ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_CE_MDS_mask_b2                      ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_CE_MDS_ce_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CE of 32bit */
N#define EMB_CR0_CE_MDS_ce_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CE of 16bit */
N#define EMB_CR0_CE_MDS_ce_b2                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):CE of 8bit */
N#define EMB_CR0_CE_MDS_ale_w                        ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):ALE of 32bit */
N#define EMB_CR0_CE_MDS_ale_h1                       ((uint16_t)0x0001)      /*!< Bit Value =(0x1):ALE of 16bit */
N#define EMB_CR0_CE_MDS_ale_b2                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):ALE of 8bit */
N#define EMB_CR0_CE_MDS_ale2_w                       ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):ALE2 of 32bit */
N#define EMB_CR0_CE_MDS_ale2_h1                      ((uint16_t)0x0002)      /*!< Bit Value =(0x2):ALE2 of 16bit */
N#define EMB_CR0_CE_MDS_ale2_b2                      ((uint8_t )0x02)        /*!< Bit Value =(0x2):ALE2 of 8bit */
N
N#define EMB_CR0_ADR_SEL_mask_w                      ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_ADR_SEL_mask_h0                     ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_ADR_SEL_mask_b1                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_ADR_SEL_16bit_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):16bit of 32bit */
N#define EMB_CR0_ADR_SEL_16bit_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):16bit of 16bit */
N#define EMB_CR0_ADR_SEL_16bit_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):16bit of 8bit */
N#define EMB_CR0_ADR_SEL_24bit_w                     ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):24bit of 32bit */
N#define EMB_CR0_ADR_SEL_24bit_h0                    ((uint16_t)0x1000)      /*!< Bit Value =(0x1):24bit of 16bit */
N#define EMB_CR0_ADR_SEL_24bit_b1                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):24bit of 8bit */
N#define EMB_CR0_ADR_SEL_30bit_w                     ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):30bit of 32bit */
N#define EMB_CR0_ADR_SEL_30bit_h0                    ((uint16_t)0x2000)      /*!< Bit Value =(0x2):30bit of 16bit */
N#define EMB_CR0_ADR_SEL_30bit_b1                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):30bit of 8bit */
N
N#define EMB_CR0_ADR_TWO_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_ADR_TWO_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_ADR_TWO_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_ADR_TWO_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR0_ADR_TWO_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR0_ADR_TWO_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR0_ADR_TWO_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR0_ADR_TWO_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR0_ADR_TWO_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR0_BUS_MDS_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_BUS_MDS_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_BUS_MDS_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_BUS_MDS_multiplex_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Multiplex of 32bit */
N#define EMB_CR0_BUS_MDS_multiplex_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Multiplex of 16bit */
N#define EMB_CR0_BUS_MDS_multiplex_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Multiplex of 8bit */
N#define EMB_CR0_BUS_MDS_separated_w                 ((uint32_t)0x00000400)  /*!< Bit Value =(1):Separated of 32bit */
N#define EMB_CR0_BUS_MDS_separated_h0                ((uint16_t)0x0400)      /*!< Bit Value =(1):Separated of 16bit */
N#define EMB_CR0_BUS_MDS_separated_b1                ((uint8_t )0x04)        /*!< Bit Value =(1):Separated of 8bit */
N
N#define EMB_CR0_SYNC_EN_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_SYNC_EN_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_SYNC_EN_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_SYNC_EN_async_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Async of 32bit */
N#define EMB_CR0_SYNC_EN_async_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Async of 16bit */
N#define EMB_CR0_SYNC_EN_async_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Async of 8bit */
N#define EMB_CR0_SYNC_EN_sync_w                      ((uint32_t)0x00000008)  /*!< Bit Value =(1):Sync of 32bit */
N#define EMB_CR0_SYNC_EN_sync_h0                     ((uint16_t)0x0008)      /*!< Bit Value =(1):Sync of 16bit */
N#define EMB_CR0_SYNC_EN_sync_b0                     ((uint8_t )0x08)        /*!< Bit Value =(1):Sync of 8bit */
N
N#define EMB_CR0_WEN_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_WEN_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_WEN_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_WEN_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR0_WEN_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR0_WEN_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR0_WEN_enable_w                        ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR0_WEN_enable_h0                       ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR0_WEN_enable_b0                       ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EMB_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EMB_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EMB_CR1  [register's definitions]
N *              Offset[0x14]  EMB control register 1 (0x4D020014)
N ******************************************************************************
N */
N///@{
N#define EMB_CR1_default                             ((uint32_t)0x00000006)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EMB_CR1 */
N#define EMB_CR1_WE_MUX_mask_w                       ((uint32_t)0xC0000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_WE_MUX_mask_h1                      ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_WE_MUX_mask_b3                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_WE_MUX_we_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):WE of 32bit */
N#define EMB_CR1_WE_MUX_we_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):WE of 16bit */
N#define EMB_CR1_WE_MUX_we_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):WE of 8bit */
N#define EMB_CR1_WE_MUX_tm10_w                       ((uint32_t)0x40000000)  /*!< Bit Value =(0x1):TM10 of 32bit */
N#define EMB_CR1_WE_MUX_tm10_h1                      ((uint16_t)0x4000)      /*!< Bit Value =(0x1):TM10 of 16bit */
N#define EMB_CR1_WE_MUX_tm10_b3                      ((uint8_t )0x40)        /*!< Bit Value =(0x1):TM10 of 8bit */
N#define EMB_CR1_WE_MUX_tm16_w                       ((uint32_t)0x80000000)  /*!< Bit Value =(0x2):TM16 of 32bit */
N#define EMB_CR1_WE_MUX_tm16_h1                      ((uint16_t)0x8000)      /*!< Bit Value =(0x2):TM16 of 16bit */
N#define EMB_CR1_WE_MUX_tm16_b3                      ((uint8_t )0x80)        /*!< Bit Value =(0x2):TM16 of 8bit */
N#define EMB_CR1_WE_MUX_tm20_w                       ((uint32_t)0xC0000000)  /*!< Bit Value =(0x3):TM20 of 32bit */
N#define EMB_CR1_WE_MUX_tm20_h1                      ((uint16_t)0xC000)      /*!< Bit Value =(0x3):TM20 of 16bit */
N#define EMB_CR1_WE_MUX_tm20_b3                      ((uint8_t )0xC0)        /*!< Bit Value =(0x3):TM20 of 8bit */
N
N#define EMB_CR1_OE_MUX_mask_w                       ((uint32_t)0x30000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_OE_MUX_mask_h1                      ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_OE_MUX_mask_b3                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_OE_MUX_oe_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):OE of 32bit */
N#define EMB_CR1_OE_MUX_oe_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0x0):OE of 16bit */
N#define EMB_CR1_OE_MUX_oe_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0x0):OE of 8bit */
N#define EMB_CR1_OE_MUX_tm10_w                       ((uint32_t)0x10000000)  /*!< Bit Value =(0x1):TM10 of 32bit */
N#define EMB_CR1_OE_MUX_tm10_h1                      ((uint16_t)0x1000)      /*!< Bit Value =(0x1):TM10 of 16bit */
N#define EMB_CR1_OE_MUX_tm10_b3                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):TM10 of 8bit */
N#define EMB_CR1_OE_MUX_tm16_w                       ((uint32_t)0x20000000)  /*!< Bit Value =(0x2):TM16 of 32bit */
N#define EMB_CR1_OE_MUX_tm16_h1                      ((uint16_t)0x2000)      /*!< Bit Value =(0x2):TM16 of 16bit */
N#define EMB_CR1_OE_MUX_tm16_b3                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):TM16 of 8bit */
N#define EMB_CR1_OE_MUX_tm20_w                       ((uint32_t)0x30000000)  /*!< Bit Value =(0x3):TM20 of 32bit */
N#define EMB_CR1_OE_MUX_tm20_h1                      ((uint16_t)0x3000)      /*!< Bit Value =(0x3):TM20 of 16bit */
N#define EMB_CR1_OE_MUX_tm20_b3                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):TM20 of 8bit */
N
N#define EMB_CR1_BW1_SWO_mask_w                      ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_BW1_SWO_mask_h1                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_BW1_SWO_mask_b3                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_BW1_SWO_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define EMB_CR1_BW1_SWO_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define EMB_CR1_BW1_SWO_0_b3                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define EMB_CR1_BW1_SWO_1_w                         ((uint32_t)0x02000000)  /*!< Bit Value =(1):1 of 32bit */
N#define EMB_CR1_BW1_SWO_1_h1                        ((uint16_t)0x0200)      /*!< Bit Value =(1):1 of 16bit */
N#define EMB_CR1_BW1_SWO_1_b3                        ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define EMB_CR1_BW1_SWEN_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_BW1_SWEN_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_BW1_SWEN_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_BW1_SWEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_BW1_SWEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_BW1_SWEN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_BW1_SWEN_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_BW1_SWEN_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_BW1_SWEN_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_BW0_SWO_mask_w                      ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_BW0_SWO_mask_h1                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_BW0_SWO_mask_b2                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_BW0_SWO_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define EMB_CR1_BW0_SWO_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define EMB_CR1_BW0_SWO_0_b2                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define EMB_CR1_BW0_SWO_1_w                         ((uint32_t)0x00800000)  /*!< Bit Value =(1):1 of 32bit */
N#define EMB_CR1_BW0_SWO_1_h1                        ((uint16_t)0x0080)      /*!< Bit Value =(1):1 of 16bit */
N#define EMB_CR1_BW0_SWO_1_b2                        ((uint8_t )0x80)        /*!< Bit Value =(1):1 of 8bit */
N
N#define EMB_CR1_BW0_SWEN_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_BW0_SWEN_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_BW0_SWEN_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_BW0_SWEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_BW0_SWEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_BW0_SWEN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_BW0_SWEN_enable_w                   ((uint32_t)0x00400000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_BW0_SWEN_enable_h1                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_BW0_SWEN_enable_b2                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_ALE2_SWO_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_ALE2_SWO_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_ALE2_SWO_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_ALE2_SWO_0_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define EMB_CR1_ALE2_SWO_0_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define EMB_CR1_ALE2_SWO_0_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define EMB_CR1_ALE2_SWO_1_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(1):1 of 32bit */
N#define EMB_CR1_ALE2_SWO_1_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(1):1 of 16bit */
N#define EMB_CR1_ALE2_SWO_1_b2                       ((uint8_t )0x20)        /*!< Bit Value =(1):1 of 8bit */
N
N#define EMB_CR1_ALE2_SWEN_mask_w                    ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_ALE2_SWEN_mask_h1                   ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_ALE2_SWEN_mask_b2                   ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_ALE2_SWEN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_ALE2_SWEN_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_ALE2_SWEN_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_ALE2_SWEN_enable_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_ALE2_SWEN_enable_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_ALE2_SWEN_enable_b2                 ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_ALE_SWO_mask_w                      ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_ALE_SWO_mask_h1                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_ALE_SWO_mask_b2                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_ALE_SWO_0_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define EMB_CR1_ALE_SWO_0_h1                        ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define EMB_CR1_ALE_SWO_0_b2                        ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define EMB_CR1_ALE_SWO_1_w                         ((uint32_t)0x00080000)  /*!< Bit Value =(1):1 of 32bit */
N#define EMB_CR1_ALE_SWO_1_h1                        ((uint16_t)0x0008)      /*!< Bit Value =(1):1 of 16bit */
N#define EMB_CR1_ALE_SWO_1_b2                        ((uint8_t )0x08)        /*!< Bit Value =(1):1 of 8bit */
N
N#define EMB_CR1_ALE_SWEN_mask_w                     ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_ALE_SWEN_mask_h1                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_ALE_SWEN_mask_b2                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_ALE_SWEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_ALE_SWEN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_ALE_SWEN_disable_b2                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_ALE_SWEN_enable_w                   ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_ALE_SWEN_enable_h1                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_ALE_SWEN_enable_b2                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_CE_SWO_mask_w                       ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_CE_SWO_mask_h1                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_CE_SWO_mask_b2                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_CE_SWO_0_w                          ((uint32_t)0x00000000)  /*!< Bit Value =(0):0 of 32bit */
N#define EMB_CR1_CE_SWO_0_h1                         ((uint16_t)0x0000)      /*!< Bit Value =(0):0 of 16bit */
N#define EMB_CR1_CE_SWO_0_b2                         ((uint8_t )0x00)        /*!< Bit Value =(0):0 of 8bit */
N#define EMB_CR1_CE_SWO_1_w                          ((uint32_t)0x00020000)  /*!< Bit Value =(1):1 of 32bit */
N#define EMB_CR1_CE_SWO_1_h1                         ((uint16_t)0x0002)      /*!< Bit Value =(1):1 of 16bit */
N#define EMB_CR1_CE_SWO_1_b2                         ((uint8_t )0x02)        /*!< Bit Value =(1):1 of 8bit */
N
N#define EMB_CR1_CE_SWEN_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_CE_SWEN_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_CE_SWEN_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_CE_SWEN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_CE_SWEN_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_CE_SWEN_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_CE_SWEN_enable_w                    ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_CE_SWEN_enable_h1                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_CE_SWEN_enable_b2                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_MAM1_SEL_mask_w                     ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_MAM1_SEL_mask_h0                    ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_MAM1_SEL_mask_b1                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_MAM1_SEL_no_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No of 32bit */
N#define EMB_CR1_MAM1_SEL_no_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No of 16bit */
N#define EMB_CR1_MAM1_SEL_no_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):No of 8bit */
N#define EMB_CR1_MAM1_SEL_mad15_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):MAD15 of 32bit */
N#define EMB_CR1_MAM1_SEL_mad15_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(0x1):MAD15 of 16bit */
N#define EMB_CR1_MAM1_SEL_mad15_b1                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):MAD15 of 8bit */
N#define EMB_CR1_MAM1_SEL_mbw1_w                     ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):MBW1 of 32bit */
N#define EMB_CR1_MAM1_SEL_mbw1_h0                    ((uint16_t)0x2000)      /*!< Bit Value =(0x2):MBW1 of 16bit */
N#define EMB_CR1_MAM1_SEL_mbw1_b1                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):MBW1 of 8bit */
N#define EMB_CR1_MAM1_SEL_male2_w                    ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):MALE2 of 32bit */
N#define EMB_CR1_MAM1_SEL_male2_h0                   ((uint16_t)0x3000)      /*!< Bit Value =(0x3):MALE2 of 16bit */
N#define EMB_CR1_MAM1_SEL_male2_b1                   ((uint8_t )0x30)        /*!< Bit Value =(0x3):MALE2 of 8bit */
N
N#define EMB_CR1_MA_SWAP_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_MA_SWAP_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_MA_SWAP_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_MA_SWAP_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_MA_SWAP_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_MA_SWAP_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_MA_SWAP_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_MA_SWAP_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_MA_SWAP_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_CLK_INV_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_CLK_INV_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_CLK_INV_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_CLK_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_CLK_INV_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_CLK_INV_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_CLK_INV_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_CLK_INV_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_CLK_INV_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_ALE2_INV_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_ALE2_INV_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_ALE2_INV_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_ALE2_INV_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_ALE2_INV_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_ALE2_INV_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_ALE2_INV_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_ALE2_INV_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_ALE2_INV_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_ALE_INV_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_ALE_INV_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_ALE_INV_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_ALE_INV_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_ALE_INV_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_ALE_INV_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_ALE_INV_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_ALE_INV_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_ALE_INV_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define EMB_CR1_CE_INV_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EMB_CR1_CE_INV_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EMB_CR1_CE_INV_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define EMB_CR1_CE_INV_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define EMB_CR1_CE_INV_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define EMB_CR1_CE_INV_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define EMB_CR1_CE_INV_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define EMB_CR1_CE_INV_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define EMB_CR1_CE_INV_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        EMB_CR2  [register's definitions]
N *              Offset[0x18]  EMB control register 2 (0x4D020018)
N ******************************************************************************
N */
N///@{
N#define EMB_CR2_default                             ((uint32_t)0x00100100)  /*!< Reg Reset Default Value */
N
N/* Bit fields of EMB_CR2 */
N#define EMB_CR2_ACCH_mask_w                         ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define EMB_CR2_ACCH_mask_h1                        ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define EMB_CR2_ACCH_mask_b2                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define EMB_CR2_ACCW_mask_w                         ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define EMB_CR2_ACCW_mask_h1                        ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define EMB_CR2_ACCW_mask_b2                        ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N
N#define EMB_CR2_ACCS_mask_w                         ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define EMB_CR2_ACCS_mask_h0                        ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define EMB_CR2_ACCS_mask_b1                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N
N#define EMB_CR2_ALEH_mask_w                         ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define EMB_CR2_ALEH_mask_h0                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define EMB_CR2_ALEH_mask_b1                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N#define EMB_CR2_ALEW_mask_w                         ((uint32_t)0x00000070)  /*!< Bit Mask of 32bit */
N#define EMB_CR2_ALEW_mask_h0                        ((uint16_t)0x0070)      /*!< Bit Mask of 16bit */
N#define EMB_CR2_ALEW_mask_b0                        ((uint8_t )0x70)        /*!< Bit Mask of 8bit */
N
N#define EMB_CR2_ALES_mask_w                         ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define EMB_CR2_ALES_mask_h0                        ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define EMB_CR2_ALES_mask_b0                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_EMB_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_EMB.h                         */
N/*----------------------------------------------------------------------------*/
L 43 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_EMB_DRV.h" 2
N
N#define EMB_IT_CmdCmp   EMB_WPE | EMB_BWE               /*!< EMB control interrupt driver compare definitions.    */
N#define EMB_IT_FlagCmp  EMB_WPE | EMB_BWE | EMB_BUSY    /*!< EMB read / write flag relationship driver compare definitions   */
N#define EMB_WPE         EMB_STA_WPEF_mask_w             /*!< EMB WPE interrupt / flag relationship control member    */
N#define EMB_BUSY        EMB_STA_BUSYF_mask_w            /*!< EMB Busy flag relationship control member */
N
N 
N#define EMB_CMP_SWEN    EMB_BW1_SWEN | EMB_BW0_SWEN | EMB_ALE2_SWEN | EMB_ALE_SWEN | EMB_CE_SWEN /*!< Compare EMB software control enable / disable member definitions */ 
N#define EMB_BW1_SWEN    EMB_CR1_BW1_SWEN_mask_w     /*!< EMB software control enable/disable member definitions */
N#define EMB_BW0_SWEN    EMB_CR1_BW0_SWEN_mask_w     /*!< EMB software control enable/disable member definitions */
N#define EMB_ALE2_SWEN   EMB_CR1_ALE2_SWEN_mask_w    /*!< EMB software control enable/disable member definitions */
N#define EMB_ALE_SWEN    EMB_CR1_ALE_SWEN_mask_w     /*!< EMB software control enable/disable member definitions */
N#define EMB_CE_SWEN     EMB_CR1_CE_SWEN_mask_w      /*!< EMB software control enable/disable member definitions */
N 
N#define EMB_CMP_SWO     EMB_BW1_SWO | EMB_BW0_SWO | EMB_ALE2_SWO | EMB_ALE_SWO | EMB_CE_SWO /*!< Compare EMB software control member definitions */ 
N#define EMB_BW1_SWO     EMB_CR1_BW1_SWO_mask_w      /*!< EMB software control member definitions */
N#define EMB_BW0_SWO     EMB_CR1_BW0_SWO_mask_w      /*!< EMB software control member definitions */
N#define EMB_ALE2_SWO    EMB_CR1_ALE2_SWO_mask_w     /*!< EMB software control member definitions */
N#define EMB_ALE_SWO     EMB_CR1_ALE_SWO_mask_w      /*!< EMB software control member definitions */
N#define EMB_CE_SWO      EMB_CR1_CE_SWO_mask_w       /*!< EMB software control member definitions */
N 
N#define EMB_CMP_BSWP    EMB_MA_SWP                  /*!< Compare EMB Signal swap enable / disable member definitions */
N#define EMB_MA_SWP      EMB_CR1_MA_SWAP_mask_w      /*!< EMB signal swap enable/disable member defineitions */
N
N#define EMB_CMP_INV     EMB_CLK_INV|EMB_ALE2_INV|EMB_ALE_INV|EMB_CE_INV /*!< Compare EMB Signal inverse enable / disable member definitions */
N#define EMB_CLK_INV     EMB_CR1_CLK_INV_mask_w      /*!< EMB signal inverse enable/disable member defineitions */
N#define EMB_ALE2_INV    EMB_CR1_ALE2_INV_mask_w     /*!< EMB signal inverse enable/disable member defineitions */
N#define EMB_ALE_INV     EMB_CR1_ALE_INV_mask_w      /*!< EMB signal inverse enable/disable member defineitions */
N#define EMB_CE_INV      EMB_CR1_CE_INV_mask_w       /*!< EMB signal inverse enable/disable member defineitions */
N 
N/*! @enum   EMB_MWE_TypeDef
N    @brief  MWE output signal select definitions.
N*/ 
Ntypedef enum 
N{
N    EMB_MWE_WE      =   0,      /*!< MWE output signal from WE */
N    EMB_MWE_TM10    =   1,      /*!< MWE output signal from Timer10 */
N    EMB_MWE_TM16    =   2,      /*!< MWE output signal from Timer16 */
N    EMB_MWE_TM20    =   3       /*!< MWE output signal from Timer20 */
N}EMB_MWE_TypeDef;
N
N/*! @enum   EMB_MOE_TypeDef
N    @brief  MDE output signal select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_MOE_OE      =   0,      /*!< MWE output signal from OE */
N    EMB_MOE_TM10    =   1,      /*!< MWE output signal from Timer10 */
N    EMB_MOE_TM16    =   2,      /*!< MWE output signal from Timer16 */
N    EMB_MOE_TM20    =   3       /*!< MWE output signal from Timer20 */
N}EMB_MOE_TypeDef;
N
N/*! @enum   EMB_ALES_TypeDef
N    @brief  ALE/ALE2 setup time select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_ALES_0MCLK  =   0x00000000,     /*!< ALE/ALE2 setup time is 0 MCLK */
N    EMB_ALES_1MCLK  =   0x00000001      /*!< ALE/ALE2 setup time is 1 MCLK */
N}EMB_ALES_TypeDef; 
N 
N/*! @enum   EMB_ALEW_TypeDef
N    @brief  ALE/ALE2 plus width select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_ALEW_1MCLK  =   0x00000000,     /*!< ALE/ALE2 plus width is 1 MCLK */
N    EMB_ALEW_2MCLK  =   0x00000010,     /*!< ALE/ALE2 plus width is 2 MCLK */     
N    EMB_ALEW_3MCLK  =   0x00000020,     /*!< ALE/ALE2 plus width is 3 MCLK */
N    EMB_ALEW_4MCLK  =   0x00000030      /*!< ALE/ALE2 plus width is 4 MCLK */
N}EMB_ALEW_TypeDef;
N
N/*! @enum   EMB_ALEH_TypeDef
N    @brief  ALE/ALE2 hold time select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_ALEH_0MCLK  =   0x00000000,     /*!< ALE/ALE2 hold time is 0 MCLK */
N    EMB_ALEH_1MCLK  =   0x00000100      /*!< ALE/ALE2 hold time is 1 MCLK */
N    
N}EMB_ALEH_TypeDef;
N
N/*! @enum   EMB_ACCS_TypeDef
N    @brief  Data access setup time select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_ACCS_0MCLK  =   0x00000000,     /*!< Data access setup time is 0 MCLK */
N    EMB_ACCS_1MCLK  =   0x00001000      /*!< Data access setup time is 1 MCLK */
N    
N}EMB_ACCS_TypeDef;
N
N/*! @enum   EMB_ACCW_TypeDef
N    @brief  Data access time select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_ACCW_1MCLK   =   0x00000000,    /*!< Data access time is 1 MCLK */
N    EMB_ACCW_2MCLK   =   0x00010000,    /*!< Data access time is 2 MCLK */
N    EMB_ACCW_3MCLK   =   0x00020000,    /*!< Data access time is 3 MCLK */
N    EMB_ACCW_4MCLK   =   0x00030000,    /*!< Data access time is 4 MCLK */
N    EMB_ACCW_5MCLK   =   0x00040000,    /*!< Data access time is 5 MCLK */
N    EMB_ACCW_6MCLK   =   0x00050000,    /*!< Data access time is 6 MCLK */
N    EMB_ACCW_7MCLK   =   0x00060000,    /*!< Data access time is 7 MCLK */
N    EMB_ACCW_8MCLK   =   0x00070000,    /*!< Data access time is 8 MCLK */
N    EMB_ACCW_9MCLK   =   0x00080000,    /*!< Data access time is 9 MCLK */
N    EMB_ACCW_10MCLK  =   0x00090000,    /*!< Data access time is 10 MCLK */
N    EMB_ACCW_11MCLK  =   0x000A0000,    /*!< Data access time is 11 MCLK */
N    EMB_ACCW_12MCLK  =   0x000B0000,    /*!< Data access time is 12 MCLK */
N    EMB_ACCW_13MCLK  =   0x000C0000,    /*!< Data access time is 13 MCLK */
N    EMB_ACCW_14MCLK  =   0x000D0000,    /*!< Data access time is 14 MCLK */
N    EMB_ACCW_15MCLK  =   0x000E0000,    /*!< Data access time is 15 MCLK */
N    EMB_ACCW_16MCLK  =   0x000F0000,    /*!< Data access time is 16 MCLK */
N}EMB_ACCW_TypeDef;
N
N/*! @enum   EMB_ACCH_TypeDef
N    @brief  Data access hold time select definitions.
N*/ 
Ntypedef enum
N{   
N    EMB_ACCH_0MCLK  =   0x00000000,     /*!< Data access hold time is 0 MCLK. */
N    EMB_ACCH_1MCLK  =   0x00100000      /*!< Data access hold time is 1 MCLK. */
N    
N}EMB_ACCH_TypeDef;
N
N/*! @enum   EMB_MCLK_TypeDef
N    @brief  EMB output clock MCK prescaler select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_PREMCLK_1   =   0,      /*!< MCK prescaler is 1 */
N    EMB_PREMCLK_2   =   1,      /*!< MCK prescaler is 2 */
N    EMB_PREMCLK_3   =   2,      /*!< MCK prescaler is 3 */
N    EMB_PREMCLK_4   =   3,      /*!< MCK prescaler is 4 */
N    EMB_PREMCLK_5   =   4,      /*!< MCK prescaler is 5 */
N    EMB_PREMCLK_6   =   5,      /*!< MCK prescaler is 6 */
N    EMB_PREMCLK_7   =   7       /*!< MCK prescaler is 7 */
N}EMB_MCLK_TypeDef;
N
N/*! @enum   EMB_RWSignalMode_TypeDef
N    @brief  EMB read / write signal mode select definitions.
N*/ 
Ntypedef enum
N{
N    EMB_TOGGLE = 0,             /*!< Read / write signal is high to low change. */
N    EMB_LOW = 1                 /*!< Read / Write signal is low during read / write access.*/
N}EMB_RWSignalMode_TypeDef;
N
N/*! @enum   EMB_CEMode_TypeDef
N    @brief  CE pin output signal select definitions.
N*/
Ntypedef enum
N{
N    EMB_CE   =   0,             /*!< CE pin output signal is CE. */
N    EMB_ALE  =   1,             /*!< CE pin output signal is ALE. */             
N    EMB_ALE2 =   2              /*!< CE pin output signal is ALE2. */
N}EMB_CEMode_TypeDef;
N
N/*! @enum   EMB_ADRBIT_TypeDef
N    @brief  Address signal bit select definitions.
N*/
Ntypedef enum
N{
N    EMB_AddressBit_16 =   EMB_CR0_ADR_SEL_16bit_w,  /*!< Address is 16 bit.*/
X    EMB_AddressBit_16 =   ((uint32_t)0x00000000),   
N    EMB_AddressBit_24 =   EMB_CR0_ADR_SEL_24bit_w,  /*!< Address is 24 bit.*/
X    EMB_AddressBit_24 =   ((uint32_t)0x00001000),   
N    EMB_AddressBit_30 =   EMB_CR0_ADR_SEL_30bit_w,  /*!< Address is 30 bit.*/
X    EMB_AddressBit_30 =   ((uint32_t)0x00002000),   
N}EMB_ADRBIT_TypeDef;
N
N/*! @enum   EMB_BusMode_TypeDef
N    @brief  Address signal and data signal mode select definitions.
N*/
Ntypedef enum
N{
N    EMB_BUS_Multiplex = EMB_CR0_BUS_MDS_multiplex_w,    /*!< Address signal and data signal is multiplex. */
X    EMB_BUS_Multiplex = ((uint32_t)0x00000000),     
N    EMB_BUS_Separated = EMB_CR0_BUS_MDS_separated_w     /*!< Address signal and data signal is sep */
X    EMB_BUS_Separated = ((uint32_t)0x00000400)      
N}EMB_BusMode_TypeDef;
N
N/*! @enum   EMB_ALE2Cmd_TypeDef
N    @brief  EMB two address phase timing mode enable or disable select definitions.
N*/
Ntypedef enum
N{
N    EMB_ALE2_DISABLE = EMB_CR0_ADR_TWO_disable_w,   /*!< EMB two address phase timing mode disable. */
X    EMB_ALE2_DISABLE = ((uint32_t)0x00000000),    
N    EMB_ALE2_ENABLE = EMB_CR0_ADR_TWO_enable_w,     /*!< EMB two address phase timing mode disable. */
X    EMB_ALE2_ENABLE = ((uint32_t)0x00000800),      
N}EMB_ALE2Cmd_TypeDef;
N
N
N/*! @enum  EMB_ALE2Mode_TypeDef
N    @brief ALE2 mode select definitions.
N*/
Ntypedef enum
N{
N    EMB_ALE2Mode_ALE2 = EMB_CR0_ALE2_MDS_ale2_w,    /*!< 2nd phase address latch enable*/
X    EMB_ALE2Mode_ALE2 = ((uint32_t)0x00000000),     
N    EMB_ALE2Mode_ALE = EMB_CR0_ALE2_MDS_ale_w       /*!< same as ALE timing.*/
X    EMB_ALE2Mode_ALE = ((uint32_t)0x01000000)        
N}EMB_ALE2Mode_TypeDef;
N
N
N/*! @enum   EMB_WriteMode_TypeDef
N    @brief  EMB write mode select definitions.
N*/
Ntypedef enum
N{
N    EMB_Write_Disable       =   EMB_CR0_WEN_disable_w,    /*!< EMB write is diable.*/
X    EMB_Write_Disable       =   ((uint32_t)0x00000000),     
N    EMB_Write_Enable        =   EMB_CR0_WEN_enable_w,    /*!< EMB write is enable.*/  
X    EMB_Write_Enable        =   ((uint32_t)0x00000002),       
N}EMB_WriteMode_TypeDef;
N
N
N/*! @enum   EMB_MA1OutputPin_TypeDef
N    @brief  EMB MA1 signal output pin select definitions.
N*/
Ntypedef enum
N{
N    EMB_MA1_NoOutput        =   0,      /*!<No output MA1 signal. */
N    EMB_MA1_OutputToMAD15   =   1,      /*!<MA1 output pin is MAD15. */
N    EMB_MA1_OutputToBW1     =   2,      /*!<MA1 output pin is BW1. */
N    EMB_MA1_OutputToALE2    =   3,      /*!<MA1 output pin is ALE2. */
N}EMB_MA1OutputPin_TypeDef;
N
N
N/*! @struct EMB_TimeStateTypeDef
N    @brief  EMB access control time state member.
N*/ 
N typedef struct
N{
N    EMB_ALES_TypeDef EMB_ALES;   /*!< ALE/ALE2 setup time*/
N    EMB_ALEW_TypeDef EMB_ALEW;   /*!< ALE/ALE2 plus width*/
N    EMB_ALEH_TypeDef EMB_ALEH;   /*!< ALE/ALE2 hold time*/
N    EMB_ACCS_TypeDef EMB_ACCS;   /*!< Data access setup time*/
N    EMB_ACCW_TypeDef EMB_ACCW;   /*!< Data access time*/
N    EMB_ACCH_TypeDef EMB_ACCH;   /*!< Data access hold time*/
N}EMB_TimeStateTypeDef;
N 
N
N/*! @struct EMB_AddressDataTypeDef
N    @brief  EMB address and data control member.
N*/
Ntypedef struct
N{
N    EMB_ADRBIT_TypeDef      EMB_AddressBit;     /*!< EMB address bit select. */
N    EMB_BusMode_TypeDef     EMB_BusMode;        /*!< EMB address and data bus mode select.*/      
N    EMB_ALE2Cmd_TypeDef     EMB_ALE2_EN;        /*!< EMB ALE2 control */
N    EMB_ALE2Mode_TypeDef    EMB_ALE2Mode;       /*!< EMB ALE2 mode control if ALE2 select.*/
N}EMB_AddressDataTypeDef;
N
N
N
Nvoid EMB_Cmd(FunctionalState EMB_EN);
N
N#if defined(MG32_1ST)
X#if 1L
Nvoid EMB_Synchonous_Cmd(FunctionalState EMB_SYNC_Cmd);
N#endif
N
Nvoid EMB_AddressDataBusMode_Config( EMB_AddressDataTypeDef* EMB_AddressDataMode);
Nvoid EMB_WriteMode_Select(EMB_WriteMode_TypeDef EMB_WriteMode);
N
Nvoid EMB_AccessTime_Config(EMB_TimeStateTypeDef* EMB_TimeState);
N
Nvoid EMB_IT_Cmd(uint32_t EMB_IT, FunctionalState EMB_IT_State);
Nvoid EMB_ITEA_Cmd(FunctionalState EMB_ITEA_State);
NDRV_Return EMB_GetSingleFlagStatus(uint32_t EMB_Flag);
Nuint32_t EMB_GetAllFlagStatus(void);
Nvoid EMB_ClearFlag(uint32_t EMB_Flag);
N
NDRV_Return EMB_SignalSWAP_Cmd(uint32_t EMB_SWAPSignal , FunctionalState EMB_SWAPSignal_Status);
NDRV_Return EMB_SignalInverse_Cmd(uint32_t EMD_InverseSignal , FunctionalState EMB_InverseSignal_Status);
NDRV_Return EMB_SignalSW_Cmd(uint32_t EMB_SWSignal ,FunctionalState EMB_SignalSW_Status);
NDRV_Return EMB_SendSignalStatus_SW(uint32_t EMB_SWSignal ,BitAction EMB_SWSingal_Status);
Nvoid EMB_MWESignal_Select(EMB_MWE_TypeDef EMB_MWE);
Nvoid EMB_MOESignal_Select(EMB_MOE_TypeDef EMB_MOE);
Nvoid EMB_MCLKPreescaler_Select(EMB_MCLK_TypeDef EMB_MCLK);
Nvoid EMB_WESignalMode_Select(EMB_RWSignalMode_TypeDef EMB_WE);
Nvoid EMB_OESignalMode_Select(EMB_RWSignalMode_TypeDef EMB_OE);
Nvoid EMB_CEMode_Select(EMB_CEMode_TypeDef EMB_CE);
Nvoid EMB_MA1SignalOutputPin_Select(EMB_MA1OutputPin_TypeDef EMB_MA1_PIN);
N
Nvoid EMB_DMA_Cmd( FunctionalState EMB_DMAState);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 61 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#include "MG32x02z_DAC_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DAC_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DAC_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the DAC 
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.12
N * @date        2020/03/30
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N#ifndef _MG32x02z_DAC_DRV_H
N
N/*!< _MG32x02z_DAC_DRV_H */ 
N#define _MG32x02z_DAC_DRV_H
N
N
N#include "MG32x02z__Common_DRV.h"
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N#include "MG32x02z_DAC.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_DAC.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_DAC.h
N *
N * @brief       MG32x02z DAC Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_DAC_H
N#define _MG32x02z_DAC_H
N#define _MG32x02z_DAC_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_DAC_H_VER)
S    #error "MG32x02z_DAC_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      DAC_Struct
N *              DAC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RDY0F         :1;     //[1] DAC-0 ready flag to update new data to data register
X            volatile uint8_t  RDY0F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[6..3] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  UDR0F         :1;     //[7] DAC-0 conversion underrun event flag
X            volatile uint8_t  UDR0F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  DAC status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] DAC interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RDY0_IE       :1;     //[1] DAC-0 ready to update new data to data register interrupt enable.
X            volatile uint8_t  RDY0_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[6..3] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  UDR0_IE       :1;     //[7] DAC-0 conversion underrun event interrupt enable.
X            volatile uint8_t  UDR0_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  DAC interrupt enable register */
N
N    __I uint32_t  RESERVED0[2];         /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0[2];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  DA0_EN        :1;     //[0] DAC-0 power-on enable bit.
X            volatile uint8_t  DA0_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  CMOD0_SEL     :2;     //[3..2] DAC-0 output current mode select.
X            volatile uint8_t  CMOD0_SEL     :2;     
N                                        //0x0 = M0 : 0.5mA full-scale output current
N                                        //0x1 = M1 : 1mA full-scale output current
N                                        //0x2 = Reserved
N                                        //0x3 = M2 : 2mA full-scale output current
N            __IO uint8_t  ALIGN0_SEL    :1;     //[4] DAC-0 data alignment select.
X            volatile uint8_t  ALIGN0_SEL    :1;     
N                                        //0 = Right (Right alignment)
N                                        //1 = Left (Left alignment)
N            __I  uint8_t                :1;     //[5] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  RES0_SEL      :1;     //[6] DAC-0 data resolution select
X            volatile uint8_t  RES0_SEL      :1;     
N                                        //0x0 = 10-bit
N                                        //0x1 = 8-bit
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  START0_SEL    :3;     //[10..8] DAC-0 start trigger control source select
X            volatile uint8_t  START0_SEL    :3;     
N                                        //0x0 = WDAT : DAC_DAT0 register written
N                                        //0x1 = PIN : DAC_TRG external trigger pin
N                                        //0x2 = CMP0 : CMP0_OUT
N                                        //0x3 = TM00 : TM00_TRGO
N                                        //0x4 = TM01 : TM01_TRGO
N                                        //0x5 = TM10 : TM10_TRGO
N                                        //0x6 = ITR6 : APB_ITR6
N                                        //0x7 = ITR7 : APB_ITR7
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  TRG0_SEL      :2;     //[13..12] DAC-0 start trigger selection
X            volatile uint8_t  TRG0_SEL      :2;     
N                                        //0x0 = Disable
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :7;     //[23..17] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :7;     //[30..24] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  DMA_EN        :1;     //[31] Direct memory access enable to transmit
X            volatile uint8_t  DMA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  DAC control register 0 */
N
N    __I uint32_t  RESERVED1[3];         /*!< RESERVED1  ~ Offset[0x14]  Reserved */
X    volatile const uint32_t  RESERVED1[3];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t DAT0          :16;    //[15..0] DAC-0 conversion data register
X            volatile uint16_t DAT0          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }DAT0;                              /*!< DAT0       ~ Offset[0x20]  DAC conversion data register 0 */
N
N    __I uint32_t  RESERVED2;            /*!< RESERVED2  ~ Offset[0x24]  Reserved */
X    volatile const uint32_t  RESERVED2;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t DOR0          :16;    //[15..0] DAC-0 conversion output register
X            volatile const  uint16_t DOR0          :16;    
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }DOR0;                              /*!< DOR0       ~ Offset[0x28]  DAC conversion output register 0 */
N
N} DAC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        DAC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define DAC_Base                        ((uint32_t)0x5C080000)              /*!< Digital-to-Analog Converter Control */
N#define DAC                             ((DAC_Struct*) DAC_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        DAC  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        DAC_STA  [register's definitions]
N *              Offset[0x00]  DAC status register (0x5C080000)
N ******************************************************************************
N */
N///@{
N#define DAC_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DAC_STA */
N#define DAC_STA_UDR0F_mask_w                        ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define DAC_STA_UDR0F_mask_h0                       ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define DAC_STA_UDR0F_mask_b0                       ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DAC_STA_UDR0F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DAC_STA_UDR0F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DAC_STA_UDR0F_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DAC_STA_UDR0F_happened_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define DAC_STA_UDR0F_happened_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define DAC_STA_UDR0F_happened_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define DAC_STA_RDY0F_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DAC_STA_RDY0F_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DAC_STA_RDY0F_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DAC_STA_RDY0F_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define DAC_STA_RDY0F_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define DAC_STA_RDY0F_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define DAC_STA_RDY0F_happened_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define DAC_STA_RDY0F_happened_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define DAC_STA_RDY0F_happened_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DAC_INT  [register's definitions]
N *              Offset[0x04]  DAC interrupt enable register (0x5C080004)
N ******************************************************************************
N */
N///@{
N#define DAC_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DAC_INT */
N#define DAC_INT_UDR0_IE_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define DAC_INT_UDR0_IE_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define DAC_INT_UDR0_IE_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DAC_INT_UDR0_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DAC_INT_UDR0_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DAC_INT_UDR0_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DAC_INT_UDR0_IE_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define DAC_INT_UDR0_IE_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define DAC_INT_UDR0_IE_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DAC_INT_RDY0_IE_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define DAC_INT_RDY0_IE_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define DAC_INT_RDY0_IE_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define DAC_INT_RDY0_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DAC_INT_RDY0_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DAC_INT_RDY0_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DAC_INT_RDY0_IE_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define DAC_INT_RDY0_IE_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define DAC_INT_RDY0_IE_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DAC_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DAC_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DAC_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DAC_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DAC_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DAC_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DAC_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DAC_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DAC_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DAC_CR0  [register's definitions]
N *              Offset[0x10]  DAC control register 0 (0x5C080010)
N ******************************************************************************
N */
N///@{
N#define DAC_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DAC_CR0 */
N#define DAC_CR0_DMA_EN_mask_w                       ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_DMA_EN_mask_h1                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_DMA_EN_mask_b3                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_DMA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DAC_CR0_DMA_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DAC_CR0_DMA_EN_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DAC_CR0_DMA_EN_enable_w                     ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define DAC_CR0_DMA_EN_enable_h1                    ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define DAC_CR0_DMA_EN_enable_b3                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define DAC_CR0_TRG0_SEL_mask_w                     ((uint32_t)0x00003000)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_TRG0_SEL_mask_h0                    ((uint16_t)0x3000)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_TRG0_SEL_mask_b1                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_TRG0_SEL_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define DAC_CR0_TRG0_SEL_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define DAC_CR0_TRG0_SEL_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define DAC_CR0_TRG0_SEL_rising_edge_w              ((uint32_t)0x00001000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define DAC_CR0_TRG0_SEL_rising_edge_h0             ((uint16_t)0x1000)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define DAC_CR0_TRG0_SEL_rising_edge_b1             ((uint8_t )0x10)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define DAC_CR0_TRG0_SEL_falling_edge_w             ((uint32_t)0x00002000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define DAC_CR0_TRG0_SEL_falling_edge_h0            ((uint16_t)0x2000)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define DAC_CR0_TRG0_SEL_falling_edge_b1            ((uint8_t )0x20)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define DAC_CR0_TRG0_SEL_dual_edge_w                ((uint32_t)0x00003000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define DAC_CR0_TRG0_SEL_dual_edge_h0               ((uint16_t)0x3000)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define DAC_CR0_TRG0_SEL_dual_edge_b1               ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define DAC_CR0_START0_SEL_mask_w                   ((uint32_t)0x00000700)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_START0_SEL_mask_h0                  ((uint16_t)0x0700)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_START0_SEL_mask_b1                  ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_START0_SEL_wdat_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):WDAT of 32bit */
N#define DAC_CR0_START0_SEL_wdat_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):WDAT of 16bit */
N#define DAC_CR0_START0_SEL_wdat_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):WDAT of 8bit */
N#define DAC_CR0_START0_SEL_pin_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):PIN of 32bit */
N#define DAC_CR0_START0_SEL_pin_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):PIN of 16bit */
N#define DAC_CR0_START0_SEL_pin_b1                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):PIN of 8bit */
N#define DAC_CR0_START0_SEL_cmp0_w                   ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):CMP0 of 32bit */
N#define DAC_CR0_START0_SEL_cmp0_h0                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):CMP0 of 16bit */
N#define DAC_CR0_START0_SEL_cmp0_b1                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):CMP0 of 8bit */
N#define DAC_CR0_START0_SEL_tm00_w                   ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):TM00 of 32bit */
N#define DAC_CR0_START0_SEL_tm00_h0                  ((uint16_t)0x0300)      /*!< Bit Value =(0x3):TM00 of 16bit */
N#define DAC_CR0_START0_SEL_tm00_b1                  ((uint8_t )0x03)        /*!< Bit Value =(0x3):TM00 of 8bit */
N#define DAC_CR0_START0_SEL_tm01_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(0x4):TM01 of 32bit */
N#define DAC_CR0_START0_SEL_tm01_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(0x4):TM01 of 16bit */
N#define DAC_CR0_START0_SEL_tm01_b1                  ((uint8_t )0x04)        /*!< Bit Value =(0x4):TM01 of 8bit */
N#define DAC_CR0_START0_SEL_tm10_w                   ((uint32_t)0x00000500)  /*!< Bit Value =(0x5):TM10 of 32bit */
N#define DAC_CR0_START0_SEL_tm10_h0                  ((uint16_t)0x0500)      /*!< Bit Value =(0x5):TM10 of 16bit */
N#define DAC_CR0_START0_SEL_tm10_b1                  ((uint8_t )0x05)        /*!< Bit Value =(0x5):TM10 of 8bit */
N#define DAC_CR0_START0_SEL_itr6_w                   ((uint32_t)0x00000600)  /*!< Bit Value =(0x6):ITR6 of 32bit */
N#define DAC_CR0_START0_SEL_itr6_h0                  ((uint16_t)0x0600)      /*!< Bit Value =(0x6):ITR6 of 16bit */
N#define DAC_CR0_START0_SEL_itr6_b1                  ((uint8_t )0x06)        /*!< Bit Value =(0x6):ITR6 of 8bit */
N#define DAC_CR0_START0_SEL_itr7_w                   ((uint32_t)0x00000700)  /*!< Bit Value =(0x7):ITR7 of 32bit */
N#define DAC_CR0_START0_SEL_itr7_h0                  ((uint16_t)0x0700)      /*!< Bit Value =(0x7):ITR7 of 16bit */
N#define DAC_CR0_START0_SEL_itr7_b1                  ((uint8_t )0x07)        /*!< Bit Value =(0x7):ITR7 of 8bit */
N
N#define DAC_CR0_RES0_SEL_mask_w                     ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_RES0_SEL_mask_h0                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_RES0_SEL_mask_b0                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_RES0_SEL_10_bit_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):10-bit of 32bit */
N#define DAC_CR0_RES0_SEL_10_bit_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0x0):10-bit of 16bit */
N#define DAC_CR0_RES0_SEL_10_bit_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0x0):10-bit of 8bit */
N#define DAC_CR0_RES0_SEL_8_bit_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):8-bit of 32bit */
N#define DAC_CR0_RES0_SEL_8_bit_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(0x1):8-bit of 16bit */
N#define DAC_CR0_RES0_SEL_8_bit_b0                   ((uint8_t )0x40)        /*!< Bit Value =(0x1):8-bit of 8bit */
N
N#define DAC_CR0_ALIGN0_SEL_mask_w                   ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_ALIGN0_SEL_mask_h0                  ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_ALIGN0_SEL_mask_b0                  ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_ALIGN0_SEL_right_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Right of 32bit */
N#define DAC_CR0_ALIGN0_SEL_right_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Right of 16bit */
N#define DAC_CR0_ALIGN0_SEL_right_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Right of 8bit */
N#define DAC_CR0_ALIGN0_SEL_left_w                   ((uint32_t)0x00000010)  /*!< Bit Value =(1):Left of 32bit */
N#define DAC_CR0_ALIGN0_SEL_left_h0                  ((uint16_t)0x0010)      /*!< Bit Value =(1):Left of 16bit */
N#define DAC_CR0_ALIGN0_SEL_left_b0                  ((uint8_t )0x10)        /*!< Bit Value =(1):Left of 8bit */
N
N#define DAC_CR0_CMOD0_SEL_mask_w                    ((uint32_t)0x0000000C)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_CMOD0_SEL_mask_h0                   ((uint16_t)0x000C)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_CMOD0_SEL_mask_b0                   ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_CMOD0_SEL_m0_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):M0 of 32bit */
N#define DAC_CR0_CMOD0_SEL_m0_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):M0 of 16bit */
N#define DAC_CR0_CMOD0_SEL_m0_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):M0 of 8bit */
N#define DAC_CR0_CMOD0_SEL_m1_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(0x1):M1 of 32bit */
N#define DAC_CR0_CMOD0_SEL_m1_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(0x1):M1 of 16bit */
N#define DAC_CR0_CMOD0_SEL_m1_b0                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):M1 of 8bit */
N#define DAC_CR0_CMOD0_SEL_m2_w                      ((uint32_t)0x0000000C)  /*!< Bit Value =(0x3):M2 of 32bit */
N#define DAC_CR0_CMOD0_SEL_m2_h0                     ((uint16_t)0x000C)      /*!< Bit Value =(0x3):M2 of 16bit */
N#define DAC_CR0_CMOD0_SEL_m2_b0                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):M2 of 8bit */
N
N#define DAC_CR0_DA0_EN_mask_w                       ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define DAC_CR0_DA0_EN_mask_h0                      ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define DAC_CR0_DA0_EN_mask_b0                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define DAC_CR0_DA0_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define DAC_CR0_DA0_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define DAC_CR0_DA0_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define DAC_CR0_DA0_EN_enable_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define DAC_CR0_DA0_EN_enable_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define DAC_CR0_DA0_EN_enable_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DAC_DAT0  [register's definitions]
N *              Offset[0x20]  DAC conversion data register 0 (0x5C080020)
N ******************************************************************************
N */
N///@{
N#define DAC_DAT0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DAC_DAT0 */
N#define DAC_DAT0_DAT0_mask_w                        ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DAC_DAT0_DAT0_mask_h0                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DAC_DAT0_DAT0_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define DAC_DAT0_DAT0_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define DAC_DAT0_DAT0_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        DAC_DOR0  [register's definitions]
N *              Offset[0x28]  DAC conversion output register 0 (0x5C080028)
N ******************************************************************************
N */
N///@{
N#define DAC_DOR0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of DAC_DOR0 */
N#define DAC_DOR0_DOR0_mask_w                        ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define DAC_DOR0_DOR0_mask_h0                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define DAC_DOR0_DOR0_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define DAC_DOR0_DOR0_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define DAC_DOR0_DOR0_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_DAC_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_DAC.h                         */
N/*----------------------------------------------------------------------------*/
L 41 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DAC_DRV.h" 2
N
N
N/** @brief  RisingEdge_IE Rising edge interrupt Enable */
N#define Underrun_IE         DAC_INT_UDR0_IE_enable_w   
N/** @brief  FallingEdge_IE Falling edge interrupt Enable */
N#define Ready_IE            DAC_INT_RDY0_IE_enable_w      
N/** @brief  RisingEdge_Flag Rising edge flag */
N#define Underrun_Flag       DAC_STA_UDR0F_happened_w    
N/** @brief  FallingEdge_Flag  Falling edge flag */
N#define Ready_Flag          DAC_STA_RDY0F_happened_w    
N
N
N/** 
N * @enum		DAC_DataAlignModeDef
N * @brief		config data alignment mode (Right/Left alignment)
N */        
Ntypedef enum 
N{ 
N    DAC_RightJustified, /*!< Right Justified of DAC conversion data format */
N    DAC_LeftJustified,  /*!< Left Justified of DAC conversion data format  */
N} DAC_DataAlignModeDef;
N
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		DAC_ResolutionDef
N * @brief		config data resolution (10/8 bit)
N */        
Ntypedef enum 
N{ 
N    DAC_10BitData,  /*!< data resolution = 10 bit */
N    DAC_8BitData,   /*!< data resolution = 8 bit */
N} DAC_ResolutionDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		DAC_ResolutionDef
S * @brief		config data resolution (12/10/8 bit)
S */        
Stypedef enum 
S{ 
S    DAC_12BitData,  /*!< data resolution = 12 bit */
S    DAC_10BitData,  /*!< data resolution = 10 bit */
S    DAC_8BitData,   /*!< data resolution = 8 bit */
S} DAC_ResolutionDef;
N#endif
N
N/** 
N * @enum		DAC_TriggerSourceDef
N * @brief		DAC0 start control source select
N */        
Ntypedef enum 
N{ 
N    DAC_SoftWare,       /*!< Software Write data (manual updata data) */
N    DAC_TRGPin,         /*!< PIN : DAC0_TRG : DAC external trigger pin */
N    DAC_CMP0Out,        /*!< CMP0 : CMP0_OUT */
N    DAC_TM00_TRGO,      /*!< TM00 : TM00_TRGO */
N    DAC_TM01_TRGO,      /*!< TM01 : TM01_TRGO */
N    DAC_TM10_TRGO,      /*!< TM10 : TM10_TRGO */
N    DAC_ITR6,           /*!< ITR6 : Trigger source from APB ITR6 signal */
N    DAC_ITR7,           /*!< ITR7 : Trigger source from APB ITR7 signal */
N} DAC_TriggerSourceDef;
N
N/** 
N * @enum		DAC_TriggerEdgeDef
N * @brief		config trigger event to start conversion
N */        
Ntypedef enum 
N{ 
N    DAC_DisableTrg,         /*!< Disable update */
N    DAC_AcceptRisingEdge,   /*!< accept rising edge of  trigger  */
N    DAC_AcceptFallingEdge,  /*!< accept falling edge of  trigger  */
N    DAC_AcceptDualEdge,     /*!< accept dual (rising & falling) edge of  trigger */
N} DAC_TriggerEdgeDef;
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		DAC_CurrentModeDef
N * @brief		config DAC output current 
N */        
Ntypedef enum 
N{ 
N    DAC_M0=0,           /*!< M0 : ~0.5mA full-scale output current */
N    DAC_M1=1,           /*!< M1 : ~1mA full-scale output current */
N    DAC_M2=3,           /*!< M2 : ~2mA full-scale output current */
N} DAC_CurrentModeDef;
N#endif
N
N
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
Nvoid DAC_DeInit(DAC_Struct* DACx);
N///@}
N
N///@{  
Nvoid DAC_Cmd(DAC_Struct* DACx, FunctionalState NewState);
NDRV_Return DAC_GetDACState(DAC_Struct* DACx);
N///@}
N
N///@{  
N#if defined(MG32_1ST)
X#if 1L
Nvoid DAC_CurrentMode_Select(DAC_Struct* DACx, DAC_CurrentModeDef OutCurr);
N#endif
N#if defined(MG32_3RD)
X#if 0L
Svoid DAC_OutputBuffer_Cmd(DAC_Struct* DACx, FunctionalState NewState);
N#endif
N///@}
N
N///@{  
Nuint16_t DAC_GetDAT0(DAC_Struct* DACx);
Nvoid DAC_SetDAT0(DAC_Struct* DACx,uint16_t dat);
Nuint16_t DAC_GetOutput(DAC_Struct* DACx);
N///@}
N
N///@{  
Nvoid DAC_TriggerSource_Select(DAC_Struct* DACx, DAC_TriggerSourceDef DACTrgSel);
Nvoid DAC_TriggerEdge_Select(DAC_Struct* DACx, DAC_TriggerEdgeDef DACEdgeSel);
N///@}
N
N///@{  
Nvoid DAC_DataAlignment_Select(DAC_Struct* DACx, DAC_DataAlignModeDef AlignMode);
Nvoid DAC_DataResolution_Select(DAC_Struct* DACx, DAC_ResolutionDef ResolutionData);
N///@}
N
N///@{  
Nvoid DAC_IT_Config(DAC_Struct* DACx, uint32_t DAC_ITSrc, FunctionalState NewState);
Nvoid DAC_ITEA_Cmd(DAC_Struct* DACx, FunctionalState NewState);
NDRV_Return DAC_GetSingleFlagStatus(DAC_Struct* DACx, uint32_t DAC_ITSrc);
Nuint32_t DAC_GetAllFlagStatus(DAC_Struct* DACx);
Nvoid DAC_ClearFlag(DAC_Struct* DACx, uint32_t DAC_ITSrc);
N///@}
N
N///@{  
Nvoid DAC_DMA_Cmd(DAC_Struct* DACx, FunctionalState NewState);
N
N///@}
N
N#endif
N#endif
L 62 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_DRV.h" 2
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S#include "MG32x02z_APX_DRV.h"
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 69 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_GPL_Init.h" 2
N#include "MG32x02z_GPL.H"
N
N
N
Nvoid GPL_Init(void);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 58 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_MEM
N    #include "MG32x02z_MEM_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_MEM_Init.h" 1
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_MEM_Init.h
N *
N * @brief       The MEM Init C file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2017/07/07
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N * 
N ******************************************************************************* 
N * @par Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N
N
N
N#ifndef __MG32x02z_MEM_INIT_H
N#define __MG32x02z_MEM_INIT_H
N#define __MG32x02z_MEM_INIT_H_VER                          0.01     /*!< File Version */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include "MG32x02z_DRV.h"
N#include "MG32x02z_MEM.H"
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N//  <O0> FCLK Frequnce(unit:HZ).<1-50000000>
N//  <o2.12..13> LATENCY: Flash Latency
N//    <i> Default: 1 wait states
N//    <0=> 0 wait states
N//    <1=> 1 wait states
N//    <2=> 2 wait states
N//  <o4.8..15> IAP memory size(unit:KByte).
N//    <i> Default value is loaded from CFG OR after Warm reset.
N//  <q5> Lock IAP memory size MEM_IAP_SIZE register access.
N//    <i>  Default value is loaded from CFG OR only after Cold reset.
N//  <q6> Flash automatic power down on Low speed.
N//    <i> Default value is loaded from CFG OR after Warm reset.
N//  <q2.2> CPU hold control under flash memory access
N//    <i> Only using on Boot from SRAM Mode.
N//  <q7> Disable Flash data access error HardFault.
N//    <i> Default: 0 Enable
N//  <e1.0> Memory controller interrupt all.
N//    <q1.1> Flash end of processing interrupt.
N//    <q1.4> code execution illegal address error detection interrupt.
N//    <q1.5> Flash write protect error detection interrupt.
N//    <q1.6> Flash read protect error detection interrupt.
N//  </e>
N//  <q1.20> Code execution illegal address detection reset.
N//  <q1.21> Flash write protect error detection reset.
N//  <q1.22> Flash read protect error detection reset.
N//*** <<< end of configuration section >>> ***
N#define     MEM_Config0_FCLK         24000000
N#define     MEM_Config0_INT          0x00000000
N#define     MEM_Config0_CR0          0x00000002
N#define     MEM_Config0_CR1          0x00000000
N#define     MEM_Config0_IAPSZ        0x00001000
N#define     MEM_Config0_LSFAPD       0
N#define     MEM_Config0_IAPSZ_Lock   0
N#define     MEM_Config0_HardFault    0
N
N
N
Nvoid MEM_Init(void);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 62 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_EMB
N    #include "MG32x02z_EMB_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_EMB_Init.h" 1
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_EMB_Init.h
N *
N * @brief       MG32x02z EMB Initial header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2016/04/11
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N */ 
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N//<e1.0> EMB Initial Enable
N//  <o0.0..3> EMB Mode Select
N//                                <0=> No Address
N//                                <1=> No Ext. Latch, 16Bit Address 
N//                                <2=> 1 Address Phase, 30Bit Address 
N//                                <3=> 1 Address Phase, 24Bit Address 
N//                                <4=> 2 Address Phase, 30Bit Address 
N//  <q4.3> Synchronous transaction enable
N//  <q5.3> CLK Output Inverse Enable
N//  <o4.16..17> EMB CE signal mode select. <0=>CE
N//                                         <1=>ALE
N//                                         <2=>ALE2
N//  <e5.16> CE Output SoftWare Control Enable
N//    <o5.17> CE Output Initial <0=> Logic-Low
N//                              <1=> Logic-High
N//  </e>
N//  <q5.0> CE Output Inverse Enable
N//  <o5.28..29> OE Output Signal Select <0=>OE
N//                                      <1=>TM10_CKO 
N//                                      <2=>TM16_CKO 
N//                                      <3=>TM20_CKO 
N//  <o4.26> OE Control timing Select <0=>Toggle
N//                                   <1=>Drive Low
N//  <o5.30..31> WE Output Signal Select <0=>WE
N//                                      <1=>TM10_CKO 
N//                                      <2=>TM16_CKO 
N//                                      <3=>TM20_CKO 
N//  <e4.1> Write Enable
N//  <o4.27> WE Control timing Select <0=>Toggle
N//                                   <1=>Drive Low
N//  </e>
N//  <o4.24> EMB MALE2 signal mode select. <0=>ALE2
N//                                        <1=>ALE
N//  <e5.18> ALE Output SoftWare Control Enable
N//    <o5.19> ALE Output Initial <0=> Logic-Low
N//                               <1=> Logic-High
N//  </e>
N//  <q5.1> ALE Output Inverse Enable 
N//  <e5.20> ALE2 Output SoftWare Control Enable
N//    <o5.21> ALE2 Output Initial <0=> Logic-Low
N//                                <1=> Logic-High
N//  </e>
N//  <q5.2> ALE2 Output Inverse Enable 
N//  <e5.22> BW0 Output SoftWare Control Enable
N//    <o5.23> BW0 Output Initial <0=> Logic-Low
N//                               <1=> Logic-High
N//  </e>
N//  <e5.24> BW1 Output SoftWare Control Enable
N//    <o5.25> BW1 Output Initial <0=> Logic-Low
N//                               <1=> Logic-High
N//  </e>
N//  <q5.8> Enable Address Reverse, 0 to 31 change to 31 to 0
N//  <e2.0> Interrupt Enable
N//    <q2.2> Write-protect error Interrupt
N//  </e>
N//  <q4.31> DMA Enable
N//  <o3.4..6> EMB_CK_PSC clock Divider 
N//                                <0=> DIV1 : CK_EMB Divided by 1
N//                                <1=> DIV2 : CK_EMB Divided by 2
N//                                <2=> DIV4 : CK_EMB Divided by 4
N//                                <3=> DIV8 : CK_EMB Divided by 8
N//                                <4=> DIV16 : CK_EMB Divided by 16
N//                                <5=> DIV32 : CK_EMB Divided by 32
N//                                <6=> DIV64 : CK_EMB Divided by 64
N//                                <7=> DIV128 : CK_EMB Divided by 128
N//  <o6.0..3> Address Setup Time (unit:MCLK) <0-1>
N//  <o6.4..7> Address Pulse width (unit:MCLK) <1-16>
N//  <o6.8..11> Address Hold Time (unit:MCLK) <0-1>
N//  <o6.12..15> Data Setup Time (unit:MCLK) <0-1>
N//  <o6.16..19> Data Pulse width (unit:MCLK) <1-16>
N//  <o6.20..23> Data Hold Time (unit:MCLK) <0-1>
N//</e>
N
N//*** <<< end of configuration section >>> ***
N
N/* Define to prevent recursive inclusion ------------------------------------*/
N#ifndef __MG32x02z_EMB_Init_H
N#define __MG32x02z_EMB_Init_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N
N
N/* Includes -----------------------------------------------------------------*/
N#include "MG32x02z_EMB_DRV.h"
N
N/* Exported types -----------------------------------------------------------*/
N
N/* Exported constants -------------------------------------------------------*/
N#define EMB_Mode_Select         1
N#define EMB_Config_Enable       0x1
N#define EMB_Config_INT          0x0
N#define EMB_Config_CLK          0x0
N#define EMB_Config_CR0          0x0
N#define EMB_Config_CR1          0x000000
N#define EMB_Config_CR2          69649
N
N#define EMB_Mode_NOAddress                     0
N#define EMB_Mode_NoLatch_16BitAddress          1
N#define EMB_Mode_1AddressPhase_30BitAddress    2
N#define EMB_Mode_1AddressPhase_24BitAddress    3
N#define EMB_Mode_2AddressPhase_30BitAddress    4
N#define EMB_Mode_2AddressPhase_24BitAddress    5
N
N/* Exported macro -----------------------------------------------------------*/
N
N/* Exported functions -------------------------------------------------------*/
Nvoid EMB_Initial(void);
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N/******************* (C) COPYRIGHT 2018 Megawin ************ END OF FILE *****/ 
N
N
L 66 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_URT
N    #include "MG32x02z_URT_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_URT_Init.h" 1
N
N
N
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_URT_Init.H
N *
N * @brief       This file is to opition URT baudrate setting.
N *   
N * @par         Project
N *              MG32x02z
N * @version     V1.03
N * @date        2020/05/26
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N *******************************************************************************
N */
N
N#include "MG32x02z_CSC.h"
N#include "MG32x02z_URT.h"
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N
N//<o0> URT Baud-rate calculation middleware select <0=> Dynamical calculation in code <1=> Static calculation by external Excel ( MG_GenWizard_URT.xlsm )
N    //<i> 1. Dynamical calculation in code :  Control by  Dymical calculation Control.
N    //<i> 2. Static calcuation by external Excel : Use MG_GenWizard_URT.xlsm to build a MG32x02z_URT_InitBR.h and place the MG32x02z_URT_InitBR.h into folder that is same MX32x02z_URT_Init.h.
N    #define CONF_URT_INITBR_H_EN      0
N
N//<h>Dynmical calculation Control
N//<i> The control is valid  in URT Baud-rate calculation middleware select is  Dynamical calculation.
N//<e0> Enable URT0 Initial
N    //<o1> URT0 baudrate is (400-6000000)Hz<400-6000000>
N//</e>
N    #define CONF_URT0_INIT_EN         0
N    #define CONF_URT0_INIT_BD         9600
N    
N    #ifndef  URT0_Base
S        #if CONF_URT0_INIT_EN == 1
S            #error MG32x02z_URT_Init.h option error - The device no support URT0
S        #endif
N    #endif
N//<e0> Enable URT1 Initial
N    //<o1> URT1 baudrate is (400-6000000)Hz<400-6000000>
N//</e>
N    #define CONF_URT1_INIT_EN         0
N    #define CONF_URT1_INIT_BD         9600
N    
N    #ifndef  URT1_Base
S        #if CONF_URT1_INIT_EN == 1
S            #error MG32x02z_URT_Init.h option error - The device no support URT1
S        #endif
N    #endif
N//<e0> Enable URT2 Initial
N    //<o1> URT1 baudrate is (400-6000000)Hz<400-6000000>
N//</e>
N    #define CONF_URT2_INIT_EN         0
N    #define CONF_URT2_INIT_BD         9600
N    
N    #ifndef  URT2_Base
S        #if CONF_URT2_INIT_EN == 1
S            #error MG32x02z_URT_Init.h option error - The device no support URT2
S        #endif
N    #endif
N//<e0> Enable URT3 Initial
N    //<o1> URT1 baudrate is (400-6000000)Hz<400-6000000>
N//</e>
N    #define CONF_URT3_INIT_EN         0
N    #define CONF_URT3_INIT_BD         9600
N    
N    #ifndef  URT3_Base
S        #if CONF_URT3_INIT_EN == 1
S            #error MG32x02z_URT_Init.h option error - The device no support URT3
S        #endif
N    #endif
N//</h>
N
N
N//*** <<< end of configuration section >>> ***
N
N
N
N
N
N
N#if CONF_URT_INITBR_H_EN == 1
X#if 0 == 1
S    #include "MG32x02z_URT_InitBR.h"
N#else
N    #include "MG32x02z_CSC_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_CSC_Init.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CSC_Init.h
N *
N * @brief       This file is used to configure CSC setting.
N *              Device : MG32F02A132
N *
N * @par         Project
N *              MG32x02z
N * @version     V0.50
N * @date        2021/03/30 16:02 (H File Generated Date)
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************* 
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N */
N#include "MG32x02z.h"
N#include "MG32x02z_CSC.h"
N#include "MG32x02z_MEM.h"
N#include "MG32x02z_GPIO.H"
N
N
N#ifndef _MG32x02z_CSC_INIT_H
S/*!< _MG32x02z_CSC_INIT_H */ 
S#define _MG32x02z_CSC_INIT_H
S
S
S//*** <<< Use Configuration Wizard in Context Menu >>> ***
S/**
S ******************************************************************************
S *
S * @brief       CSC Initial Configure
S *
S ******************************************************************************
S */
S
S//<h> CSC Initial Configure
S
S//      <o> Enter XOSC Or External Clock Frequency 1~36000000Hz <1-36000000>
S//      <i> When use CK_HS = CK_XOSC or CK_EXT, this space must be entered at the correct frequency.
S//      <i> CK_XOSC = 1~25000000Hz, CK_EXT = 1~36000000Hz
S#define CONF_XOSC_EXTCK_FREQ             12000000    // 1
S
S//      <o.18> Select IHRCO <0=> 12MHz
S//                          <1=> 11.059MHz
S//      <i> IHRCO clock source frequency select.
S#define CONF_CSC_IHRCO_SEL                0x00000000  // 2  [18] IHRCO Select
S
S//          <o.16..17> Select XOSC Gain <0=> Normal Gain For 32 KHz
S//                                      <1=> Medium Gain 4 ~ 25MHz
S//                                      <2=> Lowest Gain For 32 KHz
S//          <i> Xtal oscillator gain select. 
S#define CONF_CSC_XOSC_GN                  0x00010000  // 3  [17:16] XOSC Gain
S
S//      <q.4> Disable MCD(Missing Clock Detector)
S#define CONF_CSC_MCD_DIS                  0x00000010  // 4  [4] MCD Disable
S//      <o.22..23> Select Missing Clock Detection Duration <0=> 125us
S//                                                         <1=> 250us
S//                                                         <2=> 500us
S//                                                         <3=> 1ms
S//      <i> MCD detection duration time select. Large time selection makes slow MCD response. 
S#define CONF_CSC_MCD_SEL                  0x00000000  // 5  [23:22] MCD Duration Select
S
S//      <o.10..11> Select CK_HS Source <0=> CK_IHRCO
S//                                     <1=> CK_XOSC
S//                                     <2=> CK_ILRCO
S//                                     <3=> CK_EXT
S//      <i> When Select CK_HS Source = CK_XOSC, MG32x02z_GPIO_Init.h Wizard PC13 configutaion and PC14 configutaion must disable.
S#define CONF_CSC_HS_SEL                   0x00000000  // 6  [11:10] CK_HS Select
S
S//      <h> Configure PLL
S//          <o.0..1> Select CK_PLLI Divider <0=> CK_HSx/1
S//                                          <1=> CK_HSx/2
S//                                          <2=> CK_HSx/4
S//                                          <3=> CK_HSx/6
S#define CONF_CSC_PLLI_DIV                 0x00000001  // 9  [1:0] PLLI DIV
S//          <o.8> Select CK_PLL Multiplication Factor <0=> CK_PLLIx16
S//                                                    <1=> CK_PLLIx24
S//          <i> CK_PLL output frequency = (CK_PLLI PLL input frequency) * (value)
S#define CONF_CSC_PLL_MUL                  0x00000000  // 10
S//          <o.4..5> Select CK_PLLO Divider <0=> CK_PLL/4
S//                                          <1=> CK_PLL/3
S//                                          <2=> CK_PLL/2
S//                                          <3=> CK_PLL/1
S#define CONF_CSC_PLLO_DIV                 0x00000000  // 12  [5:4] PLLO DIV
S//      </h>
S
S//      <o.14..15> Select CK_MAIN Source <0=> CK_HS
S//                                       <1=> CK_PLLI
S//                                       <2=> CK_PLLO 
S//      <i> When Select CK_MAIN Source = CK_PPLI, the PLL must enable.
S#define CONF_CSC_MAIN_SEL                 0x00000000  // 14  [15:14] CK_MAIN Select
S
S//      <o.8..9> Select CK_LS Source <1=> CK_XOSC
S//                                   <2=> CK_ILRCO
S//                                   <3=> CK_EXT
S//      <i> When Select CK_LS Source = CK_XOSC, MG32x02z_GPIO_Init.h Wizard PC13 configutaion and PC14 configutaion  must disable.
S#define CONF_CSC_LS_SEL                   0x00000200  // 15  [9:8] CK_LS Select
S
S//      <o.16> Select CK_ST Source <0=> HCLK/8
S//                                 <1=> CK_LS/2
S//      <i> System tick timer external clock source select.
S//      <i> This function is valid when CPU_CLKSOURCE is set 0(default).
S#define CONF_CSC_ST_SEL                   0x00000000  // 16  [16] CK_ST Select
S
S/**/
S//      <e.0> IHRCO/PLL Enable or XOSC/EXTCK AFS Pin Disable
S//      <i> The functions enable or disable by C-code checking if this CheckBox unchecked.
S//      <i> The functions enable or disable by following user setting if this CheckBox checked.
S#define CONF_CSC_CKIP_EN                  0x00000000  // 17  [0] 0=C-code auto checking
S
S//            <q.3> IHRCO_EN
S//            <i> IHRCO device enable
S#define CONF_CSC_CR0_IHRCO_EN             0x00000008  // 18  [3] IHRCO_EN
S
S
S//            <q.5> PLL_EN
S//            <i> PLL device enable
S#define CONF_CSC_CR0_PLL_EN               0x00000000  // 19  [5] PLL_EN (CSC_init.c and .h not used)
S
S
S//            <q.31> XOSC_EN
S//            <i> Crystal Oscillator and XIN/XOUT pins enable
S#define CONF_CFG_XOSC_EN                  0x00000000  // 20  [31] XOSC_EN
S
S
S//            <q.31> EXTCK_EN
S//            <i> External clock input and XIN pin enable if CK_EXT was selected in any HS/HS2/LS Mux
S#define CONF_CFG_EXTCK_EN                 0x00000000  // 21  [31] EXTCK pin enable (CSC_init.c and .h not used)
S
S//      </e>
S
S//      <o.16..18> Select APB Prescaler <0x00=> CK_MAIN/1
S//                                      <0x01=> CK_MAIN/2
S//                                      <0x02=> CK_MAIN/4
S//                                      <0x03=> CK_MAIN/8
S//                                      <0x04=> CK_MAIN/16
S//          <i> CK_APB frequency = (CK_MAIN frequency) / (selected Divider Value)
S#define CONF_CSC_APB_DIV                  0x00000000  // 22  [18:16] APB DIV
S
S//      <o.8..11> Select AHB Prescaler <0x00=> CK_APB/1
S//                                     <0x01=> CK_APB/2
S//                                     <0x02=> CK_APB/4
S//                                     <0x03=> CK_APB/8
S//                                     <0x04=> CK_APB/16
S//                                     <0x05=> CK_APB/32
S//                                     <0x06=> CK_APB/64
S//                                     <0x07=> CK_APB/128
S//                                     <0x08=> CK_APB/256
S//                                     <0x09=> CK_APB/512
S//          <i> CK_AHB frequency = (CK_APB frequency) / (selected Divider Value)
S#define CONF_CSC_AHB_DIV                  0x00000000  // 23  [11:8] AHB DIV
S
S//      <o.26..27> Select CK_UT Divider <0x00=> ILRCO/32
S//                                      <0x01=> ILRCO/8
S//                                      <0x02=> ILRCO/16
S//                                      <0x03=> ILRCO/128
S//          <i> CK_UT frequency = (ILRCO frequency) / (selected Divider Value)
S#define CONF_CSC_UT_DIV                   0x00000000  // 24  [27:26] UT DIV
S
S//      <h> Configure Peripheral ON Mode Clock
S//      <i> Peripheral module process clock enable when MCU is running ON mode.
S//          <q.0>  Port A
S//          <i> PA module process clock and register write-access enable.
S#define CONF_CSC_IOPA_EN                  0x00000001  // 30
S//          <q.1>  Port B
S//          <i> PB module process clock and register write-access enable.
S#define CONF_CSC_IOPB_EN                  0x00000002  // 31
S//          <q.2>  Port C
S//          <i> PC module process clock and register write-access enable.
S#define CONF_CSC_IOPC_EN                  0x00000004  // 32
S//          <q.3>  Port D
S//          <i> PD module process clock and register write-access enable.
S#define CONF_CSC_IOPD_EN                  0x00000008  // 33
S//          <q.4>  Port E
S//          <i> PE module process clock and register write-access enable.
S#define CONF_CSC_IOPE_EN                  0x00000010  // 34
S//          <q.8>  GPL
S//          <i> GPL clock source enable.
S#define CONF_CSC_GPL_EN                   0x00000100  // 35
S//          <q.12> EMB
S//          <i> EMB clock source enable.
S#define CONF_CSC_EMB_EN                   0x00001000  // 36
S//          <q.15> DMA
S//          <i> DMA clock source enable.
S#define CONF_CSC_DMA_EN                   0x00008000  // 37
S//          <e.0>  ADC0
S//          <i> ADC clock source enable.
S#define CONF_CSC_ADC0                     0x00000001  // 38
S//              <o.0>  Select ADCx_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> ADC Process clock source select.
S#define CONF_CSC_ADC0_CKS                 0x00000000  // 39
S//          </e>
S//          <e.2>  CMP
S//          <i> CMP clock source enable.
S#define CONF_CSC_CMP_EN                   0x00000004  // 40
S//              <o.4>  Select CMP_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> CMP Process clock source select.
S#define CONF_CSC_CMP_CKS                  0x00000004  // 41
S//          </e>
S//          <e.3>  DAC
S#define CONF_CSC_DAC_EN                   0x00000008  // 42
S//          <i> DAC clock source enable.
S//              <o.5>  Select CMP_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> DAC Process clock source select.
S#define CONF_CSC_DAC_CKS                  0x00000000  // 43
S//          </e>
S//          <q.5>  RTC
S//          <i> RTC clock source enable.
S#define CONF_CSC_RTC_EN                   0x00000020  // 50
S//          <q.6>  IWDT
S//          <i> IWDT clock source enable.
S#define CONF_CSC_IWDT_EN                  0x00000040  // 51
S//          <q.7>  WWDT
S//          <i> WWDT clock source enable.
S#define CONF_CSC_WWDT_EN                  0x00000080  // 52
S//          <e.8>  I2C0
S//          <i> I2C0 clock source enable.
S#define CONF_CSC_I2C0_EN                  0x00000100  // 53
S//              <o.0>  Select I2C0_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_I2C0_CKS                 0x00000000  // 54
S//          </e>
S//          <e.9>  I2C1
S//          <i> I2C1 clock source enable.
S#define CONF_CSC_I2C1_EN                  0x00000200  // 55
S//              <o.2>  Select I2C0_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_I2C1_CKS                 0x00000000  // 56
S//          </e>
S//          <e.12> SPI0
S//          <i> SPI0 clock source enable.
S#define CONF_CSC_SPI0_EN                  0x00001000  // 57
S//              <o.8>  Select SPI0_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_SPI0_CKS                 0x00000000  // 58
S//          </e>
S//          <e.16> URT0
S//          <i> URT0 clock source enable.
S#define CONF_CSC_URT0_EN                  0x00010000  // 59
S//              <o.16> Select URT0_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_URT0_CKS                 0x00000000  // 60
S//          </e>
S//          <e.17> URT1
S//          <i> URT1 clock source enable.
S#define CONF_CSC_URT1_EN                  0x00020000  // 61
S//              <o.18> Select URT1_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_URT1_CKS                 0x00000000  // 62
S//          </e>
S//          <e.18> URT2
S//          <i> URT2 clock source enable.
S#define CONF_CSC_URT2_EN                  0x00040000  // 63
S//              <o.20> Select URT2_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_URT2_CKS                 0x00000000  // 64
S//          </e>
S//          <e.19> URT3
S//          <i> URT3 clock source enable.
S#define CONF_CSC_URT3_EN                  0x00080000  // 65
S//              <o.22> Select URT3_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_URT3_CKS                 0x00000000  // 66
S//          </e>
S//          <e.0>  TM00
S//          <i> TM00 clock source enable.
S#define CONF_CSC_TM00_EN                  0x00000001  // 79
S//              <o.0>  Select TM00_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM00_CKS                 0x00000000  // 80
S//          </e>
S//          <e.1>  TM01
S//          <i> TM01 clock source enable.
S#define CONF_CSC_TM01_EN                  0x00000002  // 81
S//              <o.2>  Select TM01_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM01_CKS                 0x00000000  // 82
S//          </e>
S//          <e.4>  TM10
S//          <i> TM10 clock source enable.
S#define CONF_CSC_TM10_EN                  0x00000010  // 83
S//              <o.8>  Select TM10_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM10_CKS                 0x00000000  // 84
S//          </e>
S//          <e.7>  TM16
S//          <i> TM16 clock source enable.
S#define CONF_CSC_TM16_EN                  0x00000080  // 85
S//              <o.14> Select TM16_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM16_CKS                 0x00000000  // 86
S//          </e>
S//          <e.8>  TM20
S//          <i> TM20 clock source enable.
S#define CONF_CSC_TM20_EN                  0x00000100  // 87
S//              <o.16> Select TM20_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM20_CKS                 0x00000000  // 88
S//          </e>
S//          <e.11>  TM26
S//          <i> TM20 clock source enable.
S#define CONF_CSC_TM26_EN                  0x00000800  // 89
S//              <o.22> Select TM26_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM26_CKS                 0x00000000  // 90
S//          </e>
S//          <e.15> TM36
S//          <i> TM36 clock source enable.
S#define CONF_CSC_TM36_EN                  0x00008000  // 91
S//              <o.30> Select TM36_PR Source <0=> CK_APB <1=> CK_AHB
S//              <i> Process clock source select.
S#define CONF_CSC_TM36_CKS                 0x00000000  // 92
S//          </e>
S//      </h>
S
S//      <h> Configure Peripheral SLEEP Mode Clock
S//      <i> Peripheral module process clock enable when MCU is entering SLEEP mode.
S//          <q.0>  ADC0
S#define CONF_CSC_SLP_ADC0                 0x00000000  // 100
S//          <q.2>  CMP
S#define CONF_CSC_SLP_CMP                  0x00000000  // 101
S//          <q.3>  DAC
S#define CONF_CSC_SLP_DAC                  0x00000000  // 102
S//          <q.5>  RTC
S#define CONF_CSC_SLP_RTC                  0x00000000  // 103
S//          <q.6>  IWDT
S#define CONF_CSC_SLP_IWDT                 0x00000000  // 104
S//          <q.7>  WWDT
S#define CONF_CSC_SLP_WWDT                 0x00000000  // 105
S//          <q.8>  I2C0
S#define CONF_CSC_SLP_I2C0                 0x00000000  // 106
S//          <q.9>  I2C1
S#define CONF_CSC_SLP_I2C1                 0x00000000  // 107
S//          <q.12> SPI0
S#define CONF_CSC_SLP_SPI0                 0x00000000  // 108
S//          <q.16> URT0
S#define CONF_CSC_SLP_URT0                 0x00000000  // 109
S//          <q.17> URT1
S#define CONF_CSC_SLP_URT1                 0x00000000  // 110
S//          <q.18> URT2
S#define CONF_CSC_SLP_URT2                 0x00000000  // 111
S//          <q.20> URT3
S#define CONF_CSC_SLP_URT3                 0x00000000  // 112
S//          <q.0>  TM00
S#define CONF_CSC_SLP_TM00                 0x00000000  // 119
S//          <q.1>  TM01
S#define CONF_CSC_SLP_TM01                 0x00000000  // 120
S//          <q.4>  TM10
S#define CONF_CSC_SLP_TM10                 0x00000000  // 121
S//          <q.7>  TM16
S#define CONF_CSC_SLP_TM16                 0x00000000  // 122
S//          <q.8>  TM20
S#define CONF_CSC_SLP_TM20                 0x00000000  // 123
S//          <q.11> TM26
S#define CONF_CSC_SLP_TM26                 0x00000000  // 124
S//          <q.15> TM36
S#define CONF_CSC_SLP_TM36                 0x00000000  // 125
S//          <q.29> DMA
S#define CONF_CSC_SLP_DMA                  0x00000000  // 128
S//          <q.30> EMB
S#define CONF_CSC_SLP_EMB                  0x00000000  // 129
S//      </h>
S
S//      <h> Configure Peripheral STOP Mode Clock
S//      <i> Peripheral module process clock enable when MCU is entering STOP mode.
S//          <q.5>  RTC
S#define CONF_CSC_STP_RTC                  0x00000000  // 140
S//          <q.6>  IWDT
S#define CONF_CSC_STP_IWDT                 0x00000000  // 141
S//      </h>
S
S//      <e.0> Enable ICKO
S//      <i> Internal clock source output enable.
S#define CONF_CSC_CKO_EN                   0x00000000  // 150
S//          <o.2..3> Select ICKO Divider <0=> ICK/1
S//                                       <1=> ICK/2
S//                                       <2=> ICK/4
S//                                       <3=> ICK/8
S//          <i> Internal clock output divider select.
S#define CONF_CSC_CKO_DIV                  0x00000008  // 151
S//          <o.4..7> Select ICKO <0=> CK_MAIN
S//                               <1=> CK_AHB
S//                               <2=> CK_APB
S//                               <3=> CK_HS
S//                               <4=> CK_LS
S//                               <5=> CK_XOSC
S//          <i> Internal clock output source select.
S#define CONF_CSC_CKO_SEL                  0x00000000  // 152
S//      </e>
S//</h>
S
S//*** <<< end of configuration section >>>    ***
S
S// CSC_INT bit 0 ~ 31
S#define CONF_CSC_IEA                      0x00000000          // 000, 000
S#define CONF_CSC_XOSC_IE                  0x00000000          // 001, 001
S#define CONF_CSC_ILRCO_IE                 0x00000000          // 004, 004
S#define CONF_CSC_IHRCO_IE                 0x00000000          // 005, 005
S#define CONF_CSC_PLL_IE                   0x00000000          // 006, 006
S#define CONF_CSC_MCD_IE                   0x00000000          // 007, 007
S                                         
S#define CONF_CSC_PLL_MDS                  0x00000001 /*MG32_3RD must be retention and value is 0x00000001 */
S                                         
S#define CONF_CSC_STA              0X00000000
S#define CONF_CSC_INT              (CONF_CSC_IEA | CONF_CSC_XOSC_IE | CONF_CSC_ILRCO_IE | CONF_CSC_IHRCO_IE | CONF_CSC_PLL_IE | CONF_CSC_MCD_IE)
S#define CONF_CSC_KEY              0x00000000
S
S#define CONF_CSC_PLL              (CONF_CSC_PLL_MUL | CONF_CSC_XOSC_GN)
S#define CONF_CSC_CR0              (CONF_CSC_MCD_DIS | CONF_CSC_LS_SEL | CONF_CSC_HS_SEL | CONF_CSC_MAIN_SEL | CONF_CSC_ST_SEL | CONF_CSC_IHRCO_SEL | CONF_CSC_MCD_SEL)
S#define CONF_CSC_DIV              (CONF_CSC_PLLI_DIV | CONF_CSC_PLLO_DIV | CONF_CSC_AHB_DIV | CONF_CSC_APB_DIV | CONF_CSC_UT_DIV)
S
S#define CONF_CSC_CKO              (CONF_CSC_CKO_EN | CONF_CSC_CKO_DIV | CONF_CSC_CKO_SEL)
S#define CONF_CSC_AHB              (CONF_CSC_IOPA_EN | CONF_CSC_IOPB_EN | CONF_CSC_IOPC_EN | CONF_CSC_IOPD_EN | CONF_CSC_IOPE_EN | CONF_CSC_GPL_EN | CONF_CSC_EMB_EN | CONF_CSC_DMA_EN)
S#define CONF_CSC_APB0             (CONF_CSC_ADC0 | CONF_CSC_CMP_EN | CONF_CSC_DAC_EN | CONF_CSC_RTC_EN | CONF_CSC_IWDT_EN | CONF_CSC_WWDT_EN | CONF_CSC_I2C0_EN | CONF_CSC_I2C1_EN | CONF_CSC_SPI0_EN | CONF_CSC_URT0_EN | CONF_CSC_URT1_EN | CONF_CSC_URT2_EN | CONF_CSC_URT3_EN)
S#define CONF_CSC_APB1             (CONF_CSC_TM00_EN | CONF_CSC_TM01_EN | CONF_CSC_TM10_EN | CONF_CSC_TM16_EN | CONF_CSC_TM20_EN | CONF_CSC_TM26_EN | CONF_CSC_TM36_EN)
S#define CONF_CSC_SLP0             (CONF_CSC_SLP_ADC0 | CONF_CSC_SLP_CMP | CONF_CSC_SLP_DAC | CONF_CSC_SLP_RTC | CONF_CSC_SLP_IWDT | CONF_CSC_SLP_WWDT | CONF_CSC_SLP_I2C0 | CONF_CSC_SLP_I2C1 | CONF_CSC_SLP_SPI0 | CONF_CSC_SLP_URT0 | CONF_CSC_SLP_URT1 | CONF_CSC_SLP_URT2 | CONF_CSC_SLP_URT3)
S#define CONF_CSC_SLP1             (CONF_CSC_SLP_TM00 | CONF_CSC_SLP_TM01 | CONF_CSC_SLP_TM10 | CONF_CSC_SLP_TM16 | CONF_CSC_SLP_TM20 | CONF_CSC_SLP_TM26 | CONF_CSC_SLP_TM36 | CONF_CSC_SLP_EMB )
S#define CONF_CSC_STP0             (CONF_CSC_STP_RTC | CONF_CSC_STP_IWDT)
S#define CONF_CSC_STP1             0x00000000
S#define CONF_CSC_CSK0             (CONF_CSC_ADC0_CKS |  CONF_CSC_CMP_CKS |  CONF_CSC_DAC_CKS)
S#define CONF_CSC_CSK1             (CONF_CSC_I2C0_CKS | CONF_CSC_I2C1_CKS | CONF_CSC_SPI0_CKS | CONF_CSC_URT0_CKS | CONF_CSC_URT1_CKS | CONF_CSC_URT2_CKS | CONF_CSC_URT3_CKS)
S#define CONF_CSC_CSK2             (CONF_CSC_TM00_CKS | CONF_CSC_TM01_CKS | CONF_CSC_TM10_CKS | CONF_CSC_TM16_CKS | CONF_CSC_TM20_CKS | CONF_CSC_TM26_CKS | CONF_CSC_TM36_CKS)
S
S    /* Calculate CK_xxx Frequency */
S// CONF_CK_HS_FREQ
S#if CONF_CSC_HS_SEL == 0x00000000
S    #if CONF_CSC_IHRCO_SEL == 0x00000000
S        #define CONF_CK_HS_FREQ   12000000
S    #else
S        #define CONF_CK_HS_FREQ   11059200
S    #endif
S#elif CONF_CSC_HS_SEL == 0x00000400
S    #define CONF_CK_HS_FREQ   CONF_XOSC_EXTCK_FREQ
S#elif CONF_CSC_HS_SEL == 0x00000800
S    #define CONF_CK_HS_FREQ   32000
S#elif CONF_CSC_HS_SEL == 0x00000C00
S    #define CONF_CK_HS_FREQ   CONF_XOSC_EXTCK_FREQ
S#endif
S
S// CONF_PLLI_DIV
S#if CONF_CSC_PLLI_DIV == 0x00000000
S    #define CONF_PLLI_DIV     1
S#elif CONF_CSC_PLLI_DIV == 0x00000001
S    #define CONF_PLLI_DIV     2
S#elif CONF_CSC_PLLI_DIV == 0x00000002
S    #define CONF_PLLI_DIV     4
S#elif CONF_CSC_PLLI_DIV == 0x00000003
S    #define CONF_PLLI_DIV     6
S#endif
S
S// CONF_PLL_MUL
S    #if CONF_CSC_PLL_MUL == 0x00000000
S        #define CONF_CSC_PLL_MUL_VAL      16
S    #elif CONF_CSC_PLL_MUL == 0x00000100
S        #define CONF_CSC_PLL_MUL_VAL      24
S    #endif
S// CONF_PLLO_DIV
S#if CONF_CSC_PLLO_DIV == 0x00000000
S    #define CONF_PLLO_DIV     4
S#elif CONF_CSC_PLLO_DIV == 0x00000010
S    #define CONF_PLLO_DIV     3
S#elif CONF_CSC_PLLO_DIV == 0x00000020
S    #define CONF_PLLO_DIV     2
S#elif CONF_CSC_PLLO_DIV == 0x00000030
S    #define CONF_PLLO_DIV     1
S#endif
S// CONF_CK_MAIN_FREQ
S#if CONF_CSC_MAIN_SEL == 0x00000000
S    #define CONF_CK_MAIN_FREQ     CONF_CK_HS_FREQ
S// When CK_AMIN = CK_PLLI
S#elif CONF_CSC_MAIN_SEL == 0x00004000
S    // When CSC_PLLI_SEL == CK_HS
S    #if CONF_CSC_PLLI_SEL == 0x00000000
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS_FREQ/CONF_PLLI_DIV
S    // When CSC_PLLI_SEL == CK_HS2
S    #else
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS2_FREQ/CONF_PLLI_DIV
S    #endif
S
S// When CK_MAIN == CK_PLLO 
S#elif CONF_CSC_MAIN_SEL == 0x00008000
S    // When CSC_PLLI_SEL == CK_HS
S    #if CONF_CSC_PLLI_SEL == 0x00000000
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS_FREQ /CONF_PLLI_DIV *CONF_CSC_PLL_MUL_VAL /CONF_PLLO_DIV
S    // When CSC_PLLI_SEL == CK_HS2
S    #else
S        #define CONF_CK_MAIN_FREQ     CONF_CK_HS2_FREQ /CONF_PLLI_DIV *CONF_CSC_PLL_MUL_VAL /CONF_PLLO_DIV
S    #endif
S#endif
S
S// CONF_CK_APB_FREQ
S#if CONF_CSC_APB_DIV == 0x00000000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /1
S#elif CONF_CSC_APB_DIV == 0x00010000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /2
S#elif CONF_CSC_APB_DIV == 0x00020000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /4
S#elif CONF_CSC_APB_DIV == 0x00030000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /8
S#elif CONF_CSC_APB_DIV == 0x00040000
S    #define CONF_CK_APB_FREQ      CONF_CK_MAIN_FREQ /16
S#endif
S
S// CONF_CK_AHB_FREQ
S#if CONF_CSC_AHB_DIV == 0x00000000
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /1
S#elif CONF_CSC_AHB_DIV == 0x00000100
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /2
S#elif CONF_CSC_AHB_DIV == 0x00000200
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /4
S#elif CONF_CSC_AHB_DIV == 0x00000300
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /8
S#elif CONF_CSC_AHB_DIV == 0x00000400
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /16
S#elif CONF_CSC_AHB_DIV == 0x00000500
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /32
S#elif CONF_CSC_AHB_DIV == 0x00000600
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /64
S#elif CONF_CSC_AHB_DIV == 0x00000700
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /128
S#elif CONF_CSC_AHB_DIV == 0x00000800
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /256
S#elif CONF_CSC_AHB_DIV == 0x00000900
S    #define CONF_CK_AHB_FREQ      CONF_CK_APB_FREQ /512
S#endif
S
S// Flash wait state setting
S#if CONF_CK_AHB_FREQ <= 25000000
S    #define CONF_FLASH_WAIT_STATE    MEM_CR0_FWAIT_zero_w
S#elif CONF_CK_AHB_FREQ <= 50000000
S    #define CONF_FLASH_WAIT_STATE    MEM_CR0_FWAIT_one_w
S#elif CONF_CK_AHB_FREQ > 50000000
S    #define CONF_FLASH_WAIT_STATE    MEM_CR0_FWAIT_two_w
S#endif
S
S/**
S ******************************************************************************
S *
S * @struct      CONF_CSC_InitConfig[]
S *              CSC initial configuration array
S *
S ******************************************************************************
S */
Sstatic const unsigned int CSC_InitConfig[] =
S{
S    CONF_CSC_STA,     /* CSC_STA 0 not use */
S    CONF_CSC_INT,     /* CSC_INT 1 not use */
S    CONF_CSC_PLL,     /* CSC_PLL 2 */
S    CONF_CSC_KEY,     /* CSC_KEY 3 not use */
S    CONF_CSC_CR0,     /* CSC_CR0 4 */
S    CONF_CSC_DIV,     /* CSC_DIV 5 */
S    CONF_CSC_CKO,     /* CSC_CKO 6 */
S    CONF_CSC_AHB,     /* CSC_AHB 7 */
S    CONF_CSC_APB0,    /* CSC_APB0 8 */
S    CONF_CSC_APB1,    /* CSC_APB1 9 */
S    CONF_CSC_SLP0,    /* CSC_SLP0 10 */
S    CONF_CSC_SLP1,    /* CSC_SLP1 11 */
S    CONF_CSC_STP0,    /* CSC_STP0 12 */
S    CONF_CSC_STP1,    /* CSC_STP1 13 */
S    CONF_CSC_CSK0,    /* CSC_CSK0 14 */
S    CONF_CSC_CSK1,    /* CSC_CSK1 15 */
S    CONF_CSC_CSK2,    /* CSC_CSK2 16 */
S    0x000000000,      /* CSC_OTHER 17 . bit0: 0: extern clock, 1: crystal clock */
S    CONF_XOSC_EXTCK_FREQ,    /* XOSC_EXTCLK_FREQ 18 */
S    CONF_FLASH_WAIT_STATE,   /* CK_APB_FREQ 19 */
S};
S
S
S/**
S * @name    Function announce
S *   
S */
S///@{  
Svoid CSC_Init (uint32_t* CSC_CFG);
S///@}
S
S
N#endif  // _MG32x02z_CSC_INIT_H
N
L 104 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_URT_Init.h" 2
N
N
N    #define CONF_URT_Freq_AHB         CONF_CK_AHB_FREQ
N    #define CONF_URT_Freq_APB         CONF_CK_APB_FREQ
N    
N    
N    #define URT0_INIT_CKS_MASK        0x00010000
N    #define URT1_INIT_CKS_MASK        0x00040000
N    #define URT2_INIT_CKS_MASK        0x00100000
N    #define URT3_INIT_CKS_MASK        0x00400000
N    
N    
N    #ifndef _MG32x02z_CSC_INIT_H
S        #error No MG32x02z_CSC_Init.h file , please option MG32x02z_ChipInit_Wizard in Manage Run Time Environment.
N    #else
N        #if CONF_CSC_URT0_CKS  == 0 
X        #if 0x00000000  == 0 
N            #define CONF_URT0_Freq         CONF_URT_Freq_APB
N        #else
S            #define CONF_URT0_Freq         CONF_URT_Freq_AHB
N        #endif
N        
N        #if CONF_CSC_URT1_CKS  == 0
X        #if 0x00000000  == 0
N            #define CONF_URT1_Freq         CONF_URT_Freq_APB
N        #else
S            #define CONF_URT1_Freq         CONF_URT_Freq_AHB
N        #endif
N        
N        #if CONF_CSC_URT2_CKS  == 0 
X        #if 0x00000000  == 0 
N            #define CONF_URT2_Freq         CONF_URT_Freq_APB
N        #else
S            #define CONF_URT2_Freq         CONF_URT_Freq_AHB
N        #endif
N        
N        #if CONF_CSC_URT3_CKS  == 0 
X        #if 0x00000000  == 0 
N            #define CONF_URT3_Freq         CONF_URT_Freq_APB
N        #else
S            #define CONF_URT3_Freq         CONF_URT_Freq_AHB
N        #endif
N    #endif
N#endif
N
N
N
N#define URT_INIT_WIZARD_SUCCESS    0
N#define URT_INIT_WIZARD_FAILURE    1
N
N
N
N
N/**
N * @name	Function announce
N *   		
N */
N///@{ 
N
Nuint8_t URT_Init(void);
N
N///@}
N
N
L 70 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_TM
N    #include "MG32x02z_TM_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_TM_Init.h" 1
N/**
N *******************************************************************************
N * @file        MG32x02z_TM_Init.h
N *
N * @brief       The TM initial code h file
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.01
N * @date        2020/08/25
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************* 
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N#include "MG32x02z.h"
N#include "MG32x02z_TM.h"
N#include "MG32x02z_MEM.h"
N
N
N#ifndef _MG32x02z_TM_INIT_H
N/*!< _MG32x02z_TM_INIT_H */ 
N#define _MG32x02z_TM_INIT_H
N
N#include "MG32x02z_TM_DRV.h"
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N//  <e0.0> Configure TM00 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM00_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR)
N//              <o4.8..10> ITR from <0=> ITR0 : TM10_TRGO <1=> ITR1 : TM20_TRGO <2=> ITR2 : CMP0_OUT <3=> ITR3 : CMP2_OUT <4=> ITR4 : INT_PA <5=> ITR5 : INT_PB <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode (Up count) <0=> Cascade : 8-bit counter with 8-bit prescaler  Mode <1=> Separate : Separated two 8-bit counters Mode <2=> Full-Counter : 16-bit counter Mode
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut config
N//          <o3.2..3> TM00 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle 
N//      </e>
N//      <h> Trigger Input/Output config (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM01_RST (Main Timer Reset) <1=> EN : TM01_EN (Main Timer Enable) <2=> UEV : TM01_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM01_TOF (Main Timer overflow) <5=> EN2 : TM01_EN2 (Timer-2 Enable) <6=> TOF2 :TM01_TOF2 (Timer-2 overflow)
N//                                                              <8=> UEV2 : TM01_UEV2 (Timer-2 Update event) <9=> SW : TM01_TRGO_SW (software control bit) <14=> TRGI : TM01_TRGI (internal TRGI signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-255>
N//      <o6> Prescaler counter range <0-255>
N//  </e>
N#define CONF_TM00_ENABLE_OPTION 0x00000000  
N#define CONF_TM00_CLK           0x00000000  
N#define CONF_TM00_CR0           0x00000000
N#define CONF_TM00_CKO           0x00000008
N#define CONF_TM00_TRG           0x00000000
N#define CONF_TM00_ARR           120
N#define CONF_TM00_PSARR         10
N
N//  <e0.0> Configure TM01 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM01_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR)
N//              <o4.8..10> ITR from <0=> ITR0 : TM16_TRGO <1=> ITR1 : TM26_TRGO <2=> ITR2 : CMP1_OUT <3=> ITR3 : CMP3_OUT <4=> ITR4 : INT_PC <5=> ITR5 : INT_PD <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode (Up count) <0=> Cascade : 8-bit counter with 8-bit prescaler  Mode <1=> Separate : Separated two 8-bit counters Mode <2=> Full-Counter : 16-bit counter Mode
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut config
N//          <o3.2..3> TM01 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle 
N//      </e>
N//      <h> Trigger Input/Output config (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM01_RST (Main Timer Reset) <1=> EN : TM01_EN (Main Timer Enable) <2=> UEV : TM01_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM01_TOF (Main Timer overflow) <5=> EN2 : TM01_EN2 (Timer-2 Enable) <6=> TOF2 :TM01_TOF2 (Timer-2 overflow)
N//                                                              <8=> UEV2 : TM01_UEV2 (Timer-2 Update event) <9=> SW : TM01_TRGO_SW (software control bit) <14=> TRGI : TM01_TRGI (internal TRGI signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-255>
N//      <o6> Prescaler counter range <0-255>
N//  </e>
N#define CONF_TM01_ENABLE_OPTION 0x00000000  
N#define CONF_TM01_CLK           0x00000000  
N#define CONF_TM01_CR0           0x00000000
N#define CONF_TM01_CKO           0x00000008
N#define CONF_TM01_TRG           0x00000000
N#define CONF_TM01_ARR           120
N#define CONF_TM01_PSARR         10
N
N//  <e0.0> Configure TM10 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM10_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR)
N//              <o4.8..10> ITR from <0=> ITR0 : TM00_TRGO <1=> ITR1 : TM20_TRGO <2=> ITR2 : CMP0_OUT <3=> ITR3 : CMP2_OUT <4=> ITR4 : INT_PA <5=> ITR5 : INT_PB <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode (Up count) <0=> Cascade : 16-bit counter with 16-bit prescaler  Mode <1=> Separate : Separated two 16-bit counters Mode <2=> Full-Counter : 32-bit counter Mode
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut config
N//          <o3.2..3> TM10 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle 
N//      </e>
N//      <h> Trigger Input/Output config (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM10_RST (Main Timer Reset) <1=> EN : TM10_EN (Main Timer Enable) <2=> UEV : TM10_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM10_TOF (Main Timer overflow) <5=> EN2 : TM10_EN2 (Timer-2 Enable) <6=> TOF2 :TM10_TOF2 (Timer-2 overflow)
N//                                                              <8=> UEV2 : TM10_UEV2 (Timer-2 Update event) <9=> SW : TM10_TRGO_SW (software control bit) <14=> TRGI : TM10_TRGI (internal TRGI signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-65535>
N//      <o6> Prescaler counter range <0-65535>
N//  </e>
N#define CONF_TM10_ENABLE_OPTION 0x00000000  
N#define CONF_TM10_CLK           0x00000000  
N#define CONF_TM10_CR0           0x00000000
N#define CONF_TM10_CKO           0x00000008
N#define CONF_TM10_TRG           0x00000000
N#define CONF_TM10_ARR           120
N#define CONF_TM10_PSARR         10
N
N//  <e0.0> Configure TM16 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM16_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR)
N//              <o4.8..10> ITR from <0=> ITR0 : TM01_TRGO <1=> ITR1 : TM26_TRGO <2=> ITR2 : CMP1_OUT <3=> ITR3 : CMP3_OUT <4=> ITR4 : INT_PC <5=> ITR5 : INT_PD <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode <0=> Cascade : 16-bit counter with 16-bit prescaler  Mode <1=> Separate : Separated two 16-bit counters Mode <2=> Full-Counter : 32-bit counter Mode
N//          <o2.6..7> Up or down count <0=> Up count (Main & Prescaler counter) <3=> Down count (Main & Prescaler counter)
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut config
N//          <o3.2..3> TM16 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle 
N//      </e>
N//      <h> Trigger Input/Output config (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM16_RST (Main Timer Reset) <1=> EN : TM16_EN (Main Timer Enable) <2=> UEV : TM16_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM16_TOF (Main Timer overflow) <4=> TUF : TM16_TUF (Main Timer underflow) 
N//                                                              <5=> EN2 : TM16_EN2 (Timer-2 Enable) <6=> TOF2 :TM16_TOF2 (Timer-2 overflow)
N//                                                              <7=> DIR : TM16_DIR (Main Timer direction event)
N//                                                              <8=> UEV2 : TM16_UEV2 (Timer-2 Update event) <9=> SW : TM16_TRGO_SW (software control bit) <14=> TRGI : TM16_TRGI (internal TRGI signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-65535>
N//      <o6> Prescaler counter range <0-65535>
N//  </e>
N#define CONF_TM16_ENABLE_OPTION 0x00000000  
N#define CONF_TM16_CLK           0x00000000  
N#define CONF_TM16_CR0           0x00000000
N#define CONF_TM16_CKO           0x00000008
N#define CONF_TM16_TRG           0x00000000
N#define CONF_TM16_ARR           120
N#define CONF_TM16_PSARR         10
N
N//  <e0.0> Configure TM20 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM20_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR) <2=> IN0 (TM20_IN0) <3=> IN1 (TM20_IN1)
N//              <o4.8..10> ITR from <0=> ITR0 : TM00_TRGO <1=> ITR1 : TM10_TRGO <2=> ITR2 : CMP0_OUT <3=> ITR3 : CMP2_OUT <4=> ITR4 : INT_PA <5=> ITR5 : INT_PB <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode (Up count) <0=> Cascade : 16-bit counter with 16-bit prescaler  Mode <1=> Separate : Separated two 16-bit counters Mode <2=> Full-Counter : 32-bit counter Mode
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut/OC/PWM configuration
N//          <o3.2..3> TM20 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle
N//      </e>
N//      <h> Trigger Input/Output configuration (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM20_RST (Main Timer Reset) <1=> EN : TM20_EN (Main Timer Enable) <2=> UEV : TM20_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM20_TOF (Main Timer overflow) <5=> EN2 : TM20_EN2 (Timer-2 Enable) <6=> TOF2 :TM20_TOF2 (Timer-2 overflow)
N//                                                              <8=> UEV2 : TM20_UEV2 (Timer-2 Update event) <9=> SW : TM20_TRGO_SW (software control bit) 
N//                                                              <10=> OS0 : TM20_OS0 (channel-0 output state signal) <11=> OS1 : TM20_OS1 (channel-1 output state signal)    
N//                                                              <14=> TRGI : TM20_TRGI (internal TRGI signal) <15=> POE : TM20_POE (Output enable register preload signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-65535>
N//      <o6> Prescaler counter range <0-65535>
N//      <h> Channel0 mode
N//          <o8.0..2> Channel-0 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs)
N//          <o9.0..1> (IC) Timer channel 0 input Mux select for input capture. <0=> IC00 : TM20_IC0 <1=> IC01 : TM20_ITR <2=> IC02 : CMP0_OUT <3=> IC03 : CMP2_OUT 
N//          <o9.16..17> (IC) Timer channel 0 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.0> (OUT) Timer channel 0 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.8> (OUT) Timer channel 0 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.0> (OUT) Timer channel 0 OC line-0 OC00 output enable. <0=> Disable (output by TM20_BK0_STA setting) <1=> Enable
N//          <o11.1> (OUT) Timer channel 0 OC line-1 OC01 output enable. <0=> Disable (output by TM20_BK0_STA setting) <1=> Enable
N//          <o11.2> (OUT) Timer channel 0 OC line-2 OC02 output enable. <0=> Disable (output by TM20_BK0_STA setting) <1=> Enable
N//          <o11.16> (OUT) Timer channel 0 OC0N (complement) line output enable. <0=> Disable (output by TM20_BK0N_STA setting) <1=> Enable
N//          <o12.0> (OUT) Timer channel 0 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.4> (OUT) Timer channel 0 OC0H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.8> (OUT) Timer channel 0 OC0N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.24> (OUT) Timer BK input active or stop condition output OC0 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.28> (OUT) Timer BK input active or stop condition output OC0N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o14.0..15> (OUT) CC0A, CC0B <0-65535>
N//      </h>
N//      <h> Channel1 mode
N//          <o8.4..6> Channel-1 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs)
N//          <o9.4..5> (IC) Timer channel 1 input Mux select for input capture. <0=> IC00 : TM20_IC1 <1=> IC01 : TM20_ITR <2=> IC02 : CMP1_OUT <3=> IC03 : CMP3_OUT 
N//          <o9.18..19> (IC) Timer channel 1 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.1> (OUT) Timer channel 1 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.9> (OUT) Timer channel 1 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.4> (OUT) Timer channel 1 OC line-0 OC10 output enable. <0=> Disable (output by TM20_BK0_STA setting) <1=> Enable
N//          <o11.5> (OUT) Timer channel 1 OC line-1 OC11 output enable. <0=> Disable (output by TM20_BK0_STA setting) <1=> Enable
N//          <o11.6> (OUT) Timer channel 1 OC line-2 OC12 output enable. <0=> Disable (output by TM20_BK0_STA setting) <1=> Enable
N//          <o11.20> (OUT) Timer channel 1 OC1N (complement) line output enable. <0=> Disable (output by TM20_BK0N_STA setting) <1=> Enable
N//          <o12.1> (OUT) Timer channel 1 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.5> (OUT) Timer channel 1 OC1H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.9> (OUT) Timer channel 1 OC1N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.25> (OUT) Timer BK input active or stop condition output OC1 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.29> (OUT) Timer BK input active or stop condition output OC1N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o15.0..15> (OUT) CC1A, CC1B <0-65535>
N//      </h>
N//  </e>
N#define CONF_TM20_ENABLE_OPTION 0x00000000  
N#define CONF_TM20_CLK           0x00000000  
N#define CONF_TM20_CR0           0x00000000
N#define CONF_TM20_CKO           0x00000008
N#define CONF_TM20_TRG           0x00000000
N#define CONF_TM20_ARR           120
N#define CONF_TM20_PSARR         10
N#define CONF_TM20_RCNT          0
N#define CONF_TM20_CCMDS         0x00000000
N#define CONF_TM20_ICCR          0x00000000
N#define CONF_TM20_OSCR          0x00002020
N#define CONF_TM20_OCCR0         0x00000000
N#define CONF_TM20_OCCR1         0x00000000
N#define CONF_TM20_BS            0x00000000
N#define CONF_TM20_CC0A          0x00000000
N#define CONF_TM20_CC1A          0x00000000
N
N
N//  <e0.0> Configure TM26 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM26_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR) <2=> IN0 (TM26_IN0) <3=> IN1 (TM26_IN1)
N//              <o4.8..10> ITR from <0=> ITR0 : TM01_TRGO <1=> ITR1 : TM16_TRGO <2=> ITR2 : CMP1_OUT <3=> ITR3 : CMP3_OUT <4=> ITR4 : INT_PC <5=> ITR5 : INT_PD <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode <0=> Cascade : 16-bit counter with 16-bit prescaler  Mode <1=> Separate : Separated two 16-bit counters Mode <2=> Full-Counter : 32-bit counter Mode
N//          <o2.6..7> Up or down count <0=> Up count (Main & Prescaler counter) <3=> Down count (Main & Prescaler counter)
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut/OC/PWM configuration
N//          <o3.2..3> TM26 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle 
N//      </e>
N//      <h> Trigger Input/Output configuration (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM26_RST (Main Timer Reset) <1=> EN : TM26_EN (Main Timer Enable) <2=> UEV : TM26_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM26_TOF (Main Timer overflow) <4=> TUF : TM26_TUF (Main Timer underflow)
N//                                                              <5=> EN2 : TM26_EN2 (Timer-2 Enable) <6=> TOF2 :TM26_TOF2 (Timer-2 overflow) <7=> DIR : TM26_DIR (Main Timer direction event)
N//                                                              <8=> UEV2 : TM26_UEV2 (Timer-2 Update event) <9=> SW : TM26_TRGO_SW (software control bit) 
N//                                                              <10=> OS0 : TM26_OS0 (channel-0 output state signal) <11=> OS1 : TM26_OS1 (channel-1 output state signal)
N//                                                              <14=> TRGI : TM26_TRGI (internal TRGI signal) <15=> POE : TM26_POE (Output enable register preload signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-65535>
N//      <o6> Prescaler counter range <0-65535>
N//      <h> QEI 
N//          <i> TMx_ETR is QEI_IDX
N//          <i> TMx_IN0 is QEI_DIR
N//          <i> TMx_IN1 is QEI_CLK
N//          <o4.16..18> QEI mode <0=> No operation (Disable QEI) <1=> N0POS : TM26_IN0 positive (high level up count, low level down count)
N//                                                               <2=> IN0NEG : TM26_IN0 negative (low level up count, high level down count)
N//                                                               <5=> BOTH : Both TM26_IN0 and TM26_IN1 edge
N//          <e4.19> Main Timer QEI external index signal input. <0=> Disable <1=> Enable (Accept QEI IDX)
N//              <o4.20..21> Main Timer QEI external index signal input reset timer transition state select. <0=> 1T2 : State change between 1 and 2
N//                                                                                                          <1=> 2T3 : State change between 2 and 3
N//                                                                                                          <2=> 3T4 : State change between 3 and 4
N//                                                                                                          <3=> 4T1 : State change between 4 and 1
N//          </e>
N//      </h>
N//      <h> Channel0 mode
N//          <o8.0..2> Channel-0 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs)
N//          <o9.0..1> (IC) Timer channel 0 input Mux select for input capture. <0=> IC00 : TM26_IC0 <1=> IC01 : TM26_ITR <2=> IC02 : CMP0_OUT <3=> IC03 : CMP2_OUT 
N//          <o9.16..17> (IC) Timer channel 0 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.0> (OUT) Timer channel 0 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.8> (OUT) Timer channel 0 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.0> (OUT) Timer channel 0 OC line-0 OC00 output enable. <0=> Disable (output by TM26_BK0_STA setting) <1=> Enable
N//          <o11.1> (OUT) Timer channel 0 OC line-1 OC01 output enable. <0=> Disable (output by TM26_BK0_STA setting) <1=> Enable
N//          <o11.2> (OUT) Timer channel 0 OC line-2 OC02 output enable. <0=> Disable (output by TM26_BK0_STA setting) <1=> Enable
N//          <o11.16> (OUT) Timer channel 0 OC0N (complement) line output enable. <0=> Disable (output by TM26_BK0N_STA setting) <1=> Enable
N//          <o12.0> (OUT) Timer channel 0 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.4> (OUT) Timer channel 0 OC0H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.8> (OUT) Timer channel 0 OC0N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.24> (OUT) Timer BK input active or stop condition output OC0 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.28> (OUT) Timer BK input active or stop condition output OC0N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o14.0..15> (OUT) CC0A, CC0B <0-65535>
N//      </h>
N//      <h> Channel1 mode
N//          <o8.4..6> Channel-1 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs)
N//          <o9.4..5> (IC) Timer channel 1 input Mux select for input capture. <0=> IC00 : TM26_IC1 <1=> IC01 : TM26_ITR <2=> IC02 : CMP1_OUT <3=> IC03 : CMP3_OUT 
N//          <o9.18..19> (IC) Timer channel 1 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.1> (OUT) Timer channel 1 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.9> (OUT) Timer channel 1 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.4> (OUT) Timer channel 1 OC line-0 OC10 output enable. <0=> Disable (output by TM26_BK0_STA setting) <1=> Enable
N//          <o11.5> (OUT) Timer channel 1 OC line-1 OC11 output enable. <0=> Disable (output by TM26_BK0_STA setting) <1=> Enable
N//          <o11.6> (OUT) Timer channel 1 OC line-2 OC12 output enable. <0=> Disable (output by TM26_BK0_STA setting) <1=> Enable
N//          <o11.20> (OUT) Timer channel 1 OC1N (complement) line output enable. <0=> Disable (output by TM26_BK0N_STA setting) <1=> Enable
N//          <o12.1> (OUT) Timer channel 1 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.5> (OUT) Timer channel 1 OC1H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.9> (OUT) Timer channel 1 OC1N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.25> (OUT) Timer BK input active or stop condition output OC1 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.29> (OUT) Timer BK input active or stop condition output OC1N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o15.0..15> (OUT) CC1A, CC1B <0-65535>
N//      </h>
N//  </e>
N#define CONF_TM26_ENABLE_OPTION 0x00000000  
N#define CONF_TM26_CLK           0x00000000  
N#define CONF_TM26_CR0           0x00000000
N#define CONF_TM26_CKO           0x00000008
N#define CONF_TM26_TRG           0x00000000
N#define CONF_TM26_ARR           120
N#define CONF_TM26_PSARR         10
N#define CONF_TM26_RCNT          0
N#define CONF_TM26_CCMDS         0x00000000
N#define CONF_TM26_ICCR          0x00000000
N#define CONF_TM26_OSCR          0x00002020
N#define CONF_TM26_OCCR0         0x00000000
N#define CONF_TM26_OCCR1         0x00000000
N#define CONF_TM26_BS            0x00000000
N#define CONF_TM26_CC0A          0x00000000
N#define CONF_TM26_CC1A          0x00000000
N
N
N//  <e0.0> Configure TM36 Module
N//      <h> Clock configuration
N//          <o1.6..7> Main / Prescaler counter clock from <0=> Internal clock <3=> External Clock
N//          <h> Internal Clock 
N//              <o1.8..9> Internal Clock from <0=> PROC : CK_TM36_PR process clock from CSC <2=> CK_LS
N//              <o1.12..13> Internal Clock divider <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <2=> DIV4 : divided by 4 <3=> DIV8 : divided by 8  
N//          </h>
N//          <h> External Clock
N//              <o1.4..5> External Clock source from <0=> ETR (CK_ETR) <1=> ITR (CK_ITR) <2=> IN0 (TM36_IN0) <3=> IN1 (TM36_IN1)
N//              <o4.8..10> ITR from <0=> ITR0 : TM10_TRGO  <2=> ITR2 : CMP0_OUT <3=> ITR3 : CMP1_OUT <4=> ITR4 : INT_PA <5=> ITR5 : INT_PC <6=> ITR6  <7=> ITR7
N//          </h>
N//      </h>
N//      <h> Timer operation mode
N//          <o2.4..5> Operation mode <0=> Cascade : 16-bit counter with 16-bit prescaler  Mode <1=> Separate : Separated two 16-bit counters Mode <2=> Full-Counter : 32-bit counter Mode
N//          <o2.6..7> Up or down count <0=> Up count (Main & Prescaler counter) <3=> Down count (Main & Prescaler counter)
N//          <o2.10..11> External trigger (EXF) <0=> Disable external trigger <1=> Enable external trigger <3=> Enable external invert trigger
N//          <o2.15> Timer external trigger update event <0=> Disable <1=> Enable
N//      </h>
N//      <e3.0> ClockOut/OC/PWM configuration
N//          <o3.2..3> TM36 CKO initial state <2=> Output 0 <3=> Output 1
N//          <o3.1> CKO event from <0=> Prescaler counter overflow <1=> Main counter overflow
N//          <o2.8..9> Repeatability parameter <0=> Always clock out <1=> Only Output once cycle 
N//      </e>
N//      <h> Trigger Input/Output configuration (TRGI & TRGO)
N//          <o4.6..7> (TRGI) Timer trigger source from <0=> ETR <1=> ITR (source from Clock configuration)
N//          <o4.0..2> (TRGI) Main counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.3..5> (TRGI) Prescaler counter trigger input mode <0=> No operation <1=> Trigger rising edge <2=> Reset rising edge <3=> Gate High <4=> Reset dual edge <5=> Trigger falling edge
N//                                                           <6=> Reset falling edge <7=> Gate Low
N//          <o4.12..15> (TRGO) Timer trigger output mode select <0=> RST : TM36_RST (Main Timer Reset) <1=> EN : TM36_EN (Main Timer Enable) <2=> UEV : TM36_UEV (Main Timer Update event)
N//                                                              <3=> TOF : TM36_TOF (Main Timer overflow) <4=> TUF : TM36_TUF (Main Timer underflow)
N//                                                              <5=> EN2 : TM36_EN2 (Timer-2 Enable) <6=> TOF2 :TM36_TOF2 (Timer-2 overflow)
N//                                                              <7=> DIR : TM36_DIR (Main Timer direction event)
N//                                                              <8=> UEV2 : TM36_UEV2 (Timer-2 Update event) <9=> SW : TM36_TRGO_SW (software control bit) 
N//                                                              <10=> OS0 : TM36_OS0 (channel-0 output state signal) <11=> OS1 : TM36_OS1 (channel-1 output state signal)
N//                                                              <12=> OS2 : TM36_OS2 (channel-2 output state signal) <13=> OS3 : TM36_OS3 (channel-3 output state signal)
N//                                                              <14=> TRGI : TM36_TRGI (internal TRGI signal) <15=> POE : TM36_POE (Output enable register preload signal)
N//          <o4.22..23> (TRGO) Timer UEV for <0=> All : output all UEV pulses <1=> TOF : output timer overflow pulses <2=> UDF : output timer underflow pulses
N//          <o2.12> (UEV) Update event generation for main Timer. <1=> Disable <0=> Enable
N//              <i> Update event is generation from counter overflow/underflow.
N//          <o4.25> (TRGO) Timer TRGO output inverse enable bit. <0=> Disable <1=> Enable
N//      </h>
N//      <o5> Main counter range <0-65535>
N//      <o6> Prescaler counter range <0-65535>
N//      <h> QEI 
N//          <i> TMx_ETR is QEI_IDX
N//          <i> TMx_IN0 is QEI_DIR
N//          <i> TMx_IN1 is QEI_CLK
N//          <o4.16..18> QEI mode <0=> No operation (Disable QEI) <1=> N0POS : TM36_IN0 positive (high level up count, low level down count)
N//                                                               <2=> IN0NEG : TM36_IN0 negative (low level up count, high level down count)
N//                                                               <5=> BOTH : Both TM36_IN0 and TM36_IN1 edge
N//          <e4.19> Main Timer QEI external index signal input. <0=> Disable <1=> Enable (Accept QEI IDX)
N//              <o4.20..21> Main Timer QEI external index signal input reset timer transition state select. <0=> 1T2 : State change between 1 and 2
N//                                                                                                          <1=> 2T3 : State change between 2 and 3
N//                                                                                                          <2=> 3T4 : State change between 3 and 4
N//                                                                                                          <3=> 4T1 : State change between 4 and 1
N//          </e>
N//      </h>
N//      <h> Channel0 mode
N//          <o8.0..2> Channel-0 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs) <6=> 16bit_PWM_DTG (16bit PWM with DTG) <0x7=> 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N//          <o9.0..1> (IC) Timer channel 0 input Mux select for input capture. <0=> IC00 : TM36_IC0 <1=> IC01 : TM36_ITR <2=> IC02 : CMP0_OUT <3=> IC03 : TM36_XOR
N//          <o9.16..17> (IC) Timer channel 0 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.0> (OUT) Timer channel 0 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.8> (OUT) Timer channel 0 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.0> (OUT) Timer channel 0 OC line-0 OC00 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.1> (OUT) Timer channel 0 OC line-1 OC01 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.2> (OUT) Timer channel 0 OC line-2 OC02 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.16> (OUT) Timer channel 0 OC0N (complement) line output enable. <0=> Disable (output by TM36_BK0N_STA setting) <1=> Enable
N//          <o12.0> (OUT) Timer channel 0 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.4> (OUT) Timer channel 0 OC0H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.8> (OUT) Timer channel 0 OC0N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.24> (OUT) Timer BK input active or stop condition output OC0 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.28> (OUT) Timer BK input active or stop condition output OC0N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o14.0..15> (OUT) CC0A, CC0B <0-65535>
N//      </h>
N//      <h> Channel1 mode
N//          <o8.4..6> Channel-1 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs) <6=> 16bit_PWM_DTG (16bit PWM with DTG) <0x7=> 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N//          <o9.4..5> (IC) Timer channel 1 input Mux select for input capture. <0=> IC00 : TM36_IC1 <1=> IC01 : TM36_ITR <2=> IC02 : CMP1_OUT 
N//          <o9.18..19> (IC) Timer channel 1 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.1> (OUT) Timer channel 1 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.9> (OUT) Timer channel 1 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.4> (OUT) Timer channel 1 OC line-0 OC10 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.5> (OUT) Timer channel 1 OC line-1 OC11 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.6> (OUT) Timer channel 1 OC line-2 OC12 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.20> (OUT) Timer channel 1 OC1N (complement) line output enable. <0=> Disable (output by TM36_BK0N_STA setting) <1=> Enable
N//          <o12.1> (OUT) Timer channel 1 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.5> (OUT) Timer channel 1 OC1H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.9> (OUT) Timer channel 1 OC1N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.25> (OUT) Timer BK input active or stop condition output OC1 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.29> (OUT) Timer BK input active or stop condition output OC1N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o15.0..15> (OUT) CC1A, CC1B <0-65535>
N//      </h>
N//      <h> Channel2 mode
N//          <o8.8..10> Channel-2 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs) <6=> 16bit_PWM_DTG (16bit PWM with DTG) <0x7=> 8bitx2_PWM_DTG (Two 8bit PWMs with DTG)
N//          <o9.8..9> (IC) Timer channel 2 input Mux select for input capture. <0=> IC00 : TM36_IC2 <1=> IC01 : TM36_ITR <2=> IC02 : CMP2_OUT
N//          <o9.20..21> (IC) Timer channel 2 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.2> (OUT) Timer channel 2 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.10> (OUT) Timer channel 2 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.8> (OUT) Timer channel 2 OC line-0 OC2 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o11.24> (OUT) Timer channel 2 OC2N (complement) line output enable. <0=> Disable (output by TM36_BK0N_STA setting) <1=> Enable
N//          <o12.2> (OUT) Timer channel 2 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.6> (OUT) Timer channel 2 OC2H output inverse enable. <0=> Disable <1=> Enable
N//          <o12.10> (OUT) Timer channel 2 OC2N output inverse enable. <0=> Disable <1=> Enable
N//          <o13.26> (OUT) Timer BK input active or stop condition output OC2 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o13.30> (OUT) Timer BK input active or stop condition output OC2N state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o16.0..15> (OUT) CC2A, CC2B <0-65535>
N//      </h>
N//      <h> Channel3 mode
N//          <o8.12..14> Channel-3 function <0=> 0x0 = NOP (No operation) <1=> 16bit_IC (Input capture) <2=> 16bit_OC (Output compare) <3=> 8bitx2_OC (Two 8-bit compare)
N//                                       <4=> 16bit_PWM (16bit PWM) <5=> 8bitx2_PWM (Two 8bit PWMs)
N//          <o9.12..13> (IC) Timer channel 3 input Mux select for input capture. <0=> IC00 : TM36_IC3 <1=> IC01 : TM36_ITR  <2=> IC03 : CMP3_OUT <3=> IC03 : TM36_XOR
N//          <o9.22..23> (IC) Timer channel 3 input trigger edge select. <0=> Disable : disable capture data <1=> Rising edge <2=> Falling edge <3=> Dual-edge
N//          <o10.3> (OUT) Timer channel 3 OC compare/compare-L output signal initial state. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o10.11> (OUT) Timer channel 3 OC compare-H output signal initial state for two 8-Bit comparator mode.. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o11.12> (OUT) Timer channel 3 OC line-0 OC3 output enable. <0=> Disable (output by TM36_BK0_STA setting) <1=> Enable
N//          <o12.3> (OUT) Timer channel 3 output inverse enable. <0=> Disable <1=> Enable
N//          <o12.7> (OUT) Timer channel 3 OC3H output inverse enable. <0=> Disable <1=> Enable
N//          <o13.27> (OUT) Timer BK input active or stop condition output OC3 state select. <0=> 0 (Output 0) <1=> 1 (Output 1)
N//          <o17.0..15> (OUT) CC3A, CC3B <0-65535>
N//      </h>
N//      <h> Align / Dead time / Break control
N//          <o18.0..1> Timer OC0/1/2/3 PWM mode select. <0=> Edge Left-aligned <1=> Center-aligned
N//          <o1.16..17> Timer internal dead time clock CK_DTG divider. <0=> DIV1 : divided by 1 <1=> DIV2 : divided by 2 <3=> DIV4 : divided by 4 <4=> DIV8 : divided by 8
N//          <o18.8..15> Timer output DTG dead-time delay for all channels. <0-255>
N//          <o13.0..1> Timer Break Input enable for OC0/1/2/3. <0=> Disable <3=> Enable
N//          <o13.4> Timer break control mode select. <0=> Latch mode <1=> Cycle by cycle
N//          <o13.20..23> Timer OC0/1/2/3 output switch control when break event happened. <0=> Stop (Switch to stop state register setting) <15=> Hold (hold the output state)
N//          <o13.8> Enable Break signal from TM36_BK0 input.
N//          <o13.9> Enable Break signal from INT_BOD1 input.
N//          <o13.10> Enable Break signal from INT_PB input.
N//          <o13.11> Enable Break signal from ADC0_OUT input.
N//          <o13.12> Enable Break signal from CMP0_OUT input.
N//          <o13.13> Enable Break signal from CMP1_OUT input.
N//          <o13.16> Enable Break signal from missing clock detect(MCD) event input.
N//          <o13.18> Enable Break signal from  CPU LOCKUP event input.
N//      </h>
N//  </e>
N#define CONF_TM36_ENABLE_OPTION 0x00000000  
N#define CONF_TM36_CLK           0x00000000  
N#define CONF_TM36_CR0           0x00000000
N#define CONF_TM36_CKO           0x00000008
N#define CONF_TM36_TRG           0x00000000
N#define CONF_TM36_ARR           120
N#define CONF_TM36_PSARR         10
N#define CONF_TM36_RCNT          0
N#define CONF_TM36_CCMDS         0x00000000
N#define CONF_TM36_ICCR          0x00000000
N#define CONF_TM36_OSCR          0x00008080
N#define CONF_TM36_OCCR0         0x00000000
N#define CONF_TM36_OCCR1         0x00000000
N#define CONF_TM36_BS            0x00000000
N#define CONF_TM36_CC0A          0x00000000
N#define CONF_TM36_CC1A          0x00000000
N#define CONF_TM36_CC2A          0x00000000
N#define CONF_TM36_CC3A          0x00000000
N#define CONF_TM36_PWM           0x00000000
N
N
N
N//*** <<< end of configuration section >>>    ***
N
N
N
N
N
N
N/**
N * @name	Function announce
N *   		
N */
N///@{  
Nvoid TM_Init (void);
N///@}
N
N
N#endif  // _MG32x02z_TM_INIT_H
N
L 74 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N#ifdef MG32x02z_ConfigerWizard_ADC
N    #include "MG32x02z_ADC_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.h" 1
N/**
N *******************************************************************************
N * @file        MG32x02z_ADC_Init.h
N *
N * @brief       The ADC initial code h file
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2020/08/05
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************* 
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N#include "MG32x02z.h"
N#include "MG32x02z_ADC.h"
N#include "RTE_Components.h"
N
N
N#ifndef _MG32x02z_ADC_INIT_H
N/*!< _MG32x02z_TM_INIT_H */ 
N#define _MG32x02z_ADC_INIT_H
N
N#include "MG32x02z_ADC_DRV.h"
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N// <h> ADC base parameters
N//      <o0.16..23> ADC0 sampling time selec <0-255>
N//          <i> 0T ~ 255T clocks.T= CK_ADC0_INT
N//      <o0.6..7> ADC0 data resolution select. <0=> 12-bit <1=> 10-bit <2=> 8-bit
N//      <o1.3> ADC0 data alignment select <0=> Right (Right alignment) <1=> Left (Left alignment)
N//      <o1.24..28> ADC adjusted 2's complement value of digital offset adjuster <0x10=> -16 <0x11=> -15 <0x12=> -14 <0x13=> -13 <0x14=> -12 <0x15=> -11
N//                                                                              <0x16=> -10 <0x17=> -9 <0x18=> -8 <0x19=> -7 <0x1A=> -6 <0x1B=> -5
N//                                                                              <0x1C=> -4 <0x1D=> -3 <0x1E=> -2 <0x1F=> -1 <0x00=> 0 <0x01=> +1
N//                                                                              <0x02=> +2 <0x03=> +3 <0x04=> +4 <0x05=> +5 <0x06=> +6 <0x07=> +7
N//                                                                              <0x08=> +8 <0x09=> +9 <0x0A=> +10 <0x0B=> +11 <0x0C=> +12 <0x0D=> +13 <0x0E=> +14 <0x0F=> +15
N//      <o1.8> ADC0 data buffer overrun mode select <0=> Overwritten (Overwritten by new data) <1=> Keep (Preserved old date)
N//      <o2.19..25> ADC0 conversion mode select <0x00=> ADC One shot mode <0x01=> ADC Continue mode <0x20=> Scan mode <0x21=> Scan continue mode <0x40=> Loop mode
N//          <i> ADC One Shot mode : Convert one ADC data from single channel after one start trigger, then stop conversion.
N//          <i> ADC Continue mode : Convert one ADC data from single channel after one start trigger, then hardware automatically start next ADC conversion continuously and does not stop conversion.
N//          <i> Scan mode : Convert one ADC data from one selected channel after one start trigger, then stop conversion. To follow and convert next ADC data from next selected channel after next start trigger. Run the same steps for all selected channels.
N//          <i> Scan continue mode : Convert multiple ADC data continuously from multiple selected channels after one start trigger, then stop conversion when scan finished for all selected channels.
N//          <i> Loop mode : When ADC conversion start by one start trigger, hardware does the channel scan ADC conversion one by one until finish the conversion for all selected channels. And hardware automatically start next channel scan ADC conversion continuously and does not stop.
N//      <o3.16..18> ADC0 start control source select <0x0=> SW : ADC0_START register setting <0x1=> TM00 : TM00_TRGO <0x2=> PIN : ADC0_TRG : ADC external trigger pin
N//                                                   <0x3=> CMP0 : CMP0_OUT <0x4=> CMP1 : CMP1_OUT <0x5=> TM01 : TM01_TRGO <0x6=> TM26 : TM26_TREGO <7=> TM36 : TM36_TRGO
N//      <o3.20..21> ADC0 start trigger selection <0x0=> Disable <0x1=> Rising edge <0x2=> Falling edge <0x4=> Dual-edge
N//          <i> When selects Disable, the edge trigger detection is disabled and no start trigger signal output. When ADC0_START_SEL = SW (ADC0_START register setting), this register is no effect.
N//      <o3.8..12> ADC One shot mode / ADC Continue Mode - channel select
N//          <0=> PA0
N//          <1=> PA1
N//          <2=> PA2
N//          <3=> PA3
N//          <4=> PA4
N//          <5=> PA5
N//          <6=> PA6
N//          <7=> PA7
N//          <8=> PA8
N//          <9=> PA9
N//          <10=> PA10
N//          <11=> PA11
N//          <12=> PA12
N//          <13=> PA13
N//          <14=> PA14
N//          <15=> PA15
N//          <16=> Internal VSSA
N//          <17=> IVREF : ADC0_IVREF
N//          <18=> INT_DACP0
N//          <19=> INT_VBG (VBUF)
N//      <h> Scan/Loop mode - sequence channel scan
N//          <q4.0> PA0
N//          <q4.1> PA1
N//          <q4.2> PA2
N//          <q4.3> PA3
N//          <q4.4> PA4
N//          <q4.5> PA5
N//          <q4.6> PA6
N//          <q4.7> PA7
N//          <q4.8> PA8
N//          <q4.9> PA9
N//          <q4.10> PA10
N//          <q4.11> PA11
N//          <q4.12> PA12
N//          <q4.13> PA13
N//          <q4.14> PA14
N//          <q4.15> PA15
N//      </h>
N// </h>
N#define CONF_ADC_CR0_REG            0
N#define CONF_ADC_CR1_REG            0x00000000
N#define CONF_ADC_START_CONV_MDS     0x00000000
N#define CONF_ADC_START_START_SEL    0x000000
N#define CONF_ADC_MSK_MSKx           0x0000
N
N#if CONF_ADC_START_CONV_MDS>0x00080000
X#if 0x00000000>0x00080000
S    #if CONF_ADC_MSK_MSKx==0
S        #error "Error: ADC0 needs to enable sequence channel"
S    #endif
N#endif
N
N//  <e0.2> PGA configuration
N//      <o1.0..5> ADC0 input PGA gain adjust bits. Gain range is x1 ~ x4. <0-63> 
N//          <i> 0: x1, 1: x1.012 ... 42: x2.0 ... 63: x4.0
N//          <i> Gain = {1+(ADC0_GAIN_PGA*3)/[63+(63-ADC0_GAIN_PGA)*3]}
N//  </e>
N#define CONF_ADC_ANA_PGA_EN         0
N#define CONF_ADC_GAIN_PGA           0
N
N
N
N//  <h> Clock configuration
N//     <o0.8..9> ADC0 internal sampling clock CK_ADC0_INT source select <0=> CK_ADC <1=> CK_PLL <3=> TM00_TRGO <3=> TM01_TRGO
N//          <i> CK_ADC from CSC (AHB or APB).
N//          <i> CK_PLL ~96MHz (CSC must enable PLL).
N//          <i> TM00_TRGO : TM00 periodic output overflow event (User must enable TM00).
N//          <i> TM01_TRGO : TM01 periodic output overflow event (User must enable TM01).
N//     <o0.4..5> Internal clock CK_ADC0_INT input divider <0=> DIV1 <1=> DIV2 <3=> DIV4 <3=> DIV16
N//     <o0.10..11> ADC0 input clock CK_PLL divider. <0=> DIV2 <1=> DIV4 <3=> DIV5 <3=> DIV6
N//  </h>
N#define CONF_ADC_CLK_SRC            0x00000000
N#define CONF_ADC_CLK_DIV            0x00000000
N
N
N//  <e0.0> Window detect threshold
N//      <o3.14..15> ADC0 output code spike limit function <0=> No operation <1=> Skip <2=> Clamp
N//      <o0.1> Apply channel <0=> Single <1=> All
N//      <o0.4..5> ADC0_OUT output signal select <0=> WDL (window detect state for outside low) <1=> WDI (window detect state for inside) <2=> WDH (window detect state for outside high)
N//      <o1.0..11> ADC0 Voltage window detect lower threshold <0-4095>
N//          <i> window detect lower threshold : 0~4095@12bit
N//      <o2.0..11> ADC0 voltage window detect higher threshold <0-4095>
N//          <i> window detect higher threshold : 0~4095@12bit
N//  </e>
N#define CONF_ADC_CR1_WIND_EN        0x00000000  
N#define CONF_ADC_WINDTH_LT          0  
N#define CONF_ADC_WINDTH_HT          0  
N#define CONF_ADC_CR0_LIM_MDS        0x0000
N
N#if CONF_ADC_WINDTH_LT > CONF_ADC_WINDTH_HT
X#if 0 > 0
S    #error "Error: window detect lower threshold > window detect higher threshold"
N#endif 
N
N// <h> ADC0 data accumulation sum
N//      <o0.16..22> ADC0 data sum accumulation data number <0-64>
N//          <i> Value 0 indicates to disable accumulation and the maximum value 0x40 indicates 64 data to accumulate.
N//      <o0.10> ADC0 data accumulation sum channel mode select <0=> Single (Single channel) <1=> All (All selected scan channels)
N//          <i> When selects Single mode for ADC one shot conversion mode, the ADC0_SUM0_MUX selection channel data is accumulated into ADC0_SUM0. When selects All mode, the all selection channel data are accumulated one-by-one into ADC0_SUM0 only.
N//          <i> When selects Single mode for ADC channel scan conversion mode, the ADC0_SUM1_MUX/ADC0_SUM2_MUX selection channel data are also separately accumulated into ADC0_SUM1/ADC0_SUM2.   
N//      <o0.9> ADC0 data sum overrun mode select <0=> Overwritten (Overwritten by new data) <1=> Keep (Preserved old date)
N//      <o1.16..19> Analog input channel selection for ADC0 data sum-0 function <0=> PA0 <1=> PA1 <2=> PA2 <3=> PA3 <4=> PA4 <5=> PA5 <6=> PA6 <7=> PA7 <8=> PA8
N//                                                                              <9=> PA9 <10=> PA10 <11=> PA11 <12=> PA12 <13=> PA13 <14=> PA14 <15=> PA15
N//      <o2.0..15> ADC0 data accumulator sum-0 initial value <0-65535>
N//      <o1.20..23> Analog input channel selection for ADC0 data sum-1 function <0=> PA0 <1=> PA1 <2=> PA2 <3=> PA3 <4=> PA4 <5=> PA5 <6=> PA6 <7=> PA7 <8=> PA8
N//                                                                              <9=> PA9 <10=> PA10 <11=> PA11 <12=> PA12 <13=> PA13 <14=> PA14 <15=> PA15
N//      <o3.0..15> ADC0 data accumulator sum-1 initial value <0-65535>
N//      <o1.24..27> Analog input channel selection for ADC0 data sum-2 function <0=> PA0 <1=> PA1 <2=> PA2 <3=> PA3 <4=> PA4 <5=> PA5 <6=> PA6 <7=> PA7 <8=> PA8
N//                                                                              <9=> PA9 <10=> PA10 <11=> PA11 <12=> PA12 <13=> PA13 <14=> PA14 <15=> PA15
N//      <o4.0..15> ADC0 data accumulator sum-2 initial value <0-65535>
N// </h>
N#define CONF_ADC_CR1_SUM_NUM        1024  
N#define CONF_ADC_MSK_SUMx_MUX       0x00000000
N#define CONF_ADC_SUM0               0
N#define CONF_ADC_SUM1               0
N#define CONF_ADC_SUM2               0
N
N
N#define CONF_ADC_CLK                (CONF_ADC_CLK_SRC | CONF_ADC_CLK_DIV)
N#define CONF_ADC_WINDTH             ((CONF_ADC_WINDTH_HT << 16) | CONF_ADC_WINDTH_LT)
N#define CONF_ADC_CR0                (CONF_ADC_CR0_REG | CONF_ADC_CR0_LIM_MDS)
N#define CONF_ADC_CR1                (CONF_ADC_CR1_REG | CONF_ADC_CR1_WIND_EN | CONF_ADC_CR1_SUM_NUM)
N#define CONF_ADC_MSK                (CONF_ADC_MSK_SUMx_MUX | CONF_ADC_MSK_MSKx)
N#define CONF_ADC_START              (CONF_ADC_START_CONV_MDS | CONF_ADC_START_START_SEL)
N#define CONF_ADC_ANA                (CONF_ADC_ANA_PGA_EN)
N#define CONF_ADC_GAIN               (CONF_ADC_GAIN_PGA)
N//*** <<< end of configuration section >>>    ***
N
N
N
N
N
N
N/**
N * @name	Function announce
N *   		
N */
N///@{  
Nvoid ADC_Init (void);
N///@}
N
N
N#endif  // _MG32x02z_TM_INIT_H
N
L 78 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ChipInit.h" 2
N#endif
N
N
N#endif
L 31 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_EMB_Init.c" 2
N
N
N
N#include "MG32x02z_EMB_Init.h"
N
N
N/* Private typedef ----------------------------------------------------------*/
N
N/* Private define -----------------------------------------------------------*/
N
N/* Private macro ------------------------------------------------------------*/
N
N/* Private variables --------------------------------------------------------*/
N
N/* Private function prototypes ----------------------------------------------*/
N
N/* Private functions --------------------------------------------------------*/
Nvoid EMB_Initial(void)
N{
N    EMB->CR0.B[0] &= ~EMB_CR0_EN_mask_b0;
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->CR0.B[0] &= ~((uint8_t )0x01);
N    EMB->INT.W = EMB_Config_INT;
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->INT.W = 0x0;
N    EMB->CLK.W = EMB_Config_CLK;
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->CLK.W = 0x0;
N    EMB->CR0.W = EMB_Config_CR0 | ((uint32_t)0x00000100);
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->CR0.W = 0x0 | ((uint32_t)0x00000100);
N    EMB->CR1.W = EMB_Config_CR1;
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->CR1.W = 0x000000;
N    EMB->CR2.W = EMB_Config_CR2;
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->CR2.W = 69649;
N
N#if(EMB_Mode_Select == EMB_Mode_NOAddress)
X#if(1 == 0)
N#endif
N
N#if(EMB_Mode_Select == EMB_Mode_NoLatch_16BitAddress)
X#if(1 == 1)
N            EMB->CR0.W |= EMB_CR0_BUS_MDS_separated_w;
X            ((EMB_Struct*) ((uint32_t)0x4D020000))->CR0.W |= ((uint32_t)0x00000400);
N#endif
N
N#if(EMB_Mode_Select == EMB_Mode_1AddressPhase_30BitAddress)
X#if(1 == 2)
S            EMB->CR0.W |= EMB_CR0_BUS_MDS_multiplex_w | 
S                          EMB_CR0_ADR_SEL_30bit_w;
N#endif
N
N#if(EMB_Mode_Select == EMB_Mode_1AddressPhase_24BitAddress)
X#if(1 == 3)
S            EMB->CR0.W |= EMB_CR0_BUS_MDS_multiplex_w |
S                          EMB_CR0_ADR_SEL_24bit_w;
N#endif
N
N#if(EMB_Mode_Select == EMB_Mode_2AddressPhase_30BitAddress)
X#if(1 == 4)
S            EMB->CR0.W |= EMB_CR0_BUS_MDS_multiplex_w | 
S                          EMB_CR0_ADR_SEL_30bit_w |
S                          EMB_CR0_ADR_TWO_mask_w;
N#endif
N
N#if(EMB_Mode_Select == EMB_Mode_2AddressPhase_24BitAddress)
X#if(1 == 5)
S            EMB->CR0.W |= EMB_CR0_BUS_MDS_multiplex_w |
S                          EMB_CR0_ADR_SEL_30bit_w |
S                          EMB_CR0_ADR_TWO_mask_w;
N#endif
N
N    EMB->CR0.B[0] |= EMB_CR0_EN_mask_b0;
X    ((EMB_Struct*) ((uint32_t)0x4D020000))->CR0.B[0] |= ((uint8_t )0x01);
N}
N
N
N/******************* (C) COPYRIGHT 2018 Megawin ************ END OF FILE *****/ 
N
N
