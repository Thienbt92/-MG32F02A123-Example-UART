L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.c"
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_ADC_Init.c
N *
N * @brief       The ADC initial code C file
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2020/08/05
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N#include "MG32x02z_ADC_Init.h"
L 1 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.h" 1
N/**
N *******************************************************************************
N * @file        MG32x02z_ADC_Init.h
N *
N * @brief       The ADC initial code h file
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.00
N * @date        2020/08/05
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************* 
N * @par         Disclaimer
N * The Demo software is provided "AS IS" without any warranty, either
N * expressed or implied, including, but not limited to, the implied warranties
N * of merchantability and fitness for a particular purpose. The author will
N * not be liable for any special, incidental, consequential or indirect
N * damages due to loss of data or any other reason.
N * These statements agree with the world wide and local dictated laws about
N * authorship and violence against these laws.
N *******************************************************************************
N *******************************************************************************
N */
N#include "MG32x02z.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z.h
N *
N * @brief       MG32x02z Device Peripheral Access Layer Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_H
N#define _MG32x02z_H
N#define _MG32x02z_H_VER                             3.9     /*!< File Version */
N
N
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N *************************************************
N *  Chip definitions
N *************************************************
N */
N// Chip Generation
N#if defined(MG32F02A132) || defined(MG32F02A072) || defined(MA862)
X#if 1L || 0L || 0L
N  #define MG32_1ST
N#elif defined(MG32F02A032)
S  #define MG32_2ND
S#elif defined(MG32F02A128) || defined(MG32F02U128) || defined(MG32F02A064) || defined(MG32F02U064)
S  #define MG32_3RD
S#elif defined(MG32F02V032)
S  #define MG32_4TH
N#endif
N
N#if defined(MG32F02U128) || defined(MG32F02U064)
X#if 0L || 0L
S  #define USB_TYPE    1
N#else
N  #define USB_TYPE    0
N#endif
N    
N
N/**
N *************************************************
N *  ARM CPU Configuration Setting
N *************************************************
N */
N#define __CM0_REV                 0 /*!< Core Revision r0p0                             */
N#define __MPU_PRESENT             0 /*!< Chip do not provide MPU                       */
N#define __NVIC_PRIO_BITS          2 /*!< Chip uses 2 Bits for the Priority Levels      */
N#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used   */
N
N/**
N ******************************************************************************
N * @enum        IRQn
N *              Interrupt Number Definition
N ******************************************************************************
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers Definitions *****************************************/
N    NMI_IRQn                    = -14 , /*!<  ;Non Maskable Interrupt                               */
N    HardFault_IRQn              = -13 , /*!<  ;Cortex-M0 Hard Fault Interrupt                       */
N    SVC_IRQn                    = -5 ,  /*!<  ;Cortex-M0 SV Call Interrupt                          */
N    PendSV_IRQn                 = -2 ,  /*!<  ;Cortex-M0 Pend SV Interrupt                          */
N    SysTick_IRQn                = -1 ,  /*!<  ;Cortex-M0 System Tick Interrupt                      */
N/******  Peripheral Interrupt Numbers Definitions ***************************************************/
N    WWDT_IRQn                   =  0 ,  /*!<  ;Window Watchdog                                      */
N    SYS_IRQn                    =  1 ,  /*!<  ;System global Interrupt                              */
N    EXINT0_IRQn                 =  3 ,  /*!<  ;EXIC EXINT0 (PA)                                     */
N    EXINT1_IRQn                 =  4 ,  /*!<  ;EXIC EXINT1 (PB)                                     */
N    EXINT2_IRQn                 =  5 ,  /*!<  ;EXIC EXINT2 (PC)                                     */
N    EXINT3_IRQn                 =  6 ,  /*!<  ;EXIC EXINT3/EXINT4 (PD/PE)                           */
N    COMP_IRQn                   =  7 ,  /*!<  ;Analog Comparators global Interrupt                  */
N    DMA_IRQn                    =  8 ,  /*!<  ;DMA all channel global Interrupt                     */
N    ADC_IRQn                    =  10 , /*!<  ;ADC                                                  */
N    DAC_IRQn                    =  11 , /*!<  ;DAC                                                  */
N    TM0x_IRQn                   =  12 , /*!<  ;Timer TM0x global Interrupt                          */
N    TM10_IRQn                   =  13 , /*!<  ;Timer TM10                                           */
N    TM1x_IRQn                   =  14 , /*!<  ;Timer TM16 ... global Interrupt                      */
N    TM20_IRQn                   =  15 , /*!<  ;Timer TM20                                           */
N    TM2x_IRQn                   =  16 , /*!<  ;Timer TM26 ... global Interrupt                      */
N    TM3x_IRQn                   =  17 , /*!<  ;Timer TM3x global Interrupt                          */
N    URT0_IRQn                   =  20 , /*!<  ;UART URT0                                            */
N    URT123_IRQn                 =  21 , /*!<  ;UART URT1/2/3 global Interrupt                       */
N    URT4x_IRQn                  =  22 , /*!<  ;UART URT4/5/6/7 global Interrupt                     */
N    SPI0_IRQn                   =  24 , /*!<  ;SPI0                                                 */
N    I2C0_IRQn                   =  28 , /*!<  ;I2C0                                                 */
N    I2Cx_IRQn                   =  29 , /*!<  ;I2C1 ... global Interrupt                            */
N    USB_IRQn                    =  30 , /*!<  ;USB                                                  */
N    APX_IRQn                    =  31 , /*!<  ;APX                                                  */
N} IRQn_Type;                    /*!< Interrupt Number Definition */
N
N
N#include "core_cm0.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.8
N * @date     21. August 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.4
N * @date     23. July 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 4U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N 
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_FP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.2.1
N * @date     26. March 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
S#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RESERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  *(vectors + (int32_t)IRQn) = vector;                              /* use pointer arithmetic to access vector */
N  /* ARM Application Note 321 states that the M0 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)(NVIC_USER_IRQ_OFFSET << 2);      /* point to 1st user interrupt */
X  uint32_t *vectors = (uint32_t *)(16 << 2);       
N  return *(vectors + (int32_t)IRQn);                                /* use pointer arithmetic to access vector */
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 107 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z.h" 2
N#include <stdint.h>
N
N/**
N *************************************************
N *  New type definitions
N *************************************************
N */
Ntypedef signed char boolean;		/*!< Boolean	*/
Ntypedef unsigned char byte;			/*!< Byte		*/
N//typedef signed char int8;
N//typedef signed char sint8;
N//typedef unsigned char uint8;
N//typedef signed short int16;
N//typedef signed short sint16;
N//typedef unsigned short uint16;
N//typedef signed int int16;
N//typedef signed int sint16;
N//typedef unsigned int uint16;
N//typedef signed long int32;
N//typedef signed long sint32;
N//typedef unsigned long uint32;
Ntypedef unsigned long long uint64;	/*!< Uint 64-bit	*/
Ntypedef float float32;				/*!< Float 32-bit	*/
Ntypedef double float64;				/*!< Float 64-bit	*/
N
N/**
N *************************************************
N *  @union		ctype
N *				Combined 32/16/8-bit type
N *************************************************
N */
Ntypedef union
N{								
N	__IO uint8_t    B[4];			/*!< Byte 8-bit 		*/
X	volatile uint8_t    B[4];			 
N	__IO uint16_t   H[2];			/*!< Half-Word 16-bit 	*/
X	volatile uint16_t   H[2];			 
N	__IO uint32_t   W;				/*!< Word 32-bit 		*/
X	volatile uint32_t   W;				 
N} ctype;
N
N
N/**
N *************************************************
N *  General definitions
N *************************************************
N */
N//#define     __I     volatile                /*!< defines 'read only' permissions		*/
N//#define     __O     volatile                /*!< defines 'write only' permissions		*/
N//#define     __IO    volatile                /*!< defines 'read / write' permissions	*/
N
N#define TRUE		1				/*!< True	*/
N#define FALSE		0				/*!< False	*/
N
N//#define ENABLE		1
N//#define DISABLE		0
N
N#define MASK8(val)  (((val) < 256) ? (val) : (val) < 65536 ? (val) >> 8 : (val) < 16777216 ?  (val) >> 16 : (val) >> 24)	/*!< Mask 8-bit		*/  
N#define MASK16(val)  (((val) < 65536) ? (val) : (val)>> 16) 																/*!< Mask 16-bit	*/
N
N/**
N ******************************************************************************
N * @enum        FunctionalState
N *              Enable/Disable
N ******************************************************************************
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;										/*!< Enable/Disable	*/
N/**
N ******************************************************************************
N * @enum        FlagStatus
N *              Clear/Se
N ******************************************************************************
N */
Ntypedef enum {CLR = 0, SET = !CLR} FlagStatus ,BitAction;											/*!< Clear/Set	*/
N/**
N ******************************************************************************
N * @enum        ITStatus
N *              None/Happened/Stable/Unstable
N ******************************************************************************
N */
Ntypedef enum {NONE = 0,  HAPPENED = !NONE, UNSTABLE = 0, STABLE = !UNSTABLE} ITStatus, CSCStatus;	/*!< None/Happened/Stable/Unstablee	*/       
N
N
N/**
N *************************************************
N *  Hardware Access
N *************************************************
N */
N 
N///**
N// * @brief  get register value
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// */
N//#define HW_ReadReg(_reg)             (_reg)											/*!< Hardware Read Register */
N
N///**
N// * @brief  set register value
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _value : definitions of register value, like MODULE_REGNAME_xyz
N// */
N//#define HW_WriteReg(_reg, _value)     _reg = (_value)								/*!< Hardware Write Register */
N
N///**
N// * @brief  set register bits value =1
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _mask : definitions of register mask value, like MODULE_REGNAME_mask
N// */
N//#define HW_SetBit(_reg, _mask)		HW_WriteReg(_reg, (HW_ReadReg(_reg) | (_mask))) /*!< Hardware Set Register Bit */
N
N///**
N// * @brief  set register bits value =0
N// * @param  _reg : definitions of register name, like MODULE_REGNAME
N// * @param  _mask : definitions of register mask value, like MODULE_REGNAME_mask
N// */
N//#define HW_ClrBit(_reg, _mask)		HW_WriteReg(_reg, (HW_ReadReg(_reg) & ~(_mask)))    /*!< Hardware Clear Register Bit */
N
N/**
N * @brief  get register bit value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N/**
N * @brief  clear register, value = 0
N * @param  REG : definitions of register name, like MODULE_REGNAME
N */
N#define CLEAR_REG(REG)        ((REG) = (0x0))                                       /*!< Hardware Clear Register */
N
N/**
N * @brief  set register value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  VAL : definitions of register value, like MODULE_REGNAME_xyz
N */
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))                                       /*!< Hardware Write Register */
N
N/**
N * @brief  get register value
N * @param  REG : definitions of register name, like MODULE_REGNAME
N */
N#define READ_REG(REG)         ((REG))                                               /*!< Hardware Write Register */
N
N/**
N * @brief  set register bits value =1
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))                                      /*!< Hardware Set Register Bit */
N
N/**
N * @brief  set register bits value =0
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  BIT : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))                                     /*!< Hardware Clear Register Bit */
N
N/**
N * @brief  set register bits value =1
N * @param  REG : definitions of register name, like MODULE_REGNAME
N * @param  CLEARMASK : definitions of register mask value, like MODULE_REGNAME_mask
N * @param  SETMASK : definitions of register mask value, like MODULE_REGNAME_mask
N */
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))  /*!< Hardware Register Modify */
N
N/**
N ******************************************************************************
N *
N *              Header Files Include
N *
N ******************************************************************************
N */
N//#include "MG32x02z__RegPointer.h"
N//#include "MG32x02z__RegAddress.h"
N//#include "MG32x02z_GPIO.h"
N//#include "MG32x02z_GPL.h"
N//#include "MG32x02z_DMA.h"
N//#include "MG32x02z_RST.h"
N//#include "MG32x02z_CSC.h"
N//#include "MG32x02z_PW.h"
N//#include "MG32x02z_SYS.h"
N//#include "MG32x02z_MEM.h"
N//#include "MG32x02z_EMB.h"
N//#include "MG32x02z_CFG.h"
N//#include "MG32x02z_EXIC.h"
N//#include "MG32x02z_I2C.h"
N//#include "MG32x02z_URT.h"
N//#include "MG32x02z_SPI.h"
N//#include "MG32x02z_TM.h"
N//#include "MG32x02z_ADC.h"
N//#include "MG32x02z_CMP.h"
N//#include "MG32x02z_DAC.h"
N//#include "MG32x02z_IWDT.h"
N//#include "MG32x02z_WWDT.h"
N//#include "MG32x02z_RTC.h"
N//#include "MG32x02z_APB.h"
N//#include "MG32x02z_CPU.h"
N
N#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) /* ARM Compiler V6 */
X#if 1L && (5060960 >= 6010050)  
S  #ifndef __weak
S    #define __weak  __attribute__((weak))
S  #endif
S  #ifndef __packed
S    #define __packed  __attribute__((packed))
S  #endif
S#elif defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#elif 0L && !1L  
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__ */
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) /* ARM Compiler V6 */
X#if 1L && (5060960 >= 6010050)  
S  #ifndef __ALIGN_BEGIN
S    #define __ALIGN_BEGIN
S  #endif
S  #ifndef __ALIGN_END
S    #define __ALIGN_END      __attribute__ ((aligned (4)))
S  #endif
S#elif defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#elif 0L && !1L  
S  #ifndef __ALIGN_END
S    #define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler V5*/
X    #if 1L       
N      #define __ALIGN_BEGIN    __align(4)  
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__ */
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)) || defined   (  __GNUC__  )
X#if 1L || (1L && (5060960 >= 6010050)) || 0L
N/* ARM V4/V5 and V6 & GNU Compiler
N   -------------------------------
N*/
N  #define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S  /* ICCARM Compiler
S     ---------------
S  */
S  #define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  // _MG32x02z_H
N
N/*----------------------------------------------------------------------------*/
N/*                           End of file MG32x02z.h                           */
N/*----------------------------------------------------------------------------*/
L 28 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.h" 2
N#include "MG32x02z_ADC.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_ADC.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_ADC.h
N *
N * @brief       MG32x02z ADC Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_ADC_H
N#define _MG32x02z_ADC_H
N#define _MG32x02z_ADC_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_ADC_H_VER)
S    #error "MG32x02z_ADC_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      ADC_Struct
N *              ADC  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESMPF         :1;     //[2] ADC sampling end flag
X            volatile uint8_t  ESMPF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  E1CNVF        :1;     //[3] ADC one-time conversion end flag
X            volatile uint8_t  E1CNVF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESCNVF        :1;     //[5] ADC channel scan conversion end flag
X            volatile uint8_t  ESCNVF        :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OVRF          :1;     //[7] ADC conversion overrun event flag
X            volatile uint8_t  OVRF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WDLF          :1;     //[8] ADC voltage window detect outside low event flag
X            volatile uint8_t  WDLF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WDIF          :1;     //[9] ADC voltage window detect inside event flag
X            volatile uint8_t  WDIF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  WDHF          :1;     //[10] ADC voltage window detect outside high event flag
X            volatile uint8_t  WDHF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  SUMUF         :1;     //[12] ADC data sum-0,1,2 accumulation underflow flag
X            volatile uint8_t  SUMUF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SUMOF         :1;     //[13] ADC data sum-0,1,2 accumulation overflow or underflow flag
X            volatile uint8_t  SUMOF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SUMCF         :1;     //[14] ADC data sum-0,1,2  accumulation complete flag
X            volatile uint8_t  SUMCF         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  SUMOVRF       :1;     //[15] ADC data sum-0,1,2  register overrun flag
X            volatile uint8_t  SUMOVRF       :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  POF           :1;     //[24] ADC PGA offset calibration status bit.
X            volatile uint8_t  POF           :1;     
N            __I  uint8_t  PHS           :1;     //[25] ADC sampling phase cycle status bit.
X            volatile const  uint8_t  PHS           :1;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  ADC status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] ADC interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESMP_IE       :1;     //[2] ADC sampling end interrupt enable.
X            volatile uint8_t  ESMP_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  E1CNV_IE      :1;     //[3] ADC one-time conversion end interrupt enable.
X            volatile uint8_t  E1CNV_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ESCNV_IE      :1;     //[5] ADC channel scan conversion end interrupt enable.
X            volatile uint8_t  ESCNV_IE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  OVR_IE        :1;     //[7] ADC conversion overrun event interrupt enable.
X            volatile uint8_t  OVR_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WDL_IE        :1;     //[8] ADC voltage window detect outside low event interrupt enable.
X            volatile uint8_t  WDL_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WDI_IE        :1;     //[9] ADC voltage window detect inside event interrupt enable.
X            volatile uint8_t  WDI_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WDH_IE        :1;     //[10] ADC voltage window detect outside high event interrupt enable.
X            volatile uint8_t  WDH_IE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[12..11] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  SUMO_IE       :1;     //[13] ADC data sum-0,1,2  accumulation overflow or underflow interrupt enable.
X            volatile uint8_t  SUMO_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SUMC_IE       :1;     //[14] ADC data sum-0,1,2  accumulation complete interrupt enable.
X            volatile uint8_t  SUMC_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SUMOVR_IE     :1;     //[15] ADC data sum-0,1,2  overrun event interrupt enable.
X            volatile uint8_t  SUMOVR_IE     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  ADC interrupt enable register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_DIV        :2;     //[5..4] ADC internal clock CK_ADC_INT input divider.
X            volatile uint8_t  CK_DIV        :2;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV16 : divided by 16
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CK_SEL2       :2;     //[9..8] ADC internal sampling clock CK_ADC_INT source select.
X            volatile uint8_t  CK_SEL2       :2;     
N                                        //0x0 = CK_ADC
N                                        //0x1 = CK_PLL
N                                        //0x2 = TM00_TRGO (only accept TM00_TRGO_UEV, TM00_TRGO_UEV2)
N                                        //0x3 = TM01_TRGO (only accept TM01_TRGO_UEV, TM01_TRGO_UEV2)
N            __IO uint8_t  CK_DIV2       :2;     //[11..10] ADC input clock CK_PLL divider.
X            volatile uint8_t  CK_DIV2       :2;     
N                                        //0x0 = DIV2 : divided by 2
N                                        //0x1 = DIV4 : divided by 4
N                                        //0x2 = DIV5 : divided by 5
N                                        //0x3 = DIV6 : divided by 6
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }CLK;                               /*!< CLK        ~ Offset[0x08]  ADC clock source register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t WIND_LT       :12;    //[11..0] ADC Voltage window detect lower threshold
X            volatile uint16_t WIND_LT       :12;    
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint16_t WIND_HT       :12;    //[27..16] ADC voltage window detect higher threshold
X            volatile uint16_t WIND_HT       :12;    
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }WINDTH;                            /*!< WINDTH     ~ Offset[0x0C]  ADC window detect threshold register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  EN            :1;     //[0] ADC power-on enable bit.
X            volatile uint8_t  EN            :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  AUTOFF_EN     :1;     //[1] Auto-off mode enable
X            volatile uint8_t  AUTOFF_EN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WAIT_EN       :1;     //[2] Wait conversion mode enable for low CPU frequency .
X            volatile uint8_t  WAIT_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  MDS           :1;     //[3] ADC conversion mode select
X            volatile uint8_t  MDS           :1;     
N                                        //0 = Single-End
N                                        //1 = Differential
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  DTEST_EN      :1;     //[5] ADC digital test mode enable for internal using
X            volatile uint8_t  DTEST_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  RES_SEL       :2;     //[7..6] ADC data resolution select. register.
X            volatile uint8_t  RES_SEL       :2;     
N                                        //0x0 = 12-bit
N                                        //0x1 = 10-bit
N                                        //0x2 = 8-bit
N                                        //0x3 = Reserved
N            __IO uint8_t  CODE_FMT      :1;     //[8] ADC data code output format select
X            volatile uint8_t  CODE_FMT      :1;     
N                                        //0 = Unsigned : unsigned data format
N                                        //1 = 2S : 2's complement data format
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[13..12] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  LIM_MDS       :2;     //[15..14] ADC output code spike limit function select
X            volatile uint8_t  LIM_MDS       :2;     
N                                        //0x0 = No operation
N                                        //0x1 = Skip
N                                        //0x2 = Clamp
N                                        //0x3 = Reserved
N            __IO uint8_t  SMP_SEL       :8;     //[23..16] ADC sampling time select from 0T clock to 255T clocks. Value 0 indicates 0T clock.
X            volatile uint8_t  SMP_SEL       :8;     
N            __I  uint8_t                :7;     //[30..24] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  DMA_EN        :1;     //[31] Direct memory access enable
X            volatile uint8_t  DMA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  ADC control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  WIND_EN       :1;     //[0] ADC Voltage window detect enable bit.
X            volatile uint8_t  WIND_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WIND_MDS      :1;     //[1] ADC Voltage window detect and output code spike limit function channel mode select.
X            volatile uint8_t  WIND_MDS      :1;     
N                                        //0 = Single (Single channel)
N                                        //1 = All (All scan channels)
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  ALIGN_SEL     :1;     //[3] ADC data alignment select.
X            volatile uint8_t  ALIGN_SEL     :1;     
N                                        //0 = Right (Right alignment)
N                                        //1 = Left (Left alignment)
N            __IO uint8_t  OUT_SEL       :2;     //[5..4] ADC_OUT output signal select.
X            volatile uint8_t  OUT_SEL       :2;     
N                                        //0x0 = WDL (window detect state for outside low)
N                                        //0x1 = WDI (window detect state for inside)
N                                        //0x2 = WDH (window detect state for outside high)
N                                        //0x3 = RDY (ADC_RDY internal data ready signal) 
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  OVR_MDS       :1;     //[8] ADC data buffer overrun mode select.
X            volatile uint8_t  OVR_MDS       :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old date)
N            __IO uint8_t  SOVR_MDS      :1;     //[9] ADC data sum overrun mode select.
X            volatile uint8_t  SOVR_MDS      :1;     
N                                        //0 = Overwritten (Overwritten by new data)
N                                        //1 = Keep (Preserved old date)
N            __IO uint8_t  SUM_MDS       :1;     //[10] ADC data accumulation sum channel mode select
X            volatile uint8_t  SUM_MDS       :1;     
N                                        //0 = Single (Single channel)
N                                        //1 = All (All selected scan channels)
N            __I  uint8_t                :5;     //[15..11] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  SUM_NUM       :7;     //[22..16] ADC data sum accumulation data number
X            volatile uint8_t  SUM_NUM       :7;     
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  DOS_VAL       :5;     //[28..24] ADC adjusted 2s complement value of digital offset adjuster.
X            volatile uint8_t  DOS_VAL       :5;     
N            __I  uint8_t                :3;     //[31..29] 
X            volatile const  uint8_t                :3;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  ADC control register 1 */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x18]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  CH_MSK0       :1;     //[0] ADC channel-0 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK0       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK1       :1;     //[1] ADC channel-1 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK1       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK2       :1;     //[2] ADC channel-2 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK2       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK3       :1;     //[3] ADC channel-3 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK3       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK4       :1;     //[4] ADC channel-4 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK4       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK5       :1;     //[5] ADC channel-5 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK5       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK6       :1;     //[6] ADC channel-6 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK6       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK7       :1;     //[7] ADC channel-7 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK7       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK8       :1;     //[8] ADC channel-8 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK8       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK9       :1;     //[9] ADC channel-9 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK9       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK10      :1;     //[10] ADC channel-10 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK10      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK11      :1;     //[11] ADC channel-11 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK11      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK12      :1;     //[12] ADC channel-12 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK12      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK13      :1;     //[13] ADC channel-13 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK13      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK14      :1;     //[14] ADC channel-14 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK14      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CH_MSK15      :1;     //[15] ADC channel-15 selection mask for sequence channel scan
X            volatile uint8_t  CH_MSK15      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  SUM0_MUX      :4;     //[19..16] Analog input channel selection for ADC data sum-0 function.
X            volatile uint8_t  SUM0_MUX      :4;     
N            __IO uint8_t  SUM1_MUX      :4;     //[23..20] ADC input channel selection for ADC data sum-1 function.
X            volatile uint8_t  SUM1_MUX      :4;     
N            __IO uint8_t  SUM2_MUX      :4;     //[27..24] ADC input channel selection for ADC data sum-2 function.
X            volatile uint8_t  SUM2_MUX      :4;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }MSK;                               /*!< MSK        ~ Offset[0x1C]  ADC channel mask register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  START         :1;     //[0] ADC start conversion command. (set by software and clear by hardware)
X            volatile uint8_t  START         :1;     
N            __IO uint8_t  HOLD          :1;     //[1] ADC hold conversion command.
X            volatile uint8_t  HOLD          :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CH_MUX        :4;     //[11..8] ADC input channel Mux selection
X            volatile uint8_t  CH_MUX        :4;     
N            __IO uint8_t  CH_SEL        :1;     //[12] ADC input channel Mux external or internal channel selection
X            volatile uint8_t  CH_SEL        :1;     
N                                        //0 = EXT : external channels
N                                        //1 = INT : internal channels
N            __I  uint8_t                :3;     //[15..13] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  START_SEL     :3;     //[18..16] ADC start control source select.
X            volatile uint8_t  START_SEL     :3;     
N                                        //0x0 = SW : ADC_START register setting
N                                        //0x1 = TM00 : TM00_TRGO
N                                        //0x2 = PIN : ADC_TRG : ADC external trigger pin
N                                        //0x3 = CMP0 : CMP0_OUT
N                                        //0x4 = CMP1 : CMP1_OUT
N                                        //0x5 = TM01 : TM01_TRGO
N                                        //0x6 = TM20 : TM20_TRGO
N                                        //0x7 = TM36 : TM36_TRGO
N            __IO uint8_t  TRG_CONT      :1;     //[19] ADC start trigger continuous control enable
X            volatile uint8_t  TRG_CONT      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  TRG_SEL       :2;     //[21..20] ADC start trigger selection
X            volatile uint8_t  TRG_SEL       :2;     
N                                        //0x0 = Disable
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CONV_MDS      :2;     //[25..24] ADC conversion mode select.
X            volatile uint8_t  CONV_MDS      :2;     
N                                        //0x0 = One :One shot (1-time) conversion
N                                        //0x1 = Scan :Single sequence channel-scan conversion
N                                        //0x2 = Loop :Continuous loop channel-scan conversion
N                                        //0x3 = Reserved
N            __I  uint8_t                :1;     //[26] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[31..27] 
X            volatile const  uint8_t                :5;     
N        }MBIT;
N    }START;                             /*!< START      ~ Offset[0x20]  ADC start conversion register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PGA_EN        :1;     //[2] ADC input buffer and PGA enable bit.
X            volatile uint8_t  PGA_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[5..4] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PGAOUT_EN     :1;     //[7] ADC PGA voltage output enable
X            volatile uint8_t  PGAOUT_EN     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[11..10] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  BUF_BIAS      :1;     //[12] ADC input buffer bias current control.
X            volatile uint8_t  BUF_BIAS      :1;     
N            __I  uint8_t                :2;     //[14..13] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[15] 
X            volatile const  uint8_t                :1;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }ANA;                               /*!< ANA        ~ Offset[0x24]  ADC analog control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :2;     //[1..0] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  CAL_AZEN      :1;     //[2] ADC calibration auto-zero function enable.
X            volatile uint8_t  CAL_AZEN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  CAL_POFFT     :1;     //[3] ADC PGA offset calibration function enable.
X            volatile uint8_t  CAL_POFFT     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[7..4] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t  REFB          :6;     //[13..8] ADC reference voltage bottom level setting.
X            volatile const  uint8_t  REFB          :6;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  REFM          :6;     //[21..16] ADC reference voltage middle level setting.
X            volatile const  uint8_t  REFM          :6;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  REFT          :6;     //[29..24] ADC reference voltage top level setting.
X            volatile const  uint8_t  REFT          :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }CAL;                               /*!< CAL        ~ Offset[0x28]  ADC calibration control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  GAIN_PGA      :6;     //[5..0] ADC input PGA gain adjust bits
X            volatile uint8_t  GAIN_PGA      :6;     
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[9..8] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  OFFT_PGA      :6;     //[21..16] ADC input PGA offset adjust bits.
X            volatile uint8_t  OFFT_PGA      :6;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }GAIN;                              /*!< GAIN       ~ Offset[0x2C]  ADC gain control register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t SUM0_DAT      :16;    //[15..0] ADC data accumulator sum-0 result.
X            volatile uint16_t SUM0_DAT      :16;    
N            __I  uint8_t                :4;     //[19..16] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SUM0_UF       :1;     //[20] ADC data sum-0 accumulation underflow indication status bit
X            volatile uint8_t  SUM0_UF       :1;     
N            __IO uint8_t  SUM0_OF       :1;     //[21] ADC data sum-0 accumulation overflow indication status bit
X            volatile uint8_t  SUM0_OF       :1;     
N            __IO uint8_t  SUM0_CF       :1;     //[22] ADC data sum-0 accumulation complete indication status bit
X            volatile uint8_t  SUM0_CF       :1;     
N            __IO uint8_t  SUM0_OVRF     :1;     //[23] ADC data sum register-0 overwrite/overrun indication status bit
X            volatile uint8_t  SUM0_OVRF     :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SUM0;                              /*!< SUM0       ~ Offset[0x30]  ADC accumulator sum result register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t SUM1_DAT      :16;    //[15..0] ADC data accumulator sum-1 result
X            volatile uint16_t SUM1_DAT      :16;    
N            __I  uint8_t                :4;     //[19..16] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SUM1_UF       :1;     //[20] ADC data sum-1 accumulation underflow indication status bit
X            volatile uint8_t  SUM1_UF       :1;     
N            __IO uint8_t  SUM1_OF       :1;     //[21] ADC data sum-1 accumulation overflow indication status bit
X            volatile uint8_t  SUM1_OF       :1;     
N            __IO uint8_t  SUM1_CF       :1;     //[22] ADC data sum-1 accumulation complete indication status bit
X            volatile uint8_t  SUM1_CF       :1;     
N            __IO uint8_t  SUM1_OVRF     :1;     //[23] ADC data sum register-1 overwrite/overrun indication status bit
X            volatile uint8_t  SUM1_OVRF     :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SUM1;                              /*!< SUM1       ~ Offset[0x34]  ADC accumulator sum result register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t SUM2_DAT      :16;    //[15..0] ADC data accumulator sum-2 result
X            volatile uint16_t SUM2_DAT      :16;    
N            __I  uint8_t                :4;     //[19..16] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  SUM2_UF       :1;     //[20] ADC data sum-2 accumulation underflow indication status bit
X            volatile uint8_t  SUM2_UF       :1;     
N            __IO uint8_t  SUM2_OF       :1;     //[21] ADC data sum-2 accumulation overflow indication status bit
X            volatile uint8_t  SUM2_OF       :1;     
N            __IO uint8_t  SUM2_CF       :1;     //[22] ADC data sum-2 accumulation complete indication status bit
X            volatile uint8_t  SUM2_CF       :1;     
N            __IO uint8_t  SUM2_OVRF     :1;     //[23] ADC data sum register-1 overwrite/overrun indication status bit
X            volatile uint8_t  SUM2_OVRF     :1;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }SUM2;                              /*!< SUM2       ~ Offset[0x38]  ADC accumulator sum result register 2 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t TCAL0         :12;    //[11..0] Temperature Sensor calibration ADC value 0.
X            volatile const  uint16_t TCAL0         :12;    
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint16_t TCAL1         :12;    //[27..16] Temperature Sensor calibration ADC value 1.
X            volatile const  uint16_t TCAL1         :12;    
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }TCAL;                              /*!< TCAL       ~ Offset[0x3C]  ADC Temperature Sensor calibration register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint16_t DAT0          :16;    //[15..0] ADC conversion data-0
X            volatile const  uint16_t DAT0          :16;    
N            __IO uint8_t  DAT0_WDLF     :1;     //[16] ADC voltage window detect outside low event flag
X            volatile uint8_t  DAT0_WDLF     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  DAT0_WDIF     :1;     //[17] ADC voltage window detect inside event flag
X            volatile uint8_t  DAT0_WDIF     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __IO uint8_t  DAT0_WDHF     :1;     //[18] ADC voltage window detect outside high event flag
X            volatile uint8_t  DAT0_WDHF     :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :3;     //[21..19] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  DAT0_CF       :1;     //[22] ADC conversion data-0 complete in 1-time and data ready status bit
X            volatile uint8_t  DAT0_CF       :1;     
N            __IO uint8_t  DAT0_OVRF     :1;     //[23] ADC conversion data register-0 overwrite/overrun indication status bit
X            volatile uint8_t  DAT0_OVRF     :1;     
N            __I  uint8_t                :4;     //[27..24] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t  DAT0_CH       :4;     //[31..28] ADC data conversion channel number
X            volatile const  uint8_t  DAT0_CH       :4;     
N        }MBIT;
N    }DAT0;                              /*!< DAT0       ~ Offset[0x40]  ADC conversion data register 0 */
N
N} ADC_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        ADC  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define ADC0_Base                       ((uint32_t)0x5B000000)              /*!< Analog-to-Digital Converter Control Module-0 */
N#define ADC0                            ((ADC_Struct*) ADC0_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        ADC  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        ADC_STA  [register's definitions]
N *              Offset[0x00]  ADC status register
N ******************************************************************************
N */
N///@{
N#define ADC_STA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_STA */
N#define ADC_STA_PHS_mask_w                          ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_PHS_mask_h1                         ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_STA_PHS_mask_b3                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_STA_PHS_shift_w                         (25)                    /*!< Bit Shift of 32bit */
N#define ADC_STA_PHS_shift_h1                        (9)                     /*!< Bit Shift of 16bit */
N#define ADC_STA_PHS_shift_b3                        (1)                     /*!< Bit Shift of 8bit */
N
N#define ADC_STA_POF_mask_w                          ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_POF_mask_h1                         ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_STA_POF_mask_b3                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_STA_POF_shift_w                         (24)                    /*!< Bit Shift of 32bit */
N#define ADC_STA_POF_shift_h1                        (8)                     /*!< Bit Shift of 16bit */
N#define ADC_STA_POF_shift_b3                        (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_STA_SUMOVRF_mask_w                      ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMOVRF_mask_h0                     ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMOVRF_mask_b1                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMOVRF_normal_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMOVRF_normal_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMOVRF_normal_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMOVRF_happened_w                  ((uint32_t)0x00008000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMOVRF_happened_h0                 ((uint16_t)0x8000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMOVRF_happened_b1                 ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_SUMCF_mask_w                        ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMCF_mask_h0                       ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMCF_mask_b1                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMCF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMCF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMCF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMCF_happened_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMCF_happened_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMCF_happened_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_SUMOF_mask_w                        ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMOF_mask_h0                       ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMOF_mask_b1                       ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMOF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMOF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMOF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMOF_happened_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMOF_happened_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMOF_happened_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_SUMUF_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_STA_SUMUF_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_STA_SUMUF_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_STA_SUMUF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_SUMUF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_SUMUF_normal_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_SUMUF_happened_w                    ((uint32_t)0x00001000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_SUMUF_happened_h0                   ((uint16_t)0x1000)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_SUMUF_happened_b1                   ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_WDHF_mask_w                         ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_STA_WDHF_mask_h0                        ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_STA_WDHF_mask_b1                        ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_STA_WDHF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_WDHF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_WDHF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_WDHF_happened_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_WDHF_happened_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_WDHF_happened_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_WDIF_mask_w                         ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_STA_WDIF_mask_h0                        ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_STA_WDIF_mask_b1                        ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_STA_WDIF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_WDIF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_WDIF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_WDIF_happened_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_WDIF_happened_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_WDIF_happened_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_WDLF_mask_w                         ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_STA_WDLF_mask_h0                        ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_STA_WDLF_mask_b1                        ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_STA_WDLF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_WDLF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_WDLF_normal_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_WDLF_happened_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_WDLF_happened_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_WDLF_happened_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_OVRF_mask_w                         ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_STA_OVRF_mask_h0                        ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_STA_OVRF_mask_b0                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_STA_OVRF_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_OVRF_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_OVRF_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_OVRF_happened_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_OVRF_happened_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_OVRF_happened_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_ESCNVF_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_STA_ESCNVF_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_STA_ESCNVF_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_STA_ESCNVF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_ESCNVF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_ESCNVF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_ESCNVF_happened_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_ESCNVF_happened_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_ESCNVF_happened_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_E1CNVF_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_STA_E1CNVF_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_STA_E1CNVF_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_STA_E1CNVF_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_E1CNVF_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_E1CNVF_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_E1CNVF_happened_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_E1CNVF_happened_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_E1CNVF_happened_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_STA_ESMPF_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_STA_ESMPF_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_STA_ESMPF_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_STA_ESMPF_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_STA_ESMPF_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_STA_ESMPF_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_STA_ESMPF_happened_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_STA_ESMPF_happened_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_STA_ESMPF_happened_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_INT  [register's definitions]
N *              Offset[0x04]  ADC interrupt enable register
N ******************************************************************************
N */
N///@{
N#define ADC_INT_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_INT */
N#define ADC_INT_SUMOVR_IE_mask_w                    ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define ADC_INT_SUMOVR_IE_mask_h0                   ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_INT_SUMOVR_IE_mask_b1                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_INT_SUMOVR_IE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_SUMOVR_IE_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_SUMOVR_IE_disable_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_SUMOVR_IE_enable_w                  ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_SUMOVR_IE_enable_h0                 ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_SUMOVR_IE_enable_b1                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_SUMC_IE_mask_w                      ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define ADC_INT_SUMC_IE_mask_h0                     ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define ADC_INT_SUMC_IE_mask_b1                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_INT_SUMC_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_SUMC_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_SUMC_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_SUMC_IE_enable_w                    ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_SUMC_IE_enable_h0                   ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_SUMC_IE_enable_b1                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_SUMO_IE_mask_w                      ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define ADC_INT_SUMO_IE_mask_h0                     ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define ADC_INT_SUMO_IE_mask_b1                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_INT_SUMO_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_SUMO_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_SUMO_IE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_SUMO_IE_enable_w                    ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_SUMO_IE_enable_h0                   ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_SUMO_IE_enable_b1                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_WDH_IE_mask_w                       ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_INT_WDH_IE_mask_h0                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_INT_WDH_IE_mask_b1                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_INT_WDH_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_WDH_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_WDH_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_WDH_IE_enable_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_WDH_IE_enable_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_WDH_IE_enable_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_WDI_IE_mask_w                       ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_INT_WDI_IE_mask_h0                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_INT_WDI_IE_mask_b1                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_INT_WDI_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_WDI_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_WDI_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_WDI_IE_enable_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_WDI_IE_enable_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_WDI_IE_enable_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_WDL_IE_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_INT_WDL_IE_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_INT_WDL_IE_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_INT_WDL_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_WDL_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_WDL_IE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_WDL_IE_enable_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_WDL_IE_enable_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_WDL_IE_enable_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_OVR_IE_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_INT_OVR_IE_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_INT_OVR_IE_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_INT_OVR_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_OVR_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_OVR_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_OVR_IE_enable_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_OVR_IE_enable_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_OVR_IE_enable_b0                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_ESCNV_IE_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_INT_ESCNV_IE_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_INT_ESCNV_IE_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_INT_ESCNV_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_ESCNV_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_ESCNV_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_ESCNV_IE_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_ESCNV_IE_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_ESCNV_IE_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_E1CNV_IE_mask_w                     ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_INT_E1CNV_IE_mask_h0                    ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_INT_E1CNV_IE_mask_b0                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_INT_E1CNV_IE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_E1CNV_IE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_E1CNV_IE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_E1CNV_IE_enable_w                   ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_E1CNV_IE_enable_h0                  ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_E1CNV_IE_enable_b0                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_ESMP_IE_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_INT_ESMP_IE_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_INT_ESMP_IE_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_INT_ESMP_IE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_ESMP_IE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_ESMP_IE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_ESMP_IE_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_ESMP_IE_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_ESMP_IE_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_INT_IEA_mask_w                          ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_INT_IEA_mask_h0                         ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_INT_IEA_mask_b0                         ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_INT_IEA_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_INT_IEA_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_INT_IEA_disable_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_INT_IEA_enable_w                        ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_INT_IEA_enable_h0                       ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_INT_IEA_enable_b0                       ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CLK  [register's definitions]
N *              Offset[0x08]  ADC clock source register
N ******************************************************************************
N */
N///@{
N#define ADC_CLK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CLK */
N#define ADC_CLK_CK_DIV2_mask_w                      ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define ADC_CLK_CK_DIV2_mask_h0                     ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define ADC_CLK_CK_DIV2_mask_b1                     ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define ADC_CLK_CK_DIV2_div2_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV2 of 32bit */
N#define ADC_CLK_CK_DIV2_div2_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV2 of 16bit */
N#define ADC_CLK_CK_DIV2_div2_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV2 of 8bit */
N#define ADC_CLK_CK_DIV2_div4_w                      ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):DIV4 of 32bit */
N#define ADC_CLK_CK_DIV2_div4_h0                     ((uint16_t)0x0400)      /*!< Bit Value =(0x1):DIV4 of 16bit */
N#define ADC_CLK_CK_DIV2_div4_b1                     ((uint8_t )0x04)        /*!< Bit Value =(0x1):DIV4 of 8bit */
N#define ADC_CLK_CK_DIV2_div5_w                      ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):DIV5 of 32bit */
N#define ADC_CLK_CK_DIV2_div5_h0                     ((uint16_t)0x0800)      /*!< Bit Value =(0x2):DIV5 of 16bit */
N#define ADC_CLK_CK_DIV2_div5_b1                     ((uint8_t )0x08)        /*!< Bit Value =(0x2):DIV5 of 8bit */
N#define ADC_CLK_CK_DIV2_div6_w                      ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):DIV6 of 32bit */
N#define ADC_CLK_CK_DIV2_div6_h0                     ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):DIV6 of 16bit */
N#define ADC_CLK_CK_DIV2_div6_b1                     ((uint8_t )0x0C)        /*!< Bit Value =(0x3):DIV6 of 8bit */
N
N#define ADC_CLK_CK_SEL2_mask_w                      ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define ADC_CLK_CK_SEL2_mask_h0                     ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define ADC_CLK_CK_SEL2_mask_b1                     ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define ADC_CLK_CK_SEL2_ck_adc_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):CK_ADC of 32bit */
N#define ADC_CLK_CK_SEL2_ck_adc_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):CK_ADC of 16bit */
N#define ADC_CLK_CK_SEL2_ck_adc_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):CK_ADC of 8bit */
N#define ADC_CLK_CK_SEL2_ck_pll_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):CK_PLL of 32bit */
N#define ADC_CLK_CK_SEL2_ck_pll_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(0x1):CK_PLL of 16bit */
N#define ADC_CLK_CK_SEL2_ck_pll_b1                   ((uint8_t )0x01)        /*!< Bit Value =(0x1):CK_PLL of 8bit */
N#define ADC_CLK_CK_SEL2_tm00_trgo_w                 ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):TM00_TRGO of 32bit */
N#define ADC_CLK_CK_SEL2_tm00_trgo_h0                ((uint16_t)0x0200)      /*!< Bit Value =(0x2):TM00_TRGO of 16bit */
N#define ADC_CLK_CK_SEL2_tm00_trgo_b1                ((uint8_t )0x02)        /*!< Bit Value =(0x2):TM00_TRGO of 8bit */
N#define ADC_CLK_CK_SEL2_tm01_trgo_w                 ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):TM01_TRGO of 32bit */
N#define ADC_CLK_CK_SEL2_tm01_trgo_h0                ((uint16_t)0x0300)      /*!< Bit Value =(0x3):TM01_TRGO of 16bit */
N#define ADC_CLK_CK_SEL2_tm01_trgo_b1                ((uint8_t )0x03)        /*!< Bit Value =(0x3):TM01_TRGO of 8bit */
N
N#define ADC_CLK_CK_DIV_mask_w                       ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define ADC_CLK_CK_DIV_mask_h0                      ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define ADC_CLK_CK_DIV_mask_b0                      ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define ADC_CLK_CK_DIV_div1_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define ADC_CLK_CK_DIV_div1_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define ADC_CLK_CK_DIV_div1_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define ADC_CLK_CK_DIV_div2_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define ADC_CLK_CK_DIV_div2_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define ADC_CLK_CK_DIV_div2_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define ADC_CLK_CK_DIV_div4_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define ADC_CLK_CK_DIV_div4_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define ADC_CLK_CK_DIV_div4_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define ADC_CLK_CK_DIV_div16_w                      ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV16 of 32bit */
N#define ADC_CLK_CK_DIV_div16_h0                     ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV16 of 16bit */
N#define ADC_CLK_CK_DIV_div16_b0                     ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV16 of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_WINDTH  [register's definitions]
N *              Offset[0x0C]  ADC window detect threshold register
N ******************************************************************************
N */
N///@{
N#define ADC_WINDTH_default                          ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_WINDTH */
N#define ADC_WINDTH_WIND_HT_mask_w                   ((uint32_t)0x0FFF0000)  /*!< Bit Mask of 32bit */
N#define ADC_WINDTH_WIND_HT_mask_h1                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_WINDTH_WIND_HT_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define ADC_WINDTH_WIND_HT_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define ADC_WINDTH_WIND_HT_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_WINDTH_WIND_LT_mask_w                   ((uint32_t)0x00000FFF)  /*!< Bit Mask of 32bit */
N#define ADC_WINDTH_WIND_LT_mask_h0                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_WINDTH_WIND_LT_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define ADC_WINDTH_WIND_LT_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define ADC_WINDTH_WIND_LT_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CR0  [register's definitions]
N *              Offset[0x10]  ADC control register 0
N ******************************************************************************
N */
N///@{
N#define ADC_CR0_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CR0 */
N#define ADC_CR0_DMA_EN_mask_w                       ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_DMA_EN_mask_h1                      ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_DMA_EN_mask_b3                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_DMA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_DMA_EN_disable_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_DMA_EN_disable_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_DMA_EN_enable_w                     ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_DMA_EN_enable_h1                    ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_DMA_EN_enable_b3                    ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_SMP_SEL_mask_w                      ((uint32_t)0x00FF0000)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_SMP_SEL_mask_h1                     ((uint16_t)0x00FF)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_SMP_SEL_mask_b2                     ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_SMP_SEL_shift_w                     (16)                    /*!< Bit Shift of 32bit */
N#define ADC_CR0_SMP_SEL_shift_h1                    (0)                     /*!< Bit Shift of 16bit */
N#define ADC_CR0_SMP_SEL_shift_b2                    (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CR0_LIM_MDS_mask_w                      ((uint32_t)0x0000C000)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_LIM_MDS_mask_h0                     ((uint16_t)0xC000)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_LIM_MDS_mask_b1                     ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_LIM_MDS_no_operation_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):No operation of 32bit */
N#define ADC_CR0_LIM_MDS_no_operation_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0x0):No operation of 16bit */
N#define ADC_CR0_LIM_MDS_no_operation_b1             ((uint8_t )0x00)        /*!< Bit Value =(0x0):No operation of 8bit */
N#define ADC_CR0_LIM_MDS_skip_w                      ((uint32_t)0x00004000)  /*!< Bit Value =(0x1):Skip of 32bit */
N#define ADC_CR0_LIM_MDS_skip_h0                     ((uint16_t)0x4000)      /*!< Bit Value =(0x1):Skip of 16bit */
N#define ADC_CR0_LIM_MDS_skip_b1                     ((uint8_t )0x40)        /*!< Bit Value =(0x1):Skip of 8bit */
N#define ADC_CR0_LIM_MDS_clamp_w                     ((uint32_t)0x00008000)  /*!< Bit Value =(0x2):Clamp of 32bit */
N#define ADC_CR0_LIM_MDS_clamp_h0                    ((uint16_t)0x8000)      /*!< Bit Value =(0x2):Clamp of 16bit */
N#define ADC_CR0_LIM_MDS_clamp_b1                    ((uint8_t )0x80)        /*!< Bit Value =(0x2):Clamp of 8bit */
N
N#define ADC_CR0_CODE_FMT_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_CODE_FMT_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_CODE_FMT_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_CODE_FMT_unsigned_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unsigned of 32bit */
N#define ADC_CR0_CODE_FMT_unsigned_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Unsigned of 16bit */
N#define ADC_CR0_CODE_FMT_unsigned_b1                ((uint8_t )0x00)        /*!< Bit Value =(0):Unsigned of 8bit */
N#define ADC_CR0_CODE_FMT_2s_w                       ((uint32_t)0x00000100)  /*!< Bit Value =(1):2S of 32bit */
N#define ADC_CR0_CODE_FMT_2s_h0                      ((uint16_t)0x0100)      /*!< Bit Value =(1):2S of 16bit */
N#define ADC_CR0_CODE_FMT_2s_b1                      ((uint8_t )0x01)        /*!< Bit Value =(1):2S of 8bit */
N
N#define ADC_CR0_RES_SEL_mask_w                      ((uint32_t)0x000000C0)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_RES_SEL_mask_h0                     ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_RES_SEL_mask_b0                     ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_RES_SEL_12_bit_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):12-bit of 32bit */
N#define ADC_CR0_RES_SEL_12_bit_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):12-bit of 16bit */
N#define ADC_CR0_RES_SEL_12_bit_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):12-bit of 8bit */
N#define ADC_CR0_RES_SEL_10_bit_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(0x1):10-bit of 32bit */
N#define ADC_CR0_RES_SEL_10_bit_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(0x1):10-bit of 16bit */
N#define ADC_CR0_RES_SEL_10_bit_b0                   ((uint8_t )0x40)        /*!< Bit Value =(0x1):10-bit of 8bit */
N#define ADC_CR0_RES_SEL_8_bit_w                     ((uint32_t)0x00000080)  /*!< Bit Value =(0x2):8-bit of 32bit */
N#define ADC_CR0_RES_SEL_8_bit_h0                    ((uint16_t)0x0080)      /*!< Bit Value =(0x2):8-bit of 16bit */
N#define ADC_CR0_RES_SEL_8_bit_b0                    ((uint8_t )0x80)        /*!< Bit Value =(0x2):8-bit of 8bit */
N
N#define ADC_CR0_DTEST_EN_mask_w                     ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_DTEST_EN_mask_h0                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_DTEST_EN_mask_b0                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_DTEST_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_DTEST_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_DTEST_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_DTEST_EN_enable_w                   ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_DTEST_EN_enable_h0                  ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_DTEST_EN_enable_b0                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_MDS_mask_w                          ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_MDS_mask_h0                         ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_MDS_mask_b0                         ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_MDS_single_end_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Single-End of 32bit */
N#define ADC_CR0_MDS_single_end_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Single-End of 16bit */
N#define ADC_CR0_MDS_single_end_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Single-End of 8bit */
N#define ADC_CR0_MDS_differential_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):Differential of 32bit */
N#define ADC_CR0_MDS_differential_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Differential of 16bit */
N#define ADC_CR0_MDS_differential_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):Differential of 8bit */
N
N#define ADC_CR0_WAIT_EN_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_WAIT_EN_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_WAIT_EN_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_WAIT_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_WAIT_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_WAIT_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_WAIT_EN_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_WAIT_EN_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_WAIT_EN_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_AUTOFF_EN_mask_w                    ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_AUTOFF_EN_mask_h0                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_AUTOFF_EN_mask_b0                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_AUTOFF_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_AUTOFF_EN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_AUTOFF_EN_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_AUTOFF_EN_enable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_AUTOFF_EN_enable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_AUTOFF_EN_enable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CR0_EN_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_CR0_EN_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_CR0_EN_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR0_EN_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR0_EN_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR0_EN_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR0_EN_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR0_EN_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR0_EN_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CR1  [register's definitions]
N *              Offset[0x14]  ADC control register 1
N ******************************************************************************
N */
N///@{
N#define ADC_CR1_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CR1 */
N#define ADC_CR1_DOS_VAL_mask_w                      ((uint32_t)0x1F000000)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_DOS_VAL_mask_h1                     ((uint16_t)0x1F00)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_DOS_VAL_mask_b3                     ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_DOS_VAL_shift_w                     (24)                    /*!< Bit Shift of 32bit */
N#define ADC_CR1_DOS_VAL_shift_h1                    (8)                     /*!< Bit Shift of 16bit */
N#define ADC_CR1_DOS_VAL_shift_b3                    (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CR1_SUM_NUM_mask_w                      ((uint32_t)0x007F0000)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_SUM_NUM_mask_h1                     ((uint16_t)0x007F)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_SUM_NUM_mask_b2                     ((uint8_t )0x7F)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_SUM_NUM_shift_w                     (16)                    /*!< Bit Shift of 32bit */
N#define ADC_CR1_SUM_NUM_shift_h1                    (0)                     /*!< Bit Shift of 16bit */
N#define ADC_CR1_SUM_NUM_shift_b2                    (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CR1_SUM_MDS_mask_w                      ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_SUM_MDS_mask_h0                     ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_SUM_MDS_mask_b1                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_SUM_MDS_single_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Single of 32bit */
N#define ADC_CR1_SUM_MDS_single_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Single of 16bit */
N#define ADC_CR1_SUM_MDS_single_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Single of 8bit */
N#define ADC_CR1_SUM_MDS_all_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(1):All of 32bit */
N#define ADC_CR1_SUM_MDS_all_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(1):All of 16bit */
N#define ADC_CR1_SUM_MDS_all_b1                      ((uint8_t )0x04)        /*!< Bit Value =(1):All of 8bit */
N
N#define ADC_CR1_SOVR_MDS_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_SOVR_MDS_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_SOVR_MDS_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_SOVR_MDS_overwritten_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define ADC_CR1_SOVR_MDS_overwritten_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define ADC_CR1_SOVR_MDS_overwritten_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define ADC_CR1_SOVR_MDS_keep_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Keep of 32bit */
N#define ADC_CR1_SOVR_MDS_keep_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Keep of 16bit */
N#define ADC_CR1_SOVR_MDS_keep_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define ADC_CR1_OVR_MDS_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_OVR_MDS_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_OVR_MDS_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_OVR_MDS_overwritten_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Overwritten of 32bit */
N#define ADC_CR1_OVR_MDS_overwritten_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Overwritten of 16bit */
N#define ADC_CR1_OVR_MDS_overwritten_b1              ((uint8_t )0x00)        /*!< Bit Value =(0):Overwritten of 8bit */
N#define ADC_CR1_OVR_MDS_keep_w                      ((uint32_t)0x00000100)  /*!< Bit Value =(1):Keep of 32bit */
N#define ADC_CR1_OVR_MDS_keep_h0                     ((uint16_t)0x0100)      /*!< Bit Value =(1):Keep of 16bit */
N#define ADC_CR1_OVR_MDS_keep_b1                     ((uint8_t )0x01)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define ADC_CR1_OUT_SEL_mask_w                      ((uint32_t)0x00000030)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_OUT_SEL_mask_h0                     ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_OUT_SEL_mask_b0                     ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_OUT_SEL_wdl_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):WDL of 32bit */
N#define ADC_CR1_OUT_SEL_wdl_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):WDL of 16bit */
N#define ADC_CR1_OUT_SEL_wdl_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):WDL of 8bit */
N#define ADC_CR1_OUT_SEL_wdi_w                       ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):WDI of 32bit */
N#define ADC_CR1_OUT_SEL_wdi_h0                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):WDI of 16bit */
N#define ADC_CR1_OUT_SEL_wdi_b0                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):WDI of 8bit */
N#define ADC_CR1_OUT_SEL_wdh_w                       ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):WDH of 32bit */
N#define ADC_CR1_OUT_SEL_wdh_h0                      ((uint16_t)0x0020)      /*!< Bit Value =(0x2):WDH of 16bit */
N#define ADC_CR1_OUT_SEL_wdh_b0                      ((uint8_t )0x20)        /*!< Bit Value =(0x2):WDH of 8bit */
N#define ADC_CR1_OUT_SEL_rdy_w                       ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):RDY of 32bit */
N#define ADC_CR1_OUT_SEL_rdy_h0                      ((uint16_t)0x0030)      /*!< Bit Value =(0x3):RDY of 16bit */
N#define ADC_CR1_OUT_SEL_rdy_b0                      ((uint8_t )0x30)        /*!< Bit Value =(0x3):RDY of 8bit */
N
N#define ADC_CR1_ALIGN_SEL_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_ALIGN_SEL_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_ALIGN_SEL_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_ALIGN_SEL_right_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Right of 32bit */
N#define ADC_CR1_ALIGN_SEL_right_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Right of 16bit */
N#define ADC_CR1_ALIGN_SEL_right_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Right of 8bit */
N#define ADC_CR1_ALIGN_SEL_left_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Left of 32bit */
N#define ADC_CR1_ALIGN_SEL_left_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Left of 16bit */
N#define ADC_CR1_ALIGN_SEL_left_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Left of 8bit */
N
N#define ADC_CR1_WIND_MDS_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_WIND_MDS_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_WIND_MDS_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_WIND_MDS_single_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Single of 32bit */
N#define ADC_CR1_WIND_MDS_single_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Single of 16bit */
N#define ADC_CR1_WIND_MDS_single_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Single of 8bit */
N#define ADC_CR1_WIND_MDS_all_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):All of 32bit */
N#define ADC_CR1_WIND_MDS_all_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):All of 16bit */
N#define ADC_CR1_WIND_MDS_all_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):All of 8bit */
N
N#define ADC_CR1_WIND_EN_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_CR1_WIND_EN_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_CR1_WIND_EN_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_CR1_WIND_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CR1_WIND_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CR1_WIND_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CR1_WIND_EN_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CR1_WIND_EN_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CR1_WIND_EN_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_MSK  [register's definitions]
N *              Offset[0x1C]  ADC channel mask register
N ******************************************************************************
N */
N///@{
N#define ADC_MSK_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_MSK */
N#define ADC_MSK_SUM2_MUX_mask_w                     ((uint32_t)0x0F000000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_SUM2_MUX_mask_h1                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_SUM2_MUX_mask_b3                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_SUM2_MUX_shift_w                    (24)                    /*!< Bit Shift of 32bit */
N#define ADC_MSK_SUM2_MUX_shift_h1                   (8)                     /*!< Bit Shift of 16bit */
N#define ADC_MSK_SUM2_MUX_shift_b3                   (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_MSK_SUM1_MUX_mask_w                     ((uint32_t)0x00F00000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_SUM1_MUX_mask_h1                    ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_SUM1_MUX_mask_b2                    ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_SUM1_MUX_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_MSK_SUM1_MUX_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_MSK_SUM1_MUX_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_MSK_SUM0_MUX_mask_w                     ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_SUM0_MUX_mask_h1                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_SUM0_MUX_mask_b2                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_SUM0_MUX_shift_w                    (16)                    /*!< Bit Shift of 32bit */
N#define ADC_MSK_SUM0_MUX_shift_h1                   (0)                     /*!< Bit Shift of 16bit */
N#define ADC_MSK_SUM0_MUX_shift_b2                   (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_MSK_CH_MSK15_mask_w                     ((uint32_t)0x00008000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK15_mask_h0                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK15_mask_b1                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK15_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK15_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK15_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK15_enable_w                   ((uint32_t)0x00008000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK15_enable_h0                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK15_enable_b1                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK14_mask_w                     ((uint32_t)0x00004000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK14_mask_h0                    ((uint16_t)0x4000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK14_mask_b1                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK14_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK14_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK14_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK14_enable_w                   ((uint32_t)0x00004000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK14_enable_h0                  ((uint16_t)0x4000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK14_enable_b1                  ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK13_mask_w                     ((uint32_t)0x00002000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK13_mask_h0                    ((uint16_t)0x2000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK13_mask_b1                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK13_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK13_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK13_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK13_enable_w                   ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK13_enable_h0                  ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK13_enable_b1                  ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK12_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK12_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK12_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK12_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK12_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK12_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK12_enable_w                   ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK12_enable_h0                  ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK12_enable_b1                  ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK11_mask_w                     ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK11_mask_h0                    ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK11_mask_b1                    ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK11_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK11_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK11_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK11_enable_w                   ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK11_enable_h0                  ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK11_enable_b1                  ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK10_mask_w                     ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK10_mask_h0                    ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK10_mask_b1                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK10_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK10_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK10_disable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK10_enable_w                   ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK10_enable_h0                  ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK10_enable_b1                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK9_mask_w                      ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK9_mask_h0                     ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK9_mask_b1                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK9_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK9_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK9_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK9_enable_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK9_enable_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK9_enable_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK8_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK8_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK8_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK8_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK8_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK8_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK8_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK8_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK8_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK7_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK7_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK7_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK7_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK7_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK7_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK7_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK7_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK7_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK6_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK6_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK6_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK6_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK6_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK6_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK6_enable_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK6_enable_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK6_enable_b0                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK5_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK5_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK5_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK5_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK5_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK5_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK5_enable_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK5_enable_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK5_enable_b0                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK4_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK4_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK4_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK4_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK4_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK4_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK4_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK4_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK4_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK3_mask_w                      ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK3_mask_h0                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK3_mask_b0                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK3_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK3_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK3_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK3_enable_w                    ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK3_enable_h0                   ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK3_enable_b0                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK2_mask_w                      ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK2_mask_h0                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK2_mask_b0                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK2_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK2_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK2_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK2_enable_w                    ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK2_enable_h0                   ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK2_enable_b0                   ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK1_mask_w                      ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK1_mask_h0                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK1_mask_b0                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK1_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK1_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK1_enable_w                    ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK1_enable_h0                   ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK1_enable_b0                   ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_MSK_CH_MSK0_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_MSK_CH_MSK0_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_MSK_CH_MSK0_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_MSK_CH_MSK0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_MSK_CH_MSK0_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_MSK_CH_MSK0_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_MSK_CH_MSK0_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_MSK_CH_MSK0_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_MSK_CH_MSK0_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_START  [register's definitions]
N *              Offset[0x20]  ADC start conversion register
N ******************************************************************************
N */
N///@{
N#define ADC_START_default                           ((uint32_t)0x00001000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_START */
N#define ADC_START_CONV_MDS_mask_w                   ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define ADC_START_CONV_MDS_mask_h1                  ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define ADC_START_CONV_MDS_mask_b3                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define ADC_START_CONV_MDS_one_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):One of 32bit */
N#define ADC_START_CONV_MDS_one_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):One of 16bit */
N#define ADC_START_CONV_MDS_one_b3                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):One of 8bit */
N#define ADC_START_CONV_MDS_scan_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Scan of 32bit */
N#define ADC_START_CONV_MDS_scan_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Scan of 16bit */
N#define ADC_START_CONV_MDS_scan_b3                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):Scan of 8bit */
N#define ADC_START_CONV_MDS_loop_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):Loop of 32bit */
N#define ADC_START_CONV_MDS_loop_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Loop of 16bit */
N#define ADC_START_CONV_MDS_loop_b3                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):Loop of 8bit */
N
N#define ADC_START_TRG_SEL_mask_w                    ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define ADC_START_TRG_SEL_mask_h1                   ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define ADC_START_TRG_SEL_mask_b2                   ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define ADC_START_TRG_SEL_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Disable of 32bit */
N#define ADC_START_TRG_SEL_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Disable of 16bit */
N#define ADC_START_TRG_SEL_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0x0):Disable of 8bit */
N#define ADC_START_TRG_SEL_rising_edge_w             ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define ADC_START_TRG_SEL_rising_edge_h1            ((uint16_t)0x0010)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define ADC_START_TRG_SEL_rising_edge_b2            ((uint8_t )0x10)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define ADC_START_TRG_SEL_falling_edge_w            ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define ADC_START_TRG_SEL_falling_edge_h1           ((uint16_t)0x0020)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define ADC_START_TRG_SEL_falling_edge_b2           ((uint8_t )0x20)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define ADC_START_TRG_SEL_dual_edge_w               ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define ADC_START_TRG_SEL_dual_edge_h1              ((uint16_t)0x0030)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define ADC_START_TRG_SEL_dual_edge_b2              ((uint8_t )0x30)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define ADC_START_TRG_CONT_mask_w                   ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define ADC_START_TRG_CONT_mask_h1                  ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_START_TRG_CONT_mask_b2                  ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_START_TRG_CONT_disable_w                ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_START_TRG_CONT_disable_h1               ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_START_TRG_CONT_disable_b2               ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_START_TRG_CONT_enable_w                 ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_START_TRG_CONT_enable_h1                ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_START_TRG_CONT_enable_b2                ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_START_START_SEL_mask_w                  ((uint32_t)0x00070000)  /*!< Bit Mask of 32bit */
N#define ADC_START_START_SEL_mask_h1                 ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define ADC_START_START_SEL_mask_b2                 ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define ADC_START_START_SEL_sw_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):SW of 32bit */
N#define ADC_START_START_SEL_sw_h1                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):SW of 16bit */
N#define ADC_START_START_SEL_sw_b2                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):SW of 8bit */
N#define ADC_START_START_SEL_tm00_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):TM00 of 32bit */
N#define ADC_START_START_SEL_tm00_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(0x1):TM00 of 16bit */
N#define ADC_START_START_SEL_tm00_b2                 ((uint8_t )0x01)        /*!< Bit Value =(0x1):TM00 of 8bit */
N#define ADC_START_START_SEL_pin_w                   ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):PIN of 32bit */
N#define ADC_START_START_SEL_pin_h1                  ((uint16_t)0x0002)      /*!< Bit Value =(0x2):PIN of 16bit */
N#define ADC_START_START_SEL_pin_b2                  ((uint8_t )0x02)        /*!< Bit Value =(0x2):PIN of 8bit */
N#define ADC_START_START_SEL_cmp0_w                  ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):CMP0 of 32bit */
N#define ADC_START_START_SEL_cmp0_h1                 ((uint16_t)0x0003)      /*!< Bit Value =(0x3):CMP0 of 16bit */
N#define ADC_START_START_SEL_cmp0_b2                 ((uint8_t )0x03)        /*!< Bit Value =(0x3):CMP0 of 8bit */
N#define ADC_START_START_SEL_cmp1_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(0x4):CMP1 of 32bit */
N#define ADC_START_START_SEL_cmp1_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(0x4):CMP1 of 16bit */
N#define ADC_START_START_SEL_cmp1_b2                 ((uint8_t )0x04)        /*!< Bit Value =(0x4):CMP1 of 8bit */
N#define ADC_START_START_SEL_tm01_w                  ((uint32_t)0x00050000)  /*!< Bit Value =(0x5):TM01 of 32bit */
N#define ADC_START_START_SEL_tm01_h1                 ((uint16_t)0x0005)      /*!< Bit Value =(0x5):TM01 of 16bit */
N#define ADC_START_START_SEL_tm01_b2                 ((uint8_t )0x05)        /*!< Bit Value =(0x5):TM01 of 8bit */
N#define ADC_START_START_SEL_tm20_w                  ((uint32_t)0x00060000)  /*!< Bit Value =(0x6):TM20 of 32bit */
N#define ADC_START_START_SEL_tm20_h1                 ((uint16_t)0x0006)      /*!< Bit Value =(0x6):TM20 of 16bit */
N#define ADC_START_START_SEL_tm20_b2                 ((uint8_t )0x06)        /*!< Bit Value =(0x6):TM20 of 8bit */
N#define ADC_START_START_SEL_tm36_w                  ((uint32_t)0x00070000)  /*!< Bit Value =(0x7):TM36 of 32bit */
N#define ADC_START_START_SEL_tm36_h1                 ((uint16_t)0x0007)      /*!< Bit Value =(0x7):TM36 of 16bit */
N#define ADC_START_START_SEL_tm36_b2                 ((uint8_t )0x07)        /*!< Bit Value =(0x7):TM36 of 8bit */
N
N#define ADC_START_CH_SEL_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_START_CH_SEL_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_START_CH_SEL_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_START_CH_SEL_ext_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):EXT of 32bit */
N#define ADC_START_CH_SEL_ext_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):EXT of 16bit */
N#define ADC_START_CH_SEL_ext_b1                     ((uint8_t )0x00)        /*!< Bit Value =(0):EXT of 8bit */
N#define ADC_START_CH_SEL_int_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):INT of 32bit */
N#define ADC_START_CH_SEL_int_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):INT of 16bit */
N#define ADC_START_CH_SEL_int_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):INT of 8bit */
N
N#define ADC_START_CH_MUX_mask_w                     ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define ADC_START_CH_MUX_mask_h0                    ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define ADC_START_CH_MUX_mask_b1                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N
N#define ADC_START_HOLD_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define ADC_START_HOLD_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_START_HOLD_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_START_HOLD_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_START_HOLD_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_START_HOLD_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_START_HOLD_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_START_HOLD_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_START_HOLD_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_START_START_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define ADC_START_START_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_START_START_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_START_START_shift_w                     (0)                     /*!< Bit Shift of 32bit */
N#define ADC_START_START_shift_h0                    (0)                     /*!< Bit Shift of 16bit */
N#define ADC_START_START_shift_b0                    (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_ANA  [register's definitions]
N *              Offset[0x24]  ADC analog control register
N ******************************************************************************
N */
N///@{
N#define ADC_ANA_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_ANA */
N#define ADC_ANA_BUF_BIAS_mask_w                     ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define ADC_ANA_BUF_BIAS_mask_h0                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define ADC_ANA_BUF_BIAS_mask_b1                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_ANA_BUF_BIAS_shift_w                    (12)                    /*!< Bit Shift of 32bit */
N#define ADC_ANA_BUF_BIAS_shift_h0                   (12)                    /*!< Bit Shift of 16bit */
N#define ADC_ANA_BUF_BIAS_shift_b1                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_ANA_PGAOUT_EN_mask_w                    ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define ADC_ANA_PGAOUT_EN_mask_h0                   ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_ANA_PGAOUT_EN_mask_b0                   ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_ANA_PGAOUT_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_ANA_PGAOUT_EN_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_ANA_PGAOUT_EN_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_ANA_PGAOUT_EN_enable_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_ANA_PGAOUT_EN_enable_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_ANA_PGAOUT_EN_enable_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_ANA_PGA_EN_mask_w                       ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_ANA_PGA_EN_mask_h0                      ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_ANA_PGA_EN_mask_b0                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_ANA_PGA_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_ANA_PGA_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_ANA_PGA_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_ANA_PGA_EN_enable_w                     ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_ANA_PGA_EN_enable_h0                    ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_ANA_PGA_EN_enable_b0                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_CAL  [register's definitions]
N *              Offset[0x28]  ADC calibration control register
N ******************************************************************************
N */
N///@{
N#define ADC_CAL_default                             ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_CAL */
N#define ADC_CAL_REFT_mask_w                         ((uint32_t)0x3F000000)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_REFT_mask_h1                        ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_REFT_mask_b3                        ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_REFT_shift_w                        (24)                    /*!< Bit Shift of 32bit */
N#define ADC_CAL_REFT_shift_h1                       (8)                     /*!< Bit Shift of 16bit */
N#define ADC_CAL_REFT_shift_b3                       (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CAL_REFM_mask_w                         ((uint32_t)0x003F0000)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_REFM_mask_h1                        ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_REFM_mask_b2                        ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_REFM_shift_w                        (16)                    /*!< Bit Shift of 32bit */
N#define ADC_CAL_REFM_shift_h1                       (0)                     /*!< Bit Shift of 16bit */
N#define ADC_CAL_REFM_shift_b2                       (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CAL_REFB_mask_w                         ((uint32_t)0x00003F00)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_REFB_mask_h0                        ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_REFB_mask_b1                        ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_REFB_shift_w                        (8)                     /*!< Bit Shift of 32bit */
N#define ADC_CAL_REFB_shift_h0                       (8)                     /*!< Bit Shift of 16bit */
N#define ADC_CAL_REFB_shift_b1                       (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_CAL_CAL_POFFT_mask_w                    ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_CAL_POFFT_mask_h0                   ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_CAL_POFFT_mask_b0                   ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_CAL_POFFT_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CAL_CAL_POFFT_disable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CAL_CAL_POFFT_disable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CAL_CAL_POFFT_enable_w                  ((uint32_t)0x00000008)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CAL_CAL_POFFT_enable_h0                 ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CAL_CAL_POFFT_enable_b0                 ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define ADC_CAL_CAL_AZEN_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define ADC_CAL_CAL_AZEN_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_CAL_CAL_AZEN_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_CAL_CAL_AZEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define ADC_CAL_CAL_AZEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define ADC_CAL_CAL_AZEN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define ADC_CAL_CAL_AZEN_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define ADC_CAL_CAL_AZEN_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define ADC_CAL_CAL_AZEN_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_GAIN  [register's definitions]
N *              Offset[0x2C]  ADC gain control register
N ******************************************************************************
N */
N///@{
N#define ADC_GAIN_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_GAIN */
N#define ADC_GAIN_OFFT_PGA_mask_w                    ((uint32_t)0x003F0000)  /*!< Bit Mask of 32bit */
N#define ADC_GAIN_OFFT_PGA_mask_h1                   ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define ADC_GAIN_OFFT_PGA_mask_b2                   ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_GAIN_OFFT_PGA_shift_w                   (16)                    /*!< Bit Shift of 32bit */
N#define ADC_GAIN_OFFT_PGA_shift_h1                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_GAIN_OFFT_PGA_shift_b2                  (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_GAIN_GAIN_PGA_mask_w                    ((uint32_t)0x0000003F)  /*!< Bit Mask of 32bit */
N#define ADC_GAIN_GAIN_PGA_mask_h0                   ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define ADC_GAIN_GAIN_PGA_mask_b0                   ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define ADC_GAIN_GAIN_PGA_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_GAIN_GAIN_PGA_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_GAIN_GAIN_PGA_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_SUM0  [register's definitions]
N *              Offset[0x30]  ADC accumulator sum result register 0
N ******************************************************************************
N */
N///@{
N#define ADC_SUM0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_SUM0 */
N#define ADC_SUM0_SUM0_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_OF_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_OF_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_OF_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_OF_shift_w                    (21)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_OF_shift_h1                   (5)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_OF_shift_b2                   (5)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_UF_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_UF_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_UF_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_SUM0_SUM0_UF_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_UF_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_UF_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM0_SUM0_DAT_mask_w                    ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_SUM0_SUM0_DAT_mask_h0                   ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_SUM0_SUM0_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_SUM0_SUM0_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM0_SUM0_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_SUM1  [register's definitions]
N *              Offset[0x34]  ADC accumulator sum result register 1
N ******************************************************************************
N */
N///@{
N#define ADC_SUM1_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_SUM1 */
N#define ADC_SUM1_SUM1_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_OF_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_OF_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_OF_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_OF_shift_w                    (21)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_OF_shift_h1                   (5)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_OF_shift_b2                   (5)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_UF_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_UF_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_UF_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_SUM1_SUM1_UF_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_UF_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_UF_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM1_SUM1_DAT_mask_w                    ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_SUM1_SUM1_DAT_mask_h0                   ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_SUM1_SUM1_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_SUM1_SUM1_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM1_SUM1_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_SUM2  [register's definitions]
N *              Offset[0x38]  ADC accumulator sum result register 2
N ******************************************************************************
N */
N///@{
N#define ADC_SUM2_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_SUM2 */
N#define ADC_SUM2_SUM2_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_OF_mask_w                     ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_OF_mask_h1                    ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_OF_mask_b2                    ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_OF_shift_w                    (21)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_OF_shift_h1                   (5)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_OF_shift_b2                   (5)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_UF_mask_w                     ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_UF_mask_h1                    ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_UF_mask_b2                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define ADC_SUM2_SUM2_UF_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_UF_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_UF_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_SUM2_SUM2_DAT_mask_w                    ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_SUM2_SUM2_DAT_mask_h0                   ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_SUM2_SUM2_DAT_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define ADC_SUM2_SUM2_DAT_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define ADC_SUM2_SUM2_DAT_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_TCAL  [register's definitions]
N *              Offset[0x3C]  ADC Temperature Sensor calibration register
N ******************************************************************************
N */
N///@{
N#define ADC_TCAL_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_TCAL */
N#define ADC_TCAL_TCAL1_mask_w                       ((uint32_t)0x0FFF0000)  /*!< Bit Mask of 32bit */
N#define ADC_TCAL_TCAL1_mask_h1                      ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_TCAL_TCAL1_shift_w                      (16)                    /*!< Bit Shift of 32bit */
N#define ADC_TCAL_TCAL1_shift_h1                     (0)                     /*!< Bit Shift of 16bit */
N#define ADC_TCAL_TCAL1_shift_b2                     (0)                     /*!< Bit Shift of 8bit */
N
N#define ADC_TCAL_TCAL0_mask_w                       ((uint32_t)0x00000FFF)  /*!< Bit Mask of 32bit */
N#define ADC_TCAL_TCAL0_mask_h0                      ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define ADC_TCAL_TCAL0_shift_w                      (0)                     /*!< Bit Shift of 32bit */
N#define ADC_TCAL_TCAL0_shift_h0                     (0)                     /*!< Bit Shift of 16bit */
N#define ADC_TCAL_TCAL0_shift_b0                     (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        ADC_DAT0  [register's definitions]
N *              Offset[0x40]  ADC conversion data register 0
N ******************************************************************************
N */
N///@{
N#define ADC_DAT0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of ADC_DAT0 */
N#define ADC_DAT0_DAT0_CH_mask_w                     ((uint32_t)0xF0000000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_CH_mask_h1                    ((uint16_t)0xF000)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_CH_mask_b3                    ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_CH_shift_w                    (28)                    /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_CH_shift_h1                   (12)                    /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_CH_shift_b3                   (4)                     /*!< Bit Shift of 8bit */
N
N#define ADC_DAT0_DAT0_OVRF_mask_w                   ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_OVRF_mask_h1                  ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_OVRF_mask_b2                  ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_OVRF_shift_w                  (23)                    /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_OVRF_shift_h1                 (7)                     /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_OVRF_shift_b2                 (7)                     /*!< Bit Shift of 8bit */
N
N#define ADC_DAT0_DAT0_CF_mask_w                     ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_CF_mask_h1                    ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_CF_mask_b2                    ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_CF_shift_w                    (22)                    /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_CF_shift_h1                   (6)                     /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_CF_shift_b2                   (6)                     /*!< Bit Shift of 8bit */
N
N#define ADC_DAT0_DAT0_WDHF_mask_w                   ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_WDHF_mask_h1                  ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_WDHF_mask_b2                  ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_WDHF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_DAT0_DAT0_WDHF_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_DAT0_DAT0_WDHF_normal_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_DAT0_DAT0_WDHF_happened_w               ((uint32_t)0x00040000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_DAT0_DAT0_WDHF_happened_h1              ((uint16_t)0x0004)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_DAT0_DAT0_WDHF_happened_b2              ((uint8_t )0x04)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_DAT0_DAT0_WDIF_mask_w                   ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_WDIF_mask_h1                  ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_WDIF_mask_b2                  ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_WDIF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_DAT0_DAT0_WDIF_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_DAT0_DAT0_WDIF_normal_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_DAT0_DAT0_WDIF_happened_w               ((uint32_t)0x00020000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_DAT0_DAT0_WDIF_happened_h1              ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_DAT0_DAT0_WDIF_happened_b2              ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_DAT0_DAT0_WDLF_mask_w                   ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_WDLF_mask_h1                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_WDLF_mask_b2                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define ADC_DAT0_DAT0_WDLF_normal_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define ADC_DAT0_DAT0_WDLF_normal_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define ADC_DAT0_DAT0_WDLF_normal_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define ADC_DAT0_DAT0_WDLF_happened_w               ((uint32_t)0x00010000)  /*!< Bit Value =(1):Happened of 32bit */
N#define ADC_DAT0_DAT0_WDLF_happened_h1              ((uint16_t)0x0001)      /*!< Bit Value =(1):Happened of 16bit */
N#define ADC_DAT0_DAT0_WDLF_happened_b2              ((uint8_t )0x01)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define ADC_DAT0_DAT0_mask_w                        ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define ADC_DAT0_DAT0_mask_h0                       ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define ADC_DAT0_DAT0_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define ADC_DAT0_DAT0_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define ADC_DAT0_DAT0_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_ADC_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_ADC.h                         */
N/*----------------------------------------------------------------------------*/
L 29 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.h" 2
N#include "RTE_Components.h"
L 1 ".\RTE\_Target_1\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'Example_UART' 
N * Target:  'Target 1' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N
N/*
N * Define the Device Header File: 
N */
N#define CMSIS_device_header "MG32x02z.h"
N
N/* Megawin::MG32x02z_ChipInit_Wizard:ADC:1.0.0 */
N#define MG32x02z_ConfigerWizard_ADC
N/* Megawin::MG32x02z_ChipInit_Wizard:CSC:1.0.4 */
N#define MG32x02z_ConfigerWizard_CSC
N/* Megawin::MG32x02z_ChipInit_Wizard:EMB:1.0.2 */
N#define MG32x02z_ConfigerWizard_EMB
N/* Megawin::MG32x02z_ChipInit_Wizard:EXIC:LQFP80:1.0.2 */
N#define MG32x02z_ConfigerWizard_EXIC
N/* Megawin::MG32x02z_ChipInit_Wizard:GPIO:LQFP80:1.0.2 */
N#define MG32x02z_Package_LQFP80            
N		#define MG32x02z_ConfigerWizard_GPIO
N/* Megawin::MG32x02z_ChipInit_Wizard:GPL:1.0.1 */
N#define MG32x02z_ConfigerWizard_GPL
N/* Megawin::MG32x02z_ChipInit_Wizard:IRQ handler:1.0.5 */
N#define MG32x02z_IRQ_Handler_
N/* Megawin::MG32x02z_ChipInit_Wizard:MEM:1.0.1 */
N#define MG32x02z_ConfigerWizard_MEM
N/* Megawin::MG32x02z_ChipInit_Wizard:PW:1.0.1 */
N#define MG32x02z_ConfigerWizard_PW
N/* Megawin::MG32x02z_ChipInit_Wizard:RST:1.0.1 */
N#define MG32x02z_ConfigerWizard_RST
N/* Megawin::MG32x02z_ChipInit_Wizard:Timer:1.0.0 */
N#define MG32x02z_ConfigerWizard_TM
N/* Megawin::MG32x02z_ChipInit_Wizard:URT:1.0.2 */
N#define MG32x02z_ConfigerWizard_URT  
N		#define URT_Initial_En 1
N/* Megawin::MG32x02z_IRQ_Handler:Systick:1.0.0 */
N#define MG32x02z_SYSTICK_Middleware_Level_IRQ_
N/* Megawin::MG32x02z_Middleware:Middleware-All:1.0.0 */
N#define IRQHandler_Middleware_Level_
N
N
N#endif /* RTE_COMPONENTS_H */
L 30 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.h" 2
N
N
N#ifndef _MG32x02z_ADC_INIT_H
N/*!< _MG32x02z_TM_INIT_H */ 
N#define _MG32x02z_ADC_INIT_H
N
N#include "MG32x02z_ADC_DRV.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_ADC_DRV.H
N *
N * @brief       This file contains all the functions prototypes for the ADC 
N *              firmware library.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.16
N * @date        2020/10/07
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2016 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N#ifndef _MG32x02z_ADC_DRV_H
N
N/*!< _MG32x02z_ADC_DRV_H */ 
N#define _MG32x02z_ADC_DRV_H
N
N
N#include "MG32x02z__Common_DRV.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z__Common_DRV.H" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z__Common_DRV.h
N *
N * @brief       This is the C code format driver head file.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.14
N * @date        2019/04/15
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2017 MegaWin Technology Co., Ltd.
N *              All rights reserved.
N *
N ******************************************************************************
N * @par 		Disclaimer 
N *		The Demo software is provided "AS IS"  without any warranty, either 
N *		expressed or implied, including, but not limited to, the implied warranties 
N *		of merchantability and fitness for a particular purpose.  The author will 
N *		not be liable for any special, incidental, consequential or indirect 
N *		damages due to loss of data or any other reason. 
N *		These statements agree with the world wide and local dictated laws about 
N *		authorship and violence against these laws. 
N ******************************************************************************
N ******************************************************************************
N */ 
N
N
N
N#ifndef _MG32x02z_Common_DRV_H
N#define _MG32x02z_Common_DRV_H
N#define _MG32x02z_Common_DRV_H_VER                            0.1      /*!< File Version */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N#include "stdint.h"
N#include "stdio.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 42 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z__Common_DRV.H" 2
N#include "string.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 43 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z__Common_DRV.H" 2
N#include "MG32x02z.h"
N
N
N
N     // Debug Configuration Setting
N#define MG_Debug	1				/*!< 0=Normal, 1=Debug for Test Chip    */
N
N
N/**
N * @enum		DRV_Return
N * @brief		General Driver return status
N */
Ntypedef enum 
N{
N    /* common status values */
N    DRV_Logic0 = 0,             /*!<                                    */
N    DRV_Logic1 = 1,             /*!< operation failed					*/
N    DRV_Low = 0,                /*!< operation failed					*/
N    DRV_High = 1,               /*!< operation failed					*/
N    DRV_Normal = 0,             /*!< operation failed					*/
N    DRV_UnHappened = 0,         /*!< operation failed					*/
N    DRV_Happened = 1,           /*!< operation failed					*/
N    DRV_Success = 0,            /*!< successful outcome					*/
N    DRV_Failure = 1,            /*!< operation failed					*/
N    DRV_False = 0,              /*!<                                    */
N    DRV_True = !DRV_False,      /*!<                                    */
N    DRV_Unready = 0,            /*!<                                    */
N    DRV_Ready = !DRV_Unready,   /*!<                                    */
N
N    /* For PW module */
N    PW_HighThreshold = 0,
N    PW_LowThreshold = 1,
N    PW_None = 0,
N    PW_Sleep = 1,
N    PW_Stop = 2,    
N
N    DRV_Completed,              /*!< operation failed					*/
N    DRV_TimeOut,                /*!< operation failed					*/
N    DRV_OverRange,
N    DRV_OutsideLow,
N    DRV_OutsideHigh,
N    DRV_Inside,
N    DRV_Busy,                   /*!<                                    */
N    DRV_OverFlow,               /*!<                                    */
N    DRV_UnderFlow,              /*!<                                    */
N//	DRV_ERR_INVALID_HANDLE,		/*!< invalid handle						*/
N//	DRV_ERR_INVALID_ID,			/*!< invalid identifier					*/
N//	DRV_ERR_INVALID_PARAM,		/*!< invalid parameter					*/
N//	DRV_ERR_INVALID_OP,			/*!< requested operation is invalid		*/
N//	DRV_ERR_MEMORY_ALLOC,		/*!< problem allocating memory			*/
N//	DRV_ERR_MEMORY_SIZE,		/*!< problem with the size of memory	*/
N//	DRV_ERR_RESOURCE_UNAVAILABLE,
N//	DRV_ERR_TIMEOUT,			/*!< timeout							*/
N//	DRV_ERR_MAX					/*!< Max error number*/
N
N//	DRV_WARN_NO_ACTION,			/* < the function completed successfully,*/
N	                                /* < but no action was taken            */
N//	DRV_WARN_PARAM_CLIPPED,		/*!< the function has completed			*/
N//									/*!< successfully, though a parameter was	*/
N//									/*!< clipped to within a valid range.		*/
N//	DRV_WARN_BUFFER_EMPTY,
N//	DRV_WARN_BUFFER_FULL,
N//	DRV_WARN_UNINITED,			/*!< driver has not been initialized yet */
N//	DRV_WARN_INITED,			/*!< driver has been initialized already */
N
N}DRV_Return;           /*!< Driver Return Status Definitions */
N
N
N
N/**
N * @enum		Protect_Type
N * @brief		TMx interrupt enable source  
N */
Ntypedef enum { 
N    RSTprotect = (uint32_t)0x4C00000C,
N    CSCprotect = (uint32_t)0x4C01000C,  
N    PWprotect = (uint32_t)0x4C02000C,
N    MEMprotect = (uint32_t)0x4D00000C,  
N    MEMsprotect = (uint32_t)0x4D00000E,
N    CFGprotect = (uint32_t)0x4FF0000C,
N    IWDTprotect = (uint32_t)0x5D00000C,  
N    WWDTprotect = (uint32_t)0x5D01000C,  
N    RTCprotect = (uint32_t)0x5D04000C,
N}Protect_Type;          /*!< Definitions for protection function */
N
N
N
N
N/**
N * @enum		Lock_Type
N * @brief		Lock Module. 
N */
Ntypedef enum{
N    RSTLock = (uint32_t)0x4C00000E,
N    IWDTLock = (uint32_t)0x5D00000E,  
N    RTCLock = (uint32_t)0x5D04000E,
N}Lock_Type;             /*!< Definitions for locked function */
N
N
N
N#if defined(IRQHandler_Middleware_Level_)
X#if 1L
N  #define InitTick(__TickClock__, __TickPriority__) MID_InitTick(__TickPriority__)
N  #define Delay         MID_Delay
N  #define GetTick       MID_GetTick
N  #define SuspendTick   MID_SuspendTick
N  #define ResumeTick    MID_ResumeTick
N#else
S  DRV_Return InitTick(uint32_t TickClock, uint32_t TickPriority);
S  void IncTick(void);
S  void Delay(__IO uint32_t DelayTime);
S  uint32_t GetTick(void);
S  void SuspendTick(void);
S  void ResumeTick(void);
N#endif
N
NDRV_Return ProtectModuleReg(Protect_Type Module);             /*!< Protect Module Register Write */
NDRV_Return UnProtectModuleReg(Protect_Type Module);           /*!< UnProtect Module Register Write */
NDRV_Return LockModuleReg(Lock_Type Module);                   /*!< Lock Module Register Write until Chip Reset */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N
L 37 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N#include "MG32x02z_ADC.H"
N#include "MG32x02z_CFG_DRV.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CFG_DRV.H" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_CFG_DRV.H
N *
N * @brief       This is the C code format driver head file for CFG module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.13
N * @date        2021/01/22
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2020 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N
N#include "MG32x02z__Common_DRV.H"
N#include "MG32x02z_CFG.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_CFG.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_CFG.h
N *
N * @brief       MG32x02z CFG Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_CFG_H
N#define _MG32x02z_CFG_H
N#define _MG32x02z_CFG_H_VER                         3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_CFG_H_VER)
S    #error "MG32x02z_CFG_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      CFG_Struct
N *              CFG  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    __I uint32_t  RESERVED0[3];         /*!< RESERVED0  ~ Offset[0x00]  Reserved */
X    volatile const uint32_t  RESERVED0[3];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] CFG key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  CFG write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  BOOT_MS       :2;     //[1..0] System cold reset boot memory select and memory is mapped at 0x0000 0000
X            volatile const  uint8_t  BOOT_MS       :2;     
N                                        //0x0 = Application Flash
N                                        //0x1 = Boot Flash
N                                        //0x2 = Embedded SRAM
N                                        //0x3 = Reserved
N            __I  uint8_t                :5;     //[6..2] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  LOCK_DIS      :1;     //[8] Main Flash code locked enable
X            volatile const  uint8_t  LOCK_DIS      :1;     
N                                        //0 = Enable
N                                        //1 = Disable (Code dump on Writer is transparent)
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t  BOD1_TH       :2;     //[17..16] BOD1 detect voltage threshold select.
X            volatile const  uint8_t  BOD1_TH       :2;     
N                                        //0x0 = 2.0v
N                                        //0x1 = 2.4v
N                                        //0x2 = 3.7v
N                                        //0x3 = 4.2v
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[21..20] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  BOD0_WE       :1;     //[24] BOD0 trigger Warm reset enable
X            volatile const  uint8_t  BOD0_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t  BOD1_WE       :1;     //[25] BOD1 trigger Warm reset enable
X            volatile const  uint8_t  BOD1_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }OR00;                              /*!< OR00       ~ Offset[0x10]  CFG option byte register 00 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  IAP_SIZE      :8;     //[15..8] IAP memory size select
X            volatile const  uint8_t  IAP_SIZE      :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR01;                              /*!< OR01       ~ Offset[0x14]  CFG option byte register 01 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  ISP_SIZE      :8;     //[15..8] ISP memory size select
X            volatile const  uint8_t  ISP_SIZE      :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR02;                              /*!< OR02       ~ Offset[0x18]  CFG option byte register 02 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  IWDT_EN       :1;     //[0] IWDT enable after Cold reset
X            volatile const  uint8_t  IWDT_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t  IWDT_WP       :1;     //[1] IWDT registers write protected enable
X            volatile const  uint8_t  IWDT_WP       :1;     
N                                        //0 = Disable
N                                        //1 = Enable : Write-protected
N            __I  uint8_t  IWDT_WE       :1;     //[2] IWDT reset generation enable option
X            volatile const  uint8_t  IWDT_WE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  IWDT_DIV      :4;     //[7..4] IWDT internal clock CK_IWDT_INT input divider select
X            volatile const  uint8_t  IWDT_DIV      :4;     
N                                        //0x0 = DIV1 : divided by 1
N                                        //0x1 = DIV2 : divided by 2
N                                        //0x2 = DIV4 : divided by 4
N                                        //0x3 = DIV8 : divided by 8
N                                        //0x4 = DIV16 : divided by 16
N                                        //0x5 = DIV32 : divided by 32
N                                        //0x6 = DIV64 : divided by 64
N                                        //0x7 = DIV128 : divided by 128
N                                        //0x8 = DIV256 : divided by 256 
N                                        //0x9 = DIV512 : divided by 512
N                                        //0xA = DIV1024 : divided by 1024
N                                        //0xB = DIV2048 : divided by 2048
N                                        //0xC = DIV4096 : divided by 4096
N            __I  uint8_t  IWDT_SLP      :1;     //[8] IWDT counting control when chip in SLEEP mode
X            volatile const  uint8_t  IWDT_SLP      :1;     
N                                        //0 = Stop : Stop counting
N                                        //1 = Keep : Keep counting
N            __I  uint8_t  IWDT_STP      :1;     //[9] IWDT counting control when chip in STOP mode
X            volatile const  uint8_t  IWDT_STP      :1;     
N                                        //0 = Stop : Stop counting
N                                        //1 = Keep : Keep counting
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR03;                              /*!< OR03       ~ Offset[0x1C]  CFG option byte register 03 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  IAP_AEN       :1;     //[0] IAP memory size MEM_IAP_SIZE register write  access disable.
X            volatile const  uint8_t  IAP_AEN       :1;     
N                                        //0 = Disable : Register access lock
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[6..2] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  HSP_EN        :1;     //[7] Flash memory high speed mode enable.
X            volatile const  uint8_t  HSP_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR04;                              /*!< OR04       ~ Offset[0x20]  CFG option byte register 04 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t  EXRST_PIN     :1;     //[0] External reset pin control after power-on
X            volatile const  uint8_t  EXRST_PIN     :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t  SWD_PIN       :1;     //[1] SWD interface pin control after power-on
X            volatile const  uint8_t  SWD_PIN       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t  PON_MDS       :1;     //[8] Fast power-up time mode select.
X            volatile const  uint8_t  PON_MDS       :1;     
N                                        //0= Fast : 4ms
N                                        //1= Slow : 32ms
N            __I  uint8_t                :7;     //[15..9] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :1;     //[16] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  HS_SEL        :1;     //[17] CK_HS clock source select after power-on (Cold reset)
X            volatile const  uint8_t  HS_SEL        :1;     
N                                        //0 = IHRCO
N                                        //1 = ILRCO
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  PLL_CTL       :2;     //[21..20] PLL control bits
X            volatile const  uint8_t  PLL_CTL       :2;     
N            __I  uint8_t  HSWKP         :2;     //[23..22] Wakeup delay selection from STOP mode.
X            volatile const  uint8_t  HSWKP         :2;     
N                                        //0x0 = 0us
N                                        //0x1 = 30us
N                                        //0x2 = 60us
N                                        //0x3 = 120us
N            __I  uint8_t  XOSC_GN       :2;     //[25..24] Gain control bits of XOSC.
X            volatile const  uint8_t  XOSC_GN       :2;     
N                                        //0x0 = 32K_Normal (for 32KHz crystal)
N                                        //0x1 = Medium
N                                        //0x2 = 32K_Lowest (for 32KHz crystal)
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  XOSC_DB       :1;     //[28] XOSC clock debounce cycle select
X            volatile const  uint8_t  XOSC_DB       :1;     
N                                        //0 = 4096
N                                        //1 = 1024
N            __I  uint8_t                :1;     //[29] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[30] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  XOSC_EN       :1;     //[31] XOSC crystal oscillation circuit enable
X            volatile const  uint8_t  XOSC_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N        }MBIT;
N    }OR05;                              /*!< OR05       ~ Offset[0x24]  CFG option byte register 05 */
N
N    __I uint32_t  RESERVED1;            /*!< RESERVED1  ~ Offset[0x28]  Reserved */
X    volatile const uint32_t  RESERVED1;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  CG21          :1;     //[1] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  CG21          :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  CG22          :1;     //[2] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  CG22          :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  LVRDE         :1;     //[5] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  LVRDE         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  LVRDS0        :1;     //[6] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  LVRDS0        :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  LVRDS1        :1;     //[7] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  LVRDS1        :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  PNDCE         :1;     //[8] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  PNDCE         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  PNDRC         :1;     //[9] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  PNDRC         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  PORDS         :1;     //[10] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  PORDS         :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  DPORDS        :1;     //[11] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  DPORDS        :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  CGIL          :1;     //[12] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  CGIL          :1;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint8_t  GF            :3;     //[15..13] OR control bit. (This bit is loaded by inverting from option byte flash data.)
X            volatile const  uint8_t  GF            :3;     
N                                        //0= Disable
N                                        //1= Enable
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR07;                              /*!< OR07       ~ Offset[0x2C]  CFG option byte register 07 */
N
N    __I uint32_t  RESERVED2;            /*!< RESERVED2  ~ Offset[0x30]  Reserved */
X    volatile const uint32_t  RESERVED2;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  VBG_OTRM      :3;     //[2..0] BandGap reference voltage output trimming bits.
X            volatile uint8_t  VBG_OTRM      :3;     
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  VBG_BTRM      :4;     //[11..8] BandGap buffer output trimming bits.
X            volatile uint8_t  VBG_BTRM      :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  DAC_CTRM0     :5;     //[20..16] DAC-0 output current trimming bits.
X            volatile uint8_t  DAC_CTRM0     :5;     
N            __I  uint8_t                :3;     //[23..21] 
X            volatile const  uint8_t                :3;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OR11;                              /*!< OR11       ~ Offset[0x34]  CFG option byte register 11 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  BOD1_TRM      :4;     //[11..8] Reserved
X            volatile uint8_t  BOD1_TRM      :4;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  LVR_TRM       :4;     //[19..16] Reserved
X            volatile uint8_t  LVR_TRM       :4;     
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }OR12;                              /*!< OR12       ~ Offset[0x38]  CFG option byte register 12 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IHR0_FTRM     :7;     //[6..0] Reserved
X            volatile uint8_t  IHR0_FTRM     :7;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IHR0_CTRM     :2;     //[9..8] Reserved
X            volatile uint8_t  IHR0_CTRM     :2;     
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IHR1_FTRM     :7;     //[22..16] Reserved
X            volatile uint8_t  IHR1_FTRM     :7;     
N            __I  uint8_t                :1;     //[23] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IHR1_CTRM     :2;     //[25..24] Reserved
X            volatile uint8_t  IHR1_CTRM     :2;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }OR13;                              /*!< OR13       ~ Offset[0x3C]  CFG option byte register 13 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  ILR_TRM       :2;     //[1..0] Reserved
X            volatile uint8_t  ILR_TRM       :2;     
N            __I  uint8_t                :6;     //[7..2] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IHR_BGTV      :2;     //[9..8] Reserved
X            volatile uint8_t  IHR_BGTV      :2;     
N            __I  uint8_t                :3;     //[12..10] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  IHR_BGTI      :3;     //[15..13] Reserved
X            volatile uint8_t  IHR_BGTI      :3;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR14;                              /*!< OR14       ~ Offset[0x40]  CFG option byte register 14 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :8;     //[7..0] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  ADC0_REFB     :6;     //[13..8] ADC0 reference voltage bottom level setting.
X            volatile uint8_t  ADC0_REFB     :6;     
N            __I  uint8_t                :2;     //[15..14] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  ADC0_REFM     :6;     //[21..16] ADC0 reference voltage middle level setting.
X            volatile uint8_t  ADC0_REFM     :6;     
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  ADC0_REFT     :6;     //[29..24] ADC0 reference voltage top level setting.
X            volatile uint8_t  ADC0_REFT     :6;     
N            __I  uint8_t                :2;     //[31..30] 
X            volatile const  uint8_t                :2;     
N        }MBIT;
N    }OR15;                              /*!< OR15       ~ Offset[0x44]  CFG option byte register 15 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t TEMP_CAL0     :12;    //[11..0] Temperature Sensor calibration value acquired at 25 degree-C.
X            volatile uint16_t TEMP_CAL0     :12;    
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint16_t TEMP_CAL1     :12;    //[27..16] Temperature Sensor calibration value acquired at 60 degree-C.
X            volatile uint16_t TEMP_CAL1     :12;    
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }OR16;                              /*!< OR16       ~ Offset[0x48]  CFG option byte register 16 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  LDO_TRM       :3;     //[2..0] Reserved
X            volatile uint8_t  LDO_TRM       :3;     
N            __I  uint8_t                :5;     //[7..3] 
X            volatile const  uint8_t                :5;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }OR17;                              /*!< OR17       ~ Offset[0x4C]  CFG option byte register 17 */
N
N    __I uint32_t  RESERVED3[4];         /*!< RESERVED3  ~ Offset[0x50]  Reserved */
X    volatile const uint32_t  RESERVED3[4];          
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  POF0          :1;     //[0] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  POF0          :1;     
N            __IO uint8_t  POF1          :1;     //[1] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  POF1          :1;     
N            __IO uint8_t  POF2          :1;     //[2] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  POF2          :1;     
N            __IO uint8_t  DPORF         :1;     //[3] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  DPORF         :1;     
N            __IO uint8_t  LVRF0         :1;     //[4] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  LVRF0         :1;     
N            __IO uint8_t  DBLVRF        :1;     //[5] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  DBLVRF        :1;     
N            __IO uint8_t  PNDF          :1;     //[6] Test using flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  PNDF          :1;     
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }TST0;                              /*!< TST0       ~ Offset[0x60]  CFG Test register 0 (not load from flash memory) */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  FLH_WE        :1;     //[0] Enable flash write operation when BOD0 active(low voltage).
X            volatile uint8_t  FLH_WE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :7;     //[7..1] 
X            volatile const  uint8_t                :7;     
N            __IO uint8_t  BOD_OE        :1;     //[8] BOD0/1 output enable
X            volatile uint8_t  BOD_OE        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LVR_DIS       :1;     //[9] LVR disable bit
X            volatile uint8_t  LVR_DIS       :1;     
N                                        //0 = Enable
N                                        //1 = Disable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __IO uint8_t  IHRCK_OE      :1;     //[16] IHRCO clock output enable
X            volatile uint8_t  IHRCK_OE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ILRCK_OE      :1;     //[17] ILRCO clock output enable
X            volatile uint8_t  ILRCK_OE      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  ILRCO_EN      :1;     //[18] Internal Low frequency RC Oscillator Enable
X            volatile uint8_t  ILRCO_EN      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :5;     //[23..19] 
X            volatile const  uint8_t                :5;     
N            __IO uint8_t  PLL_TST       :1;     //[24] PLL test enable.
X            volatile uint8_t  PLL_TST       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[25] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }TST1;                              /*!< TST1       ~ Offset[0x64]  CFG Test register 1 (not load from flash memory) */
N
N} CFG_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        CFG  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define CFG_Base                        ((uint32_t)0x4FF00000)              /*!< Hardware Option Bytes Configure Control */
N#define CFG                             ((CFG_Struct*) CFG_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        CFG  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        CFG_KEY  [register's definitions]
N *              Offset[0x0C]  CFG write protected Key register (0x4FF0000C)
N ******************************************************************************
N */
N///@{
N#define CFG_KEY_default                             ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_KEY */
N#define CFG_KEY_KEY_mask_w                          ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define CFG_KEY_KEY_mask_h0                         ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define CFG_KEY_KEY_unprotected_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define CFG_KEY_KEY_unprotected_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define CFG_KEY_KEY_unprotected_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define CFG_KEY_KEY_protected_w                     ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define CFG_KEY_KEY_protected_h0                    ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define CFG_KEY_KEY_protected_b0                    ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR00  [register's definitions]
N *              Offset[0x10]  CFG option byte register 00 (0x4FF00010)
N ******************************************************************************
N */
N///@{
N#define CFG_OR00_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR00 */
N#define CFG_OR00_BOD1_WE_mask_w                     ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOD1_WE_mask_h1                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOD1_WE_mask_b3                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOD1_WE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR00_BOD1_WE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR00_BOD1_WE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR00_BOD1_WE_enable_w                   ((uint32_t)0x02000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR00_BOD1_WE_enable_h1                  ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR00_BOD1_WE_enable_b3                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR00_BOD0_WE_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOD0_WE_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOD0_WE_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOD0_WE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR00_BOD0_WE_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR00_BOD0_WE_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR00_BOD0_WE_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR00_BOD0_WE_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR00_BOD0_WE_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR00_BOD1_TH_mask_w                     ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOD1_TH_mask_h1                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOD1_TH_mask_b2                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOD1_TH_2_0v_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):2.0v of 32bit */
N#define CFG_OR00_BOD1_TH_2_0v_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):2.0v of 16bit */
N#define CFG_OR00_BOD1_TH_2_0v_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):2.0v of 8bit */
N#define CFG_OR00_BOD1_TH_2_4v_w                     ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):2.4v of 32bit */
N#define CFG_OR00_BOD1_TH_2_4v_h1                    ((uint16_t)0x0001)      /*!< Bit Value =(0x1):2.4v of 16bit */
N#define CFG_OR00_BOD1_TH_2_4v_b2                    ((uint8_t )0x01)        /*!< Bit Value =(0x1):2.4v of 8bit */
N#define CFG_OR00_BOD1_TH_3_7v_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):3.7v of 32bit */
N#define CFG_OR00_BOD1_TH_3_7v_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(0x2):3.7v of 16bit */
N#define CFG_OR00_BOD1_TH_3_7v_b2                    ((uint8_t )0x02)        /*!< Bit Value =(0x2):3.7v of 8bit */
N#define CFG_OR00_BOD1_TH_4_2v_w                     ((uint32_t)0x00030000)  /*!< Bit Value =(0x3):4.2v of 32bit */
N#define CFG_OR00_BOD1_TH_4_2v_h1                    ((uint16_t)0x0003)      /*!< Bit Value =(0x3):4.2v of 16bit */
N#define CFG_OR00_BOD1_TH_4_2v_b2                    ((uint8_t )0x03)        /*!< Bit Value =(0x3):4.2v of 8bit */
N
N#define CFG_OR00_LOCK_DIS_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_LOCK_DIS_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_LOCK_DIS_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_LOCK_DIS_enable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_OR00_LOCK_DIS_enable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_OR00_LOCK_DIS_enable_b1                 ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_OR00_LOCK_DIS_disable_w                 ((uint32_t)0x00000100)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_OR00_LOCK_DIS_disable_h0                ((uint16_t)0x0100)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_OR00_LOCK_DIS_disable_b1                ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CFG_OR00_BOOT_MS_mask_w                     ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define CFG_OR00_BOOT_MS_mask_h0                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CFG_OR00_BOOT_MS_mask_b0                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR00_BOOT_MS_application_flash_w        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):Application Flash of 32bit */
N#define CFG_OR00_BOOT_MS_application_flash_h0       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):Application Flash of 16bit */
N#define CFG_OR00_BOOT_MS_application_flash_b0       ((uint8_t )0x00)        /*!< Bit Value =(0x0):Application Flash of 8bit */
N#define CFG_OR00_BOOT_MS_boot_flash_w               ((uint32_t)0x00000001)  /*!< Bit Value =(0x1):Boot Flash of 32bit */
N#define CFG_OR00_BOOT_MS_boot_flash_h0              ((uint16_t)0x0001)      /*!< Bit Value =(0x1):Boot Flash of 16bit */
N#define CFG_OR00_BOOT_MS_boot_flash_b0              ((uint8_t )0x01)        /*!< Bit Value =(0x1):Boot Flash of 8bit */
N#define CFG_OR00_BOOT_MS_embedded_sram_w            ((uint32_t)0x00000002)  /*!< Bit Value =(0x2):Embedded SRAM of 32bit */
N#define CFG_OR00_BOOT_MS_embedded_sram_h0           ((uint16_t)0x0002)      /*!< Bit Value =(0x2):Embedded SRAM of 16bit */
N#define CFG_OR00_BOOT_MS_embedded_sram_b0           ((uint8_t )0x02)        /*!< Bit Value =(0x2):Embedded SRAM of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR01  [register's definitions]
N *              Offset[0x14]  CFG option byte register 01 (0x4FF00014)
N ******************************************************************************
N */
N///@{
N#define CFG_OR01_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR01 */
N#define CFG_OR01_IAP_SIZE_mask_w                    ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define CFG_OR01_IAP_SIZE_mask_h0                   ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define CFG_OR01_IAP_SIZE_mask_b1                   ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define CFG_OR01_IAP_SIZE_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR01_IAP_SIZE_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR01_IAP_SIZE_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR02  [register's definitions]
N *              Offset[0x18]  CFG option byte register 02 (0x4FF00018)
N ******************************************************************************
N */
N///@{
N#define CFG_OR02_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR02 */
N#define CFG_OR02_ISP_SIZE_mask_w                    ((uint32_t)0x0000FF00)  /*!< Bit Mask of 32bit */
N#define CFG_OR02_ISP_SIZE_mask_h0                   ((uint16_t)0xFF00)      /*!< Bit Mask of 16bit */
N#define CFG_OR02_ISP_SIZE_mask_b1                   ((uint8_t )0xFF)        /*!< Bit Mask of 8bit */
N#define CFG_OR02_ISP_SIZE_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR02_ISP_SIZE_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR02_ISP_SIZE_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR03  [register's definitions]
N *              Offset[0x1C]  CFG option byte register 03 (0x4FF0001C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR03_default                            ((uint32_t)0x000000C0)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR03 */
N#define CFG_OR03_IWDT_STP_mask_w                    ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_STP_mask_h0                   ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_STP_mask_b1                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_STP_stop_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define CFG_OR03_IWDT_STP_stop_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define CFG_OR03_IWDT_STP_stop_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define CFG_OR03_IWDT_STP_keep_w                    ((uint32_t)0x00000200)  /*!< Bit Value =(1):Keep of 32bit */
N#define CFG_OR03_IWDT_STP_keep_h0                   ((uint16_t)0x0200)      /*!< Bit Value =(1):Keep of 16bit */
N#define CFG_OR03_IWDT_STP_keep_b1                   ((uint8_t )0x02)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define CFG_OR03_IWDT_SLP_mask_w                    ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_SLP_mask_h0                   ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_SLP_mask_b1                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_SLP_stop_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Stop of 32bit */
N#define CFG_OR03_IWDT_SLP_stop_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Stop of 16bit */
N#define CFG_OR03_IWDT_SLP_stop_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Stop of 8bit */
N#define CFG_OR03_IWDT_SLP_keep_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Keep of 32bit */
N#define CFG_OR03_IWDT_SLP_keep_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Keep of 16bit */
N#define CFG_OR03_IWDT_SLP_keep_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Keep of 8bit */
N
N#define CFG_OR03_IWDT_DIV_mask_w                    ((uint32_t)0x000000F0)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_DIV_mask_h0                   ((uint16_t)0x00F0)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_DIV_mask_b0                   ((uint8_t )0xF0)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_DIV_div1_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DIV1 of 32bit */
N#define CFG_OR03_IWDT_DIV_div1_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DIV1 of 16bit */
N#define CFG_OR03_IWDT_DIV_div1_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0x0):DIV1 of 8bit */
N#define CFG_OR03_IWDT_DIV_div2_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(0x1):DIV2 of 32bit */
N#define CFG_OR03_IWDT_DIV_div2_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DIV2 of 16bit */
N#define CFG_OR03_IWDT_DIV_div2_b0                   ((uint8_t )0x10)        /*!< Bit Value =(0x1):DIV2 of 8bit */
N#define CFG_OR03_IWDT_DIV_div4_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(0x2):DIV4 of 32bit */
N#define CFG_OR03_IWDT_DIV_div4_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DIV4 of 16bit */
N#define CFG_OR03_IWDT_DIV_div4_b0                   ((uint8_t )0x20)        /*!< Bit Value =(0x2):DIV4 of 8bit */
N#define CFG_OR03_IWDT_DIV_div8_w                    ((uint32_t)0x00000030)  /*!< Bit Value =(0x3):DIV8 of 32bit */
N#define CFG_OR03_IWDT_DIV_div8_h0                   ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DIV8 of 16bit */
N#define CFG_OR03_IWDT_DIV_div8_b0                   ((uint8_t )0x30)        /*!< Bit Value =(0x3):DIV8 of 8bit */
N#define CFG_OR03_IWDT_DIV_div16_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(0x4):DIV16 of 32bit */
N#define CFG_OR03_IWDT_DIV_div16_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(0x4):DIV16 of 16bit */
N#define CFG_OR03_IWDT_DIV_div16_b0                  ((uint8_t )0x40)        /*!< Bit Value =(0x4):DIV16 of 8bit */
N#define CFG_OR03_IWDT_DIV_div32_w                   ((uint32_t)0x00000050)  /*!< Bit Value =(0x5):DIV32 of 32bit */
N#define CFG_OR03_IWDT_DIV_div32_h0                  ((uint16_t)0x0050)      /*!< Bit Value =(0x5):DIV32 of 16bit */
N#define CFG_OR03_IWDT_DIV_div32_b0                  ((uint8_t )0x50)        /*!< Bit Value =(0x5):DIV32 of 8bit */
N#define CFG_OR03_IWDT_DIV_div64_w                   ((uint32_t)0x00000060)  /*!< Bit Value =(0x6):DIV64 of 32bit */
N#define CFG_OR03_IWDT_DIV_div64_h0                  ((uint16_t)0x0060)      /*!< Bit Value =(0x6):DIV64 of 16bit */
N#define CFG_OR03_IWDT_DIV_div64_b0                  ((uint8_t )0x60)        /*!< Bit Value =(0x6):DIV64 of 8bit */
N#define CFG_OR03_IWDT_DIV_div128_w                  ((uint32_t)0x00000070)  /*!< Bit Value =(0x7):DIV128 of 32bit */
N#define CFG_OR03_IWDT_DIV_div128_h0                 ((uint16_t)0x0070)      /*!< Bit Value =(0x7):DIV128 of 16bit */
N#define CFG_OR03_IWDT_DIV_div128_b0                 ((uint8_t )0x70)        /*!< Bit Value =(0x7):DIV128 of 8bit */
N#define CFG_OR03_IWDT_DIV_div256_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(0x8):DIV256 of 32bit */
N#define CFG_OR03_IWDT_DIV_div256_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(0x8):DIV256 of 16bit */
N#define CFG_OR03_IWDT_DIV_div256_b0                 ((uint8_t )0x80)        /*!< Bit Value =(0x8):DIV256 of 8bit */
N#define CFG_OR03_IWDT_DIV_div512_w                  ((uint32_t)0x00000090)  /*!< Bit Value =(0x9):DIV512 of 32bit */
N#define CFG_OR03_IWDT_DIV_div512_h0                 ((uint16_t)0x0090)      /*!< Bit Value =(0x9):DIV512 of 16bit */
N#define CFG_OR03_IWDT_DIV_div512_b0                 ((uint8_t )0x90)        /*!< Bit Value =(0x9):DIV512 of 8bit */
N#define CFG_OR03_IWDT_DIV_div1024_w                 ((uint32_t)0x000000A0)  /*!< Bit Value =(0xA):DIV1024 of 32bit */
N#define CFG_OR03_IWDT_DIV_div1024_h0                ((uint16_t)0x00A0)      /*!< Bit Value =(0xA):DIV1024 of 16bit */
N#define CFG_OR03_IWDT_DIV_div1024_b0                ((uint8_t )0xA0)        /*!< Bit Value =(0xA):DIV1024 of 8bit */
N#define CFG_OR03_IWDT_DIV_div2048_w                 ((uint32_t)0x000000B0)  /*!< Bit Value =(0xB):DIV2048 of 32bit */
N#define CFG_OR03_IWDT_DIV_div2048_h0                ((uint16_t)0x00B0)      /*!< Bit Value =(0xB):DIV2048 of 16bit */
N#define CFG_OR03_IWDT_DIV_div2048_b0                ((uint8_t )0xB0)        /*!< Bit Value =(0xB):DIV2048 of 8bit */
N#define CFG_OR03_IWDT_DIV_div4096_w                 ((uint32_t)0x000000C0)  /*!< Bit Value =(0xC):DIV4096 of 32bit */
N#define CFG_OR03_IWDT_DIV_div4096_h0                ((uint16_t)0x00C0)      /*!< Bit Value =(0xC):DIV4096 of 16bit */
N#define CFG_OR03_IWDT_DIV_div4096_b0                ((uint8_t )0xC0)        /*!< Bit Value =(0xC):DIV4096 of 8bit */
N
N#define CFG_OR03_IWDT_WE_mask_w                     ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_WE_mask_h0                    ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_WE_mask_b0                    ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_WE_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR03_IWDT_WE_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR03_IWDT_WE_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR03_IWDT_WE_enable_w                   ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR03_IWDT_WE_enable_h0                  ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR03_IWDT_WE_enable_b0                  ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR03_IWDT_WP_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_WP_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_WP_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_WP_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR03_IWDT_WP_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR03_IWDT_WP_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR03_IWDT_WP_enable_w                   ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR03_IWDT_WP_enable_h0                  ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR03_IWDT_WP_enable_b0                  ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR03_IWDT_EN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_OR03_IWDT_EN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_OR03_IWDT_EN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR03_IWDT_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR03_IWDT_EN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR03_IWDT_EN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR03_IWDT_EN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR03_IWDT_EN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR03_IWDT_EN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR04  [register's definitions]
N *              Offset[0x20]  CFG option byte register 04 (0x4FF00020)
N ******************************************************************************
N */
N///@{
N#define CFG_OR04_default                            ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR04 */
N#define CFG_OR04_HSP_EN_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CFG_OR04_HSP_EN_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CFG_OR04_HSP_EN_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CFG_OR04_HSP_EN_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR04_HSP_EN_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR04_HSP_EN_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR04_HSP_EN_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR04_HSP_EN_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR04_HSP_EN_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR04_IAP_AEN_mask_w                     ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_OR04_IAP_AEN_mask_h0                    ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_OR04_IAP_AEN_mask_b0                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR04_IAP_AEN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR04_IAP_AEN_disable_h0                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR04_IAP_AEN_disable_b0                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR04_IAP_AEN_enable_w                   ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR04_IAP_AEN_enable_h0                  ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR04_IAP_AEN_enable_b0                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR05  [register's definitions]
N *              Offset[0x24]  CFG option byte register 05 (0x4FF00024)
N ******************************************************************************
N */
N///@{
N#define CFG_OR05_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR05 */
N#define CFG_OR05_XOSC_EN_mask_w                     ((uint32_t)0x80000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_XOSC_EN_mask_h1                    ((uint16_t)0x8000)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_XOSC_EN_mask_b3                    ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_XOSC_EN_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR05_XOSC_EN_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR05_XOSC_EN_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR05_XOSC_EN_enable_w                   ((uint32_t)0x80000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR05_XOSC_EN_enable_h1                  ((uint16_t)0x8000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR05_XOSC_EN_enable_b3                  ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR05_XOSC_DB_mask_w                     ((uint32_t)0x10000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_XOSC_DB_mask_h1                    ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_XOSC_DB_mask_b3                    ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_XOSC_DB_4096_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):4096 of 32bit */
N#define CFG_OR05_XOSC_DB_4096_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):4096 of 16bit */
N#define CFG_OR05_XOSC_DB_4096_b3                    ((uint8_t )0x00)        /*!< Bit Value =(0):4096 of 8bit */
N#define CFG_OR05_XOSC_DB_1024_w                     ((uint32_t)0x10000000)  /*!< Bit Value =(1):1024 of 32bit */
N#define CFG_OR05_XOSC_DB_1024_h1                    ((uint16_t)0x1000)      /*!< Bit Value =(1):1024 of 16bit */
N#define CFG_OR05_XOSC_DB_1024_b3                    ((uint8_t )0x10)        /*!< Bit Value =(1):1024 of 8bit */
N
N#define CFG_OR05_XOSC_GN_mask_w                     ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_XOSC_GN_mask_h1                    ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_XOSC_GN_mask_b3                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_XOSC_GN_32k_normal_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):32K_Normal of 32bit */
N#define CFG_OR05_XOSC_GN_32k_normal_h1              ((uint16_t)0x0000)      /*!< Bit Value =(0x0):32K_Normal of 16bit */
N#define CFG_OR05_XOSC_GN_32k_normal_b3              ((uint8_t )0x00)        /*!< Bit Value =(0x0):32K_Normal of 8bit */
N#define CFG_OR05_XOSC_GN_medium_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(0x1):Medium of 32bit */
N#define CFG_OR05_XOSC_GN_medium_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Medium of 16bit */
N#define CFG_OR05_XOSC_GN_medium_b3                  ((uint8_t )0x01)        /*!< Bit Value =(0x1):Medium of 8bit */
N#define CFG_OR05_XOSC_GN_32k_lowest_w               ((uint32_t)0x02000000)  /*!< Bit Value =(0x2):32K_Lowest of 32bit */
N#define CFG_OR05_XOSC_GN_32k_lowest_h1              ((uint16_t)0x0200)      /*!< Bit Value =(0x2):32K_Lowest of 16bit */
N#define CFG_OR05_XOSC_GN_32k_lowest_b3              ((uint8_t )0x02)        /*!< Bit Value =(0x2):32K_Lowest of 8bit */
N
N#define CFG_OR05_HSWKP_mask_w                       ((uint32_t)0x00C00000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_HSWKP_mask_h1                      ((uint16_t)0x00C0)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_HSWKP_mask_b2                      ((uint8_t )0xC0)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_HSWKP_0us_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):0us of 32bit */
N#define CFG_OR05_HSWKP_0us_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):0us of 16bit */
N#define CFG_OR05_HSWKP_0us_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):0us of 8bit */
N#define CFG_OR05_HSWKP_30us_w                       ((uint32_t)0x00400000)  /*!< Bit Value =(0x1):30us of 32bit */
N#define CFG_OR05_HSWKP_30us_h1                      ((uint16_t)0x0040)      /*!< Bit Value =(0x1):30us of 16bit */
N#define CFG_OR05_HSWKP_30us_b2                      ((uint8_t )0x40)        /*!< Bit Value =(0x1):30us of 8bit */
N#define CFG_OR05_HSWKP_60us_w                       ((uint32_t)0x00800000)  /*!< Bit Value =(0x2):60us of 32bit */
N#define CFG_OR05_HSWKP_60us_h1                      ((uint16_t)0x0080)      /*!< Bit Value =(0x2):60us of 16bit */
N#define CFG_OR05_HSWKP_60us_b2                      ((uint8_t )0x80)        /*!< Bit Value =(0x2):60us of 8bit */
N#define CFG_OR05_HSWKP_120us_w                      ((uint32_t)0x00C00000)  /*!< Bit Value =(0x3):120us of 32bit */
N#define CFG_OR05_HSWKP_120us_h1                     ((uint16_t)0x00C0)      /*!< Bit Value =(0x3):120us of 16bit */
N#define CFG_OR05_HSWKP_120us_b2                     ((uint8_t )0xC0)        /*!< Bit Value =(0x3):120us of 8bit */
N
N#define CFG_OR05_PLL_CTL_mask_w                     ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_PLL_CTL_mask_h1                    ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_PLL_CTL_mask_b2                    ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_PLL_CTL_shift_w                    (20)                    /*!< Bit Shift of 32bit */
N#define CFG_OR05_PLL_CTL_shift_h1                   (4)                     /*!< Bit Shift of 16bit */
N#define CFG_OR05_PLL_CTL_shift_b2                   (4)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR05_HS_SEL_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_HS_SEL_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_HS_SEL_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_HS_SEL_ihrco_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):IHRCO of 32bit */
N#define CFG_OR05_HS_SEL_ihrco_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0):IHRCO of 16bit */
N#define CFG_OR05_HS_SEL_ihrco_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0):IHRCO of 8bit */
N#define CFG_OR05_HS_SEL_ilrco_w                     ((uint32_t)0x00020000)  /*!< Bit Value =(1):ILRCO of 32bit */
N#define CFG_OR05_HS_SEL_ilrco_h1                    ((uint16_t)0x0002)      /*!< Bit Value =(1):ILRCO of 16bit */
N#define CFG_OR05_HS_SEL_ilrco_b2                    ((uint8_t )0x02)        /*!< Bit Value =(1):ILRCO of 8bit */
N
N#define CFG_OR05_PON_MDS_mask_w                     ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_PON_MDS_mask_h0                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_PON_MDS_mask_b1                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_PON_MDS_fast_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Fast of 32bit */
N#define CFG_OR05_PON_MDS_fast_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Fast of 16bit */
N#define CFG_OR05_PON_MDS_fast_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Fast of 8bit */
N#define CFG_OR05_PON_MDS_slow_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Slow of 32bit */
N#define CFG_OR05_PON_MDS_slow_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Slow of 16bit */
N#define CFG_OR05_PON_MDS_slow_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Slow of 8bit */
N
N#define CFG_OR05_SWD_PIN_mask_w                     ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_SWD_PIN_mask_h0                    ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_SWD_PIN_mask_b0                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_SWD_PIN_enable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_OR05_SWD_PIN_enable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_OR05_SWD_PIN_enable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_OR05_SWD_PIN_disable_w                  ((uint32_t)0x00000002)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_OR05_SWD_PIN_disable_h0                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_OR05_SWD_PIN_disable_b0                 ((uint8_t )0x02)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CFG_OR05_EXRST_PIN_mask_w                   ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_OR05_EXRST_PIN_mask_h0                  ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_OR05_EXRST_PIN_mask_b0                  ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR05_EXRST_PIN_enable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_OR05_EXRST_PIN_enable_h0                ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_OR05_EXRST_PIN_enable_b0                ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_OR05_EXRST_PIN_disable_w                ((uint32_t)0x00000001)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_OR05_EXRST_PIN_disable_h0               ((uint16_t)0x0001)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_OR05_EXRST_PIN_disable_b0               ((uint8_t )0x01)        /*!< Bit Value =(1):Disable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR07  [register's definitions]
N *              Offset[0x2C]  CFG option byte register 07 (0x4FF0002C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR07_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR07 */
N#define CFG_OR07_GF_mask_w                          ((uint32_t)0x0000E000)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_GF_mask_h0                         ((uint16_t)0xE000)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_GF_mask_b1                         ((uint8_t )0xE0)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_GF_disable_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_GF_disable_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_GF_disable_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_GF_enable_w                        ((uint32_t)0x00002000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_GF_enable_h0                       ((uint16_t)0x2000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_GF_enable_b1                       ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_CGIL_mask_w                        ((uint32_t)0x00001000)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_CGIL_mask_h0                       ((uint16_t)0x1000)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_CGIL_mask_b1                       ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_CGIL_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_CGIL_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_CGIL_disable_b1                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_CGIL_enable_w                      ((uint32_t)0x00001000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_CGIL_enable_h0                     ((uint16_t)0x1000)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_CGIL_enable_b1                     ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_DPORDS_mask_w                      ((uint32_t)0x00000800)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_DPORDS_mask_h0                     ((uint16_t)0x0800)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_DPORDS_mask_b1                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_DPORDS_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_DPORDS_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_DPORDS_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_DPORDS_enable_w                    ((uint32_t)0x00000800)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_DPORDS_enable_h0                   ((uint16_t)0x0800)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_DPORDS_enable_b1                   ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_PORDS_mask_w                       ((uint32_t)0x00000400)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_PORDS_mask_h0                      ((uint16_t)0x0400)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_PORDS_mask_b1                      ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_PORDS_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_PORDS_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_PORDS_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_PORDS_enable_w                     ((uint32_t)0x00000400)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_PORDS_enable_h0                    ((uint16_t)0x0400)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_PORDS_enable_b1                    ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_PNDRC_mask_w                       ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_PNDRC_mask_h0                      ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_PNDRC_mask_b1                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_PNDRC_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_PNDRC_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_PNDRC_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_PNDRC_enable_w                     ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_PNDRC_enable_h0                    ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_PNDRC_enable_b1                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_PNDCE_mask_w                       ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_PNDCE_mask_h0                      ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_PNDCE_mask_b1                      ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_PNDCE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_PNDCE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_PNDCE_disable_b1                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_PNDCE_enable_w                     ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_PNDCE_enable_h0                    ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_PNDCE_enable_b1                    ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_LVRDS1_mask_w                      ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_LVRDS1_mask_h0                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_LVRDS1_mask_b0                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_LVRDS1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_LVRDS1_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_LVRDS1_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_LVRDS1_enable_w                    ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_LVRDS1_enable_h0                   ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_LVRDS1_enable_b0                   ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_LVRDS0_mask_w                      ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_LVRDS0_mask_h0                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_LVRDS0_mask_b0                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_LVRDS0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_LVRDS0_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_LVRDS0_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_LVRDS0_enable_w                    ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_LVRDS0_enable_h0                   ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_LVRDS0_enable_b0                   ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_LVRDE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_LVRDE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_LVRDE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_LVRDE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_LVRDE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_LVRDE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_LVRDE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_LVRDE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_LVRDE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_CG22_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_CG22_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_CG22_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_CG22_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_CG22_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_CG22_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_CG22_enable_w                      ((uint32_t)0x00000004)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_CG22_enable_h0                     ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_CG22_enable_b0                     ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_OR07_CG21_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_OR07_CG21_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_OR07_CG21_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_OR07_CG21_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_OR07_CG21_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_OR07_CG21_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_OR07_CG21_enable_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_OR07_CG21_enable_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_OR07_CG21_enable_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR11  [register's definitions]
N *              Offset[0x34]  CFG option byte register 11 (0x4FF00034)
N ******************************************************************************
N */
N///@{
N#define CFG_OR11_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR11 */
N#define CFG_OR11_DAC_CTRM0_mask_w                   ((uint32_t)0x001F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR11_DAC_CTRM0_mask_h1                  ((uint16_t)0x001F)      /*!< Bit Mask of 16bit */
N#define CFG_OR11_DAC_CTRM0_mask_b2                  ((uint8_t )0x1F)        /*!< Bit Mask of 8bit */
N#define CFG_OR11_DAC_CTRM0_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR11_DAC_CTRM0_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR11_DAC_CTRM0_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR11_VBG_BTRM_mask_w                    ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define CFG_OR11_VBG_BTRM_mask_h0                   ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR11_VBG_BTRM_mask_b1                   ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CFG_OR11_VBG_BTRM_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR11_VBG_BTRM_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR11_VBG_BTRM_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR11_VBG_OTRM_mask_w                    ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define CFG_OR11_VBG_OTRM_mask_h0                   ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define CFG_OR11_VBG_OTRM_mask_b0                   ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CFG_OR11_VBG_OTRM_shift_w                   (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR11_VBG_OTRM_shift_h0                  (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR11_VBG_OTRM_shift_b0                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR12  [register's definitions]
N *              Offset[0x38]  CFG option byte register 12 (0x4FF00038)
N ******************************************************************************
N */
N///@{
N#define CFG_OR12_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR12 */
N#define CFG_OR12_LVR_TRM_mask_w                     ((uint32_t)0x000F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR12_LVR_TRM_mask_h1                    ((uint16_t)0x000F)      /*!< Bit Mask of 16bit */
N#define CFG_OR12_LVR_TRM_mask_b2                    ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CFG_OR12_LVR_TRM_shift_w                    (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR12_LVR_TRM_shift_h1                   (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR12_LVR_TRM_shift_b2                   (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR12_BOD1_TRM_mask_w                    ((uint32_t)0x00000F00)  /*!< Bit Mask of 32bit */
N#define CFG_OR12_BOD1_TRM_mask_h0                   ((uint16_t)0x0F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR12_BOD1_TRM_mask_b1                   ((uint8_t )0x0F)        /*!< Bit Mask of 8bit */
N#define CFG_OR12_BOD1_TRM_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR12_BOD1_TRM_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR12_BOD1_TRM_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR13  [register's definitions]
N *              Offset[0x3C]  CFG option byte register 13 (0x4FF0003C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR13_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR13 */
N#define CFG_OR13_IHR1_CTRM_mask_w                   ((uint32_t)0x03000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR1_CTRM_mask_h1                  ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR1_CTRM_mask_b3                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR1_CTRM_shift_w                  (24)                    /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR1_CTRM_shift_h1                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR1_CTRM_shift_b3                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR13_IHR1_FTRM_mask_w                   ((uint32_t)0x007F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR1_FTRM_mask_h1                  ((uint16_t)0x007F)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR1_FTRM_mask_b2                  ((uint8_t )0x7F)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR1_FTRM_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR1_FTRM_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR1_FTRM_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR13_IHR0_CTRM_mask_w                   ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR0_CTRM_mask_h0                  ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR0_CTRM_mask_b1                  ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR0_CTRM_shift_w                  (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR0_CTRM_shift_h0                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR0_CTRM_shift_b1                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR13_IHR0_FTRM_mask_w                   ((uint32_t)0x0000007F)  /*!< Bit Mask of 32bit */
N#define CFG_OR13_IHR0_FTRM_mask_h0                  ((uint16_t)0x007F)      /*!< Bit Mask of 16bit */
N#define CFG_OR13_IHR0_FTRM_mask_b0                  ((uint8_t )0x7F)        /*!< Bit Mask of 8bit */
N#define CFG_OR13_IHR0_FTRM_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR13_IHR0_FTRM_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR13_IHR0_FTRM_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR14  [register's definitions]
N *              Offset[0x40]  CFG option byte register 14 (0x4FF00040)
N ******************************************************************************
N */
N///@{
N#define CFG_OR14_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR14 */
N#define CFG_OR14_IHR_BGTI_mask_w                    ((uint32_t)0x0000E000)  /*!< Bit Mask of 32bit */
N#define CFG_OR14_IHR_BGTI_mask_h0                   ((uint16_t)0xE000)      /*!< Bit Mask of 16bit */
N#define CFG_OR14_IHR_BGTI_mask_b1                   ((uint8_t )0xE0)        /*!< Bit Mask of 8bit */
N#define CFG_OR14_IHR_BGTI_shift_w                   (13)                    /*!< Bit Shift of 32bit */
N#define CFG_OR14_IHR_BGTI_shift_h0                  (13)                    /*!< Bit Shift of 16bit */
N#define CFG_OR14_IHR_BGTI_shift_b1                  (5)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR14_IHR_BGTV_mask_w                    ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define CFG_OR14_IHR_BGTV_mask_h0                   ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define CFG_OR14_IHR_BGTV_mask_b1                   ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR14_IHR_BGTV_shift_w                   (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR14_IHR_BGTV_shift_h0                  (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR14_IHR_BGTV_shift_b1                  (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR14_ILR_TRM_mask_w                     ((uint32_t)0x00000003)  /*!< Bit Mask of 32bit */
N#define CFG_OR14_ILR_TRM_mask_h0                    ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define CFG_OR14_ILR_TRM_mask_b0                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define CFG_OR14_ILR_TRM_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR14_ILR_TRM_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR14_ILR_TRM_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR15  [register's definitions]
N *              Offset[0x44]  CFG option byte register 15 (0x4FF00044)
N ******************************************************************************
N */
N///@{
N#define CFG_OR15_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR15 */
N#define CFG_OR15_ADC0_REFT_mask_w                   ((uint32_t)0x3F000000)  /*!< Bit Mask of 32bit */
N#define CFG_OR15_ADC0_REFT_mask_h1                  ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR15_ADC0_REFT_mask_b3                  ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define CFG_OR15_ADC0_REFT_shift_w                  (24)                    /*!< Bit Shift of 32bit */
N#define CFG_OR15_ADC0_REFT_shift_h1                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR15_ADC0_REFT_shift_b3                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR15_ADC0_REFM_mask_w                   ((uint32_t)0x003F0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR15_ADC0_REFM_mask_h1                  ((uint16_t)0x003F)      /*!< Bit Mask of 16bit */
N#define CFG_OR15_ADC0_REFM_mask_b2                  ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define CFG_OR15_ADC0_REFM_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR15_ADC0_REFM_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR15_ADC0_REFM_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR15_ADC0_REFB_mask_w                   ((uint32_t)0x00003F00)  /*!< Bit Mask of 32bit */
N#define CFG_OR15_ADC0_REFB_mask_h0                  ((uint16_t)0x3F00)      /*!< Bit Mask of 16bit */
N#define CFG_OR15_ADC0_REFB_mask_b1                  ((uint8_t )0x3F)        /*!< Bit Mask of 8bit */
N#define CFG_OR15_ADC0_REFB_shift_w                  (8)                     /*!< Bit Shift of 32bit */
N#define CFG_OR15_ADC0_REFB_shift_h0                 (8)                     /*!< Bit Shift of 16bit */
N#define CFG_OR15_ADC0_REFB_shift_b1                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR16  [register's definitions]
N *              Offset[0x48]  CFG option byte register 16 (0x4FF00048)
N ******************************************************************************
N */
N///@{
N#define CFG_OR16_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR16 */
N#define CFG_OR16_TEMP_CAL1_mask_w                   ((uint32_t)0x0FFF0000)  /*!< Bit Mask of 32bit */
N#define CFG_OR16_TEMP_CAL1_mask_h1                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define CFG_OR16_TEMP_CAL1_shift_w                  (16)                    /*!< Bit Shift of 32bit */
N#define CFG_OR16_TEMP_CAL1_shift_h1                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR16_TEMP_CAL1_shift_b2                 (0)                     /*!< Bit Shift of 8bit */
N
N#define CFG_OR16_TEMP_CAL0_mask_w                   ((uint32_t)0x00000FFF)  /*!< Bit Mask of 32bit */
N#define CFG_OR16_TEMP_CAL0_mask_h0                  ((uint16_t)0x0FFF)      /*!< Bit Mask of 16bit */
N#define CFG_OR16_TEMP_CAL0_shift_w                  (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR16_TEMP_CAL0_shift_h0                 (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR16_TEMP_CAL0_shift_b0                 (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_OR17  [register's definitions]
N *              Offset[0x4C]  CFG option byte register 17 (0x4FF0004C)
N ******************************************************************************
N */
N///@{
N#define CFG_OR17_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_OR17 */
N#define CFG_OR17_LDO_TRM_mask_w                     ((uint32_t)0x00000007)  /*!< Bit Mask of 32bit */
N#define CFG_OR17_LDO_TRM_mask_h0                    ((uint16_t)0x0007)      /*!< Bit Mask of 16bit */
N#define CFG_OR17_LDO_TRM_mask_b0                    ((uint8_t )0x07)        /*!< Bit Mask of 8bit */
N#define CFG_OR17_LDO_TRM_shift_w                    (0)                     /*!< Bit Shift of 32bit */
N#define CFG_OR17_LDO_TRM_shift_h0                   (0)                     /*!< Bit Shift of 16bit */
N#define CFG_OR17_LDO_TRM_shift_b0                   (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_TST0  [register's definitions]
N *              Offset[0x60]  CFG Test register 0 (not load from flash memory) (0x4FF00060)
N ******************************************************************************
N */
N///@{
N#define CFG_TST0_default                            ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_TST0 */
N#define CFG_TST0_PNDF_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_PNDF_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_PNDF_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_PNDF_shift_w                       (6)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_PNDF_shift_h0                      (6)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_PNDF_shift_b0                      (6)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_DBLVRF_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_DBLVRF_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_DBLVRF_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_DBLVRF_shift_w                     (5)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_DBLVRF_shift_h0                    (5)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_DBLVRF_shift_b0                    (5)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_LVRF0_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_LVRF0_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_LVRF0_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_LVRF0_shift_w                      (4)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_LVRF0_shift_h0                     (4)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_LVRF0_shift_b0                     (4)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_DPORF_mask_w                       ((uint32_t)0x00000008)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_DPORF_mask_h0                      ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_DPORF_mask_b0                      ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_DPORF_shift_w                      (3)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_DPORF_shift_h0                     (3)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_DPORF_shift_b0                     (3)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_POF2_mask_w                        ((uint32_t)0x00000004)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_POF2_mask_h0                       ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_POF2_mask_b0                       ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_POF2_shift_w                       (2)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_POF2_shift_h0                      (2)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_POF2_shift_b0                      (2)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_POF1_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_POF1_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_POF1_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_POF1_shift_w                       (1)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_POF1_shift_h0                      (1)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_POF1_shift_b0                      (1)                     /*!< Bit Shift of 8bit */
N
N#define CFG_TST0_POF0_mask_w                        ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_TST0_POF0_mask_h0                       ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_TST0_POF0_mask_b0                       ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST0_POF0_shift_w                       (0)                     /*!< Bit Shift of 32bit */
N#define CFG_TST0_POF0_shift_h0                      (0)                     /*!< Bit Shift of 16bit */
N#define CFG_TST0_POF0_shift_b0                      (0)                     /*!< Bit Shift of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        CFG_TST1  [register's definitions]
N *              Offset[0x64]  CFG Test register 1 (not load from flash memory) (0x4FF00064)
N ******************************************************************************
N */
N///@{
N#define CFG_TST1_default                            ((uint32_t)0x00040000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of CFG_TST1 */
N#define CFG_TST1_PLL_TST_mask_w                     ((uint32_t)0x01000000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_PLL_TST_mask_h1                    ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_PLL_TST_mask_b3                    ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_PLL_TST_disable_w                  ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_PLL_TST_disable_h1                 ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_PLL_TST_disable_b3                 ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_PLL_TST_enable_w                   ((uint32_t)0x01000000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_PLL_TST_enable_h1                  ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_PLL_TST_enable_b3                  ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_ILRCO_EN_mask_w                    ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_ILRCO_EN_mask_h1                   ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_ILRCO_EN_mask_b2                   ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_ILRCO_EN_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_ILRCO_EN_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_ILRCO_EN_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_ILRCO_EN_enable_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_ILRCO_EN_enable_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_ILRCO_EN_enable_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_ILRCK_OE_mask_w                    ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_ILRCK_OE_mask_h1                   ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_ILRCK_OE_mask_b2                   ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_ILRCK_OE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_ILRCK_OE_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_ILRCK_OE_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_ILRCK_OE_enable_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_ILRCK_OE_enable_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_ILRCK_OE_enable_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_IHRCK_OE_mask_w                    ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_IHRCK_OE_mask_h1                   ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_IHRCK_OE_mask_b2                   ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_IHRCK_OE_disable_w                 ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_IHRCK_OE_disable_h1                ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_IHRCK_OE_disable_b2                ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_IHRCK_OE_enable_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_IHRCK_OE_enable_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_IHRCK_OE_enable_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_LVR_DIS_mask_w                     ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_LVR_DIS_mask_h0                    ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_LVR_DIS_mask_b1                    ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_LVR_DIS_enable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Enable of 32bit */
N#define CFG_TST1_LVR_DIS_enable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Enable of 16bit */
N#define CFG_TST1_LVR_DIS_enable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Enable of 8bit */
N#define CFG_TST1_LVR_DIS_disable_w                  ((uint32_t)0x00000200)  /*!< Bit Value =(1):Disable of 32bit */
N#define CFG_TST1_LVR_DIS_disable_h0                 ((uint16_t)0x0200)      /*!< Bit Value =(1):Disable of 16bit */
N#define CFG_TST1_LVR_DIS_disable_b1                 ((uint8_t )0x02)        /*!< Bit Value =(1):Disable of 8bit */
N
N#define CFG_TST1_BOD_OE_mask_w                      ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_BOD_OE_mask_h0                     ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_BOD_OE_mask_b1                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_BOD_OE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_BOD_OE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_BOD_OE_disable_b1                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_BOD_OE_enable_w                    ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_BOD_OE_enable_h0                   ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_BOD_OE_enable_b1                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define CFG_TST1_FLH_WE_mask_w                      ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define CFG_TST1_FLH_WE_mask_h0                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define CFG_TST1_FLH_WE_mask_b0                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define CFG_TST1_FLH_WE_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define CFG_TST1_FLH_WE_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define CFG_TST1_FLH_WE_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define CFG_TST1_FLH_WE_enable_w                    ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define CFG_TST1_FLH_WE_enable_h0                   ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define CFG_TST1_FLH_WE_enable_b0                   ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_CFG_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_CFG.h                         */
N/*----------------------------------------------------------------------------*/
L 31 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_CFG_DRV.H" 2
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define ADC_RefTopMask          CFG_OR15_ADC0_REFT_mask_b3      /*!<  */	
N#define ADC_RefMiddleMask       CFG_OR15_ADC0_REFM_mask_b2      /*!<  */
N#define ADC_RefBottomMask       CFG_OR15_ADC0_REFB_mask_b1      /*!<  */
N
N#define CFG_TempHighCalMask      CFG_OR16_TEMP_CAL1_mask_h1      /*!<  */
N#define CFG_TempLowCalMask      CFG_OR16_TEMP_CAL0_mask_h0      /*!<  */
N
N#define CFG_PNDF        CFG_TST0_PNDF_mask_w        /*!<  */
N#define CFG_DBLVRF      CFG_TST0_DBLVRF_mask_w      /*!<  */
N#define CFG_LVRF0       CFG_TST0_LVRF0_mask_w       /*!<  */
N#define CFG_DPORF       CFG_TST0_DPORF_mask_w       /*!<  */
N#define CFG_POF2        CFG_TST0_POF2_mask_w        /*!<  */
N#define CFG_POF1        CFG_TST0_POF1_mask_w        /*!<  */
N#define CFG_POF0        CFG_TST0_POF0_mask_w        /*!<  */
N#define CFG_ALLF        CFG_PNDF | CFG_DBLVRF | CFG_LVRF0 | CFG_DPORF | CFG_DPORF | CFG_POF2 | CFG_POF1 | CFG_POF0      /*!<  */
N
N/* @} */
N
N/**
N * @name    Function announce
N *
N */ 
N///@{
N#if defined(MG32_1ST)
X#if 1L
Nuint8_t CFG_GetADC0RefTop (void);
Nvoid CFG_SetADC0RefTop (uint8_t ADC_REFT);
Nuint8_t CFG_GetADC0RefMiddle (void);
Nvoid CFG_SetADC0RefMiddle (uint8_t ADC_REFM);
Nuint8_t CFG_GetADC0RefBottom (void);
Nvoid CFG_SetADC0RefBottom (uint8_t ADC_REFB);
N#endif
N
N
Nuint32_t CFG_GetAllFlagStatus (void);
NDRV_Return CFG_GetSingleFlagStatus (uint32_t CFG_ITSrc);
Nvoid CFG_ClearFlag (uint32_t CFG_ITSrc);
N///@}
L 39 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N#include "MG32x02z_PW_DRV.H"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_PW_DRV.H" 1
N/**
N *******************************************************************************
N *
N * @file        MG32x02z_PW_DRV.H
N *
N * @brief       This is the C code format driver head file for PW module.
N *
N * @par         Project
N *              MG32x02z
N * @version     V1.22
N * @date        2021/04/28
N * @author      Megawin Software Center
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N *******************************************************************************
N * @par         Disclaimer 
N * The Demo software is provided "AS IS" without any warranty, either 
N * expressed or implied, including, but not limited to, the implied warranties 
N * of merchantability and fitness for a particular purpose. The author will 
N * not be liable for any special, incidental, consequential or indirect 
N * damages due to loss of data or any other reason. 
N * These statements agree with the world wide and local dictated laws about 
N * authorship and violence against these laws. 
N *******************************************************************************
N *******************************************************************************
N */ 
N 
N 
N#include "MG32x02z__Common_DRV.h"
N#include "MG32x02z_PW.h"
L 1 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include\MG32x02z_PW.h" 1
N/**
N ******************************************************************************
N *
N * @file        MG32x02z_PW.h
N *
N * @brief       MG32x02z PW Register Definitions Header File
N *
N * @par         Project
N *              MG32x02z
N * @version     V3.9 (Register File Date : 2021_0331)
N * @date        2021/04/07 18:41 (H File Generated Date)
N * @author      HeadCodeGen V1.10
N * @copyright   Copyright (c) 2021 Megawin Technology Co., Ltd.
N *              All rights reserved.
N *
N * Important!   This file is generated by code generator. Do not edit!
N *
N ******************************************************************************
N */
N
N#ifndef _MG32x02z_PW_H
N#define _MG32x02z_PW_H
N#define _MG32x02z_PW_H_VER                          3.9     /*!< File Version */
N
N#if !(MG32x02z_H_VER == MG32x02z_PW_H_VER)
S    #error "MG32x02z_PW_H - Main/Module Version Mismatch !"
N#endif
N
N/**
N ******************************************************************************
N *
N * @struct      PW_Struct
N *              PW  [Module Structure Typedef]
N *
N ******************************************************************************
N */
Ntypedef struct
N{
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  PORF          :1;     //[1] Power-On reset status flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  PORF          :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BOD0F         :1;     //[4] BOD0 brown-out detection interrupt flag
X            volatile uint8_t  BOD0F         :1;     
N                                        //0 = Normal : No event occurred and VDD is than high BOD0 threshold
N                                        //1 = Happened : Event happened and VDD is  lower than BOD0 threshold
N            __IO uint8_t  BOD1F         :1;     //[5] BOD1 brown-out detection interrupt flag
X            volatile uint8_t  BOD1F         :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WKF           :1;     //[7] System received wakeup event flag. (set by hardware and clear by software writing 1)
X            volatile uint8_t  WKF           :1;     
N                                        //0 = Normal (No event occurred)
N                                        //1 = Happened (Event happened)
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t  STATE         :2;     //[17..16] System operation power mode state
X            volatile const  uint8_t  STATE         :2;     
N                                        //0x0 = ON
N                                        //0x1 = SLEEP
N                                        //0x2 = STOP
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t  WKMODE        :2;     //[21..20] System wakeup from which power-down mode status.
X            volatile const  uint8_t  WKMODE        :2;     
N                                        //0x0 = NONE : Never wakeup from power-down mode.
N                                        //0x1 = SLEEP
N                                        //0x2 = STOP
N                                        //0x3 = Reserved
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[24] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t  BOD1_S        :1;     //[25] Brown-Out detect BOD1 status.
X            volatile const  uint8_t  BOD1_S        :1;     
N                                        //0 = High : VDD is high than BOD1 threshold
N                                        //1 = Low : VDD is  lower than BOD1 threshold
N            __I  uint8_t                :6;     //[31..26] 
X            volatile const  uint8_t                :6;     
N        }MBIT;
N    }STA;                               /*!< STA        ~ Offset[0x00]  PW status register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint8_t  IEA           :1;     //[0] PW interrupt all enable
X            volatile uint8_t  IEA           :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :3;     //[3..1] 
X            volatile const  uint8_t                :3;     
N            __IO uint8_t  BOD0_IE       :1;     //[4] BOD0 brown-out detection interrupt enable.
X            volatile uint8_t  BOD0_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD1_IE       :1;     //[5] BOD1 brown-out detection interrupt enable.
X            volatile uint8_t  BOD1_IE       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[6] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WK_IE         :1;     //[7] System received wakeup event interrupt enable bit.
X            volatile uint8_t  WK_IE         :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }INT;                               /*!< INT        ~ Offset[0x04]  PW interrupt enable register */
N
N    __I uint32_t  RESERVED0;            /*!< RESERVED0  ~ Offset[0x08]  Reserved */
X    volatile const uint32_t  RESERVED0;             
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __IO uint16_t KEY           :16;    //[15..0] PW key register
X            volatile uint16_t KEY           :16;    
N                                        //0 = Unprotected
N                                        //1 = Protected
N            __I  uint16_t               :16;    //[31..16] 
X            volatile const  uint16_t               :16;    
N        }MBIT;
N    }KEY;                               /*!< KEY        ~ Offset[0x0C]  PW write protected Key register */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  IVR_EN        :1;     //[1] Internal voltage reference source enable
X            volatile uint8_t  IVR_EN        :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[2] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[3] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  BOD0_EN       :1;     //[4] BOD0 voltage detect enable.
X            volatile uint8_t  BOD0_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  BOD1_EN       :1;     //[5] BOD1 voltage detect enable.
X            volatile uint8_t  BOD1_EN       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  LDO_ON        :1;     //[6] Core voltage LDO mode select when ON or SLEEP mode.
X            volatile uint8_t  LDO_ON        :1;     
N                                        //0 = Normal
N                                        //1 = Low power
N            __IO uint8_t  LDO_STP       :1;     //[7] Core voltage LDO mode select when STOP mode. (default=1)
X            volatile uint8_t  LDO_STP       :1;     
N                                        //0 = Normal
N                                        //1 = Low power
N            __IO uint8_t  BOD1_TRGS     :2;     //[9..8] BOD1 Interrupt trigger selection.
X            volatile uint8_t  BOD1_TRGS     :2;     
N                                        //0x0 = Reserved
N                                        //0x1 = Rising edge
N                                        //0x2 = Falling edge
N                                        //0x3 = Dual-edge
N            __IO uint8_t  BOD1_TH       :2;     //[11..10] BOD1 detect voltage threshold select
X            volatile uint8_t  BOD1_TH       :2;     
N                                        //0x0 = 2.0v
N                                        //0x1 = 2.4v
N                                        //0x2 = 3.7v
N                                        //0x3 = 4.2v
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :2;     //[17..16] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[19..18] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  WKSTP_DSEL    :2;     //[21..20] Wakeup delay time selection from STOP mode 
X            volatile uint8_t  WKSTP_DSEL    :2;     
N                                        //0x0 = DT0 (45~60us)
N                                        //0x1 = DT1 (60~75us)
N                                        //0x2 = DT2 (90~105us)
N                                        //0x3 = DT3 (150~165us)
N            __I  uint8_t                :2;     //[23..22] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[25..24] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :2;     //[27..26] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :4;     //[31..28] 
X            volatile const  uint8_t                :4;     
N        }MBIT;
N    }CR0;                               /*!< CR0        ~ Offset[0x10]  PW control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  STP_POR       :1;     //[1] POR power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_POR       :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __IO uint8_t  STP_BOD0      :1;     //[4] BOD0 power-on configuration after enter STOP mode
X            volatile uint8_t  STP_BOD0      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  STP_BOD1      :1;     //[5] BOD1 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_BOD1      :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :8;     //[15..8] 
X            volatile const  uint8_t                :8;     
N            __IO uint8_t  SLP_CMP0      :1;     //[16] Analog comparator CMP0 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP0      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  SLP_CMP1      :1;     //[17] Analog comparator CMP1 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP1      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  SLP_CMP2      :1;     //[18] Analog comparator CMP2 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP2      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  SLP_CMP3      :1;     //[19] Analog comparator CMP3 power-on configuration after enter SLEEP mode.
X            volatile uint8_t  SLP_CMP3      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP0      :1;     //[20] Analog comparator CMP0 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP0      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP1      :1;     //[21] Analog comparator CMP1 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP1      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP2      :1;     //[22] Analog comparator CMP2 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP2      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __IO uint8_t  STP_CMP3      :1;     //[23] Analog comparator CMP3 power-on configuration after enter STOP mode.
X            volatile uint8_t  STP_CMP3      :1;     
N                                        //0 = Disable
N                                        //1 = power-on
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }CR1;                               /*!< CR1        ~ Offset[0x14]  PW control register 1 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :4;     //[3..0] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  WKSTP_BOD0    :1;     //[4] BOD0 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_BOD0    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_BOD1    :1;     //[5] BOD1 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_BOD1    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :2;     //[7..6] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[8] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[9] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[10] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[11] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :4;     //[15..12] 
X            volatile const  uint8_t                :4;     
N            __IO uint8_t  WKSTP_CMP0    :1;     //[16] Analog comparator CMP0 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP0    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_CMP1    :1;     //[17] Analog comparator CMP1 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP1    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_CMP2    :1;     //[18] Analog comparator CMP2 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP2    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_CMP3    :1;     //[19] Analog comparator CMP3 voltage detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_CMP3    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :4;     //[23..20] 
X            volatile const  uint8_t                :4;     
N            __I  uint8_t                :8;     //[31..24] 
X            volatile const  uint8_t                :8;     
N        }MBIT;
N    }WKSTP0;                            /*!< WKSTP0     ~ Offset[0x18]  PW STOP mode wakeup control register 0 */
N
N    union
N    {
N        __IO  uint32_t  W;
X        volatile  uint32_t  W;
N        __IO  uint16_t  H[2];
X        volatile  uint16_t  H[2];
N        __IO  uint8_t   B[4];
X        volatile  uint8_t   B[4];
N        struct
N        {
N            __I  uint8_t                :1;     //[0] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :1;     //[1] 
X            volatile const  uint8_t                :1;     
N            __I  uint8_t                :2;     //[3..2] 
X            volatile const  uint8_t                :2;     
N            __I  uint8_t                :1;     //[4] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WKSTP_RTC     :1;     //[5] RTC module events wakeup from STOP mode enable bit
X            volatile uint8_t  WKSTP_RTC     :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_IWDT    :1;     //[6] IWDT module events wakeup from STOP mode enable bit
X            volatile uint8_t  WKSTP_IWDT    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :1;     //[7] 
X            volatile const  uint8_t                :1;     
N            __IO uint8_t  WKSTP_I2C0    :1;     //[8] I2C0 slave address detection wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_I2C0    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __IO uint8_t  WKSTP_I2C1    :1;     //[9] I2C1 slave address detection event wakeup from STOP mode enable bit.
X            volatile uint8_t  WKSTP_I2C1    :1;     
N                                        //0 = Disable
N                                        //1 = Enable
N            __I  uint8_t                :6;     //[15..10] 
X            volatile const  uint8_t                :6;     
N            __I  uint8_t                :8;     //[23..16] 
X            volatile const  uint8_t                :8;     
N            __I  uint8_t                :7;     //[30..24] 
X            volatile const  uint8_t                :7;     
N            __I  uint8_t                :1;     //[31] 
X            volatile const  uint8_t                :1;     
N        }MBIT;
N    }WKSTP1;                            /*!< WKSTP1     ~ Offset[0x1C]  PW STOP mode wakeup control register 1 */
N
N} PW_Struct;
N
N/**
N ******************************************************************************
N *
N * @name        PW  [Base Address/Type]
N *
N ******************************************************************************
N */
N///@{
N#define PW_Base                         ((uint32_t)0x4C020000)              /*!< Power Management Controller */
N#define PW                              ((PW_Struct*) PW_Base)
N///@}
N
N/**
N ******************************************************************************
N *
N * @name        PW  [Register Definitions]
N *
N ******************************************************************************
N */
N/**
N ******************************************************************************
N * @name        PW_STA  [register's definitions]
N *              Offset[0x00]  PW status register (0x4C020000)
N ******************************************************************************
N */
N///@{
N#define PW_STA_default                              ((uint32_t)0x00000002)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_STA */
N#define PW_STA_BOD1_S_mask_w                        ((uint32_t)0x02000000)  /*!< Bit Mask of 32bit */
N#define PW_STA_BOD1_S_mask_h1                       ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PW_STA_BOD1_S_mask_b3                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_STA_BOD1_S_high_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):High of 32bit */
N#define PW_STA_BOD1_S_high_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0):High of 16bit */
N#define PW_STA_BOD1_S_high_b3                       ((uint8_t )0x00)        /*!< Bit Value =(0):High of 8bit */
N#define PW_STA_BOD1_S_low_w                         ((uint32_t)0x02000000)  /*!< Bit Value =(1):Low of 32bit */
N#define PW_STA_BOD1_S_low_h1                        ((uint16_t)0x0200)      /*!< Bit Value =(1):Low of 16bit */
N#define PW_STA_BOD1_S_low_b3                        ((uint8_t )0x02)        /*!< Bit Value =(1):Low of 8bit */
N
N#define PW_STA_WKMODE_mask_w                        ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define PW_STA_WKMODE_mask_h1                       ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define PW_STA_WKMODE_mask_b2                       ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define PW_STA_WKMODE_none_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):NONE of 32bit */
N#define PW_STA_WKMODE_none_h1                       ((uint16_t)0x0000)      /*!< Bit Value =(0x0):NONE of 16bit */
N#define PW_STA_WKMODE_none_b2                       ((uint8_t )0x00)        /*!< Bit Value =(0x0):NONE of 8bit */
N#define PW_STA_WKMODE_sleep_w                       ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):SLEEP of 32bit */
N#define PW_STA_WKMODE_sleep_h1                      ((uint16_t)0x0010)      /*!< Bit Value =(0x1):SLEEP of 16bit */
N#define PW_STA_WKMODE_sleep_b2                      ((uint8_t )0x10)        /*!< Bit Value =(0x1):SLEEP of 8bit */
N#define PW_STA_WKMODE_stop_w                        ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):STOP of 32bit */
N#define PW_STA_WKMODE_stop_h1                       ((uint16_t)0x0020)      /*!< Bit Value =(0x2):STOP of 16bit */
N#define PW_STA_WKMODE_stop_b2                       ((uint8_t )0x20)        /*!< Bit Value =(0x2):STOP of 8bit */
N
N#define PW_STA_STATE_mask_w                         ((uint32_t)0x00030000)  /*!< Bit Mask of 32bit */
N#define PW_STA_STATE_mask_h1                        ((uint16_t)0x0003)      /*!< Bit Mask of 16bit */
N#define PW_STA_STATE_mask_b2                        ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define PW_STA_STATE_on_w                           ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):ON of 32bit */
N#define PW_STA_STATE_on_h1                          ((uint16_t)0x0000)      /*!< Bit Value =(0x0):ON of 16bit */
N#define PW_STA_STATE_on_b2                          ((uint8_t )0x00)        /*!< Bit Value =(0x0):ON of 8bit */
N#define PW_STA_STATE_sleep_w                        ((uint32_t)0x00010000)  /*!< Bit Value =(0x1):SLEEP of 32bit */
N#define PW_STA_STATE_sleep_h1                       ((uint16_t)0x0001)      /*!< Bit Value =(0x1):SLEEP of 16bit */
N#define PW_STA_STATE_sleep_b2                       ((uint8_t )0x01)        /*!< Bit Value =(0x1):SLEEP of 8bit */
N#define PW_STA_STATE_stop_w                         ((uint32_t)0x00020000)  /*!< Bit Value =(0x2):STOP of 32bit */
N#define PW_STA_STATE_stop_h1                        ((uint16_t)0x0002)      /*!< Bit Value =(0x2):STOP of 16bit */
N#define PW_STA_STATE_stop_b2                        ((uint8_t )0x02)        /*!< Bit Value =(0x2):STOP of 8bit */
N
N#define PW_STA_WKF_mask_w                           ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PW_STA_WKF_mask_h0                          ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_STA_WKF_mask_b0                          ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_STA_WKF_normal_w                         ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_WKF_normal_h0                        ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_WKF_normal_b0                        ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_WKF_happened_w                       ((uint32_t)0x00000080)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_WKF_happened_h0                      ((uint16_t)0x0080)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_WKF_happened_b0                      ((uint8_t )0x80)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define PW_STA_BOD1F_mask_w                         ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_STA_BOD1F_mask_h0                        ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_STA_BOD1F_mask_b0                        ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_STA_BOD1F_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_BOD1F_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_BOD1F_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_BOD1F_happened_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_BOD1F_happened_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_BOD1F_happened_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define PW_STA_BOD0F_mask_w                         ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_STA_BOD0F_mask_h0                        ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_STA_BOD0F_mask_b0                        ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_STA_BOD0F_normal_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_BOD0F_normal_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_BOD0F_normal_b0                      ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_BOD0F_happened_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_BOD0F_happened_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_BOD0F_happened_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Happened of 8bit */
N
N#define PW_STA_PORF_mask_w                          ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PW_STA_PORF_mask_h0                         ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_STA_PORF_mask_b0                         ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_STA_PORF_normal_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_STA_PORF_normal_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_STA_PORF_normal_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_STA_PORF_happened_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Happened of 32bit */
N#define PW_STA_PORF_happened_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Happened of 16bit */
N#define PW_STA_PORF_happened_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Happened of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_INT  [register's definitions]
N *              Offset[0x04]  PW interrupt enable register (0x4C020004)
N ******************************************************************************
N */
N///@{
N#define PW_INT_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_INT */
N#define PW_INT_WK_IE_mask_w                         ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PW_INT_WK_IE_mask_h0                        ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_INT_WK_IE_mask_b0                        ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_INT_WK_IE_disable_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_WK_IE_disable_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_WK_IE_disable_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_WK_IE_enable_w                       ((uint32_t)0x00000080)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_WK_IE_enable_h0                      ((uint16_t)0x0080)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_WK_IE_enable_b0                      ((uint8_t )0x80)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_INT_BOD1_IE_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_INT_BOD1_IE_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_INT_BOD1_IE_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_INT_BOD1_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_BOD1_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_BOD1_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_BOD1_IE_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_BOD1_IE_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_BOD1_IE_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_INT_BOD0_IE_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_INT_BOD0_IE_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_INT_BOD0_IE_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_INT_BOD0_IE_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_BOD0_IE_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_BOD0_IE_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_BOD0_IE_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_BOD0_IE_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_BOD0_IE_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_INT_IEA_mask_w                           ((uint32_t)0x00000001)  /*!< Bit Mask of 32bit */
N#define PW_INT_IEA_mask_h0                          ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PW_INT_IEA_mask_b0                          ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_INT_IEA_disable_w                        ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_INT_IEA_disable_h0                       ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_INT_IEA_disable_b0                       ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_INT_IEA_enable_w                         ((uint32_t)0x00000001)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_INT_IEA_enable_h0                        ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_INT_IEA_enable_b0                        ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_KEY  [register's definitions]
N *              Offset[0x0C]  PW write protected Key register (0x4C02000C)
N ******************************************************************************
N */
N///@{
N#define PW_KEY_default                              ((uint32_t)0x00000001)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_KEY */
N#define PW_KEY_KEY_mask_w                           ((uint32_t)0x0000FFFF)  /*!< Bit Mask of 32bit */
N#define PW_KEY_KEY_mask_h0                          ((uint16_t)0xFFFF)      /*!< Bit Mask of 16bit */
N#define PW_KEY_KEY_unprotected_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Unprotected of 32bit */
N#define PW_KEY_KEY_unprotected_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Unprotected of 16bit */
N#define PW_KEY_KEY_unprotected_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Unprotected of 8bit */
N#define PW_KEY_KEY_protected_w                      ((uint32_t)0x00000001)  /*!< Bit Value =(1):Protected of 32bit */
N#define PW_KEY_KEY_protected_h0                     ((uint16_t)0x0001)      /*!< Bit Value =(1):Protected of 16bit */
N#define PW_KEY_KEY_protected_b0                     ((uint8_t )0x01)        /*!< Bit Value =(1):Protected of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_CR0  [register's definitions]
N *              Offset[0x10]  PW control register 0 (0x4C020010)
N ******************************************************************************
N */
N///@{
N#define PW_CR0_default                              ((uint32_t)0x00000080)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_CR0 */
N#define PW_CR0_WKSTP_DSEL_mask_w                    ((uint32_t)0x00300000)  /*!< Bit Mask of 32bit */
N#define PW_CR0_WKSTP_DSEL_mask_h1                   ((uint16_t)0x0030)      /*!< Bit Mask of 16bit */
N#define PW_CR0_WKSTP_DSEL_mask_b2                   ((uint8_t )0x30)        /*!< Bit Mask of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt0_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):DT0 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt0_h1                    ((uint16_t)0x0000)      /*!< Bit Value =(0x0):DT0 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt0_b2                    ((uint8_t )0x00)        /*!< Bit Value =(0x0):DT0 of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt1_w                     ((uint32_t)0x00100000)  /*!< Bit Value =(0x1):DT1 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt1_h1                    ((uint16_t)0x0010)      /*!< Bit Value =(0x1):DT1 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt1_b2                    ((uint8_t )0x10)        /*!< Bit Value =(0x1):DT1 of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt2_w                     ((uint32_t)0x00200000)  /*!< Bit Value =(0x2):DT2 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt2_h1                    ((uint16_t)0x0020)      /*!< Bit Value =(0x2):DT2 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt2_b2                    ((uint8_t )0x20)        /*!< Bit Value =(0x2):DT2 of 8bit */
N#define PW_CR0_WKSTP_DSEL_dt3_w                     ((uint32_t)0x00300000)  /*!< Bit Value =(0x3):DT3 of 32bit */
N#define PW_CR0_WKSTP_DSEL_dt3_h1                    ((uint16_t)0x0030)      /*!< Bit Value =(0x3):DT3 of 16bit */
N#define PW_CR0_WKSTP_DSEL_dt3_b2                    ((uint8_t )0x30)        /*!< Bit Value =(0x3):DT3 of 8bit */
N
N#define PW_CR0_BOD1_TH_mask_w                       ((uint32_t)0x00000C00)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD1_TH_mask_h0                      ((uint16_t)0x0C00)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD1_TH_mask_b1                      ((uint8_t )0x0C)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD1_TH_2_0v_w                       ((uint32_t)0x00000000)  /*!< Bit Value =(0x0):2.0v of 32bit */
N#define PW_CR0_BOD1_TH_2_0v_h0                      ((uint16_t)0x0000)      /*!< Bit Value =(0x0):2.0v of 16bit */
N#define PW_CR0_BOD1_TH_2_0v_b1                      ((uint8_t )0x00)        /*!< Bit Value =(0x0):2.0v of 8bit */
N#define PW_CR0_BOD1_TH_2_4v_w                       ((uint32_t)0x00000400)  /*!< Bit Value =(0x1):2.4v of 32bit */
N#define PW_CR0_BOD1_TH_2_4v_h0                      ((uint16_t)0x0400)      /*!< Bit Value =(0x1):2.4v of 16bit */
N#define PW_CR0_BOD1_TH_2_4v_b1                      ((uint8_t )0x04)        /*!< Bit Value =(0x1):2.4v of 8bit */
N#define PW_CR0_BOD1_TH_3_7v_w                       ((uint32_t)0x00000800)  /*!< Bit Value =(0x2):3.7v of 32bit */
N#define PW_CR0_BOD1_TH_3_7v_h0                      ((uint16_t)0x0800)      /*!< Bit Value =(0x2):3.7v of 16bit */
N#define PW_CR0_BOD1_TH_3_7v_b1                      ((uint8_t )0x08)        /*!< Bit Value =(0x2):3.7v of 8bit */
N#define PW_CR0_BOD1_TH_4_2v_w                       ((uint32_t)0x00000C00)  /*!< Bit Value =(0x3):4.2v of 32bit */
N#define PW_CR0_BOD1_TH_4_2v_h0                      ((uint16_t)0x0C00)      /*!< Bit Value =(0x3):4.2v of 16bit */
N#define PW_CR0_BOD1_TH_4_2v_b1                      ((uint8_t )0x0C)        /*!< Bit Value =(0x3):4.2v of 8bit */
N
N#define PW_CR0_BOD1_TRGS_mask_w                     ((uint32_t)0x00000300)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD1_TRGS_mask_h0                    ((uint16_t)0x0300)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD1_TRGS_mask_b1                    ((uint8_t )0x03)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD1_TRGS_rising_edge_w              ((uint32_t)0x00000100)  /*!< Bit Value =(0x1):Rising edge of 32bit */
N#define PW_CR0_BOD1_TRGS_rising_edge_h0             ((uint16_t)0x0100)      /*!< Bit Value =(0x1):Rising edge of 16bit */
N#define PW_CR0_BOD1_TRGS_rising_edge_b1             ((uint8_t )0x01)        /*!< Bit Value =(0x1):Rising edge of 8bit */
N#define PW_CR0_BOD1_TRGS_falling_edge_w             ((uint32_t)0x00000200)  /*!< Bit Value =(0x2):Falling edge of 32bit */
N#define PW_CR0_BOD1_TRGS_falling_edge_h0            ((uint16_t)0x0200)      /*!< Bit Value =(0x2):Falling edge of 16bit */
N#define PW_CR0_BOD1_TRGS_falling_edge_b1            ((uint8_t )0x02)        /*!< Bit Value =(0x2):Falling edge of 8bit */
N#define PW_CR0_BOD1_TRGS_dual_edge_w                ((uint32_t)0x00000300)  /*!< Bit Value =(0x3):Dual-edge of 32bit */
N#define PW_CR0_BOD1_TRGS_dual_edge_h0               ((uint16_t)0x0300)      /*!< Bit Value =(0x3):Dual-edge of 16bit */
N#define PW_CR0_BOD1_TRGS_dual_edge_b1               ((uint8_t )0x03)        /*!< Bit Value =(0x3):Dual-edge of 8bit */
N
N#define PW_CR0_LDO_STP_mask_w                       ((uint32_t)0x00000080)  /*!< Bit Mask of 32bit */
N#define PW_CR0_LDO_STP_mask_h0                      ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_CR0_LDO_STP_mask_b0                      ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_CR0_LDO_STP_normal_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_CR0_LDO_STP_normal_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_CR0_LDO_STP_normal_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_CR0_LDO_STP_low_power_w                  ((uint32_t)0x00000080)  /*!< Bit Value =(1):Low power of 32bit */
N#define PW_CR0_LDO_STP_low_power_h0                 ((uint16_t)0x0080)      /*!< Bit Value =(1):Low power of 16bit */
N#define PW_CR0_LDO_STP_low_power_b0                 ((uint8_t )0x80)        /*!< Bit Value =(1):Low power of 8bit */
N
N#define PW_CR0_LDO_ON_mask_w                        ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PW_CR0_LDO_ON_mask_h0                       ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PW_CR0_LDO_ON_mask_b0                       ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define PW_CR0_LDO_ON_normal_w                      ((uint32_t)0x00000000)  /*!< Bit Value =(0):Normal of 32bit */
N#define PW_CR0_LDO_ON_normal_h0                     ((uint16_t)0x0000)      /*!< Bit Value =(0):Normal of 16bit */
N#define PW_CR0_LDO_ON_normal_b0                     ((uint8_t )0x00)        /*!< Bit Value =(0):Normal of 8bit */
N#define PW_CR0_LDO_ON_low_power_w                   ((uint32_t)0x00000040)  /*!< Bit Value =(1):Low power of 32bit */
N#define PW_CR0_LDO_ON_low_power_h0                  ((uint16_t)0x0040)      /*!< Bit Value =(1):Low power of 16bit */
N#define PW_CR0_LDO_ON_low_power_b0                  ((uint8_t )0x40)        /*!< Bit Value =(1):Low power of 8bit */
N
N#define PW_CR0_BOD1_EN_mask_w                       ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD1_EN_mask_h0                      ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD1_EN_mask_b0                      ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD1_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR0_BOD1_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR0_BOD1_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR0_BOD1_EN_enable_w                     ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR0_BOD1_EN_enable_h0                    ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR0_BOD1_EN_enable_b0                    ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR0_BOD0_EN_mask_w                       ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_CR0_BOD0_EN_mask_h0                      ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_CR0_BOD0_EN_mask_b0                      ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_CR0_BOD0_EN_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR0_BOD0_EN_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR0_BOD0_EN_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR0_BOD0_EN_enable_w                     ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR0_BOD0_EN_enable_h0                    ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR0_BOD0_EN_enable_b0                    ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR0_IVR_EN_mask_w                        ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PW_CR0_IVR_EN_mask_h0                       ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_CR0_IVR_EN_mask_b0                       ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_CR0_IVR_EN_disable_w                     ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR0_IVR_EN_disable_h0                    ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR0_IVR_EN_disable_b0                    ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR0_IVR_EN_enable_w                      ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR0_IVR_EN_enable_h0                     ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR0_IVR_EN_enable_b0                     ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_CR1  [register's definitions]
N *              Offset[0x14]  PW control register 1 (0x4C020014)
N ******************************************************************************
N */
N///@{
N#define PW_CR1_default                              ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_CR1 */
N#define PW_CR1_STP_CMP3_mask_w                      ((uint32_t)0x00800000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP3_mask_h1                     ((uint16_t)0x0080)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP3_mask_b2                     ((uint8_t )0x80)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP3_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP3_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP3_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP3_power_on_w                  ((uint32_t)0x00800000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP3_power_on_h1                 ((uint16_t)0x0080)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP3_power_on_b2                 ((uint8_t )0x80)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_CMP2_mask_w                      ((uint32_t)0x00400000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP2_mask_h1                     ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP2_mask_b2                     ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP2_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP2_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP2_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP2_power_on_w                  ((uint32_t)0x00400000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP2_power_on_h1                 ((uint16_t)0x0040)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP2_power_on_b2                 ((uint8_t )0x40)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_CMP1_mask_w                      ((uint32_t)0x00200000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP1_mask_h1                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP1_mask_b2                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP1_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP1_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP1_power_on_w                  ((uint32_t)0x00200000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP1_power_on_h1                 ((uint16_t)0x0020)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP1_power_on_b2                 ((uint8_t )0x20)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_CMP0_mask_w                      ((uint32_t)0x00100000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_CMP0_mask_h1                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_CMP0_mask_b2                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_CMP0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_CMP0_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_CMP0_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_CMP0_power_on_w                  ((uint32_t)0x00100000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_STP_CMP0_power_on_h1                 ((uint16_t)0x0010)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_STP_CMP0_power_on_b2                 ((uint8_t )0x10)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP3_mask_w                      ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP3_mask_h1                     ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP3_mask_b2                     ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP3_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP3_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP3_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP3_power_on_w                  ((uint32_t)0x00080000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP3_power_on_h1                 ((uint16_t)0x0008)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP3_power_on_b2                 ((uint8_t )0x08)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP2_mask_w                      ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP2_mask_h1                     ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP2_mask_b2                     ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP2_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP2_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP2_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP2_power_on_w                  ((uint32_t)0x00040000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP2_power_on_h1                 ((uint16_t)0x0004)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP2_power_on_b2                 ((uint8_t )0x04)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP1_mask_w                      ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP1_mask_h1                     ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP1_mask_b2                     ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP1_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP1_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP1_power_on_w                  ((uint32_t)0x00020000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP1_power_on_h1                 ((uint16_t)0x0002)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP1_power_on_b2                 ((uint8_t )0x02)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_SLP_CMP0_mask_w                      ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PW_CR1_SLP_CMP0_mask_h1                     ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PW_CR1_SLP_CMP0_mask_b2                     ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_CR1_SLP_CMP0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_SLP_CMP0_disable_h1                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_SLP_CMP0_disable_b2                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_SLP_CMP0_power_on_w                  ((uint32_t)0x00010000)  /*!< Bit Value =(1):power-on of 32bit */
N#define PW_CR1_SLP_CMP0_power_on_h1                 ((uint16_t)0x0001)      /*!< Bit Value =(1):power-on of 16bit */
N#define PW_CR1_SLP_CMP0_power_on_b2                 ((uint8_t )0x01)        /*!< Bit Value =(1):power-on of 8bit */
N
N#define PW_CR1_STP_BOD1_mask_w                      ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_BOD1_mask_h0                     ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_BOD1_mask_b0                     ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_BOD1_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_BOD1_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_BOD1_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_BOD1_enable_w                    ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR1_STP_BOD1_enable_h0                   ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR1_STP_BOD1_enable_b0                   ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR1_STP_BOD0_mask_w                      ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_BOD0_mask_h0                     ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_BOD0_mask_b0                     ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_BOD0_disable_w                   ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_BOD0_disable_h0                  ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_BOD0_disable_b0                  ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_BOD0_enable_w                    ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR1_STP_BOD0_enable_h0                   ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR1_STP_BOD0_enable_b0                   ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_CR1_STP_POR_mask_w                       ((uint32_t)0x00000002)  /*!< Bit Mask of 32bit */
N#define PW_CR1_STP_POR_mask_h0                      ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_CR1_STP_POR_mask_b0                      ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_CR1_STP_POR_disable_w                    ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_CR1_STP_POR_disable_h0                   ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_CR1_STP_POR_disable_b0                   ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_CR1_STP_POR_enable_w                     ((uint32_t)0x00000002)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_CR1_STP_POR_enable_h0                    ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_CR1_STP_POR_enable_b0                    ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_WKSTP0  [register's definitions]
N *              Offset[0x18]  PW STOP mode wakeup control register 0 (0x4C020018)
N ******************************************************************************
N */
N///@{
N#define PW_WKSTP0_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_WKSTP0 */
N#define PW_WKSTP0_WKSTP_CMP3_mask_w                 ((uint32_t)0x00080000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP3_mask_h1                ((uint16_t)0x0008)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP3_mask_b2                ((uint8_t )0x08)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP3_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP3_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP3_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP3_enable_w               ((uint32_t)0x00080000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP3_enable_h1              ((uint16_t)0x0008)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP3_enable_b2              ((uint8_t )0x08)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_CMP2_mask_w                 ((uint32_t)0x00040000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP2_mask_h1                ((uint16_t)0x0004)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP2_mask_b2                ((uint8_t )0x04)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP2_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP2_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP2_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP2_enable_w               ((uint32_t)0x00040000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP2_enable_h1              ((uint16_t)0x0004)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP2_enable_b2              ((uint8_t )0x04)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_CMP1_mask_w                 ((uint32_t)0x00020000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP1_mask_h1                ((uint16_t)0x0002)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP1_mask_b2                ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP1_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP1_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP1_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP1_enable_w               ((uint32_t)0x00020000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP1_enable_h1              ((uint16_t)0x0002)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP1_enable_b2              ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_CMP0_mask_w                 ((uint32_t)0x00010000)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_CMP0_mask_h1                ((uint16_t)0x0001)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_CMP0_mask_b2                ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_CMP0_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP0_disable_h1             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP0_disable_b2             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_CMP0_enable_w               ((uint32_t)0x00010000)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_CMP0_enable_h1              ((uint16_t)0x0001)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_CMP0_enable_b2              ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_BOD1_mask_w                 ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_BOD1_mask_h0                ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_BOD1_mask_b0                ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_BOD1_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD1_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD1_disable_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_BOD1_enable_w               ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD1_enable_h0              ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD1_enable_b0              ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP0_WKSTP_BOD0_mask_w                 ((uint32_t)0x00000010)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP0_WKSTP_BOD0_mask_h0                ((uint16_t)0x0010)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP0_WKSTP_BOD0_mask_b0                ((uint8_t )0x10)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP0_WKSTP_BOD0_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD0_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD0_disable_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP0_WKSTP_BOD0_enable_w               ((uint32_t)0x00000010)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP0_WKSTP_BOD0_enable_h0              ((uint16_t)0x0010)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP0_WKSTP_BOD0_enable_b0              ((uint8_t )0x10)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N/**
N ******************************************************************************
N * @name        PW_WKSTP1  [register's definitions]
N *              Offset[0x1C]  PW STOP mode wakeup control register 1 (0x4C02001C)
N ******************************************************************************
N */
N///@{
N#define PW_WKSTP1_default                           ((uint32_t)0x00000000)  /*!< Reg Reset Default Value */
N
N/* Bit fields of PW_WKSTP1 */
N#define PW_WKSTP1_WKSTP_I2C1_mask_w                 ((uint32_t)0x00000200)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_I2C1_mask_h0                ((uint16_t)0x0200)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_I2C1_mask_b1                ((uint8_t )0x02)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_I2C1_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C1_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C1_disable_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_I2C1_enable_w               ((uint32_t)0x00000200)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C1_enable_h0              ((uint16_t)0x0200)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C1_enable_b1              ((uint8_t )0x02)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP1_WKSTP_I2C0_mask_w                 ((uint32_t)0x00000100)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_I2C0_mask_h0                ((uint16_t)0x0100)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_I2C0_mask_b1                ((uint8_t )0x01)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_I2C0_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C0_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C0_disable_b1             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_I2C0_enable_w               ((uint32_t)0x00000100)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_I2C0_enable_h0              ((uint16_t)0x0100)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_I2C0_enable_b1              ((uint8_t )0x01)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP1_WKSTP_IWDT_mask_w                 ((uint32_t)0x00000040)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_IWDT_mask_h0                ((uint16_t)0x0040)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_IWDT_mask_b0                ((uint8_t )0x40)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_IWDT_disable_w              ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_IWDT_disable_h0             ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_IWDT_disable_b0             ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_IWDT_enable_w               ((uint32_t)0x00000040)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_IWDT_enable_h0              ((uint16_t)0x0040)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_IWDT_enable_b0              ((uint8_t )0x40)        /*!< Bit Value =(1):Enable of 8bit */
N
N#define PW_WKSTP1_WKSTP_RTC_mask_w                  ((uint32_t)0x00000020)  /*!< Bit Mask of 32bit */
N#define PW_WKSTP1_WKSTP_RTC_mask_h0                 ((uint16_t)0x0020)      /*!< Bit Mask of 16bit */
N#define PW_WKSTP1_WKSTP_RTC_mask_b0                 ((uint8_t )0x20)        /*!< Bit Mask of 8bit */
N#define PW_WKSTP1_WKSTP_RTC_disable_w               ((uint32_t)0x00000000)  /*!< Bit Value =(0):Disable of 32bit */
N#define PW_WKSTP1_WKSTP_RTC_disable_h0              ((uint16_t)0x0000)      /*!< Bit Value =(0):Disable of 16bit */
N#define PW_WKSTP1_WKSTP_RTC_disable_b0              ((uint8_t )0x00)        /*!< Bit Value =(0):Disable of 8bit */
N#define PW_WKSTP1_WKSTP_RTC_enable_w                ((uint32_t)0x00000020)  /*!< Bit Value =(1):Enable of 32bit */
N#define PW_WKSTP1_WKSTP_RTC_enable_h0               ((uint16_t)0x0020)      /*!< Bit Value =(1):Enable of 16bit */
N#define PW_WKSTP1_WKSTP_RTC_enable_b0               ((uint8_t )0x20)        /*!< Bit Value =(1):Enable of 8bit */
N
N///@}
N
N#endif  // _MG32x02z_PW_H
N
N/*----------------------------------------------------------------------------*/
N/*                         End of file MG32x02z_PW.h                          */
N/*----------------------------------------------------------------------------*/
L 32 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_PW_DRV.H" 2
N
N
N#ifndef _MG32x02z_PW_DRV_H
N/*!< _MG32x02z_PW_DRV_H */ 
N#define _MG32x02z_PW_DRV_H
N
N
N/*! @name 
N*/
N/* @{ */ 
N#define PW_PORF     PW_STA_PORF_mask_w                          /*!< Power-On reset status flag */
N#define PW_BOD0F    PW_STA_BOD0F_mask_w                         /*!< Brown-Out detect BOD0 status flag  */
N#define PW_BOD1F    PW_STA_BOD1F_mask_w                         /*!< Brown-Out detect BOD1 interrupt flag */
N#if (defined(MG32_3RD))
X#if (0L)
S#define PW_BOD2F    PW_STA_BOD2F_mask_w                         /*!< Brown-Out detect BOD2 interrupt flag */
N#endif
N#define PW_WKF      PW_STA_WKF_mask_w                           /*!< System received wakeup event flag */
N#if (defined(MG32_1ST) || defined(MG32_2ND))
X#if (1L || 0L)
N#define PW_ALLF     PW_PORF | PW_BOD0F | PW_BOD1F | PW_WKF              /*!< All event and interrupt flag */
N#endif
N#if (defined(MG32_3RD))
X#if (0L)
S#define PW_ALLF     PW_PORF | PW_BOD0F | PW_BOD1F | PW_BOD2F | PW_WKF   /*!< All event and interrupt flag */
N#endif
N
N#define PW_INT_WK       PW_INT_WK_IE_mask_w         /*!< System received wakeup event interrupt enable bit */
N#if (defined(MG32_3RD))
X#if (0L)
S#define PW_INT_BOD2     PW_INT_BOD2_IE_mask_w       /*!< BOD2 interrupt enable */
N#endif
N#define PW_INT_BOD1     PW_INT_BOD1_IE_mask_w       /*!< BOD1 interrupt enable */
N#define PW_INT_BOD0     PW_INT_BOD0_IE_mask_w       /*!< BOD0 interrupt enable */
N/* @} */
N
N
N/*! @enum   PW_WakeUpDly_TypeDef
N    @brief  MCU wake up delay selection
N*/ 
Ntypedef enum
N{   
N    PW_WK_15us      = 0,    /*!< Wakeup delay time 15us */
N    PW_WK_45us      = 1,    /*!< Wakeup delay time 45us */
N    PW_WK_75us      = 2,    /*!< Wakeup delay time 65us */
N    PW_WK_135us     = 3     /*!< Wakeup delay time 135us */
N}PW_WakeUpDly_TypeDef;
N
N
N
N/*! @enum   PW_WakeUpMode_TypeDef
N    @brief  MCU wakeup mode selection
N*/
Ntypedef enum
N{
N    PW_Normal_SleepMode = 0,    /*!< Wakeup from normal SLEEP mode */
N    PW_LowPower_SleepMode = 1,  /*!< Wakeup from low power SLEEP mode */
N}PW_WakeUpMode_TypeDef;
N
N
N/*! @enum   PW_BOD1_TH_TypeDef
N    @brief  BOD1 detect voltage threshold select
N*/ 
Ntypedef enum
N{   
N    PW_BOD1_2V0     = 0,    /*!< BOD1 detect voltage is 2.0V */
N    PW_BOD1_2V4     = 1,    /*!< BOD1 detect voltage is 2.4V */
N    PW_BOD1_3V7     = 2,    /*!< BOD1 detect voltage is 3.7V */
N    PW_BOD1_4V2     = 3,    /*!< BOD1 detect voltage is 4.2V */
N}PW_BOD1_TH_TypeDef;
N
N
N/*! @enum   PW_BODx_TRGS_TypeDef
N    @brief  BODx Interrupt trigger selection.
N*/
Ntypedef enum
N{   
N    PW_BODx_Reserved    = 0,    /*!< BODx not interrupt trigger */
N    PW_BODx_RisingEdge  = 1,    /*!< BODx interrupt trigger at rising edge */
N    PW_BODx_FallingEdge = 2,    /*!< BODx interrupt trigger at falling edge */
N    PW_BODx_DualEdge    = 3     /*!< BODx interrupt trigger at rising edge and falling edge  */
N}PW_BODx_TRGS_TypeDef;
N
N
N/*! @enum   PW_LowPowerLdo_TypeDef
N    @brief  Low power LDO level selection
N*/
Ntypedef enum
N{   
N    PW_LV0      = 0,    /*!< Low power LDO is Lowest level */
N    PW_LV1      = 1,    /*!< Low power LDO is the same PW_LV2 */
N    PW_LV2      = 2,    /*!< Low power LDO is the same PW_LV1 */
N    PW_LV3      = 3     /*!< Low power LDO is highest level */
N}PW_LowPowerLdo_TypeDef;
N
N
N/*! @enum   PW_LDOMode_TypeDef
N    @brief  Core voltage LDO mode selection.
N*/
Ntypedef enum
N{   
N    PW_Normal_LDO   = 0,    /*!< Core voltage LDO mode select normal LDO */
N    PW_LowPower_LDO = 1     /*!< Core voltage LDO mode select low power LDO */
N}PW_LDOMode_TypeDef;
N
N
N/*! @enum   PW_WKSTP_Periph_TypeDef
N    @brief  Peripheral event wakeup from STOP mode configure.
N*/
N#if (defined(MG32_1ST))
X#if (1L)
Ntypedef enum
N{   
N    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
N    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP2   = 18,   /*!< CMP2 voltage detection wakeup from STOP mode */
N    PW_WKSTP_CMP3   = 19,   /*!< CMP3 voltage detection wakeup from STOP mode */
N    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
N    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
N    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
N    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
N}PW_WKSTP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_2ND))
X#if (0L)
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Stypedef enum
S{   
S    PW_WKSTP_BOD0   = 4,    /*!< BOD0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD1   = 5,    /*!< BOD1 voltage detection wakeup from STOP mode */
S    PW_WKSTP_BOD2   = 6,    /*!< BOD2 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP0   = 16,   /*!< CMP0 voltage detection wakeup from STOP mode */
S    PW_WKSTP_CMP1   = 17,   /*!< CMP1 voltage detection wakeup from STOP mode */
S#if (USB_TYPE)
S    PW_WKSTP_USB    = 24,   /*!< USB module event wakeup from STOP mode */
S#endif
S    PW_WKSTP_RTC    = 37,   /*!< RTC module event wakeup from STOP mode */
S    PW_WKSTP_IWDT   = 38,   /*!< IWDT module event wakeup from STOP mode */
S    PW_WKSTP_I2C0   = 40,   /*!< I2C0 module event wakeup from STOP mode */
S    PW_WKSTP_I2C1   = 41,   /*!< I2C1 module event wakeup from STOP mode */
S}PW_WKSTP_Periph_TypeDef;
N#endif
N
N
N
N/*! @enum   PW_STP_Periph_TypeDef
N    @brief  Peripheral stop mode continuous run configure.
N*/
N#if (defined(MG32_1ST))
X#if (1L)
Ntypedef enum
N{
N    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
X    PW_STPPO_POR    = ((uint32_t)0x00000002),     
N    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
X    PW_STPPO_BOD0   = ((uint32_t)0x00000010),    
N    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
X    PW_STPPO_BOD1   = ((uint32_t)0x00000020),    
N    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP0   = ((uint32_t)0x00100000),    
N    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP1   = ((uint32_t)0x00200000),    
N    PW_STPPO_CMP2   = PW_CR1_STP_CMP2_mask_w,   /*!< CMP2 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP2   = ((uint32_t)0x00400000),    
N    PW_STPPO_CMP3   = PW_CR1_STP_CMP3_mask_w,   /*!< CMP3 power-on configuration after enter STOP mode */
X    PW_STPPO_CMP3   = ((uint32_t)0x00800000),    
N}PW_STP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_2ND))
X#if (0L)
Stypedef enum
S{   
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S}PW_STP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Stypedef enum
S{
S    PW_STPPO_POR    = PW_CR1_STP_POR_mask_w,    /*!< POR power-on configuration after enter STOP mode */
S    PW_STPPO_BOD0   = PW_CR1_STP_BOD0_mask_w,   /*!< BOD0 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD1   = PW_CR1_STP_BOD1_mask_w,   /*!< BOD1 power-on configuration after enter STOP mode */
S    PW_STPPO_BOD2   = PW_CR1_STP_BOD2_mask_w,   /*!< BOD2 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP0   = PW_CR1_STP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter STOP mode */
S    PW_STPPO_CMP1   = PW_CR1_STP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter STOP mode */
S#if (USB_TYPE)
S    PW_STPPO_USB    = PW_CR1_STP_USB_mask_w     /*!< USB power-on configuration after enter STOP mode */
S#endif
S}PW_STP_Periph_TypeDef;
N#endif
N
N
N
N
N/*! @enum   PW_SLP_Periph_TypeDef
N    @brief  Peripheral sleep mode continuous run configure.
N*/
N#if (defined(MG32_1ST))
X#if (1L)
Ntypedef enum
N{   
N    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP0   = ((uint32_t)0x00010000),    
N    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP1   = ((uint32_t)0x00020000),    
N    PW_SLPPO_CMP2   = PW_CR1_SLP_CMP2_mask_w,   /*!< CMP2 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP2   = ((uint32_t)0x00040000),    
N    PW_SLPPO_CMP3   = PW_CR1_SLP_CMP3_mask_w,   /*!< CMP3 power-on configuration after enter SLEEP mode */
X    PW_SLPPO_CMP3   = ((uint32_t)0x00080000),    
N}PW_SLP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_2ND))
X#if (0L)
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S}PW_SLP_Periph_TypeDef;
N#endif
N
N#if (defined(MG32_3RD))
X#if (0L)
Stypedef enum
S{   
S    PW_SLPPO_CMP0   = PW_CR1_SLP_CMP0_mask_w,   /*!< CMP0 power-on configuration after enter SLEEP mode */
S    PW_SLPPO_CMP1   = PW_CR1_SLP_CMP1_mask_w,   /*!< CMP1 power-on configuration after enter SLEEP mode */
S#if (USB_TYPE)
S    PW_SLPPO_USB    = PW_CR1_SLP_USB_mask_w     /*!< USB power-on configuration after enter SLEEP mode */
S#endif
S}PW_SLP_Periph_TypeDef;
N#endif
N
N/** @name   Function rename
N *       
N */ 
N#define PW_PeriphStopModeWakeUp_Config      PW_PeriphSTOPModeWakeUp_Config
N#define PW_StopModeLDO_Select               PW_STOPModeLDO_Select
N#define PW_OnModeLDO_Select                 PW_ONModeLDO_Select
N#define PW_PeriphStopModeContinuous_Config  PW_PeriphSTOPModeContinuous_Config
N#define PW_PeriphSleepModeContinuous_Config PW_PeriphSLEEPModeContinuous_Config
N
N/**
N * @name	Function announce
N *
N */ 
N///@{  
Nuint32_t PW_GetAllFlagStatus (void);
NDRV_Return PW_GetSingleFlagStatus (uint32_t PW_ITSrc);
Nvoid PW_ClearFlag (uint32_t PW_ITSrc);
Nvoid PW_IT_Config (uint32_t PW_ITSrc, FunctionalState NewState);
Nvoid PW_ITEA_Cmd (FunctionalState NewState);
N
Nvoid PW_PeriphSTOPModeWakeUp_Config (PW_WKSTP_Periph_TypeDef WKSTP_Periph, FunctionalState NewState);
Nvoid PW_WakeUpDelay_Select (PW_WakeUpDly_TypeDef WakeUpDly);
N#if (defined(MG32_3RD))
X#if (0L)
Svoid PW_WakeUpMode_Select (PW_WakeUpMode_TypeDef WakeUpModeSelect);
N#endif
NDRV_Return PW_GetWakeUpMode (void);;
N
Nvoid PW_BOD1Threshold_Select (PW_BOD1_TH_TypeDef BOD1_TH);
Nvoid PW_BOD1Trigger_Select (PW_BODx_TRGS_TypeDef BOD1_TRGS);
Nvoid PW_BOD1_Cmd (FunctionalState NewState);
Nvoid PW_BOD0_Cmd (FunctionalState NewState);
NDRV_Return PW_GetBod1Status (void);
N#if (defined(MG32_3RD))
X#if (0L)
Svoid PW_BOD2Trigger_Select (PW_BODx_TRGS_TypeDef BOD2_TRGS);
Svoid PW_BOD2_Cmd (FunctionalState NewState);
SDRV_Return PW_GetBod2Status (void);
N#endif
N
Nvoid PW_VoltageBuffer (FunctionalState NewState);
Nvoid PW_STOPModeLDO_Select (PW_LDOMode_TypeDef LdoSelect);
Nvoid PW_ONModeLDO_Select (PW_LDOMode_TypeDef LdoSelect);
N
Nvoid PW_PeriphSTOPModeContinuous_Config (PW_STP_Periph_TypeDef STP_Periph,FunctionalState NewState);
N#if (defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD))
X#if (1L || 0L || 0L)
Nvoid PW_PeriphSLEEPModeContinuous_Config (PW_SLP_Periph_TypeDef SLP_Periph, FunctionalState NewState);
N#endif
N///@}
N
N
N#endif  //_MG32x02z_PW_DRV_H
N
L 40 "C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include\MG32x02z_ADC_DRV.h" 2
N
N
N/** 
N * @enum		ADC_PLLClockDivDef
N * @brief		declare Timer PLL clock divider 
N */        
Ntypedef enum 
N{ 
N    ADC_PLLDIV2=0,       /*!< ADC PLL clock divder (DIV2) */
N    ADC_PLLDIV4,         /*!< ADC PLL clock divder (DIV4) */
N    ADC_PLLDIV5,         /*!< ADC PLL clock divder (DIV5) */
N    ADC_PLLDIV6          /*!< ADC PLL clock divder (DIV6) */
N} ADC_PLLClockDivDef;
N
N
N
N/** 
N * @enum		ADC_ClockSourceDef
N * @brief		declare ADC clock source
N */        
Ntypedef enum 
N{ 
N    ADC_CKADC=0,         /*!< ADC clock from CK_ADC */
N    ADC_CKPLL,           /*!< ADC clock from PLL */
N    ADC_TM00TRGO,        /*!< ADC clock from TM00 TRGO */
N    ADC_TM01TRGO,        /*!< ADC clock from TM01 TRGO */
N} ADC_ClockSourceDef;
N
N
N/** 
N * @enum		ADC_INTClockDivDef
N * @brief		declare ADC internal clock divided 
N */        
Ntypedef enum 
N{ 
N    ADC_IntDIV1=0,       /*!< ADC internal clock divider (DIV1) */
N    ADC_IntDIV2,         /*!< ADC internal clock divider (DIV2) */
N    ADC_IntDIV4,         /*!< ADC internal clock divider (DIV4) */
N    ADC_IntDIV16         /*!< ADC internal clock divider (DIV16) */
N} ADC_INTClockDivDef;
N
N
N/** 
N * @enum		ADC_SCNTClockDivDef
N * @brief		declare ADC SCNT internal clock divided 
N */        
Ntypedef enum 
N{ 
N    ADC_SCNTIntDIV1=0,  /*!< ADC SCNT internal clock divider (DIV1) */
N    ADC_SCNTIntDIV4,    /*!< ADC SCNT internal clock divider (DIV4) */
N    ADC_SCNTIntDIV16,   /*!< ADC SCNT internal clock divider (DIV16) */
N    ADC_SCNTIntDIV32    /*!< ADC SCNT internal clock divider (DIV32) */
N} ADC_SCNTClockDivDef;
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_ConversionTimeDef
S * @brief		declare ADC internal clock divided 
S */        
Stypedef enum 
S{ 
S    ADC_FastCONV=0,     /*!< Conversion time ~24 ADC clocks */
S    ADC_NormalCONV,     /*!< Conversion time ~30 ADC clocks */
S} ADC_ConversionTimeDef;
N#endif
N
N/** 
N * @enum		ADC_WindowDetectApplyDef
N * @brief		apply window detect function (single / all channels)
N */        
Ntypedef enum 
N{ 
N    ADC_WINDSingle=0,   /*!< window detect function only apply single channel */
N    ADC_WINDAll,        /*!< window detect function apply all channel */
N} ADC_WindowDetectApplyDef;
N
N/** 
N * @enum		ADC_OutputDef
N * @brief		select ADC ouput property (LF,IF,HF,Current State)
N */        
Ntypedef enum 
N{ 
N    ADC_WDL_Event=0,    /*!< WDLF - outside low */
N    ADC_WDI_Event,      /*!< WDIF - inside */
N    ADC_WDH_Event,      /*!< WDHF - outside high */
N} ADC_OutputDef;
N
N/** 
N * @enum		ADC_ConversionModeDef
N * @brief		select ADC conversion mode (ONE,Scan, Loop /w Continue)
N */        
Ntypedef enum 
N{ 
N    ADCMode,            /*!< One channel */
N    ADCContinueMode,    /*!< One + Continue */
N    ScanMode,           /*!< Scan */
N    ScanContinueMode,   /*!< Scan + continue */
N    LoopMode,           /*!< Loop */
N} ADC_ConversionModeDef;
N
N
N/** 
N * @enum		ADC_MainConversionModeDef
N * @brief		select ADC conversion mode (ONE,Scan, Loop)
N */        
Ntypedef enum 
N{ 
N    ADC_OneShot,        /*!< One shot mode */
N    ADC_Scan,           /*!< scan mode */
N    ADC_Loop,           /*!< loop mode */
N} ADC_MainConversionModeDef;
N
N/** 
N * @enum		ADC_TriggerSourceDef
N * @brief		Select ADC trigger event to start conversion
N */        
Ntypedef enum 
N{ 
N    ADC_START,          /*!< SW : ADC0_START register setting */
N    ADC_TM00_TRGO,      /*!< TM00 : TM00_TRGO */
N    ADC_TRGPin,         /*!< PIN : ADC0_TRG : ADC external trigger pin */
N    ADC_CMP0Out,        /*!< CMP0 : CMP0_OUT */
N    ADC_CMP1Out,        /*!< CMP1 : CMP1_OUT */
N    ADC_TM01_TRGO,      /*!< TM01 : TM01_TRGO */
N    ADC_TM20_TRGO,      /*!< TM20 : TM20_TRGO */
N    ADC_TM36_TRGO,      /*!< TM36 : TM36_TRGO */
N} ADC_TriggerSourceDef;
N
N/** 
N * @enum		ADC_TriggerEdgeDef
N * @brief		config external trigger event to start conversion
N */        
Ntypedef enum 
N{ 
N    ADC_DisableTrg,         /*!< Disable trigger source */
N    ADC_AcceptRisingEdge,   /*!< accept rising edge of trigger  */
N    ADC_AcceptFallingEdge,  /*!< accept falling edge of trigger  */
N    ADC_AcceptDualEdge,     /*!< accept dual (rising & falling) edge of trigger */
N} ADC_TriggerEdgeDef;
N
N
N/** 
N * @enum		ADC_ChannelMUX_Def
N * @brief		config channel for ADC channel input (external/internal)
N */        
Ntypedef enum 
N{
N    ADC_ExternalChannel,    /*!< select external channel, AIN0~15 */
N    ADC_InternalChannel,    /*!< select internal channel, ie. VSSA, IVREF, VBUF ... */
N} ADC_ChannelMUX_Def;
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N/** 
N * @enum		ADC_MskChannelDef
N * @brief		specify channel select for mask (scan/loop)
N */        
Ntypedef enum 
N{ 
N    ADC_MskAIN0 = ADC_MSK_CH_MSK0_enable_h0,    /*!< specify ADC select channel channel 0 */ 
X    ADC_MskAIN0 = ((uint16_t)0x0001),      
N    ADC_MskAIN1 = ADC_MSK_CH_MSK1_enable_h0,    /*!< specify ADC select channel channel 1 */  
X    ADC_MskAIN1 = ((uint16_t)0x0002),       
N    ADC_MskAIN2 = ADC_MSK_CH_MSK2_enable_h0,    /*!< specify ADC select channel channel 2 */  
X    ADC_MskAIN2 = ((uint16_t)0x0004),       
N    ADC_MskAIN3 = ADC_MSK_CH_MSK3_enable_h0,    /*!< specify ADC select channel channel 3 */ 
X    ADC_MskAIN3 = ((uint16_t)0x0008),      
N    ADC_MskAIN4 = ADC_MSK_CH_MSK4_enable_h0,    /*!< specify ADC select channel channel 4 */  
X    ADC_MskAIN4 = ((uint16_t)0x0010),       
N    ADC_MskAIN5 = ADC_MSK_CH_MSK5_enable_h0,    /*!< specify ADC select channel channel 5 */  
X    ADC_MskAIN5 = ((uint16_t)0x0020),       
N    ADC_MskAIN6 = ADC_MSK_CH_MSK6_enable_h0,    /*!< specify ADC select channel channel 6 */  
X    ADC_MskAIN6 = ((uint16_t)0x0040),       
N    ADC_MskAIN7 = ADC_MSK_CH_MSK7_enable_h0,    /*!< specify ADC select channel channel 7 */  
X    ADC_MskAIN7 = ((uint16_t)0x0080),       
N    ADC_MskAIN8 = ADC_MSK_CH_MSK8_enable_h0,    /*!< specify ADC select channel channel 8 */  
X    ADC_MskAIN8 = ((uint16_t)0x0100),       
N    ADC_MskAIN9 = ADC_MSK_CH_MSK9_enable_h0,    /*!< specify ADC select channel channel 9 */  
X    ADC_MskAIN9 = ((uint16_t)0x0200),       
N    ADC_MskAIN10 = ADC_MSK_CH_MSK10_enable_h0,  /*!< specify ADC select channel channel 10 */ 
X    ADC_MskAIN10 = ((uint16_t)0x0400),    
N    ADC_MskAIN11 = ADC_MSK_CH_MSK11_enable_h0,  /*!< specify ADC select channel channel 11 */ 
X    ADC_MskAIN11 = ((uint16_t)0x0800),    
N    ADC_MskAIN12 = ADC_MSK_CH_MSK12_enable_h0,  /*!< specify ADC select channel channel 12 */ 
X    ADC_MskAIN12 = ((uint16_t)0x1000),    
N    ADC_MskAIN13 = ADC_MSK_CH_MSK13_enable_h0,  /*!< specify ADC select channel channel 13 */ 
X    ADC_MskAIN13 = ((uint16_t)0x2000),    
N    ADC_MskAIN14 = ADC_MSK_CH_MSK14_enable_h0,  /*!< specify ADC select channel channel 14 */ 
X    ADC_MskAIN14 = ((uint16_t)0x4000),    
N    ADC_MskAIN15 = ADC_MSK_CH_MSK15_enable_h0,  /*!< specify ADC select channel channel 15 */ 
X    ADC_MskAIN15 = ((uint16_t)0x8000),    
N} ADC_MskChannelDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		ADC_MskChannelDef
S * @brief		specify channel select for mask (scan/loop)
S */        
Stypedef enum 
S{ 
S    ADC_MskAIN0 = ADC_MSK_CH_MSK0_enable_h0,    /*!< specify ADC select channel channel 0 */ 
S    ADC_MskAIN1 = ADC_MSK_CH_MSK1_enable_h0,    /*!< specify ADC select channel channel 1 */  
S    ADC_MskAIN2 = ADC_MSK_CH_MSK2_enable_h0,    /*!< specify ADC select channel channel 2 */  
S    ADC_MskAIN3 = ADC_MSK_CH_MSK3_enable_h0,    /*!< specify ADC select channel channel 3 */ 
S    ADC_MskAIN8 = ADC_MSK_CH_MSK8_enable_h0,    /*!< specify ADC select channel channel 8 */  
S    ADC_MskAIN9 = ADC_MSK_CH_MSK9_enable_h0,    /*!< specify ADC select channel channel 9 */  
S    ADC_MskAIN10 = ADC_MSK_CH_MSK10_enable_h0,  /*!< specify ADC select channel channel 10 */ 
S    ADC_MskAIN11 = ADC_MSK_CH_MSK11_enable_h0,  /*!< specify ADC select channel channel 11 */ 
S    ADC_MskAIN12 = ADC_MSK_CH_MSK12_enable_h0,  /*!< specify ADC select channel channel 12 */ 
S    ADC_MskAIN13 = ADC_MSK_CH_MSK13_enable_h0,  /*!< specify ADC select channel channel 13 */ 
S    ADC_MskAIN14 = ADC_MSK_CH_MSK14_enable_h0,  /*!< specify ADC select channel channel 14 */ 
S    ADC_MskAIN15 = ADC_MSK_CH_MSK15_enable_h0,  /*!< specify ADC select channel channel 15 */ 
S} ADC_MskChannelDef;
N#endif
N
N
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N/** 
N * @enum		ADC_ExtChannelDef
N * @brief		specify external channel select 
N */        
Ntypedef enum 
N{ 
N    ADC_ExtAIN0=0,		/*!< specify ADC sample external channel 0 */ 
N    ADC_ExtAIN1=1,    	/*!< specify ADC sample external channel 1 */  
N    ADC_ExtAIN2=2,    	/*!< specify ADC sample external channel 2 */  
N    ADC_ExtAIN3=3,    	/*!< specify ADC sample external channel 3 */  
N    ADC_ExtAIN4=4,    	/*!< specify ADC sample external channel 4 */  
N    ADC_ExtAIN5=5,    	/*!< specify ADC sample external channel 5 */  
N    ADC_ExtAIN6=6,    	/*!< specify ADC sample external channel 6 */  
N    ADC_ExtAIN7=7,    	/*!< specify ADC sample external channel 7 */
N    ADC_ExtAIN8=8,    	/*!< specify ADC sample external channel 8 */  
N    ADC_ExtAIN9=9,    	/*!< specify ADC sample external channel 9 */  
N    ADC_ExtAIN10=10,	/*!< specify ADC sample external channel 10 */ 
N    ADC_ExtAIN11=11,    /*!< specify ADC sample external channel 11 */ 
N    ADC_ExtAIN12=12,    /*!< specify ADC sample external channel 12 */ 
N    ADC_ExtAIN13=13,    /*!< specify ADC sample external channel 13 */ 
N    ADC_ExtAIN14=14,    /*!< specify ADC sample external channel 14 */ 
N    ADC_ExtAIN15=15,    /*!< specify ADC sample external channel 15 */ 
N} ADC_ExtChannelDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		ADC_ExtChannelDef
S * @brief		specify external channel select 
S */        
Stypedef enum 
S{ 
S    ADC_ExtAIN0=0,		/*!< specify ADC sample external channel 0 */ 
S    ADC_ExtAIN1=1,    	/*!< specify ADC sample external channel 1 */  
S    ADC_ExtAIN2=2,    	/*!< specify ADC sample external channel 2 */  
S    ADC_ExtAIN3=3,    	/*!< specify ADC sample external channel 3 */  
S    ADC_ExtAIN8=8,    	/*!< specify ADC sample external channel 8 */  
S    ADC_ExtAIN9=9,    	/*!< specify ADC sample external channel 9 */  
S    ADC_ExtAIN10=10,	/*!< specify ADC sample external channel 10 */ 
S    ADC_ExtAIN11=11,    /*!< specify ADC sample external channel 11 */ 
S    ADC_ExtAIN12=12,    /*!< specify ADC sample external channel 12 */ 
S    ADC_ExtAIN13=13,    /*!< specify ADC sample external channel 13 */ 
S    ADC_ExtAIN14=14,    /*!< specify ADC sample external channel 14 */ 
S    ADC_ExtAIN15=15,    /*!< specify ADC sample external channel 15 */ 
S} ADC_ExtChannelDef;
N#endif
N
N
N#if defined(MG32_1ST)
X#if 1L
N/** 
N * @enum		ADC_IntChannelDef
N * @brief		specify internal channel select 
N */        
Ntypedef enum 
N{ 
N    ADC_INT_VSSA    = 0x10, /*!< specify ADC sample internal VSSA. */  
N    ADC_INT_IVREF   = 0x11, /*!< specify ADC sample internal IVREF. */ 
N    ADC_INT_DACP0   = 0x12, /*!< specify ADC sample internal DAC_P0. */ 
N    ADC_INT_VBUF    = 0x13, /*!< specify ADC sample internal VBUF. */ 
N} ADC_IntChannelDef;
N#endif
N
N#if defined(MG32_2ND)
X#if 0L
S/** 
S * @enum		ADC_IntChannelDef
S * @brief		specify internal channel select 
S */        
Stypedef enum 
S{ 
S    ADC_INT_VSSA    = 0x10, /*!< specify ADC sample internal VSSA. */  
S    ADC_INT_IVREF   = 0x11, /*!< specify ADC sample internal IVREF. */ 
S    ADC_INT_VBUF    = 0x13, /*!< specify ADC sample internal VBUF. */ 
S    ADC_INT_LDO     = 0x18, /*!< specify ADC sample internal LDO. */ 
S} ADC_IntChannelDef;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_IntChannelDef
S * @brief		specify internal channel select 
S */        
Stypedef enum 
S{ 
S    ADC_INT_VSSA    = 0x10, /*!< specify ADC sample internal VSSA. */  
S    ADC_INT_DACP0   = 0x12, /*!< specify ADC sample internal DAC_P0. */ 
S    ADC_INT_VBUF    = 0x13, /*!< specify ADC sample internal VBUF. */ 
S    ADC_INT_LDO     = 0x18, /*!< specify ADC sample internal LDO VR0. */ 
S    ADC_INT_TSO     = 0x19, /*!< specify ADC sample internal Temperature sensor (TSO). */ 
S    ADC_INT_HalfVDD = 0x1A, /*!< specify ADC sample internal 1/2 VDD output. */ 
S    ADC_INT_VPG     = 0x1B, /*!< specify ADC sample internal VPG. */ 
S    ADC_INT_V33     = 0x1C, /*!< specify ADC sample internal V33 voltage. */ 
S} ADC_IntChannelDef;
N#endif
N
N
N
N
N/** 
N * @enum		ADC_ConversionTypeDef
N * @brief		config ADC conversion type
N */        
Ntypedef enum 
N{ 
N    ADC_SingleMode,         /*!< ADC single conversion mode */
N    ADC_DifferentMode,      /*!< ADC different conversion mode  */
N} ADC_ConversionTypeDef;
N
N
N
N/** 
N * @enum		ADC_LimitModeDef
N * @brief		config process mode for spike data 
N */        
Ntypedef enum 
N{ 
N    ADC_LimitNoOperation,   /*!< No operation for spike ADC conversion data */
N    ADC_LimitSkip,          /*!< Skip for spike ADC conversion data  */
N    ADC_LimitClamp,         /*!< Clamp for spike ADC conversion data */
N} ADC_LimitModeDef;
N
N
N/**
N * @name	SumXChannelSel
N *   		SumXChannelSel(SAIN0, SAIN1, SAIN2 ... AIN15)
N */ 
N///@{  
N#define SAIN0       0       /*!< External channel-0 be scan/loop channel. */    
N#define SAIN1       1       /*!< External channel-1 be scan/loop channel. */
N#define SAIN2       2       /*!< External channel-2 be scan/loop channel. */
N#define SAIN3       3       /*!< External channel-3 be scan/loop channel. */
N
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N    #define SAIN4       4   /*!< External channel-4 be scan/loop channel. */
N    #define SAIN5       5   /*!< External channel-5 be scan/loop channel. */
N    #define SAIN6       6   /*!< External channel-6 be scan/loop channel. */
N    #define SAIN7       7   /*!< External channel-7 be scan/loop channel. */
N#endif
N
N#define SAIN8       8       /*!< External channel-8 be scan/loop channel. */
N#define SAIN9       9       /*!< External channel-9 be scan/loop channel. */
N#define SAIN10      10      /*!< External channel-10 be scan/loop channel. */
N#define SAIN11      11      /*!< External channel-11 be scan/loop channel. */
N
N#if defined(MG32_1ST) || defined(MG32_2ND) ||  defined(MG32_3RD)
X#if 1L || 0L ||  0L
N#define SAIN12      12      /*!< External channel-12 be scan/loop channel. */
N#define SAIN13      13      /*!< External channel-13 be scan/loop channel. */
N#define SAIN14      14      /*!< External channel-14 be scan/loop channel. */
N#define SAIN15      15      /*!< External channel-15 be scan/loop channel. */
N#endif
N
N///@}
N
N/** 
N * @enum		ADC_SumChannelXDef
N * @brief		accumulate channel that single / all channel
N */        
Ntypedef enum 
N{ 
N    ADC_SumSpeciallyChannel,/*!< Single specify channel */
N    ADC_SumAllChannel,      /*!< accumulate all conversion channel data  */
N} ADC_SumChannelXDef;
N
N/** 
N * @enum		ADC_SumDataOWDef
N * @brief		config sum overrun mode 
N */        
Ntypedef enum 
N{ 
N    ADC_SumOverWritten, /*!< Overwritten by new data */
N    ADC_SumKeep,        /*!< Preserved old date */
N} ADC_SumDataOWDef;
N
N/** 
N * @enum		ADC_DataAlignModeDef
N * @brief		config data alignment mode (Right/Left alignment)
N */        
Ntypedef enum 
N{ 
N    ADC_RightJustified, /*!< Right Justified of ADC conversion data format */
N    ADC_LeftJustified,  /*!< Left Justified of ADC conversion data format  */
N} ADC_DataAlignModeDef;
N
N/** 
N * @enum		ADC_ResolutionDef
N * @brief		config data resolution (12/10 bit)
N */        
Ntypedef enum 
N{ 
N    ADC_12BitData,  /*!< data resolution = 12 bit */
N    ADC_10BitData,  /*!< data resolution = 10 bit */
N    ADC_8BitData,   /*!< data resolution = 8 bit */
N} ADC_ResolutionDef;
N
N/** 
N * @enum		ADC_DataOWDef
N * @brief		config data overrun mode 
N */        
Ntypedef enum 
N{ 
N    ADC_DataOverWritten, /*!< Overwritten by new data */
N    ADC_DataKeep,        /*!< Preserved old date */
N} ADC_DataOWDef;
N
N
N/** 
N * @enum		ADC_ITSrc
N * @brief		ADC interrupt source
N */        
Ntypedef enum 
N{ 
N    ADC_SUMOVR_IE = ADC_INT_SUMOVR_IE_enable_w, /*!< ADC0 data sum-0,1,2  overrun event interrupt enable */
X    ADC_SUMOVR_IE = ((uint32_t)0x00008000),  
N    ADC_SUMC_IE = ADC_INT_SUMC_IE_enable_w,     /*!< ADC0 data sum-0,1,2  accumulation complete interrupt  */
X    ADC_SUMC_IE = ((uint32_t)0x00004000),      
N    ADC_SUMO_IE = ADC_INT_SUMO_IE_enable_w,     /*!< ADC0 data sum-0,1,2  accumulation overflow or underflow interrupt enable */
X    ADC_SUMO_IE = ((uint32_t)0x00002000),      
N    ADC_WDH_IE = ADC_INT_WDH_IE_enable_w,       /*!< ADC0 voltage window detect outside high event interrupt enable */
X    ADC_WDH_IE = ((uint32_t)0x00000400),        
N    ADC_WDI_IE = ADC_INT_WDI_IE_enable_w,       /*!< ADC0 voltage window detect inside event interrupt enable */
X    ADC_WDI_IE = ((uint32_t)0x00000200),        
N    ADC_WDL_IE = ADC_INT_WDL_IE_enable_w,       /*!< ADC0 voltage window detect outside low event interrupt enabl */
X    ADC_WDL_IE = ((uint32_t)0x00000100),        
N    ADC_OVR_IE = ADC_INT_OVR_IE_enable_w,       /*!< ADC0 conversion overrun event interrupt enable */
X    ADC_OVR_IE = ((uint32_t)0x00000080),        
N    ADC_ESCNV_IE = ADC_INT_ESCNV_IE_enable_w,   /*!< ADC0 channel scan conversion end interrupt enable */
X    ADC_ESCNV_IE = ((uint32_t)0x00000020),    
N    ADC_E1CNV_IE = ADC_INT_E1CNV_IE_enable_w,   /*!< ADC0 one-time conversion end interrupt enable */
X    ADC_E1CNV_IE = ((uint32_t)0x00000008),    
N    ADC_ESMP_IE = ADC_INT_ESMP_IE_enable_w,     /*!< ADC0 sampling end interrupt enable */
X    ADC_ESMP_IE = ((uint32_t)0x00000004),      
N    
N} ADC_ITSrc;
N
N
N/** 
N * @enum		ADC_ITSTAFlag
N * @brief		ADC status flag 
N */    
Ntypedef enum 
N{
N    ADC_SUMOVRF =   ADC_STA_SUMOVRF_happened_w, /*!< ADC0 data sum-0,1,2  register overrun flag */
X    ADC_SUMOVRF =   ((uint32_t)0x00008000),  
N    ADC_SUMCF   =   ADC_STA_SUMCF_happened_w,   /*!< ADC0 data sum-0,1,2  accumulation complete flag */
X    ADC_SUMCF   =   ((uint32_t)0x00004000),    
N    ADC_SUMOF   =   ADC_STA_SUMOF_happened_w,   /*!< ADC0 data sum-0,1,2 accumulation overflow or underflow flag */
X    ADC_SUMOF   =   ((uint32_t)0x00002000),    
N    ADC_WDHF    =   ADC_STA_WDHF_happened_w,    /*!< ADC0 voltage window detect outside high event flag */
X    ADC_WDHF    =   ((uint32_t)0x00000400),     
N    ADC_WDIF    =   ADC_STA_WDIF_happened_w,    /*!< ADC0 voltage window detect inside event flag */
X    ADC_WDIF    =   ((uint32_t)0x00000200),     
N    ADC_WDLF    =   ADC_STA_WDLF_happened_w,    /*!< ADC0 voltage window detect outside low event flag */
X    ADC_WDLF    =   ((uint32_t)0x00000100),     
N    ADC_OVRF    =   ADC_STA_OVRF_happened_w,    /*!< ADC0 conversion overrun event flag */
X    ADC_OVRF    =   ((uint32_t)0x00000080),     
N    ADC_ESCNVF  =   ADC_STA_ESCNVF_happened_w,  /*!< ADC0 channel scan conversion end flag */
X    ADC_ESCNVF  =   ((uint32_t)0x00000020),   
N    ADC_E1CNVF  =   ADC_STA_E1CNVF_happened_w,  /*!< ADC0 one-time conversion end flagg */
X    ADC_E1CNVF  =   ((uint32_t)0x00000008),   
N    ADC_ESMPF   =   ADC_STA_ESMPF_happened_w,   /*!< ADC0 sampling end flag */
X    ADC_ESMPF   =   ((uint32_t)0x00000004),    
N} ADC_ITSTAFlag;
N
N/** 
N * @enum		ADC_OutputCodeFormatDef
N * @brief		Config ADC conversion code format
N */    
Ntypedef enum 
N{
N    ADC_UnsignedFormat,         /*!< ADC output unsigned data format */
N    ADC_2sCompletementFormat,   /*!< ADC output 2's complement data format */
N} ADC_OutputCodeFormatDef;
N
N
N/** 
N * @enum		ADC_DAT0FlagsDef
N * @brief		ADC interrupt source
N */        
Ntypedef enum 
N{ 
N    ADC_DAT0_WDLF = ADC_DAT0_DAT0_WDLF_normal_b2,   /*!< ADC voltage window detect outside low event flag */
X    ADC_DAT0_WDLF = ((uint8_t )0x00),    
N    ADC_DAT0_WDIF = ADC_DAT0_DAT0_WDIF_normal_b2,   /*!< ADC voltage window detect inside event flag */
X    ADC_DAT0_WDIF = ((uint8_t )0x00),    
N    ADC_DAT0_WDHF = ADC_DAT0_DAT0_WDHF_normal_b2,   /*!< ADC voltage window detect outside high event flag */
X    ADC_DAT0_WDHF = ((uint8_t )0x00),    
N    ADC_DAT0_CF = ADC_DAT0_DAT0_CF_mask_b2,         /*!< ADC0 conversion data-0 complete in 1-time and data ready status bit */
X    ADC_DAT0_CF = ((uint8_t )0x40),          
N    ADC_DAT0_OVRF = ADC_DAT0_DAT0_OVRF_mask_b2,     /*!< ADC0 conversion data register-0 overwrite/overrun indication status bit */
X    ADC_DAT0_OVRF = ((uint8_t )0x80),      
N} ADC_DAT0FlagsDef;
N
N
N/** 
N * @enum		ADC_SUMxFlagDef
N * @brief		ADC SUMx flag declare
N */        
Ntypedef enum 
N{ 
N    ADC_SUMxOVRF = ADC_SUM0_SUM0_OVRF_mask_h1,      /*!< ADC0 data sum-0,1,2 register overrun flag */
X    ADC_SUMxOVRF = ((uint16_t)0x0080),       
N    ADC_SUMxCF = ADC_SUM0_SUM0_CF_mask_h1,          /*!< ADC0 data sum-0,1,2 accumulation complete flag */
X    ADC_SUMxCF = ((uint16_t)0x0040),           
N    ADC_SUMxOF = ADC_SUM0_SUM0_OF_mask_h1,          /*!< ADC0 data sum-0,1,2 accumulation overflow flag */
X    ADC_SUMxOF = ((uint16_t)0x0020),           
N    ADC_SUMxUF = ADC_SUM0_SUM0_UF_mask_h1,          /*!< ADC0 data sum-0,1,2 accumulation underflow flag */
X    ADC_SUMxUF = ((uint16_t)0x0010),           
N} ADC_SUMxFlagDef;
N
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S/** 
S * @enum		ADC_DMADataSizeDef
S * @brief		Config ADC data size for DMA transmission
S */    
Stypedef enum 
S{
S    ADC_DMA_32bit,              /*!< ADC will transfer ADC0_DAT0 for DMA transmission */
S    ADC_DMA_16bit,              /*!< ADC will transfer the bit[15:0] of ADC0_DAT0 for DMA transmission */
S} ADC_DMADataSizeDef;
S
S/** 
S * @enum		ADC_DMAMaskE1CNVFDef
S * @brief		Config ADC mask E1CNVF during DMA transmission
S */    
Stypedef enum 
S{
S    ADC_Mask_E1CNVF,            /*!< E1CNVF flag will be masked after ADC conversion end during DMA access */
S    ADC_Assert_E1CNVF,          /*!< E1CNVF flag asserted mode select during DMA access */
S} ADC_DMAMaskE1CNVFDef;
S
S
S/** 
S * @enum		ADC_ChangeTimingDef
S * @brief		Config ADC change channel MUX timing 
S */    
Stypedef enum 
S{
S    ADC_ChangeMUX_E1CNVF,       /*!< Change channel MUX when E1CNVF happened. */
S    ADC_ChangeMUX_ESMPF,        /*!< Change channel MUX when ESMPF happened. */
S} ADC_ChangeTimingDef;
S
N#endif
N
N/** 
N * @struct  ADC_InitTypeDef
N * @brief   ADC Base initial structure
N */        
Ntypedef struct 				
N{ 
N    ADC_ClockSourceDef ADCMainClockSelect;      /*!< Specifies whether the conversion is performed in */
N    
N        ADC_INTClockDivDef ADC_IntCK_Div;       /*!< Select CK_ADC divider .
N                                                  This parameter can be Selected /1, /2, /4, /16 .*/                         
N                                                  
N        ADC_PLLClockDivDef ADC_CKPLL_Div;       /*!< Select PLL clock divider .
N                                                  This parameter can be Selected /2, /4, /5, /6 .*/    
N    
N    ADC_DataAlignModeDef ADC_DataAlign;         /*!< Specifies whether the ADC data alignment is left or righ */
N    
N    ADC_ResolutionDef ADC_ResolutionSel;        /*!< Specifies whether the ADC conversion resolution 10 or 12 bit */
N                                                                                                    
N    ADC_DataOWDef ADC_DataOverrunEvent;         /*!< Specifies the ADC data overwritten or Keep */   
N    
N} ADC_InitTypeDef;   
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_TSOVrefSel
S * @brief		Config TSO Vref source for ADC sampling
S */    
Stypedef enum 
S{
S    ADC_VREF,                   /*!< ADC keep Vref pin when ADC sample TSO. */
S    ADC_IVR24,                  /*!< ADC Vref select IVR24 (2.4V) when ADC sample TSO. */
S} ADC_TSOVrefSel;
N#endif
N
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_ConvTimeSel
S * @brief		ADC conversion time select
S */    
Stypedef enum 
S{
S    ADC_24ADCK,                 /*!< ADC select 24 ADC sampleing clock. */
S    ADC_30ADCK,                 /*!< ADC select 30 ADC sampleing clock. */
S} ADC_ConvTimeSel;
N#endif
N
N#if defined(MG32_3RD)
X#if 0L
S/** 
S * @enum		ADC_ReferenceSel
S * @brief		ADC reference select
S */    
Stypedef enum 
S{
S    ADC_VREF_Pin,               /*!< external reference pin VREF+ (ADC_VREF). */
S    ADC_INT_VR24,               /*!< internal reference voltage 2.4 volt. */
S} ADC_ReferenceSel;
N#endif
N
N
N
N/**
N * @name	Function announce
N *   		
N */ 
N///@{  
Nvoid ADC_DeInit(ADC_Struct *ADCx);
N///@}
N
N///@{
Nvoid ADC_BaseStructure_Init(ADC_InitTypeDef* ADC_BaseInitStruct);
Nvoid ADC_Base_Init(ADC_Struct* ADCx, ADC_InitTypeDef* ADC_BaseInitStruct);
N///@}
N
N///@{
Nvoid ADC_SetPLLClockDivider(ADC_Struct* ADCx, ADC_PLLClockDivDef PLLClockDIV);
Nvoid ADC_ClockSource_Select(ADC_Struct* ADCx, ADC_ClockSourceDef ADCClockSrc);
Nvoid ADC_SetInternalClockDivider(ADC_Struct* ADCx, ADC_INTClockDivDef INTClockSrc);
N#if defined(MG32_3RD)
X#if 0L
S    void ADC_SetConversionTime(ADC_Struct* ADCx, ADC_ConversionTimeDef CONVTime);
N#endif
N///@}
N
N///@{
Nvoid ADC_SetLowerThreshold(ADC_Struct* ADCx, int16_t LThreshold);
Nvoid ADC_SetHigherThreshold(ADC_Struct* ADCx, int16_t HThreshold);
Nvoid ADC_WindowDetectRange_Select(ADC_Struct* ADCx, ADC_WindowDetectApplyDef WINDApply);
Nvoid ADC_WindowDetect_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_Output_Select(ADC_Struct* ADCx,ADC_OutputDef ADCOutSel);
N///@}
N
N///@{
N#if defined(MG32_1ST) || defined(MG32_2ND) || defined(MG32_3RD)
X#if 1L || 0L || 0L
Nvoid ADC_PGA_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_SetPGAGain(ADC_Struct* ADCx, uint8_t PGAGain);
Nvoid ADC_SetPGAOffset(ADC_Struct* ADCx, uint8_t PGAOFFT);
Nvoid ADC_PGAOffsetCalibration_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
N#endif
N///@}
N
N///@{
N#if defined(MG32_1ST)
X#if 1L
Nvoid ADC_VRMCalibration(ADC_Struct* ADCx,uint8_t VRMV);
N#endif
Nvoid ADC_StartCalibration(ADC_Struct* ADCx, FunctionalState NewState);
N///@}
N
N///@{
Nvoid ADC_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_DMA_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S    void ADC_DMADataSize_Select(ADC_Struct* ADCx, ADC_DMADataSizeDef DMADataSize);
S    void ADC_DMAMaskFlag_Select(ADC_Struct* ADCx, ADC_DMAMaskE1CNVFDef DMAMaskFlagDef);
S    uint8_t ADC_GetNextConversionChannel(ADC_Struct* ADCx);
N#endif
N#if defined(MG32_1ST) || defined(MG32_3RD)
X#if 1L || 0L
N    void ADC_AutoOff_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
N    #if defined(MG32_3RD)
X    #if 0L
S        void ADC_SetStartupTime(ADC_Struct* ADCx, uint16_t ADCSCNTime);
S        void ADC_SetStartupDivider(ADC_Struct* ADCx, ADC_SCNTClockDivDef ADCSCNDIV);
N    #endif
N#endif
Nvoid ADC_WaitDataReadOut(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_SetExtendSampling(ADC_Struct* ADCx, uint8_t ADCSampleTime);
N///@}
N
N///@{
Nvoid ADC_ConversionMode_Select(ADC_Struct* ADCx, ADC_ConversionModeDef ADCConvMode);
Nvoid ADC_ContinueMode_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_HoldConversion_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_MainConversionMode_Select(ADC_Struct* ADCx, ADC_MainConversionModeDef MainCM);
N///@}
N
N///@{
Nvoid ADC_TriggerSource_Select(ADC_Struct* ADCx, ADC_TriggerSourceDef ADCTrgSel);
Nvoid ADC_SoftwareConversion_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Nvoid ADC_TriggerEdge_Select(ADC_Struct* ADCx, ADC_TriggerEdgeDef ADCExtEdgeSel);
N///@}
N
N///@{
Nvoid ADC_ChannelMUX_Select(ADC_Struct* ADCx, ADC_ChannelMUX_Def ChannelSel);
Nvoid ADC_ExternalChannel_Select(ADC_Struct* ADCx, ADC_ExtChannelDef ExtCHSel);
Nvoid ADC_InternalChannel_Select(ADC_Struct* ADCx, ADC_IntChannelDef IntCHSel);
Nvoid ADC_ScanLoopChannel_Enable(ADC_Struct* ADCx, uint16_t MSKChannelSel, FunctionalState NewState);
N#if defined(MG32_2ND) || defined(MG32_3RD)
X#if 0L || 0L
S    void ADC_ChangeMUXTiming_Select(ADC_Struct* ADCx, ADC_ChangeTimingDef ADC_ChangTimeing);
N#endif
N///@}
N
N///@{
Nvoid ADC_SingleDifferentMode_Select(ADC_Struct* ADCx, ADC_ConversionTypeDef ADC_ConversionType);
N///@}
N
N///@{
Nvoid ADC_SetLimitFunction(ADC_Struct* ADCx, ADC_LimitModeDef ADCLimitMode);
Nvoid ADC_SetSum0Channel(ADC_Struct* ADCx,uint8_t Sum0ChannelSel);
Nvoid ADC_SetSum1Channel(ADC_Struct* ADCx,uint8_t Sum1ChannelSel);
Nvoid ADC_SetSum2Channel(ADC_Struct* ADCx,uint8_t Sum2ChannelSel);
Nvoid ADC_SumChannelMode_Select(ADC_Struct* ADCx,ADC_SumChannelXDef ADCSumChXDef);
Nvoid ADC_SetSumNumber(ADC_Struct* ADCx, uint8_t ADCSumNumbers);
Nvoid ADC_SumOverrunMode_Select(ADC_Struct* ADCx, ADC_SumDataOWDef ADCSumOW);
Nuint16_t ADC_GetSum0Flags(ADC_Struct* ADCx);
Nuint16_t ADC_GetSum1Flags(ADC_Struct* ADCx);
Nuint16_t ADC_GetSum2Flags(ADC_Struct* ADCx);
Nvoid ADC_ClearSum0Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag);
Nvoid ADC_ClearSum1Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag);
Nvoid ADC_ClearSum2Flags(ADC_Struct* ADCx, uint8_t ADC_SUMxFlag);
Nint16_t ADC_GetSum0Data(ADC_Struct* ADCx);
Nint16_t ADC_GetSum1Data(ADC_Struct* ADCx);
Nint16_t ADC_GetSum2Data(ADC_Struct* ADCx);
Nvoid ADC_SetSum0Data(ADC_Struct* ADCx, int16_t ADCSum0Initial);
Nvoid ADC_SetSum1Data(ADC_Struct* ADCx, int16_t ADCSum1Initial);
Nvoid ADC_SetSum2Data(ADC_Struct* ADCx, int16_t ADCSum2Initial);
N///@}
N
N///@{
Nvoid ADC_DataAlignment_Select(ADC_Struct* ADCx, ADC_DataAlignModeDef AlignMode);
Nvoid ADC_DataResolution_Select(ADC_Struct* ADCx, ADC_ResolutionDef ResolutionData);
Nvoid ADC_DataOverrunMode_Select(ADC_Struct* ADCx, ADC_DataOWDef DataOW);
Nuint8_t ADC_GetDAT0Flags(ADC_Struct* ADCx);
Nuint8_t ADC_GetDAT0Channel(ADC_Struct* ADCx);
Nint16_t ADC_GetDAT0Data(ADC_Struct* ADCx);
Nvoid ADC_SetDigitalOffset(ADC_Struct* ADCx, int8_t sDigiOffset);
Nvoid ADC_SetOutputCodeFormat(ADC_Struct* ADCx, ADC_OutputCodeFormatDef DatFormat);
N///@}
N
N
N///@{
N#if defined(MG32_3RD)
X#if 0L
Svoid ADC_TSO_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Svoid ADC_TSOVref_Select(ADC_Struct* ADCx, ADC_TSOVrefSel TSOVref);
N#endif
N#if defined(MG32_3RD)
X#if 0L
Svoid ADC_IVR24_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
Svoid ADC_TopRefernce_Select(ADC_Struct* ADCx, ADC_ReferenceSel RefSel);
S///@}
N#endif
N
N
N///@{
Nvoid ADC_IT_Config(ADC_Struct* ADCx, uint32_t ADC_ITSrc, FunctionalState NewState);
Nvoid ADC_ITEA_Cmd(ADC_Struct* ADCx, FunctionalState NewState);
NDRV_Return ADC_GetSingleFlagStatus(ADC_Struct* ADCx, uint32_t ADC_ITSTAFlag);
Nuint32_t ADC_GetAllFlagStatus(ADC_Struct* ADCx);
Nvoid ADC_ClearFlag(ADC_Struct* ADCx, uint32_t ADC_ITSTAFlag);
N///@}
N
N#endif
L 37 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.h" 2
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N// <h> ADC base parameters
N//      <o0.16..23> ADC0 sampling time selec <0-255>
N//          <i> 0T ~ 255T clocks.T= CK_ADC0_INT
N//      <o0.6..7> ADC0 data resolution select. <0=> 12-bit <1=> 10-bit <2=> 8-bit
N//      <o1.3> ADC0 data alignment select <0=> Right (Right alignment) <1=> Left (Left alignment)
N//      <o1.24..28> ADC adjusted 2's complement value of digital offset adjuster <0x10=> -16 <0x11=> -15 <0x12=> -14 <0x13=> -13 <0x14=> -12 <0x15=> -11
N//                                                                              <0x16=> -10 <0x17=> -9 <0x18=> -8 <0x19=> -7 <0x1A=> -6 <0x1B=> -5
N//                                                                              <0x1C=> -4 <0x1D=> -3 <0x1E=> -2 <0x1F=> -1 <0x00=> 0 <0x01=> +1
N//                                                                              <0x02=> +2 <0x03=> +3 <0x04=> +4 <0x05=> +5 <0x06=> +6 <0x07=> +7
N//                                                                              <0x08=> +8 <0x09=> +9 <0x0A=> +10 <0x0B=> +11 <0x0C=> +12 <0x0D=> +13 <0x0E=> +14 <0x0F=> +15
N//      <o1.8> ADC0 data buffer overrun mode select <0=> Overwritten (Overwritten by new data) <1=> Keep (Preserved old date)
N//      <o2.19..25> ADC0 conversion mode select <0x00=> ADC One shot mode <0x01=> ADC Continue mode <0x20=> Scan mode <0x21=> Scan continue mode <0x40=> Loop mode
N//          <i> ADC One Shot mode : Convert one ADC data from single channel after one start trigger, then stop conversion.
N//          <i> ADC Continue mode : Convert one ADC data from single channel after one start trigger, then hardware automatically start next ADC conversion continuously and does not stop conversion.
N//          <i> Scan mode : Convert one ADC data from one selected channel after one start trigger, then stop conversion. To follow and convert next ADC data from next selected channel after next start trigger. Run the same steps for all selected channels.
N//          <i> Scan continue mode : Convert multiple ADC data continuously from multiple selected channels after one start trigger, then stop conversion when scan finished for all selected channels.
N//          <i> Loop mode : When ADC conversion start by one start trigger, hardware does the channel scan ADC conversion one by one until finish the conversion for all selected channels. And hardware automatically start next channel scan ADC conversion continuously and does not stop.
N//      <o3.16..18> ADC0 start control source select <0x0=> SW : ADC0_START register setting <0x1=> TM00 : TM00_TRGO <0x2=> PIN : ADC0_TRG : ADC external trigger pin
N//                                                   <0x3=> CMP0 : CMP0_OUT <0x4=> CMP1 : CMP1_OUT <0x5=> TM01 : TM01_TRGO <0x6=> TM26 : TM26_TREGO <7=> TM36 : TM36_TRGO
N//      <o3.20..21> ADC0 start trigger selection <0x0=> Disable <0x1=> Rising edge <0x2=> Falling edge <0x4=> Dual-edge
N//          <i> When selects Disable, the edge trigger detection is disabled and no start trigger signal output. When ADC0_START_SEL = SW (ADC0_START register setting), this register is no effect.
N//      <o3.8..12> ADC One shot mode / ADC Continue Mode - channel select
N//          <0=> PA0
N//          <1=> PA1
N//          <2=> PA2
N//          <3=> PA3
N//          <4=> PA4
N//          <5=> PA5
N//          <6=> PA6
N//          <7=> PA7
N//          <8=> PA8
N//          <9=> PA9
N//          <10=> PA10
N//          <11=> PA11
N//          <12=> PA12
N//          <13=> PA13
N//          <14=> PA14
N//          <15=> PA15
N//          <16=> Internal VSSA
N//          <17=> IVREF : ADC0_IVREF
N//          <18=> INT_DACP0
N//          <19=> INT_VBG (VBUF)
N//      <h> Scan/Loop mode - sequence channel scan
N//          <q4.0> PA0
N//          <q4.1> PA1
N//          <q4.2> PA2
N//          <q4.3> PA3
N//          <q4.4> PA4
N//          <q4.5> PA5
N//          <q4.6> PA6
N//          <q4.7> PA7
N//          <q4.8> PA8
N//          <q4.9> PA9
N//          <q4.10> PA10
N//          <q4.11> PA11
N//          <q4.12> PA12
N//          <q4.13> PA13
N//          <q4.14> PA14
N//          <q4.15> PA15
N//      </h>
N// </h>
N#define CONF_ADC_CR0_REG            0
N#define CONF_ADC_CR1_REG            0x00000000
N#define CONF_ADC_START_CONV_MDS     0x00000000
N#define CONF_ADC_START_START_SEL    0x000000
N#define CONF_ADC_MSK_MSKx           0x0000
N
N#if CONF_ADC_START_CONV_MDS>0x00080000
X#if 0x00000000>0x00080000
S    #if CONF_ADC_MSK_MSKx==0
S        #error "Error: ADC0 needs to enable sequence channel"
S    #endif
N#endif
N
N//  <e0.2> PGA configuration
N//      <o1.0..5> ADC0 input PGA gain adjust bits. Gain range is x1 ~ x4. <0-63> 
N//          <i> 0: x1, 1: x1.012 ... 42: x2.0 ... 63: x4.0
N//          <i> Gain = {1+(ADC0_GAIN_PGA*3)/[63+(63-ADC0_GAIN_PGA)*3]}
N//  </e>
N#define CONF_ADC_ANA_PGA_EN         0
N#define CONF_ADC_GAIN_PGA           0
N
N
N
N//  <h> Clock configuration
N//     <o0.8..9> ADC0 internal sampling clock CK_ADC0_INT source select <0=> CK_ADC <1=> CK_PLL <3=> TM00_TRGO <3=> TM01_TRGO
N//          <i> CK_ADC from CSC (AHB or APB).
N//          <i> CK_PLL ~96MHz (CSC must enable PLL).
N//          <i> TM00_TRGO : TM00 periodic output overflow event (User must enable TM00).
N//          <i> TM01_TRGO : TM01 periodic output overflow event (User must enable TM01).
N//     <o0.4..5> Internal clock CK_ADC0_INT input divider <0=> DIV1 <1=> DIV2 <3=> DIV4 <3=> DIV16
N//     <o0.10..11> ADC0 input clock CK_PLL divider. <0=> DIV2 <1=> DIV4 <3=> DIV5 <3=> DIV6
N//  </h>
N#define CONF_ADC_CLK_SRC            0x00000000
N#define CONF_ADC_CLK_DIV            0x00000000
N
N
N//  <e0.0> Window detect threshold
N//      <o3.14..15> ADC0 output code spike limit function <0=> No operation <1=> Skip <2=> Clamp
N//      <o0.1> Apply channel <0=> Single <1=> All
N//      <o0.4..5> ADC0_OUT output signal select <0=> WDL (window detect state for outside low) <1=> WDI (window detect state for inside) <2=> WDH (window detect state for outside high)
N//      <o1.0..11> ADC0 Voltage window detect lower threshold <0-4095>
N//          <i> window detect lower threshold : 0~4095@12bit
N//      <o2.0..11> ADC0 voltage window detect higher threshold <0-4095>
N//          <i> window detect higher threshold : 0~4095@12bit
N//  </e>
N#define CONF_ADC_CR1_WIND_EN        0x00000000  
N#define CONF_ADC_WINDTH_LT          0  
N#define CONF_ADC_WINDTH_HT          0  
N#define CONF_ADC_CR0_LIM_MDS        0x0000
N
N#if CONF_ADC_WINDTH_LT > CONF_ADC_WINDTH_HT
X#if 0 > 0
S    #error "Error: window detect lower threshold > window detect higher threshold"
N#endif 
N
N// <h> ADC0 data accumulation sum
N//      <o0.16..22> ADC0 data sum accumulation data number <0-64>
N//          <i> Value 0 indicates to disable accumulation and the maximum value 0x40 indicates 64 data to accumulate.
N//      <o0.10> ADC0 data accumulation sum channel mode select <0=> Single (Single channel) <1=> All (All selected scan channels)
N//          <i> When selects Single mode for ADC one shot conversion mode, the ADC0_SUM0_MUX selection channel data is accumulated into ADC0_SUM0. When selects All mode, the all selection channel data are accumulated one-by-one into ADC0_SUM0 only.
N//          <i> When selects Single mode for ADC channel scan conversion mode, the ADC0_SUM1_MUX/ADC0_SUM2_MUX selection channel data are also separately accumulated into ADC0_SUM1/ADC0_SUM2.   
N//      <o0.9> ADC0 data sum overrun mode select <0=> Overwritten (Overwritten by new data) <1=> Keep (Preserved old date)
N//      <o1.16..19> Analog input channel selection for ADC0 data sum-0 function <0=> PA0 <1=> PA1 <2=> PA2 <3=> PA3 <4=> PA4 <5=> PA5 <6=> PA6 <7=> PA7 <8=> PA8
N//                                                                              <9=> PA9 <10=> PA10 <11=> PA11 <12=> PA12 <13=> PA13 <14=> PA14 <15=> PA15
N//      <o2.0..15> ADC0 data accumulator sum-0 initial value <0-65535>
N//      <o1.20..23> Analog input channel selection for ADC0 data sum-1 function <0=> PA0 <1=> PA1 <2=> PA2 <3=> PA3 <4=> PA4 <5=> PA5 <6=> PA6 <7=> PA7 <8=> PA8
N//                                                                              <9=> PA9 <10=> PA10 <11=> PA11 <12=> PA12 <13=> PA13 <14=> PA14 <15=> PA15
N//      <o3.0..15> ADC0 data accumulator sum-1 initial value <0-65535>
N//      <o1.24..27> Analog input channel selection for ADC0 data sum-2 function <0=> PA0 <1=> PA1 <2=> PA2 <3=> PA3 <4=> PA4 <5=> PA5 <6=> PA6 <7=> PA7 <8=> PA8
N//                                                                              <9=> PA9 <10=> PA10 <11=> PA11 <12=> PA12 <13=> PA13 <14=> PA14 <15=> PA15
N//      <o4.0..15> ADC0 data accumulator sum-2 initial value <0-65535>
N// </h>
N#define CONF_ADC_CR1_SUM_NUM        1024  
N#define CONF_ADC_MSK_SUMx_MUX       0x00000000
N#define CONF_ADC_SUM0               0
N#define CONF_ADC_SUM1               0
N#define CONF_ADC_SUM2               0
N
N
N#define CONF_ADC_CLK                (CONF_ADC_CLK_SRC | CONF_ADC_CLK_DIV)
N#define CONF_ADC_WINDTH             ((CONF_ADC_WINDTH_HT << 16) | CONF_ADC_WINDTH_LT)
N#define CONF_ADC_CR0                (CONF_ADC_CR0_REG | CONF_ADC_CR0_LIM_MDS)
N#define CONF_ADC_CR1                (CONF_ADC_CR1_REG | CONF_ADC_CR1_WIND_EN | CONF_ADC_CR1_SUM_NUM)
N#define CONF_ADC_MSK                (CONF_ADC_MSK_SUMx_MUX | CONF_ADC_MSK_MSKx)
N#define CONF_ADC_START              (CONF_ADC_START_CONV_MDS | CONF_ADC_START_START_SEL)
N#define CONF_ADC_ANA                (CONF_ADC_ANA_PGA_EN)
N#define CONF_ADC_GAIN               (CONF_ADC_GAIN_PGA)
N//*** <<< end of configuration section >>>    ***
N
N
N
N
N
N
N/**
N * @name	Function announce
N *   		
N */
N///@{  
Nvoid ADC_Init (void);
N///@}
N
N
N#endif  // _MG32x02z_TM_INIT_H
N
L 29 "RTE\MG32x02z_ChipInit_Wizard\MG32F02A132\MG32x02z_ADC_Init.c" 2
N
N
N/**
N *******************************************************************************
N * @brief  	    Initialized ADC module.
N * @param[in]   None
N * @return      None
N *******************************************************************************
N */
Nvoid ADC_Init (void)
N{
N    uint16_t    SettleTime;
N        
N    /* ADC00 initial wizard */
N    ADC0->CLK.W     = CONF_ADC_CLK;
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->CLK.W     = (0x00000000 | 0x00000000);
N    ADC0->WINDTH.W  = CONF_ADC_WINDTH; 
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->WINDTH.W  = ((0 << 16) | 0); 
N    ADC0->CR0.W     = CONF_ADC_CR0 | ADC_CR0_EN_enable_w;  
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->CR0.W     = (0 | 0x0000) | ((uint32_t)0x00000001);  
N    ADC0->CR1.W     = CONF_ADC_CR1;  
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->CR1.W     = (0x00000000 | 0x00000000 | 1024);  
N    ADC0->MSK.W     = CONF_ADC_MSK;  
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->MSK.W     = (0x00000000 | 0x0000);  
N    ADC0->START.W   = CONF_ADC_START;
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->START.W   = (0x00000000 | 0x000000);
N    ADC0->ANA.W     = CONF_ADC_ANA;  
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->ANA.W     = (0);  
N    ADC0->GAIN.W    = CONF_ADC_GAIN; 
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->GAIN.W    = (0); 
N    ADC0->SUM0.W    = CONF_ADC_SUM0;
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->SUM0.W    = 0;
N    ADC0->SUM1.W    = CONF_ADC_SUM1;
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->SUM1.W    = 0;
N    ADC0->SUM2.W    = CONF_ADC_SUM2;
X    ((ADC_Struct*) ((uint32_t)0x5B000000))->SUM2.W    = 0;
N    
N    
N    // ADC Settle time (needs ~5us)
N    for (SettleTime=0; SettleTime<250; SettleTime++);
N    
N    // ADC calibration 
N    ADC_StartCalibration(ADC0, ENABLE); 
X    ADC_StartCalibration(((ADC_Struct*) ((uint32_t)0x5B000000)), ENABLE); 
N
N    // PGA calibration
N    #if ADC_ANA_PGA_EN!=0
S        ADC_PGAOffsetCalibration_Cmd(ADC0, ENABLE);
N    #endif
N   
N    
N    
N}
N
N
N
N
N
N
