; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mg32x02z_i2c_drv.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mg32x02z_i2c_drv.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\UserLib\Inc -I.\Main\Inc -I.\MGLib\Inc -I.\ProjectLib\Inc -I.\RTE\MG32x02z_ChipInit_Wizard\MG32F02A132 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A132\MG32x02z_ConfigerWizard\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Middleware\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Driver\Include -IC:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Sample\Middleware\Include -D__UVISION_VERSION=534 -D_RTE_ -DMG32F02A132 -D_RTE_ --omf_browse=.\objects\mg32x02z_i2c_drv.crf C:\Keil_v5\ARM\PACK\Megawin\CM0_DFP\2.0.4\Device\MG32x02z\MG32F02A_Driver\Source\MG32x02z_I2C_DRV.c]
                          THUMB

                          AREA ||i.I2C_ClearEventFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearEventFlag PROC
;;;1011    */
;;;1012   void I2C_ClearEventFlag(I2C_Struct* I2Cx)
000000  2201              MOVS     r2,#1
;;;1013   {
;;;1014       I2Cx->STA2.B[1] = I2C_STA2_EVENTF2_mask_b1;
000002  2129              MOVS     r1,#0x29
000004  540a              STRB     r2,[r1,r0]
;;;1015   }
000006  4770              BX       lr
;;;1016   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;892     */
;;;893    void I2C_ClearFlag(I2C_Struct* I2Cx, uint32_t I2C_FLAG)
000000  6001              STR      r1,[r0,#0]
;;;894    {
;;;895        I2Cx->STA.W = I2C_FLAG;
;;;896    }
000002  4770              BX       lr
;;;897    
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;474     */
;;;475    void I2C_Cmd(I2C_Struct* I2Cx, FunctionalState State)
000000  2901              CMP      r1,#1
;;;476    {
;;;477        if(State == ENABLE)
000002  d104              BNE      |L3.14|
;;;478            I2Cx->CR0.B[0] |= I2C_CR0_EN_enable_b0;
000004  7c02              LDRB     r2,[r0,#0x10]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  7402              STRB     r2,[r0,#0x10]
00000c  e003              B        |L3.22|
                  |L3.14|
;;;479        else
;;;480            I2Cx->CR0.B[0] &= (~I2C_CR0_EN_mask_b0);
00000e  7c02              LDRB     r2,[r0,#0x10]
000010  0852              LSRS     r2,r2,#1
000012  0052              LSLS     r2,r2,#1
000014  7402              STRB     r2,[r0,#0x10]
                  |L3.22|
;;;481    }
000016  4770              BX       lr
;;;482    
                          ENDP


                          AREA ||i.I2C_GeneralCallAddress_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallAddress_Cmd PROC
;;;281     */
;;;282    void I2C_GeneralCallAddress_Cmd(I2C_Struct* I2Cx, FunctionalState State)
000000  2901              CMP      r1,#1
;;;283    {
;;;284        if(State == ENABLE)
000002  d104              BNE      |L4.14|
;;;285            I2Cx->CR0.B[0] |= I2C_CR0_GC_EN_enable_b0;
000004  7c02              LDRB     r2,[r0,#0x10]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  7402              STRB     r2,[r0,#0x10]
00000c  e003              B        |L4.22|
                  |L4.14|
;;;286        else
;;;287            I2Cx->CR0.B[0] &= (~I2C_CR0_GC_EN_mask_b0);
00000e  7c02              LDRB     r2,[r0,#0x10]
000010  2380              MOVS     r3,#0x80
000012  439a              BICS     r2,r2,r3
000014  7402              STRB     r2,[r0,#0x10]
                  |L4.22|
;;;288    }
000016  4770              BX       lr
;;;289    
                          ENDP


                          AREA ||i.I2C_GetAllFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetAllFlagStatus PROC
;;;752     */
;;;753    uint32_t I2C_GetAllFlagStatus(I2C_Struct* I2Cx)
000000  4601              MOV      r1,r0
;;;754    {
;;;755    
;;;756        return(I2Cx->STA.W);
000002  6808              LDR      r0,[r1,#0]
;;;757    
;;;758    }
000004  4770              BX       lr
;;;759    
                          ENDP


                          AREA ||i.I2C_GetEventCode||, CODE, READONLY, ALIGN=1

                  I2C_GetEventCode PROC
;;;953     */
;;;954    uint8_t I2C_GetEventCode(I2C_Struct* I2Cx)
000000  4601              MOV      r1,r0
;;;955    {
;;;956        return(I2Cx->STA2.B[0] & 0xF8);
000002  2028              MOVS     r0,#0x28
000004  5c40              LDRB     r0,[r0,r1]
000006  22f8              MOVS     r2,#0xf8
000008  4010              ANDS     r0,r0,r2
;;;957    }
00000a  4770              BX       lr
;;;958    
                          ENDP


                          AREA ||i.I2C_GetEventFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetEventFlag PROC
;;;982     */
;;;983    DRV_Return I2C_GetEventFlag(I2C_Struct* I2Cx)
000000  4601              MOV      r1,r0
;;;984    {
;;;985        if((I2Cx->STA2.B[1] & 0x01) != 0)
000002  2029              MOVS     r0,#0x29
000004  5c40              LDRB     r0,[r0,r1]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L7.18|
;;;986            return DRV_Success;
00000e  2000              MOVS     r0,#0
                  |L7.16|
;;;987        else
;;;988            return DRV_Failure;
;;;989    }
000010  4770              BX       lr
                  |L7.18|
000012  2001              MOVS     r0,#1                 ;988
000014  e7fc              B        |L7.16|
;;;990    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;810     */
;;;811    DRV_Return I2C_GetFlagStatus(I2C_Struct* I2Cx, uint32_t I2C_FLAG)
000000  4602              MOV      r2,r0
;;;812    {
;;;813        if((I2Cx->STA.W & I2C_FLAG) == I2C_FLAG)
000002  6810              LDR      r0,[r2,#0]
000004  4008              ANDS     r0,r0,r1
000006  4288              CMP      r0,r1
000008  d101              BNE      |L8.14|
;;;814            return (DRV_Happened);
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;815        else
;;;816            return (DRV_UnHappened);
;;;817    }
00000c  4770              BX       lr
                  |L8.14|
00000e  2000              MOVS     r0,#0                 ;816
000010  e7fc              B        |L8.12|
;;;818    
                          ENDP


                          AREA ||i.I2C_GetITSource||, CODE, READONLY, ALIGN=1

                  I2C_GetITSource PROC
;;;687     */
;;;688    uint32_t I2C_GetITSource(I2C_Struct* I2Cx)
000000  4601              MOV      r1,r0
;;;689    {
;;;690        return (I2Cx->INT.W &(I2C_IT_BUF | I2C_IT_ERR | I2C_IT_EVENT | I2C_IT_TMOUT | I2C_IT_STPSTR | I2C_IT_IEA));
000002  6848              LDR      r0,[r1,#4]
000004  06c0              LSLS     r0,r0,#27
000006  0ec0              LSRS     r0,r0,#27
;;;691    }
000008  4770              BX       lr
;;;692    
                          ENDP


                          AREA ||i.I2C_GetSlaveAddress||, CODE, READONLY, ALIGN=1

                  I2C_GetSlaveAddress PROC
;;;433     */
;;;434    uint8_t I2C_GetSlaveAddress(I2C_Struct* I2Cx, uint8_t I2C_SADRx)
000000  4602              MOV      r2,r0
;;;435    {
;;;436        if(I2C_SADRx == I2C_SADR_0)
000002  2980              CMP      r1,#0x80
000004  d101              BNE      |L10.10|
;;;437            return 0x00;
000006  2000              MOVS     r0,#0
                  |L10.8|
;;;438    
;;;439        if(I2C_SADRx == I2C_SADR_1)
;;;440            return (I2Cx->SADR.B[0] & 0xFE);
;;;441    
;;;442        if(I2C_SADRx == I2C_SADR_2)
;;;443            return (I2Cx->SADR.B[1] & 0xFE);
;;;444    
;;;445        return 0xFF;
;;;446    }
000008  4770              BX       lr
                  |L10.10|
00000a  2902              CMP      r1,#2                 ;439
00000c  d103              BNE      |L10.22|
00000e  7f10              LDRB     r0,[r2,#0x1c]         ;440
000010  23fe              MOVS     r3,#0xfe              ;440
000012  4018              ANDS     r0,r0,r3              ;440
000014  e7f8              B        |L10.8|
                  |L10.22|
000016  2904              CMP      r1,#4                 ;442
000018  d103              BNE      |L10.34|
00001a  7f50              LDRB     r0,[r2,#0x1d]         ;443
00001c  23fe              MOVS     r3,#0xfe              ;443
00001e  4018              ANDS     r0,r0,r3              ;443
000020  e7f2              B        |L10.8|
                  |L10.34|
000022  20ff              MOVS     r0,#0xff              ;445
000024  e7f0              B        |L10.8|
;;;447    
                          ENDP


                          AREA ||i.I2C_GetSlaveMatchAddress||, CODE, READONLY, ALIGN=1

                  I2C_GetSlaveMatchAddress PROC
;;;1057    */
;;;1058   uint8_t I2C_GetSlaveMatchAddress(I2C_Struct* I2Cx)
000000  4601              MOV      r1,r0
;;;1059   {
;;;1060       return(I2Cx->SAC.B[0]);
000002  7b08              LDRB     r0,[r1,#0xc]
;;;1061   }
000004  4770              BX       lr
;;;1062   
                          ENDP


                          AREA ||i.I2C_ITEA_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_ITEA_Cmd PROC
;;;642     */
;;;643    void I2C_ITEA_Cmd(I2C_Struct* I2Cx, FunctionalState State)
000000  2901              CMP      r1,#1
;;;644    {
;;;645        if(State == ENABLE)
000002  d104              BNE      |L12.14|
;;;646            I2Cx->INT.B[0] |= I2C_CR0_EN_enable_b0;
000004  7902              LDRB     r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  7102              STRB     r2,[r0,#4]
00000c  e003              B        |L12.22|
                  |L12.14|
;;;647        else
;;;648            I2Cx->INT.B[0] &= ~I2C_CR0_EN_mask_b0;
00000e  7902              LDRB     r2,[r0,#4]
000010  0852              LSRS     r2,r2,#1
000012  0052              LSLS     r2,r2,#1
000014  7102              STRB     r2,[r0,#4]
                  |L12.22|
;;;649    }
000016  4770              BX       lr
;;;650    
                          ENDP


                          AREA ||i.I2C_IT_Config||, CODE, READONLY, ALIGN=1

                  I2C_IT_Config PROC
;;;608     */
;;;609    void I2C_IT_Config(I2C_Struct* I2Cx, uint32_t I2C_ITSrc, FunctionalState State)
000000  2a01              CMP      r2,#1
;;;610    {
;;;611        if(State == ENABLE)
000002  d103              BNE      |L13.12|
;;;612            I2Cx->INT.W |= State;
000004  6843              LDR      r3,[r0,#4]
000006  4313              ORRS     r3,r3,r2
000008  6043              STR      r3,[r0,#4]
00000a  e002              B        |L13.18|
                  |L13.12|
;;;613        else
;;;614            I2Cx->INT.W &= (~State);
00000c  6843              LDR      r3,[r0,#4]
00000e  4393              BICS     r3,r3,r2
000010  6043              STR      r3,[r0,#4]
                  |L13.18|
;;;615    }
000012  4770              BX       lr
;;;616    
                          ENDP


                          AREA ||i.I2C_RXDMA_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_RXDMA_Cmd PROC
;;;550     */
;;;551    void I2C_RXDMA_Cmd(I2C_Struct* I2Cx, FunctionalState State)
000000  2901              CMP      r1,#1
;;;552    {
;;;553        if(State == ENABLE)
000002  d104              BNE      |L14.14|
;;;554            I2Cx->CR0.B[3] |= I2C_CR0_DMA_RXEN_mask_b3;
000004  7cc2              LDRB     r2,[r0,#0x13]
000006  2340              MOVS     r3,#0x40
000008  431a              ORRS     r2,r2,r3
00000a  74c2              STRB     r2,[r0,#0x13]
00000c  e003              B        |L14.22|
                  |L14.14|
;;;555        else
;;;556            I2Cx->CR0.B[3] &= (~I2C_CR0_DMA_RXEN_mask_b3);
00000e  7cc2              LDRB     r2,[r0,#0x13]
000010  2340              MOVS     r3,#0x40
000012  439a              BICS     r2,r2,r3
000014  74c2              STRB     r2,[r0,#0x13]
                  |L14.22|
;;;557    }
000016  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.I2C_ReceiveSBUF||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveSBUF PROC
;;;1108    */
;;;1109   uint8_t I2C_ReceiveSBUF(I2C_Struct* I2Cx)
000000  4601              MOV      r1,r0
;;;1110   {
;;;1111       return(I2Cx->SBUF.B[0]);
000002  202c              MOVS     r0,#0x2c
000004  5c40              LDRB     r0,[r0,r1]
;;;1112   }
000006  4770              BX       lr
;;;1113   
                          ENDP


                          AREA ||i.I2C_SendSBUF||, CODE, READONLY, ALIGN=1

                  I2C_SendSBUF PROC
;;;1083    */
;;;1084   void I2C_SendSBUF(I2C_Struct* I2Cx, uint8_t TxData)
000000  222c              MOVS     r2,#0x2c
;;;1085   {
;;;1086       I2Cx->SBUF.B[0] = TxData;
000002  5411              STRB     r1,[r2,r0]
;;;1087   }
000004  4770              BX       lr
;;;1088   
                          ENDP


                          AREA ||i.I2C_SetClockDivider||, CODE, READONLY, ALIGN=1

                  I2C_SetClockDivider PROC
;;;145     */
;;;146    void I2C_SetClockDivider(I2C_Struct* I2Cx, uint8_t Select)
000000  7a02              LDRB     r2,[r0,#8]
;;;147    {
;;;148        I2Cx->CLK.B[0] = (I2Cx->CLK.B[0] & (~I2C_CLK_DIV_MASK)) | (Select & I2C_CLK_DIV_MASK);
000002  2370              MOVS     r3,#0x70
000004  439a              BICS     r2,r2,r3
000006  400b              ANDS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  7202              STRB     r2,[r0,#8]
;;;149    }
00000c  4770              BX       lr
;;;150    
                          ENDP


                          AREA ||i.I2C_SetClockPrescaler||, CODE, READONLY, ALIGN=1

                  I2C_SetClockPrescaler PROC
;;;104     */
;;;105    void I2C_SetClockPrescaler(I2C_Struct* I2Cx, uint8_t Select)
000000  7a42              LDRB     r2,[r0,#9]
;;;106    {
;;;107        I2Cx->CLK.B[1] = ((I2Cx->CLK.B[1] & (~I2C_CLK_PSC_MASK)) | Select);
000002  08d2              LSRS     r2,r2,#3
000004  00d2              LSLS     r2,r2,#3
000006  430a              ORRS     r2,r2,r1
000008  7242              STRB     r2,[r0,#9]
;;;108    }
00000a  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.I2C_SetClockSource||, CODE, READONLY, ALIGN=1

                  I2C_SetClockSource PROC
;;;63      */
;;;64     void I2C_SetClockSource(I2C_Struct* I2Cx, uint8_t Select)
000000  7a42              LDRB     r2,[r0,#9]
;;;65     {
;;;66         I2Cx->CLK.B[1] = ((I2Cx->CLK.B[1] & (~I2C_CLK_SRC_MASK)) | Select);
000002  230c              MOVS     r3,#0xc
000004  439a              BICS     r2,r2,r3
000006  430a              ORRS     r2,r2,r1
000008  7242              STRB     r2,[r0,#9]
;;;67     }
00000a  4770              BX       lr
;;;68     
                          ENDP


                          AREA ||i.I2C_SetPreDriveTime||, CODE, READONLY, ALIGN=1

                  I2C_SetPreDriveTime PROC
;;;243     */
;;;244    void I2C_SetPreDriveTime(I2C_Struct* I2Cx, uint32_t Select)
000000  7c42              LDRB     r2,[r0,#0x11]
;;;245    {
;;;246        I2Cx->CR0.B[1] = (I2Cx->CR0.B[1] & (~I2C_PDRV_MASK)) | (Select & I2C_PDRV_MASK);
000002  2303              MOVS     r3,#3
000004  039b              LSLS     r3,r3,#14
000006  439a              BICS     r2,r2,r3
000008  400b              ANDS     r3,r3,r1
00000a  431a              ORRS     r2,r2,r3
00000c  7442              STRB     r2,[r0,#0x11]
;;;247    }
00000e  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.I2C_SetSCLHighTime||, CODE, READONLY, ALIGN=1

                  I2C_SetSCLHighTime PROC
;;;175     */
;;;176    void I2C_SetSCLHighTime(I2C_Struct* I2Cx, uint8_t HighTime)
000000  7541              STRB     r1,[r0,#0x15]
;;;177    {
;;;178        I2Cx->CR1.B[1] = HighTime;
;;;179    }
000002  4770              BX       lr
;;;180    
                          ENDP


                          AREA ||i.I2C_SetSCLLowTime||, CODE, READONLY, ALIGN=1

                  I2C_SetSCLLowTime PROC
;;;206     */
;;;207    void I2C_SetSCLLowTime(I2C_Struct* I2Cx, uint8_t LowTime)
000000  7501              STRB     r1,[r0,#0x14]
;;;208    {
;;;209        I2Cx->CR1.B[0] = LowTime;
;;;210    }
000002  4770              BX       lr
;;;211    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddress||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddress PROC
;;;362     */
;;;363    void I2C_SetSlaveAddress(I2C_Struct* I2Cx, uint8_t I2C_SADRx, uint8_t Address)
000000  2902              CMP      r1,#2
;;;364    {
;;;365        if(I2C_SADRx == I2C_SADR_1)
000002  d100              BNE      |L23.6|
;;;366            I2Cx->SADR.B[0] = Address;
000004  7702              STRB     r2,[r0,#0x1c]
                  |L23.6|
;;;367    
;;;368        if(I2C_SADRx == I2C_SADR_2)
000006  2904              CMP      r1,#4
000008  d100              BNE      |L23.12|
;;;369            I2Cx->SADR.B[1] = Address;
00000a  7742              STRB     r2,[r0,#0x1d]
                  |L23.12|
;;;370    }
00000c  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.I2C_SlaveAddressDetect_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_SlaveAddressDetect_Cmd PROC
;;;326     */
;;;327    void I2C_SlaveAddressDetect_Cmd(I2C_Struct* I2Cx, uint8_t I2C_SADRx, FunctionalState State)
000000  2a01              CMP      r2,#1
;;;328    {
;;;329        if(State == ENABLE)
000002  d103              BNE      |L24.12|
;;;330            I2Cx->CR0.B[0] |= I2C_SADRx;
000004  7c03              LDRB     r3,[r0,#0x10]
000006  430b              ORRS     r3,r3,r1
000008  7403              STRB     r3,[r0,#0x10]
00000a  e002              B        |L24.18|
                  |L24.12|
;;;331        else
;;;332            I2Cx->CR0.B[0] &= (~I2C_SADRx);
00000c  7c03              LDRB     r3,[r0,#0x10]
00000e  438b              BICS     r3,r3,r1
000010  7403              STRB     r3,[r0,#0x10]
                  |L24.18|
;;;333    }
000012  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.I2C_TXDMA_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_TXDMA_Cmd PROC
;;;516     */
;;;517    void I2C_TXDMA_Cmd(I2C_Struct* I2Cx, FunctionalState State)
000000  2901              CMP      r1,#1
;;;518    {
;;;519        if(State == ENABLE)
000002  d104              BNE      |L25.14|
;;;520            I2Cx->CR0.B[3] |= I2C_CR0_DMA_TXEN_mask_b3;
000004  7cc2              LDRB     r2,[r0,#0x13]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  74c2              STRB     r2,[r0,#0x13]
00000c  e003              B        |L25.22|
                  |L25.14|
;;;521        else
;;;522            I2Cx->CR0.B[3] &= ~I2C_CR0_DMA_TXEN_mask_b3;
00000e  7cc2              LDRB     r2,[r0,#0x13]
000010  2380              MOVS     r3,#0x80
000012  439a              BICS     r2,r2,r3
000014  74c2              STRB     r2,[r0,#0x13]
                  |L25.22|
;;;523    }
000016  4770              BX       lr
;;;524    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Megawin\\CM0_DFP\\2.0.4\\Device\\MG32x02z\\MG32F02A_Driver\\Source\\MG32x02z_I2C_DRV.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_I2C_DRV_c_439c7563____REV16|
#line 481 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.7.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___18_MG32x02z_I2C_DRV_c_439c7563____REV16| PROC
#line 482

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MG32x02z_I2C_DRV_c_439c7563____REVSH|
#line 496
|__asm___18_MG32x02z_I2C_DRV_c_439c7563____REVSH| PROC
#line 497

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
